
//// Automatically Generated by generate-swiftsyntaxbuilder
//// Do Not Edit Directly!
//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2022 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

import SwiftSyntax
import SwiftBasicFormat

/// A CodeBlockItem is any Syntax node that appears on its own line insidea CodeBlock.
public struct CodeBlockItem: SyntaxBuildable, ExpressibleAsCodeBlockItem {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeItem: UnexpectedNodes?
    var item: SyntaxBuildable
    var unexpectedBetweenItemAndSemicolon: UnexpectedNodes?
    var semicolon: Token?
    var unexpectedBetweenSemicolonAndErrorTokens: UnexpectedNodes?
    var errorTokens: SyntaxBuildable?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(CodeBlockItemSyntax)
  }
  private var data: Data
  /// Creates a `CodeBlockItem` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeItem: 
  ///   - item: The underlying node inside the code block.
  ///   - unexpectedBetweenItemAndSemicolon: 
  ///   - semicolon: If present, the trailing semicolon at the end of the item.
  ///   - unexpectedBetweenSemicolonAndErrorTokens: 
  ///   - errorTokens: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeItem: ExpressibleAsUnexpectedNodes? = nil, item: ExpressibleAsSyntaxBuildable, unexpectedBetweenItemAndSemicolon: ExpressibleAsUnexpectedNodes? = nil, semicolon: Token? = nil, unexpectedBetweenSemicolonAndErrorTokens: ExpressibleAsUnexpectedNodes? = nil, errorTokens: ExpressibleAsSyntaxBuildable? = nil) {
    assert(semicolon == nil || semicolon!.text == #";"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeItem: unexpectedBeforeItem?.createUnexpectedNodes(), item: item.createSyntaxBuildable(), unexpectedBetweenItemAndSemicolon: unexpectedBetweenItemAndSemicolon?.createUnexpectedNodes(), semicolon: semicolon, unexpectedBetweenSemicolonAndErrorTokens: unexpectedBetweenSemicolonAndErrorTokens?.createUnexpectedNodes(), errorTokens: errorTokens?.createSyntaxBuildable()))
  }
  public init(_ constructedNode: CodeBlockItemSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `CodeBlockItemSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `CodeBlockItemSyntax`.
  func buildCodeBlockItem(format: Format) -> CodeBlockItemSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = CodeBlockItemSyntax(buildableData.unexpectedBeforeItem?.buildUnexpectedNodes(format: format), item: buildableData.item.buildSyntax(format: format), buildableData.unexpectedBetweenItemAndSemicolon?.buildUnexpectedNodes(format: format), semicolon: buildableData.semicolon?.buildToken(format: format), buildableData.unexpectedBetweenSemicolonAndErrorTokens?.buildUnexpectedNodes(format: format), errorTokens: buildableData.errorTokens?.buildSyntax(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildCodeBlockItem(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsCodeBlockItem`.
  public func createCodeBlockItem() -> CodeBlockItem {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `CodeBlockItem` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct CodeBlock: SyntaxBuildable, ExpressibleAsCodeBlock {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeLeftBrace: UnexpectedNodes?
    var leftBrace: Token
    var unexpectedBetweenLeftBraceAndStatements: UnexpectedNodes?
    var statements: CodeBlockItemList
    var unexpectedBetweenStatementsAndRightBrace: UnexpectedNodes?
    var rightBrace: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(CodeBlockSyntax)
  }
  private var data: Data
  /// Creates a `CodeBlock` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftBrace: 
  ///   - leftBrace: 
  ///   - unexpectedBetweenLeftBraceAndStatements: 
  ///   - statements: 
  ///   - unexpectedBetweenStatementsAndRightBrace: 
  ///   - rightBrace: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftBrace: ExpressibleAsUnexpectedNodes? = nil, leftBrace: Token = Token.`leftBrace`, unexpectedBetweenLeftBraceAndStatements: ExpressibleAsUnexpectedNodes? = nil, statements: ExpressibleAsCodeBlockItemList, unexpectedBetweenStatementsAndRightBrace: ExpressibleAsUnexpectedNodes? = nil, rightBrace: Token = Token.`rightBrace`) {
    assert(leftBrace.text == #"{"#)
    assert(rightBrace.text == #"}"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeLeftBrace: unexpectedBeforeLeftBrace?.createUnexpectedNodes(), leftBrace: leftBrace, unexpectedBetweenLeftBraceAndStatements: unexpectedBetweenLeftBraceAndStatements?.createUnexpectedNodes(), statements: statements.createCodeBlockItemList(), unexpectedBetweenStatementsAndRightBrace: unexpectedBetweenStatementsAndRightBrace?.createUnexpectedNodes(), rightBrace: rightBrace))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftBrace: ExpressibleAsUnexpectedNodes? = nil, leftBrace: Token = Token.`leftBrace`, unexpectedBetweenLeftBraceAndStatements: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenStatementsAndRightBrace: ExpressibleAsUnexpectedNodes? = nil, rightBrace: Token = Token.`rightBrace`, @CodeBlockItemListBuilder statementsBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftBrace: unexpectedBeforeLeftBrace, leftBrace: leftBrace, unexpectedBetweenLeftBraceAndStatements: unexpectedBetweenLeftBraceAndStatements, statements: statementsBuilder(), unexpectedBetweenStatementsAndRightBrace: unexpectedBetweenStatementsAndRightBrace, rightBrace: rightBrace)
  }
  public init(_ constructedNode: CodeBlockSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `CodeBlockSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `CodeBlockSyntax`.
  func buildCodeBlock(format: Format) -> CodeBlockSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = CodeBlockSyntax(buildableData.unexpectedBeforeLeftBrace?.buildUnexpectedNodes(format: format), leftBrace: buildableData.leftBrace.buildToken(format: format), buildableData.unexpectedBetweenLeftBraceAndStatements?.buildUnexpectedNodes(format: format), statements: buildableData.statements.buildCodeBlockItemList(format: format._indented), buildableData.unexpectedBetweenStatementsAndRightBrace?.buildUnexpectedNodes(format: format), rightBrace: buildableData.rightBrace.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildCodeBlock(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsCodeBlock`.
  public func createCodeBlock() -> CodeBlock {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `CodeBlock` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct InOutExpr: ExprBuildable, ExpressibleAsInOutExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeAmpersand: UnexpectedNodes?
    var ampersand: Token
    var unexpectedBetweenAmpersandAndExpression: UnexpectedNodes?
    var expression: ExprBuildable
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(InOutExprSyntax)
  }
  private var data: Data
  /// Creates a `InOutExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAmpersand: 
  ///   - ampersand: 
  ///   - unexpectedBetweenAmpersandAndExpression: 
  ///   - expression: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAmpersand: ExpressibleAsUnexpectedNodes? = nil, ampersand: Token = Token.`prefixAmpersand`, unexpectedBetweenAmpersandAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable) {
    assert(ampersand.text == #"&"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeAmpersand: unexpectedBeforeAmpersand?.createUnexpectedNodes(), ampersand: ampersand, unexpectedBetweenAmpersandAndExpression: unexpectedBetweenAmpersandAndExpression?.createUnexpectedNodes(), expression: expression.createExprBuildable()))
  }
  public init(_ constructedNode: InOutExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `InOutExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `InOutExprSyntax`.
  func buildInOutExpr(format: Format) -> InOutExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = InOutExprSyntax(buildableData.unexpectedBeforeAmpersand?.buildUnexpectedNodes(format: format), ampersand: buildableData.ampersand.buildToken(format: format), buildableData.unexpectedBetweenAmpersandAndExpression?.buildUnexpectedNodes(format: format), expression: buildableData.expression.buildExpr(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildInOutExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsInOutExpr`.
  public func createInOutExpr() -> InOutExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `InOutExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct PoundColumnExpr: ExprBuildable, ExpressibleAsPoundColumnExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforePoundColumn: UnexpectedNodes?
    var poundColumn: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(PoundColumnExprSyntax)
  }
  private var data: Data
  /// Creates a `PoundColumnExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundColumn: 
  ///   - poundColumn: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePoundColumn: ExpressibleAsUnexpectedNodes? = nil, poundColumn: Token = Token.`poundColumn`) {
    assert(poundColumn.text == #"#column"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforePoundColumn: unexpectedBeforePoundColumn?.createUnexpectedNodes(), poundColumn: poundColumn))
  }
  public init(_ constructedNode: PoundColumnExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `PoundColumnExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PoundColumnExprSyntax`.
  func buildPoundColumnExpr(format: Format) -> PoundColumnExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = PoundColumnExprSyntax(buildableData.unexpectedBeforePoundColumn?.buildUnexpectedNodes(format: format), poundColumn: buildableData.poundColumn.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildPoundColumnExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsPoundColumnExpr`.
  public func createPoundColumnExpr() -> PoundColumnExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `PoundColumnExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct TryExpr: ExprBuildable, ExpressibleAsTryExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeTryKeyword: UnexpectedNodes?
    var tryKeyword: Token
    var unexpectedBetweenTryKeywordAndQuestionOrExclamationMark: UnexpectedNodes?
    var questionOrExclamationMark: Token?
    var unexpectedBetweenQuestionOrExclamationMarkAndExpression: UnexpectedNodes?
    var expression: ExprBuildable
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(TryExprSyntax)
  }
  private var data: Data
  /// Creates a `TryExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeTryKeyword: 
  ///   - tryKeyword: 
  ///   - unexpectedBetweenTryKeywordAndQuestionOrExclamationMark: 
  ///   - questionOrExclamationMark: 
  ///   - unexpectedBetweenQuestionOrExclamationMarkAndExpression: 
  ///   - expression: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeTryKeyword: ExpressibleAsUnexpectedNodes? = nil, tryKeyword: Token = Token.`try`, unexpectedBetweenTryKeywordAndQuestionOrExclamationMark: ExpressibleAsUnexpectedNodes? = nil, questionOrExclamationMark: Token? = nil, unexpectedBetweenQuestionOrExclamationMarkAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable) {
    assert(tryKeyword.text == #"try"#)
    assert(questionOrExclamationMark == nil || questionOrExclamationMark!.text == #"?"# || questionOrExclamationMark!.text == #"!"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeTryKeyword: unexpectedBeforeTryKeyword?.createUnexpectedNodes(), tryKeyword: tryKeyword, unexpectedBetweenTryKeywordAndQuestionOrExclamationMark: unexpectedBetweenTryKeywordAndQuestionOrExclamationMark?.createUnexpectedNodes(), questionOrExclamationMark: questionOrExclamationMark, unexpectedBetweenQuestionOrExclamationMarkAndExpression: unexpectedBetweenQuestionOrExclamationMarkAndExpression?.createUnexpectedNodes(), expression: expression.createExprBuildable()))
  }
  public init(_ constructedNode: TryExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `TryExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TryExprSyntax`.
  func buildTryExpr(format: Format) -> TryExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = TryExprSyntax(buildableData.unexpectedBeforeTryKeyword?.buildUnexpectedNodes(format: format), tryKeyword: buildableData.tryKeyword.buildToken(format: format), buildableData.unexpectedBetweenTryKeywordAndQuestionOrExclamationMark?.buildUnexpectedNodes(format: format), questionOrExclamationMark: buildableData.questionOrExclamationMark?.buildToken(format: format), buildableData.unexpectedBetweenQuestionOrExclamationMarkAndExpression?.buildUnexpectedNodes(format: format), expression: buildableData.expression.buildExpr(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildTryExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsTryExpr`.
  public func createTryExpr() -> TryExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `TryExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct AwaitExpr: ExprBuildable, ExpressibleAsAwaitExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeAwaitKeyword: UnexpectedNodes?
    var awaitKeyword: Token
    var unexpectedBetweenAwaitKeywordAndExpression: UnexpectedNodes?
    var expression: ExprBuildable
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(AwaitExprSyntax)
  }
  private var data: Data
  /// Creates a `AwaitExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAwaitKeyword: 
  ///   - awaitKeyword: 
  ///   - unexpectedBetweenAwaitKeywordAndExpression: 
  ///   - expression: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAwaitKeyword: ExpressibleAsUnexpectedNodes? = nil, awaitKeyword: Token, unexpectedBetweenAwaitKeywordAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable) {
    assert(awaitKeyword.text == #"await"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeAwaitKeyword: unexpectedBeforeAwaitKeyword?.createUnexpectedNodes(), awaitKeyword: awaitKeyword, unexpectedBetweenAwaitKeywordAndExpression: unexpectedBetweenAwaitKeywordAndExpression?.createUnexpectedNodes(), expression: expression.createExprBuildable()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAwaitKeyword: ExpressibleAsUnexpectedNodes? = nil, awaitKeyword: String, unexpectedBetweenAwaitKeywordAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAwaitKeyword: unexpectedBeforeAwaitKeyword, awaitKeyword: Token.`contextualKeyword`(awaitKeyword), unexpectedBetweenAwaitKeywordAndExpression: unexpectedBetweenAwaitKeywordAndExpression, expression: expression)
  }
  public init(_ constructedNode: AwaitExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `AwaitExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AwaitExprSyntax`.
  func buildAwaitExpr(format: Format) -> AwaitExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = AwaitExprSyntax(buildableData.unexpectedBeforeAwaitKeyword?.buildUnexpectedNodes(format: format), awaitKeyword: buildableData.awaitKeyword.buildToken(format: format), buildableData.unexpectedBetweenAwaitKeywordAndExpression?.buildUnexpectedNodes(format: format), expression: buildableData.expression.buildExpr(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildAwaitExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsAwaitExpr`.
  public func createAwaitExpr() -> AwaitExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `AwaitExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct MoveExpr: ExprBuildable, ExpressibleAsMoveExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeMoveKeyword: UnexpectedNodes?
    var moveKeyword: Token
    var unexpectedBetweenMoveKeywordAndExpression: UnexpectedNodes?
    var expression: ExprBuildable
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(MoveExprSyntax)
  }
  private var data: Data
  /// Creates a `MoveExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeMoveKeyword: 
  ///   - moveKeyword: 
  ///   - unexpectedBetweenMoveKeywordAndExpression: 
  ///   - expression: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeMoveKeyword: ExpressibleAsUnexpectedNodes? = nil, moveKeyword: Token, unexpectedBetweenMoveKeywordAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable) {
    assert(moveKeyword.text == #"_move"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeMoveKeyword: unexpectedBeforeMoveKeyword?.createUnexpectedNodes(), moveKeyword: moveKeyword, unexpectedBetweenMoveKeywordAndExpression: unexpectedBetweenMoveKeywordAndExpression?.createUnexpectedNodes(), expression: expression.createExprBuildable()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeMoveKeyword: ExpressibleAsUnexpectedNodes? = nil, moveKeyword: String, unexpectedBetweenMoveKeywordAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeMoveKeyword: unexpectedBeforeMoveKeyword, moveKeyword: Token.`contextualKeyword`(moveKeyword), unexpectedBetweenMoveKeywordAndExpression: unexpectedBetweenMoveKeywordAndExpression, expression: expression)
  }
  public init(_ constructedNode: MoveExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `MoveExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `MoveExprSyntax`.
  func buildMoveExpr(format: Format) -> MoveExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = MoveExprSyntax(buildableData.unexpectedBeforeMoveKeyword?.buildUnexpectedNodes(format: format), moveKeyword: buildableData.moveKeyword.buildToken(format: format), buildableData.unexpectedBetweenMoveKeywordAndExpression?.buildUnexpectedNodes(format: format), expression: buildableData.expression.buildExpr(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildMoveExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsMoveExpr`.
  public func createMoveExpr() -> MoveExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `MoveExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct DeclNameArgument: SyntaxBuildable, ExpressibleAsDeclNameArgument {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeName: UnexpectedNodes?
    var name: Token
    var unexpectedBetweenNameAndColon: UnexpectedNodes?
    var colon: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(DeclNameArgumentSyntax)
  }
  private var data: Data
  /// Creates a `DeclNameArgument` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndColon: 
  ///   - colon: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`) {
    assert(colon.text == #":"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeName: unexpectedBeforeName?.createUnexpectedNodes(), name: name, unexpectedBetweenNameAndColon: unexpectedBetweenNameAndColon?.createUnexpectedNodes(), colon: colon))
  }
  public init(_ constructedNode: DeclNameArgumentSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `DeclNameArgumentSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DeclNameArgumentSyntax`.
  func buildDeclNameArgument(format: Format) -> DeclNameArgumentSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = DeclNameArgumentSyntax(buildableData.unexpectedBeforeName?.buildUnexpectedNodes(format: format), name: buildableData.name.buildToken(format: format), buildableData.unexpectedBetweenNameAndColon?.buildUnexpectedNodes(format: format), colon: buildableData.colon.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildDeclNameArgument(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsDeclNameArgument`.
  public func createDeclNameArgument() -> DeclNameArgument {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclNameArgument` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct DeclNameArguments: SyntaxBuildable, ExpressibleAsDeclNameArguments {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeLeftParen: UnexpectedNodes?
    var leftParen: Token
    var unexpectedBetweenLeftParenAndArguments: UnexpectedNodes?
    var arguments: DeclNameArgumentList
    var unexpectedBetweenArgumentsAndRightParen: UnexpectedNodes?
    var rightParen: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(DeclNameArgumentsSyntax)
  }
  private var data: Data
  /// Creates a `DeclNameArguments` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndArguments: 
  ///   - arguments: 
  ///   - unexpectedBetweenArgumentsAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndArguments: ExpressibleAsUnexpectedNodes? = nil, arguments: ExpressibleAsDeclNameArgumentList, unexpectedBetweenArgumentsAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    assert(leftParen.text == #"("#)
    assert(rightParen.text == #")"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeLeftParen: unexpectedBeforeLeftParen?.createUnexpectedNodes(), leftParen: leftParen, unexpectedBetweenLeftParenAndArguments: unexpectedBetweenLeftParenAndArguments?.createUnexpectedNodes(), arguments: arguments.createDeclNameArgumentList(), unexpectedBetweenArgumentsAndRightParen: unexpectedBetweenArgumentsAndRightParen?.createUnexpectedNodes(), rightParen: rightParen))
  }
  public init(_ constructedNode: DeclNameArgumentsSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `DeclNameArgumentsSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DeclNameArgumentsSyntax`.
  func buildDeclNameArguments(format: Format) -> DeclNameArgumentsSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = DeclNameArgumentsSyntax(buildableData.unexpectedBeforeLeftParen?.buildUnexpectedNodes(format: format), leftParen: buildableData.leftParen.buildToken(format: format), buildableData.unexpectedBetweenLeftParenAndArguments?.buildUnexpectedNodes(format: format), arguments: buildableData.arguments.buildDeclNameArgumentList(format: format), buildableData.unexpectedBetweenArgumentsAndRightParen?.buildUnexpectedNodes(format: format), rightParen: buildableData.rightParen.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildDeclNameArguments(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsDeclNameArguments`.
  public func createDeclNameArguments() -> DeclNameArguments {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclNameArguments` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct IdentifierExpr: ExprBuildable, ExpressibleAsIdentifierExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeIdentifier: UnexpectedNodes?
    var identifier: Token
    var unexpectedBetweenIdentifierAndDeclNameArguments: UnexpectedNodes?
    var declNameArguments: DeclNameArguments?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(IdentifierExprSyntax)
  }
  private var data: Data
  /// Creates a `IdentifierExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeIdentifier: 
  ///   - identifier: 
  ///   - unexpectedBetweenIdentifierAndDeclNameArguments: 
  ///   - declNameArguments: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndDeclNameArguments: ExpressibleAsUnexpectedNodes? = nil, declNameArguments: ExpressibleAsDeclNameArguments? = nil) {
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeIdentifier: unexpectedBeforeIdentifier?.createUnexpectedNodes(), identifier: identifier, unexpectedBetweenIdentifierAndDeclNameArguments: unexpectedBetweenIdentifierAndDeclNameArguments?.createUnexpectedNodes(), declNameArguments: declNameArguments?.createDeclNameArguments()))
  }
  public init(_ constructedNode: IdentifierExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `IdentifierExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `IdentifierExprSyntax`.
  func buildIdentifierExpr(format: Format) -> IdentifierExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = IdentifierExprSyntax(buildableData.unexpectedBeforeIdentifier?.buildUnexpectedNodes(format: format), identifier: buildableData.identifier.buildToken(format: format), buildableData.unexpectedBetweenIdentifierAndDeclNameArguments?.buildUnexpectedNodes(format: format), declNameArguments: buildableData.declNameArguments?.buildDeclNameArguments(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildIdentifierExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsIdentifierExpr`.
  public func createIdentifierExpr() -> IdentifierExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `IdentifierExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct SuperRefExpr: ExprBuildable, ExpressibleAsSuperRefExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeSuperKeyword: UnexpectedNodes?
    var superKeyword: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(SuperRefExprSyntax)
  }
  private var data: Data
  /// Creates a `SuperRefExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeSuperKeyword: 
  ///   - superKeyword: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeSuperKeyword: ExpressibleAsUnexpectedNodes? = nil, superKeyword: Token = Token.`super`) {
    assert(superKeyword.text == #"super"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeSuperKeyword: unexpectedBeforeSuperKeyword?.createUnexpectedNodes(), superKeyword: superKeyword))
  }
  public init(_ constructedNode: SuperRefExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `SuperRefExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SuperRefExprSyntax`.
  func buildSuperRefExpr(format: Format) -> SuperRefExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = SuperRefExprSyntax(buildableData.unexpectedBeforeSuperKeyword?.buildUnexpectedNodes(format: format), superKeyword: buildableData.superKeyword.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildSuperRefExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsSuperRefExpr`.
  public func createSuperRefExpr() -> SuperRefExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `SuperRefExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct NilLiteralExpr: ExprBuildable, ExpressibleAsNilLiteralExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeNilKeyword: UnexpectedNodes?
    var nilKeyword: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(NilLiteralExprSyntax)
  }
  private var data: Data
  /// Creates a `NilLiteralExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeNilKeyword: 
  ///   - nilKeyword: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeNilKeyword: ExpressibleAsUnexpectedNodes? = nil, nilKeyword: Token = Token.`nil`) {
    assert(nilKeyword.text == #"nil"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeNilKeyword: unexpectedBeforeNilKeyword?.createUnexpectedNodes(), nilKeyword: nilKeyword))
  }
  public init(_ constructedNode: NilLiteralExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `NilLiteralExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `NilLiteralExprSyntax`.
  func buildNilLiteralExpr(format: Format) -> NilLiteralExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = NilLiteralExprSyntax(buildableData.unexpectedBeforeNilKeyword?.buildUnexpectedNodes(format: format), nilKeyword: buildableData.nilKeyword.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildNilLiteralExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsNilLiteralExpr`.
  public func createNilLiteralExpr() -> NilLiteralExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `NilLiteralExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct DiscardAssignmentExpr: ExprBuildable, ExpressibleAsDiscardAssignmentExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeWildcard: UnexpectedNodes?
    var wildcard: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(DiscardAssignmentExprSyntax)
  }
  private var data: Data
  /// Creates a `DiscardAssignmentExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeWildcard: 
  ///   - wildcard: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeWildcard: ExpressibleAsUnexpectedNodes? = nil, wildcard: Token = Token.`wildcard`) {
    assert(wildcard.text == #"_"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeWildcard: unexpectedBeforeWildcard?.createUnexpectedNodes(), wildcard: wildcard))
  }
  public init(_ constructedNode: DiscardAssignmentExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `DiscardAssignmentExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DiscardAssignmentExprSyntax`.
  func buildDiscardAssignmentExpr(format: Format) -> DiscardAssignmentExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = DiscardAssignmentExprSyntax(buildableData.unexpectedBeforeWildcard?.buildUnexpectedNodes(format: format), wildcard: buildableData.wildcard.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildDiscardAssignmentExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsDiscardAssignmentExpr`.
  public func createDiscardAssignmentExpr() -> DiscardAssignmentExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `DiscardAssignmentExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct AssignmentExpr: ExprBuildable, ExpressibleAsAssignmentExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeAssignToken: UnexpectedNodes?
    var assignToken: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(AssignmentExprSyntax)
  }
  private var data: Data
  /// Creates a `AssignmentExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAssignToken: 
  ///   - assignToken: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAssignToken: ExpressibleAsUnexpectedNodes? = nil, assignToken: Token = Token.`equal`) {
    assert(assignToken.text == #"="#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeAssignToken: unexpectedBeforeAssignToken?.createUnexpectedNodes(), assignToken: assignToken))
  }
  public init(_ constructedNode: AssignmentExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `AssignmentExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AssignmentExprSyntax`.
  func buildAssignmentExpr(format: Format) -> AssignmentExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = AssignmentExprSyntax(buildableData.unexpectedBeforeAssignToken?.buildUnexpectedNodes(format: format), assignToken: buildableData.assignToken.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildAssignmentExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsAssignmentExpr`.
  public func createAssignmentExpr() -> AssignmentExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `AssignmentExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct SequenceExpr: ExprBuildable, ExpressibleAsSequenceExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeElements: UnexpectedNodes?
    var elements: ExprList
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(SequenceExprSyntax)
  }
  private var data: Data
  /// Creates a `SequenceExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeElements: 
  ///   - elements: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeElements: ExpressibleAsUnexpectedNodes? = nil, elements: ExpressibleAsExprList) {
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeElements: unexpectedBeforeElements?.createUnexpectedNodes(), elements: elements.createExprList()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeElements: ExpressibleAsUnexpectedNodes? = nil, @ExprListBuilder elementsBuilder: () -> ExpressibleAsExprList =  {
    ExprList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeElements: unexpectedBeforeElements, elements: elementsBuilder())
  }
  public init(_ constructedNode: SequenceExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `SequenceExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SequenceExprSyntax`.
  func buildSequenceExpr(format: Format) -> SequenceExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = SequenceExprSyntax(buildableData.unexpectedBeforeElements?.buildUnexpectedNodes(format: format), elements: buildableData.elements.buildExprList(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildSequenceExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsSequenceExpr`.
  public func createSequenceExpr() -> SequenceExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `SequenceExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct PoundLineExpr: ExprBuildable, ExpressibleAsPoundLineExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforePoundLine: UnexpectedNodes?
    var poundLine: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(PoundLineExprSyntax)
  }
  private var data: Data
  /// Creates a `PoundLineExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundLine: 
  ///   - poundLine: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePoundLine: ExpressibleAsUnexpectedNodes? = nil, poundLine: Token = Token.`poundLine`) {
    assert(poundLine.text == #"#line"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforePoundLine: unexpectedBeforePoundLine?.createUnexpectedNodes(), poundLine: poundLine))
  }
  public init(_ constructedNode: PoundLineExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `PoundLineExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PoundLineExprSyntax`.
  func buildPoundLineExpr(format: Format) -> PoundLineExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = PoundLineExprSyntax(buildableData.unexpectedBeforePoundLine?.buildUnexpectedNodes(format: format), poundLine: buildableData.poundLine.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildPoundLineExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsPoundLineExpr`.
  public func createPoundLineExpr() -> PoundLineExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `PoundLineExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct PoundFileExpr: ExprBuildable, ExpressibleAsPoundFileExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforePoundFile: UnexpectedNodes?
    var poundFile: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(PoundFileExprSyntax)
  }
  private var data: Data
  /// Creates a `PoundFileExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundFile: 
  ///   - poundFile: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePoundFile: ExpressibleAsUnexpectedNodes? = nil, poundFile: Token = Token.`poundFile`) {
    assert(poundFile.text == #"#file"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforePoundFile: unexpectedBeforePoundFile?.createUnexpectedNodes(), poundFile: poundFile))
  }
  public init(_ constructedNode: PoundFileExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `PoundFileExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PoundFileExprSyntax`.
  func buildPoundFileExpr(format: Format) -> PoundFileExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = PoundFileExprSyntax(buildableData.unexpectedBeforePoundFile?.buildUnexpectedNodes(format: format), poundFile: buildableData.poundFile.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildPoundFileExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsPoundFileExpr`.
  public func createPoundFileExpr() -> PoundFileExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `PoundFileExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct PoundFileIDExpr: ExprBuildable, ExpressibleAsPoundFileIDExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforePoundFileID: UnexpectedNodes?
    var poundFileID: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(PoundFileIDExprSyntax)
  }
  private var data: Data
  /// Creates a `PoundFileIDExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundFileID: 
  ///   - poundFileID: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePoundFileID: ExpressibleAsUnexpectedNodes? = nil, poundFileID: Token = Token.`poundFileID`) {
    assert(poundFileID.text == #"#fileID"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforePoundFileID: unexpectedBeforePoundFileID?.createUnexpectedNodes(), poundFileID: poundFileID))
  }
  public init(_ constructedNode: PoundFileIDExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `PoundFileIDExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PoundFileIDExprSyntax`.
  func buildPoundFileIDExpr(format: Format) -> PoundFileIDExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = PoundFileIDExprSyntax(buildableData.unexpectedBeforePoundFileID?.buildUnexpectedNodes(format: format), poundFileID: buildableData.poundFileID.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildPoundFileIDExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsPoundFileIDExpr`.
  public func createPoundFileIDExpr() -> PoundFileIDExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `PoundFileIDExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct PoundFilePathExpr: ExprBuildable, ExpressibleAsPoundFilePathExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforePoundFilePath: UnexpectedNodes?
    var poundFilePath: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(PoundFilePathExprSyntax)
  }
  private var data: Data
  /// Creates a `PoundFilePathExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundFilePath: 
  ///   - poundFilePath: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePoundFilePath: ExpressibleAsUnexpectedNodes? = nil, poundFilePath: Token = Token.`poundFilePath`) {
    assert(poundFilePath.text == #"#filePath"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforePoundFilePath: unexpectedBeforePoundFilePath?.createUnexpectedNodes(), poundFilePath: poundFilePath))
  }
  public init(_ constructedNode: PoundFilePathExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `PoundFilePathExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PoundFilePathExprSyntax`.
  func buildPoundFilePathExpr(format: Format) -> PoundFilePathExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = PoundFilePathExprSyntax(buildableData.unexpectedBeforePoundFilePath?.buildUnexpectedNodes(format: format), poundFilePath: buildableData.poundFilePath.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildPoundFilePathExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsPoundFilePathExpr`.
  public func createPoundFilePathExpr() -> PoundFilePathExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `PoundFilePathExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct PoundFunctionExpr: ExprBuildable, ExpressibleAsPoundFunctionExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforePoundFunction: UnexpectedNodes?
    var poundFunction: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(PoundFunctionExprSyntax)
  }
  private var data: Data
  /// Creates a `PoundFunctionExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundFunction: 
  ///   - poundFunction: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePoundFunction: ExpressibleAsUnexpectedNodes? = nil, poundFunction: Token = Token.`poundFunction`) {
    assert(poundFunction.text == #"#function"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforePoundFunction: unexpectedBeforePoundFunction?.createUnexpectedNodes(), poundFunction: poundFunction))
  }
  public init(_ constructedNode: PoundFunctionExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `PoundFunctionExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PoundFunctionExprSyntax`.
  func buildPoundFunctionExpr(format: Format) -> PoundFunctionExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = PoundFunctionExprSyntax(buildableData.unexpectedBeforePoundFunction?.buildUnexpectedNodes(format: format), poundFunction: buildableData.poundFunction.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildPoundFunctionExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsPoundFunctionExpr`.
  public func createPoundFunctionExpr() -> PoundFunctionExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `PoundFunctionExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct PoundDsohandleExpr: ExprBuildable, ExpressibleAsPoundDsohandleExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforePoundDsohandle: UnexpectedNodes?
    var poundDsohandle: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(PoundDsohandleExprSyntax)
  }
  private var data: Data
  /// Creates a `PoundDsohandleExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundDsohandle: 
  ///   - poundDsohandle: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePoundDsohandle: ExpressibleAsUnexpectedNodes? = nil, poundDsohandle: Token = Token.`poundDsohandle`) {
    assert(poundDsohandle.text == #"#dsohandle"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforePoundDsohandle: unexpectedBeforePoundDsohandle?.createUnexpectedNodes(), poundDsohandle: poundDsohandle))
  }
  public init(_ constructedNode: PoundDsohandleExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `PoundDsohandleExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PoundDsohandleExprSyntax`.
  func buildPoundDsohandleExpr(format: Format) -> PoundDsohandleExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = PoundDsohandleExprSyntax(buildableData.unexpectedBeforePoundDsohandle?.buildUnexpectedNodes(format: format), poundDsohandle: buildableData.poundDsohandle.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildPoundDsohandleExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsPoundDsohandleExpr`.
  public func createPoundDsohandleExpr() -> PoundDsohandleExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `PoundDsohandleExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct SymbolicReferenceExpr: ExprBuildable, ExpressibleAsSymbolicReferenceExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeIdentifier: UnexpectedNodes?
    var identifier: Token
    var unexpectedBetweenIdentifierAndGenericArgumentClause: UnexpectedNodes?
    var genericArgumentClause: GenericArgumentClause?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(SymbolicReferenceExprSyntax)
  }
  private var data: Data
  /// Creates a `SymbolicReferenceExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeIdentifier: 
  ///   - identifier: 
  ///   - unexpectedBetweenIdentifierAndGenericArgumentClause: 
  ///   - genericArgumentClause: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndGenericArgumentClause: ExpressibleAsUnexpectedNodes? = nil, genericArgumentClause: ExpressibleAsGenericArgumentClause? = nil) {
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeIdentifier: unexpectedBeforeIdentifier?.createUnexpectedNodes(), identifier: identifier, unexpectedBetweenIdentifierAndGenericArgumentClause: unexpectedBetweenIdentifierAndGenericArgumentClause?.createUnexpectedNodes(), genericArgumentClause: genericArgumentClause?.createGenericArgumentClause()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: String, unexpectedBetweenIdentifierAndGenericArgumentClause: ExpressibleAsUnexpectedNodes? = nil, genericArgumentClause: ExpressibleAsGenericArgumentClause? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeIdentifier: unexpectedBeforeIdentifier, identifier: Token.`identifier`(identifier), unexpectedBetweenIdentifierAndGenericArgumentClause: unexpectedBetweenIdentifierAndGenericArgumentClause, genericArgumentClause: genericArgumentClause)
  }
  public init(_ constructedNode: SymbolicReferenceExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `SymbolicReferenceExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SymbolicReferenceExprSyntax`.
  func buildSymbolicReferenceExpr(format: Format) -> SymbolicReferenceExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = SymbolicReferenceExprSyntax(buildableData.unexpectedBeforeIdentifier?.buildUnexpectedNodes(format: format), identifier: buildableData.identifier.buildToken(format: format), buildableData.unexpectedBetweenIdentifierAndGenericArgumentClause?.buildUnexpectedNodes(format: format), genericArgumentClause: buildableData.genericArgumentClause?.buildGenericArgumentClause(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildSymbolicReferenceExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsSymbolicReferenceExpr`.
  public func createSymbolicReferenceExpr() -> SymbolicReferenceExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `SymbolicReferenceExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct PrefixOperatorExpr: ExprBuildable, ExpressibleAsPrefixOperatorExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeOperatorToken: UnexpectedNodes?
    var operatorToken: Token?
    var unexpectedBetweenOperatorTokenAndPostfixExpression: UnexpectedNodes?
    var postfixExpression: ExprBuildable
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(PrefixOperatorExprSyntax)
  }
  private var data: Data
  /// Creates a `PrefixOperatorExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeOperatorToken: 
  ///   - operatorToken: 
  ///   - unexpectedBetweenOperatorTokenAndPostfixExpression: 
  ///   - postfixExpression: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeOperatorToken: ExpressibleAsUnexpectedNodes? = nil, operatorToken: Token? = nil, unexpectedBetweenOperatorTokenAndPostfixExpression: ExpressibleAsUnexpectedNodes? = nil, postfixExpression: ExpressibleAsExprBuildable) {
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeOperatorToken: unexpectedBeforeOperatorToken?.createUnexpectedNodes(), operatorToken: operatorToken, unexpectedBetweenOperatorTokenAndPostfixExpression: unexpectedBetweenOperatorTokenAndPostfixExpression?.createUnexpectedNodes(), postfixExpression: postfixExpression.createExprBuildable()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeOperatorToken: ExpressibleAsUnexpectedNodes? = nil, operatorToken: String?, unexpectedBetweenOperatorTokenAndPostfixExpression: ExpressibleAsUnexpectedNodes? = nil, postfixExpression: ExpressibleAsExprBuildable) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeOperatorToken: unexpectedBeforeOperatorToken, operatorToken: operatorToken.map { Token.`prefixOperator`($0) }, unexpectedBetweenOperatorTokenAndPostfixExpression: unexpectedBetweenOperatorTokenAndPostfixExpression, postfixExpression: postfixExpression)
  }
  public init(_ constructedNode: PrefixOperatorExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `PrefixOperatorExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PrefixOperatorExprSyntax`.
  func buildPrefixOperatorExpr(format: Format) -> PrefixOperatorExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = PrefixOperatorExprSyntax(buildableData.unexpectedBeforeOperatorToken?.buildUnexpectedNodes(format: format), operatorToken: buildableData.operatorToken?.buildToken(format: format), buildableData.unexpectedBetweenOperatorTokenAndPostfixExpression?.buildUnexpectedNodes(format: format), postfixExpression: buildableData.postfixExpression.buildExpr(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildPrefixOperatorExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsPrefixOperatorExpr`.
  public func createPrefixOperatorExpr() -> PrefixOperatorExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `PrefixOperatorExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct BinaryOperatorExpr: ExprBuildable, ExpressibleAsBinaryOperatorExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeOperatorToken: UnexpectedNodes?
    var operatorToken: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(BinaryOperatorExprSyntax)
  }
  private var data: Data
  /// Creates a `BinaryOperatorExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeOperatorToken: 
  ///   - operatorToken: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeOperatorToken: ExpressibleAsUnexpectedNodes? = nil, operatorToken: Token) {
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeOperatorToken: unexpectedBeforeOperatorToken?.createUnexpectedNodes(), operatorToken: operatorToken))
  }
  public init(_ constructedNode: BinaryOperatorExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `BinaryOperatorExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `BinaryOperatorExprSyntax`.
  func buildBinaryOperatorExpr(format: Format) -> BinaryOperatorExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = BinaryOperatorExprSyntax(buildableData.unexpectedBeforeOperatorToken?.buildUnexpectedNodes(format: format), operatorToken: buildableData.operatorToken.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildBinaryOperatorExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsBinaryOperatorExpr`.
  public func createBinaryOperatorExpr() -> BinaryOperatorExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `BinaryOperatorExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct ArrowExpr: ExprBuildable, ExpressibleAsArrowExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeAsyncKeyword: UnexpectedNodes?
    var asyncKeyword: Token?
    var unexpectedBetweenAsyncKeywordAndThrowsToken: UnexpectedNodes?
    var throwsToken: Token?
    var unexpectedBetweenThrowsTokenAndArrowToken: UnexpectedNodes?
    var arrowToken: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ArrowExprSyntax)
  }
  private var data: Data
  /// Creates a `ArrowExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAsyncKeyword: 
  ///   - asyncKeyword: 
  ///   - unexpectedBetweenAsyncKeywordAndThrowsToken: 
  ///   - throwsToken: 
  ///   - unexpectedBetweenThrowsTokenAndArrowToken: 
  ///   - arrowToken: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAsyncKeyword: ExpressibleAsUnexpectedNodes? = nil, asyncKeyword: Token? = nil, unexpectedBetweenAsyncKeywordAndThrowsToken: ExpressibleAsUnexpectedNodes? = nil, throwsToken: Token? = nil, unexpectedBetweenThrowsTokenAndArrowToken: ExpressibleAsUnexpectedNodes? = nil, arrowToken: Token = Token.`arrow`) {
    assert(asyncKeyword == nil || asyncKeyword!.text == #"async"#)
    assert(throwsToken == nil || throwsToken!.text == #"throws"#)
    assert(arrowToken.text == #"->"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeAsyncKeyword: unexpectedBeforeAsyncKeyword?.createUnexpectedNodes(), asyncKeyword: asyncKeyword, unexpectedBetweenAsyncKeywordAndThrowsToken: unexpectedBetweenAsyncKeywordAndThrowsToken?.createUnexpectedNodes(), throwsToken: throwsToken, unexpectedBetweenThrowsTokenAndArrowToken: unexpectedBetweenThrowsTokenAndArrowToken?.createUnexpectedNodes(), arrowToken: arrowToken))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAsyncKeyword: ExpressibleAsUnexpectedNodes? = nil, asyncKeyword: String?, unexpectedBetweenAsyncKeywordAndThrowsToken: ExpressibleAsUnexpectedNodes? = nil, throwsToken: Token? = nil, unexpectedBetweenThrowsTokenAndArrowToken: ExpressibleAsUnexpectedNodes? = nil, arrowToken: Token = Token.`arrow`) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAsyncKeyword: unexpectedBeforeAsyncKeyword, asyncKeyword: asyncKeyword.map { Token.`contextualKeyword`($0) }, unexpectedBetweenAsyncKeywordAndThrowsToken: unexpectedBetweenAsyncKeywordAndThrowsToken, throwsToken: throwsToken, unexpectedBetweenThrowsTokenAndArrowToken: unexpectedBetweenThrowsTokenAndArrowToken, arrowToken: arrowToken)
  }
  public init(_ constructedNode: ArrowExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ArrowExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ArrowExprSyntax`.
  func buildArrowExpr(format: Format) -> ArrowExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ArrowExprSyntax(buildableData.unexpectedBeforeAsyncKeyword?.buildUnexpectedNodes(format: format), asyncKeyword: buildableData.asyncKeyword?.buildToken(format: format), buildableData.unexpectedBetweenAsyncKeywordAndThrowsToken?.buildUnexpectedNodes(format: format), throwsToken: buildableData.throwsToken?.buildToken(format: format), buildableData.unexpectedBetweenThrowsTokenAndArrowToken?.buildUnexpectedNodes(format: format), arrowToken: buildableData.arrowToken.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildArrowExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsArrowExpr`.
  public func createArrowExpr() -> ArrowExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `ArrowExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct InfixOperatorExpr: ExprBuildable, ExpressibleAsInfixOperatorExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeLeftOperand: UnexpectedNodes?
    var leftOperand: ExprBuildable
    var unexpectedBetweenLeftOperandAndOperatorOperand: UnexpectedNodes?
    var operatorOperand: ExprBuildable
    var unexpectedBetweenOperatorOperandAndRightOperand: UnexpectedNodes?
    var rightOperand: ExprBuildable
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(InfixOperatorExprSyntax)
  }
  private var data: Data
  /// Creates a `InfixOperatorExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftOperand: 
  ///   - leftOperand: 
  ///   - unexpectedBetweenLeftOperandAndOperatorOperand: 
  ///   - operatorOperand: 
  ///   - unexpectedBetweenOperatorOperandAndRightOperand: 
  ///   - rightOperand: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftOperand: ExpressibleAsUnexpectedNodes? = nil, leftOperand: ExpressibleAsExprBuildable, unexpectedBetweenLeftOperandAndOperatorOperand: ExpressibleAsUnexpectedNodes? = nil, operatorOperand: ExpressibleAsExprBuildable, unexpectedBetweenOperatorOperandAndRightOperand: ExpressibleAsUnexpectedNodes? = nil, rightOperand: ExpressibleAsExprBuildable) {
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeLeftOperand: unexpectedBeforeLeftOperand?.createUnexpectedNodes(), leftOperand: leftOperand.createExprBuildable(), unexpectedBetweenLeftOperandAndOperatorOperand: unexpectedBetweenLeftOperandAndOperatorOperand?.createUnexpectedNodes(), operatorOperand: operatorOperand.createExprBuildable(), unexpectedBetweenOperatorOperandAndRightOperand: unexpectedBetweenOperatorOperandAndRightOperand?.createUnexpectedNodes(), rightOperand: rightOperand.createExprBuildable()))
  }
  public init(_ constructedNode: InfixOperatorExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `InfixOperatorExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `InfixOperatorExprSyntax`.
  func buildInfixOperatorExpr(format: Format) -> InfixOperatorExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = InfixOperatorExprSyntax(buildableData.unexpectedBeforeLeftOperand?.buildUnexpectedNodes(format: format), leftOperand: buildableData.leftOperand.buildExpr(format: format), buildableData.unexpectedBetweenLeftOperandAndOperatorOperand?.buildUnexpectedNodes(format: format), operatorOperand: buildableData.operatorOperand.buildExpr(format: format), buildableData.unexpectedBetweenOperatorOperandAndRightOperand?.buildUnexpectedNodes(format: format), rightOperand: buildableData.rightOperand.buildExpr(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildInfixOperatorExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsInfixOperatorExpr`.
  public func createInfixOperatorExpr() -> InfixOperatorExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `InfixOperatorExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct FloatLiteralExpr: ExprBuildable, ExpressibleAsFloatLiteralExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeFloatingDigits: UnexpectedNodes?
    var floatingDigits: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(FloatLiteralExprSyntax)
  }
  private var data: Data
  /// Creates a `FloatLiteralExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeFloatingDigits: 
  ///   - floatingDigits: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeFloatingDigits: ExpressibleAsUnexpectedNodes? = nil, floatingDigits: Token) {
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeFloatingDigits: unexpectedBeforeFloatingDigits?.createUnexpectedNodes(), floatingDigits: floatingDigits))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeFloatingDigits: ExpressibleAsUnexpectedNodes? = nil, floatingDigits: String) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeFloatingDigits: unexpectedBeforeFloatingDigits, floatingDigits: Token.`floatingLiteral`(floatingDigits))
  }
  public init(_ constructedNode: FloatLiteralExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `FloatLiteralExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `FloatLiteralExprSyntax`.
  func buildFloatLiteralExpr(format: Format) -> FloatLiteralExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = FloatLiteralExprSyntax(buildableData.unexpectedBeforeFloatingDigits?.buildUnexpectedNodes(format: format), floatingDigits: buildableData.floatingDigits.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildFloatLiteralExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsFloatLiteralExpr`.
  public func createFloatLiteralExpr() -> FloatLiteralExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `FloatLiteralExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct TupleExpr: ExprBuildable, ExpressibleAsTupleExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeLeftParen: UnexpectedNodes?
    var leftParen: Token
    var unexpectedBetweenLeftParenAndElementList: UnexpectedNodes?
    var elementList: TupleExprElementList
    var unexpectedBetweenElementListAndRightParen: UnexpectedNodes?
    var rightParen: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(TupleExprSyntax)
  }
  private var data: Data
  /// Creates a `TupleExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndElementList: 
  ///   - elementList: 
  ///   - unexpectedBetweenElementListAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndElementList: ExpressibleAsUnexpectedNodes? = nil, elementList: ExpressibleAsTupleExprElementList, unexpectedBetweenElementListAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    assert(leftParen.text == #"("#)
    assert(rightParen.text == #")"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeLeftParen: unexpectedBeforeLeftParen?.createUnexpectedNodes(), leftParen: leftParen, unexpectedBetweenLeftParenAndElementList: unexpectedBetweenLeftParenAndElementList?.createUnexpectedNodes(), elementList: elementList.createTupleExprElementList(), unexpectedBetweenElementListAndRightParen: unexpectedBetweenElementListAndRightParen?.createUnexpectedNodes(), rightParen: rightParen))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndElementList: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenElementListAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`, @TupleExprElementListBuilder elementListBuilder: () -> ExpressibleAsTupleExprElementList =  {
    TupleExprElementList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftParen: unexpectedBeforeLeftParen, leftParen: leftParen, unexpectedBetweenLeftParenAndElementList: unexpectedBetweenLeftParenAndElementList, elementList: elementListBuilder(), unexpectedBetweenElementListAndRightParen: unexpectedBetweenElementListAndRightParen, rightParen: rightParen)
  }
  public init(_ constructedNode: TupleExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `TupleExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TupleExprSyntax`.
  func buildTupleExpr(format: Format) -> TupleExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = TupleExprSyntax(buildableData.unexpectedBeforeLeftParen?.buildUnexpectedNodes(format: format), leftParen: buildableData.leftParen.buildToken(format: format), buildableData.unexpectedBetweenLeftParenAndElementList?.buildUnexpectedNodes(format: format), elementList: buildableData.elementList.buildTupleExprElementList(format: format), buildableData.unexpectedBetweenElementListAndRightParen?.buildUnexpectedNodes(format: format), rightParen: buildableData.rightParen.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildTupleExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsTupleExpr`.
  public func createTupleExpr() -> TupleExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `TupleExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct ArrayExpr: ExprBuildable, ExpressibleAsArrayExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeLeftSquare: UnexpectedNodes?
    var leftSquare: Token
    var unexpectedBetweenLeftSquareAndElements: UnexpectedNodes?
    var elements: ArrayElementList
    var unexpectedBetweenElementsAndRightSquare: UnexpectedNodes?
    var rightSquare: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ArrayExprSyntax)
  }
  private var data: Data
  /// Creates a `ArrayExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftSquare: 
  ///   - leftSquare: 
  ///   - unexpectedBetweenLeftSquareAndElements: 
  ///   - elements: 
  ///   - unexpectedBetweenElementsAndRightSquare: 
  ///   - rightSquare: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftSquare: ExpressibleAsUnexpectedNodes? = nil, leftSquare: Token = Token.`leftSquareBracket`, unexpectedBetweenLeftSquareAndElements: ExpressibleAsUnexpectedNodes? = nil, elements: ExpressibleAsArrayElementList, unexpectedBetweenElementsAndRightSquare: ExpressibleAsUnexpectedNodes? = nil, rightSquare: Token = Token.`rightSquareBracket`) {
    assert(leftSquare.text == #"["#)
    assert(rightSquare.text == #"]"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeLeftSquare: unexpectedBeforeLeftSquare?.createUnexpectedNodes(), leftSquare: leftSquare, unexpectedBetweenLeftSquareAndElements: unexpectedBetweenLeftSquareAndElements?.createUnexpectedNodes(), elements: elements.createArrayElementList(), unexpectedBetweenElementsAndRightSquare: unexpectedBetweenElementsAndRightSquare?.createUnexpectedNodes(), rightSquare: rightSquare))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftSquare: ExpressibleAsUnexpectedNodes? = nil, leftSquare: Token = Token.`leftSquareBracket`, unexpectedBetweenLeftSquareAndElements: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenElementsAndRightSquare: ExpressibleAsUnexpectedNodes? = nil, rightSquare: Token = Token.`rightSquareBracket`, @ArrayElementListBuilder elementsBuilder: () -> ExpressibleAsArrayElementList =  {
    ArrayElementList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftSquare: unexpectedBeforeLeftSquare, leftSquare: leftSquare, unexpectedBetweenLeftSquareAndElements: unexpectedBetweenLeftSquareAndElements, elements: elementsBuilder(), unexpectedBetweenElementsAndRightSquare: unexpectedBetweenElementsAndRightSquare, rightSquare: rightSquare)
  }
  public init(_ constructedNode: ArrayExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ArrayExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ArrayExprSyntax`.
  func buildArrayExpr(format: Format) -> ArrayExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ArrayExprSyntax(buildableData.unexpectedBeforeLeftSquare?.buildUnexpectedNodes(format: format), leftSquare: buildableData.leftSquare.buildToken(format: format), buildableData.unexpectedBetweenLeftSquareAndElements?.buildUnexpectedNodes(format: format), elements: buildableData.elements.buildArrayElementList(format: format), buildableData.unexpectedBetweenElementsAndRightSquare?.buildUnexpectedNodes(format: format), rightSquare: buildableData.rightSquare.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildArrayExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsArrayExpr`.
  public func createArrayExpr() -> ArrayExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `ArrayExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct DictionaryExpr: ExprBuildable, ExpressibleAsDictionaryExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeLeftSquare: UnexpectedNodes?
    var leftSquare: Token
    var unexpectedBetweenLeftSquareAndContent: UnexpectedNodes?
    var content: SyntaxBuildable
    var unexpectedBetweenContentAndRightSquare: UnexpectedNodes?
    var rightSquare: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(DictionaryExprSyntax)
  }
  private var data: Data
  /// Creates a `DictionaryExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftSquare: 
  ///   - leftSquare: 
  ///   - unexpectedBetweenLeftSquareAndContent: 
  ///   - content: 
  ///   - unexpectedBetweenContentAndRightSquare: 
  ///   - rightSquare: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftSquare: ExpressibleAsUnexpectedNodes? = nil, leftSquare: Token = Token.`leftSquareBracket`, unexpectedBetweenLeftSquareAndContent: ExpressibleAsUnexpectedNodes? = nil, content: ExpressibleAsSyntaxBuildable, unexpectedBetweenContentAndRightSquare: ExpressibleAsUnexpectedNodes? = nil, rightSquare: Token = Token.`rightSquareBracket`) {
    assert(leftSquare.text == #"["#)
    assert(rightSquare.text == #"]"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeLeftSquare: unexpectedBeforeLeftSquare?.createUnexpectedNodes(), leftSquare: leftSquare, unexpectedBetweenLeftSquareAndContent: unexpectedBetweenLeftSquareAndContent?.createUnexpectedNodes(), content: content.createSyntaxBuildable(), unexpectedBetweenContentAndRightSquare: unexpectedBetweenContentAndRightSquare?.createUnexpectedNodes(), rightSquare: rightSquare))
  }
  public init(_ constructedNode: DictionaryExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `DictionaryExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DictionaryExprSyntax`.
  func buildDictionaryExpr(format: Format) -> DictionaryExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = DictionaryExprSyntax(buildableData.unexpectedBeforeLeftSquare?.buildUnexpectedNodes(format: format), leftSquare: buildableData.leftSquare.buildToken(format: format), buildableData.unexpectedBetweenLeftSquareAndContent?.buildUnexpectedNodes(format: format), content: buildableData.content.buildSyntax(format: format), buildableData.unexpectedBetweenContentAndRightSquare?.buildUnexpectedNodes(format: format), rightSquare: buildableData.rightSquare.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildDictionaryExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsDictionaryExpr`.
  public func createDictionaryExpr() -> DictionaryExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `DictionaryExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct TupleExprElement: SyntaxBuildable, ExpressibleAsTupleExprElement, HasTrailingComma {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeLabel: UnexpectedNodes?
    var label: Token?
    var unexpectedBetweenLabelAndColon: UnexpectedNodes?
    var colon: Token?
    var unexpectedBetweenColonAndExpression: UnexpectedNodes?
    var expression: ExprBuildable
    var unexpectedBetweenExpressionAndTrailingComma: UnexpectedNodes?
    var trailingComma: Token?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(TupleExprElementSyntax)
  }
  private var data: Data
  var hasTrailingComma: Bool {
    switch data {
    case .buildable(let buildableData):
      return buildableData.trailingComma != nil
    case .constructed(let node):
      return node.trailingComma != nil
    }
  }
  /// Creates a `TupleExprElement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLabel: 
  ///   - label: 
  ///   - unexpectedBetweenLabelAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndExpression: 
  ///   - expression: 
  ///   - unexpectedBetweenExpressionAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLabel: ExpressibleAsUnexpectedNodes? = nil, label: Token? = nil, unexpectedBetweenLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token? = nil, unexpectedBetweenColonAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    assert(colon == nil || colon!.text == #":"#)
    assert(trailingComma == nil || trailingComma!.text == #","#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeLabel: unexpectedBeforeLabel?.createUnexpectedNodes(), label: label, unexpectedBetweenLabelAndColon: unexpectedBetweenLabelAndColon?.createUnexpectedNodes(), colon: colon, unexpectedBetweenColonAndExpression: unexpectedBetweenColonAndExpression?.createUnexpectedNodes(), expression: expression.createExprBuildable(), unexpectedBetweenExpressionAndTrailingComma: unexpectedBetweenExpressionAndTrailingComma?.createUnexpectedNodes(), trailingComma: trailingComma))
  }
  public init(_ constructedNode: TupleExprElementSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `TupleExprElementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TupleExprElementSyntax`.
  func buildTupleExprElement(format: Format) -> TupleExprElementSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = TupleExprElementSyntax(buildableData.unexpectedBeforeLabel?.buildUnexpectedNodes(format: format), label: buildableData.label?.buildToken(format: format), buildableData.unexpectedBetweenLabelAndColon?.buildUnexpectedNodes(format: format), colon: buildableData.colon?.buildToken(format: format), buildableData.unexpectedBetweenColonAndExpression?.buildUnexpectedNodes(format: format), expression: buildableData.expression.buildExpr(format: format), buildableData.unexpectedBetweenExpressionAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: buildableData.trailingComma?.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildTupleExprElement(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsTupleExprElement`.
  public func createTupleExprElement() -> TupleExprElement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TupleExprElement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingComma = withComma ? .comma : nil
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withComma = node.withTrailingComma(withComma ? .commaToken() : nil)
      var result = self
      result.data = .constructed(withComma)
      return result
    }
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct ArrayElement: SyntaxBuildable, ExpressibleAsArrayElement, HasTrailingComma {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeExpression: UnexpectedNodes?
    var expression: ExprBuildable
    var unexpectedBetweenExpressionAndTrailingComma: UnexpectedNodes?
    var trailingComma: Token?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ArrayElementSyntax)
  }
  private var data: Data
  var hasTrailingComma: Bool {
    switch data {
    case .buildable(let buildableData):
      return buildableData.trailingComma != nil
    case .constructed(let node):
      return node.trailingComma != nil
    }
  }
  /// Creates a `ArrayElement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeExpression: 
  ///   - expression: 
  ///   - unexpectedBetweenExpressionAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    assert(trailingComma == nil || trailingComma!.text == #","#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeExpression: unexpectedBeforeExpression?.createUnexpectedNodes(), expression: expression.createExprBuildable(), unexpectedBetweenExpressionAndTrailingComma: unexpectedBetweenExpressionAndTrailingComma?.createUnexpectedNodes(), trailingComma: trailingComma))
  }
  public init(_ constructedNode: ArrayElementSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ArrayElementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ArrayElementSyntax`.
  func buildArrayElement(format: Format) -> ArrayElementSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ArrayElementSyntax(buildableData.unexpectedBeforeExpression?.buildUnexpectedNodes(format: format), expression: buildableData.expression.buildExpr(format: format), buildableData.unexpectedBetweenExpressionAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: buildableData.trailingComma?.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildArrayElement(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsArrayElement`.
  public func createArrayElement() -> ArrayElement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ArrayElement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingComma = withComma ? .comma : nil
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withComma = node.withTrailingComma(withComma ? .commaToken() : nil)
      var result = self
      result.data = .constructed(withComma)
      return result
    }
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct DictionaryElement: SyntaxBuildable, ExpressibleAsDictionaryElement, HasTrailingComma {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeKeyExpression: UnexpectedNodes?
    var keyExpression: ExprBuildable
    var unexpectedBetweenKeyExpressionAndColon: UnexpectedNodes?
    var colon: Token
    var unexpectedBetweenColonAndValueExpression: UnexpectedNodes?
    var valueExpression: ExprBuildable
    var unexpectedBetweenValueExpressionAndTrailingComma: UnexpectedNodes?
    var trailingComma: Token?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(DictionaryElementSyntax)
  }
  private var data: Data
  var hasTrailingComma: Bool {
    switch data {
    case .buildable(let buildableData):
      return buildableData.trailingComma != nil
    case .constructed(let node):
      return node.trailingComma != nil
    }
  }
  /// Creates a `DictionaryElement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeKeyExpression: 
  ///   - keyExpression: 
  ///   - unexpectedBetweenKeyExpressionAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndValueExpression: 
  ///   - valueExpression: 
  ///   - unexpectedBetweenValueExpressionAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeKeyExpression: ExpressibleAsUnexpectedNodes? = nil, keyExpression: ExpressibleAsExprBuildable, unexpectedBetweenKeyExpressionAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndValueExpression: ExpressibleAsUnexpectedNodes? = nil, valueExpression: ExpressibleAsExprBuildable, unexpectedBetweenValueExpressionAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    assert(colon.text == #":"#)
    assert(trailingComma == nil || trailingComma!.text == #","#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeKeyExpression: unexpectedBeforeKeyExpression?.createUnexpectedNodes(), keyExpression: keyExpression.createExprBuildable(), unexpectedBetweenKeyExpressionAndColon: unexpectedBetweenKeyExpressionAndColon?.createUnexpectedNodes(), colon: colon, unexpectedBetweenColonAndValueExpression: unexpectedBetweenColonAndValueExpression?.createUnexpectedNodes(), valueExpression: valueExpression.createExprBuildable(), unexpectedBetweenValueExpressionAndTrailingComma: unexpectedBetweenValueExpressionAndTrailingComma?.createUnexpectedNodes(), trailingComma: trailingComma))
  }
  public init(_ constructedNode: DictionaryElementSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `DictionaryElementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DictionaryElementSyntax`.
  func buildDictionaryElement(format: Format) -> DictionaryElementSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = DictionaryElementSyntax(buildableData.unexpectedBeforeKeyExpression?.buildUnexpectedNodes(format: format), keyExpression: buildableData.keyExpression.buildExpr(format: format), buildableData.unexpectedBetweenKeyExpressionAndColon?.buildUnexpectedNodes(format: format), colon: buildableData.colon.buildToken(format: format), buildableData.unexpectedBetweenColonAndValueExpression?.buildUnexpectedNodes(format: format), valueExpression: buildableData.valueExpression.buildExpr(format: format), buildableData.unexpectedBetweenValueExpressionAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: buildableData.trailingComma?.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildDictionaryElement(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsDictionaryElement`.
  public func createDictionaryElement() -> DictionaryElement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DictionaryElement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingComma = withComma ? .comma : nil
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withComma = node.withTrailingComma(withComma ? .commaToken() : nil)
      var result = self
      result.data = .constructed(withComma)
      return result
    }
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct IntegerLiteralExpr: ExprBuildable, ExpressibleAsIntegerLiteralExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeDigits: UnexpectedNodes?
    var digits: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(IntegerLiteralExprSyntax)
  }
  private var data: Data
  /// Creates a `IntegerLiteralExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeDigits: 
  ///   - digits: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeDigits: ExpressibleAsUnexpectedNodes? = nil, digits: Token) {
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeDigits: unexpectedBeforeDigits?.createUnexpectedNodes(), digits: digits))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeDigits: ExpressibleAsUnexpectedNodes? = nil, digits: String) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeDigits: unexpectedBeforeDigits, digits: Token.`integerLiteral`(digits))
  }
  public init(_ constructedNode: IntegerLiteralExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `IntegerLiteralExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `IntegerLiteralExprSyntax`.
  func buildIntegerLiteralExpr(format: Format) -> IntegerLiteralExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = IntegerLiteralExprSyntax(buildableData.unexpectedBeforeDigits?.buildUnexpectedNodes(format: format), digits: buildableData.digits.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildIntegerLiteralExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsIntegerLiteralExpr`.
  public func createIntegerLiteralExpr() -> IntegerLiteralExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `IntegerLiteralExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct BooleanLiteralExpr: ExprBuildable, ExpressibleAsBooleanLiteralExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeBooleanLiteral: UnexpectedNodes?
    var booleanLiteral: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(BooleanLiteralExprSyntax)
  }
  private var data: Data
  /// Creates a `BooleanLiteralExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeBooleanLiteral: 
  ///   - booleanLiteral: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeBooleanLiteral: ExpressibleAsUnexpectedNodes? = nil, booleanLiteral: Token) {
    assert(booleanLiteral.text == #"true"# || booleanLiteral.text == #"false"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeBooleanLiteral: unexpectedBeforeBooleanLiteral?.createUnexpectedNodes(), booleanLiteral: booleanLiteral))
  }
  public init(_ constructedNode: BooleanLiteralExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `BooleanLiteralExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `BooleanLiteralExprSyntax`.
  func buildBooleanLiteralExpr(format: Format) -> BooleanLiteralExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = BooleanLiteralExprSyntax(buildableData.unexpectedBeforeBooleanLiteral?.buildUnexpectedNodes(format: format), booleanLiteral: buildableData.booleanLiteral.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildBooleanLiteralExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsBooleanLiteralExpr`.
  public func createBooleanLiteralExpr() -> BooleanLiteralExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `BooleanLiteralExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct UnresolvedTernaryExpr: ExprBuildable, ExpressibleAsUnresolvedTernaryExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeQuestionMark: UnexpectedNodes?
    var questionMark: Token
    var unexpectedBetweenQuestionMarkAndFirstChoice: UnexpectedNodes?
    var firstChoice: ExprBuildable
    var unexpectedBetweenFirstChoiceAndColonMark: UnexpectedNodes?
    var colonMark: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(UnresolvedTernaryExprSyntax)
  }
  private var data: Data
  /// Creates a `UnresolvedTernaryExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeQuestionMark: 
  ///   - questionMark: 
  ///   - unexpectedBetweenQuestionMarkAndFirstChoice: 
  ///   - firstChoice: 
  ///   - unexpectedBetweenFirstChoiceAndColonMark: 
  ///   - colonMark: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeQuestionMark: ExpressibleAsUnexpectedNodes? = nil, questionMark: Token = Token.`infixQuestionMark`, unexpectedBetweenQuestionMarkAndFirstChoice: ExpressibleAsUnexpectedNodes? = nil, firstChoice: ExpressibleAsExprBuildable, unexpectedBetweenFirstChoiceAndColonMark: ExpressibleAsUnexpectedNodes? = nil, colonMark: Token = Token.`colon`) {
    assert(questionMark.text == #"?"#)
    assert(colonMark.text == #":"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeQuestionMark: unexpectedBeforeQuestionMark?.createUnexpectedNodes(), questionMark: questionMark, unexpectedBetweenQuestionMarkAndFirstChoice: unexpectedBetweenQuestionMarkAndFirstChoice?.createUnexpectedNodes(), firstChoice: firstChoice.createExprBuildable(), unexpectedBetweenFirstChoiceAndColonMark: unexpectedBetweenFirstChoiceAndColonMark?.createUnexpectedNodes(), colonMark: colonMark))
  }
  public init(_ constructedNode: UnresolvedTernaryExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `UnresolvedTernaryExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `UnresolvedTernaryExprSyntax`.
  func buildUnresolvedTernaryExpr(format: Format) -> UnresolvedTernaryExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = UnresolvedTernaryExprSyntax(buildableData.unexpectedBeforeQuestionMark?.buildUnexpectedNodes(format: format), questionMark: buildableData.questionMark.buildToken(format: format), buildableData.unexpectedBetweenQuestionMarkAndFirstChoice?.buildUnexpectedNodes(format: format), firstChoice: buildableData.firstChoice.buildExpr(format: format), buildableData.unexpectedBetweenFirstChoiceAndColonMark?.buildUnexpectedNodes(format: format), colonMark: buildableData.colonMark.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildUnresolvedTernaryExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsUnresolvedTernaryExpr`.
  public func createUnresolvedTernaryExpr() -> UnresolvedTernaryExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `UnresolvedTernaryExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct TernaryExpr: ExprBuildable, ExpressibleAsTernaryExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeConditionExpression: UnexpectedNodes?
    var conditionExpression: ExprBuildable
    var unexpectedBetweenConditionExpressionAndQuestionMark: UnexpectedNodes?
    var questionMark: Token
    var unexpectedBetweenQuestionMarkAndFirstChoice: UnexpectedNodes?
    var firstChoice: ExprBuildable
    var unexpectedBetweenFirstChoiceAndColonMark: UnexpectedNodes?
    var colonMark: Token
    var unexpectedBetweenColonMarkAndSecondChoice: UnexpectedNodes?
    var secondChoice: ExprBuildable
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(TernaryExprSyntax)
  }
  private var data: Data
  /// Creates a `TernaryExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeConditionExpression: 
  ///   - conditionExpression: 
  ///   - unexpectedBetweenConditionExpressionAndQuestionMark: 
  ///   - questionMark: 
  ///   - unexpectedBetweenQuestionMarkAndFirstChoice: 
  ///   - firstChoice: 
  ///   - unexpectedBetweenFirstChoiceAndColonMark: 
  ///   - colonMark: 
  ///   - unexpectedBetweenColonMarkAndSecondChoice: 
  ///   - secondChoice: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeConditionExpression: ExpressibleAsUnexpectedNodes? = nil, conditionExpression: ExpressibleAsExprBuildable, unexpectedBetweenConditionExpressionAndQuestionMark: ExpressibleAsUnexpectedNodes? = nil, questionMark: Token = Token.`infixQuestionMark`, unexpectedBetweenQuestionMarkAndFirstChoice: ExpressibleAsUnexpectedNodes? = nil, firstChoice: ExpressibleAsExprBuildable, unexpectedBetweenFirstChoiceAndColonMark: ExpressibleAsUnexpectedNodes? = nil, colonMark: Token = Token.`colon`, unexpectedBetweenColonMarkAndSecondChoice: ExpressibleAsUnexpectedNodes? = nil, secondChoice: ExpressibleAsExprBuildable) {
    assert(questionMark.text == #"?"#)
    assert(colonMark.text == #":"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeConditionExpression: unexpectedBeforeConditionExpression?.createUnexpectedNodes(), conditionExpression: conditionExpression.createExprBuildable(), unexpectedBetweenConditionExpressionAndQuestionMark: unexpectedBetweenConditionExpressionAndQuestionMark?.createUnexpectedNodes(), questionMark: questionMark, unexpectedBetweenQuestionMarkAndFirstChoice: unexpectedBetweenQuestionMarkAndFirstChoice?.createUnexpectedNodes(), firstChoice: firstChoice.createExprBuildable(), unexpectedBetweenFirstChoiceAndColonMark: unexpectedBetweenFirstChoiceAndColonMark?.createUnexpectedNodes(), colonMark: colonMark, unexpectedBetweenColonMarkAndSecondChoice: unexpectedBetweenColonMarkAndSecondChoice?.createUnexpectedNodes(), secondChoice: secondChoice.createExprBuildable()))
  }
  public init(_ constructedNode: TernaryExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `TernaryExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TernaryExprSyntax`.
  func buildTernaryExpr(format: Format) -> TernaryExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = TernaryExprSyntax(buildableData.unexpectedBeforeConditionExpression?.buildUnexpectedNodes(format: format), conditionExpression: buildableData.conditionExpression.buildExpr(format: format), buildableData.unexpectedBetweenConditionExpressionAndQuestionMark?.buildUnexpectedNodes(format: format), questionMark: buildableData.questionMark.buildToken(format: format), buildableData.unexpectedBetweenQuestionMarkAndFirstChoice?.buildUnexpectedNodes(format: format), firstChoice: buildableData.firstChoice.buildExpr(format: format), buildableData.unexpectedBetweenFirstChoiceAndColonMark?.buildUnexpectedNodes(format: format), colonMark: buildableData.colonMark.buildToken(format: format), buildableData.unexpectedBetweenColonMarkAndSecondChoice?.buildUnexpectedNodes(format: format), secondChoice: buildableData.secondChoice.buildExpr(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildTernaryExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsTernaryExpr`.
  public func createTernaryExpr() -> TernaryExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `TernaryExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct MemberAccessExpr: ExprBuildable, ExpressibleAsMemberAccessExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeBase: UnexpectedNodes?
    var base: ExprBuildable?
    var unexpectedBetweenBaseAndDot: UnexpectedNodes?
    var dot: Token
    var unexpectedBetweenDotAndName: UnexpectedNodes?
    var name: Token
    var unexpectedBetweenNameAndDeclNameArguments: UnexpectedNodes?
    var declNameArguments: DeclNameArguments?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(MemberAccessExprSyntax)
  }
  private var data: Data
  /// Creates a `MemberAccessExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeBase: 
  ///   - base: 
  ///   - unexpectedBetweenBaseAndDot: 
  ///   - dot: 
  ///   - unexpectedBetweenDotAndName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndDeclNameArguments: 
  ///   - declNameArguments: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeBase: ExpressibleAsUnexpectedNodes? = nil, base: ExpressibleAsExprBuildable? = nil, unexpectedBetweenBaseAndDot: ExpressibleAsUnexpectedNodes? = nil, dot: Token, unexpectedBetweenDotAndName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndDeclNameArguments: ExpressibleAsUnexpectedNodes? = nil, declNameArguments: ExpressibleAsDeclNameArguments? = nil) {
    assert(dot.text == #"."# || dot.text == #"."#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeBase: unexpectedBeforeBase?.createUnexpectedNodes(), base: base?.createExprBuildable(), unexpectedBetweenBaseAndDot: unexpectedBetweenBaseAndDot?.createUnexpectedNodes(), dot: dot, unexpectedBetweenDotAndName: unexpectedBetweenDotAndName?.createUnexpectedNodes(), name: name, unexpectedBetweenNameAndDeclNameArguments: unexpectedBetweenNameAndDeclNameArguments?.createUnexpectedNodes(), declNameArguments: declNameArguments?.createDeclNameArguments()))
  }
  public init(_ constructedNode: MemberAccessExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `MemberAccessExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `MemberAccessExprSyntax`.
  func buildMemberAccessExpr(format: Format) -> MemberAccessExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = MemberAccessExprSyntax(buildableData.unexpectedBeforeBase?.buildUnexpectedNodes(format: format), base: buildableData.base?.buildExpr(format: format), buildableData.unexpectedBetweenBaseAndDot?.buildUnexpectedNodes(format: format), dot: buildableData.dot.buildToken(format: format), buildableData.unexpectedBetweenDotAndName?.buildUnexpectedNodes(format: format), name: buildableData.name.buildToken(format: format), buildableData.unexpectedBetweenNameAndDeclNameArguments?.buildUnexpectedNodes(format: format), declNameArguments: buildableData.declNameArguments?.buildDeclNameArguments(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildMemberAccessExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsMemberAccessExpr`.
  public func createMemberAccessExpr() -> MemberAccessExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `MemberAccessExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct UnresolvedIsExpr: ExprBuildable, ExpressibleAsUnresolvedIsExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeIsTok: UnexpectedNodes?
    var isTok: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(UnresolvedIsExprSyntax)
  }
  private var data: Data
  /// Creates a `UnresolvedIsExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeIsTok: 
  ///   - isTok: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeIsTok: ExpressibleAsUnexpectedNodes? = nil, isTok: Token = Token.`is`) {
    assert(isTok.text == #"is"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeIsTok: unexpectedBeforeIsTok?.createUnexpectedNodes(), isTok: isTok))
  }
  public init(_ constructedNode: UnresolvedIsExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `UnresolvedIsExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `UnresolvedIsExprSyntax`.
  func buildUnresolvedIsExpr(format: Format) -> UnresolvedIsExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = UnresolvedIsExprSyntax(buildableData.unexpectedBeforeIsTok?.buildUnexpectedNodes(format: format), isTok: buildableData.isTok.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildUnresolvedIsExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsUnresolvedIsExpr`.
  public func createUnresolvedIsExpr() -> UnresolvedIsExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `UnresolvedIsExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct IsExpr: ExprBuildable, ExpressibleAsIsExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeExpression: UnexpectedNodes?
    var expression: ExprBuildable
    var unexpectedBetweenExpressionAndIsTok: UnexpectedNodes?
    var isTok: Token
    var unexpectedBetweenIsTokAndTypeName: UnexpectedNodes?
    var typeName: TypeBuildable
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(IsExprSyntax)
  }
  private var data: Data
  /// Creates a `IsExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeExpression: 
  ///   - expression: 
  ///   - unexpectedBetweenExpressionAndIsTok: 
  ///   - isTok: 
  ///   - unexpectedBetweenIsTokAndTypeName: 
  ///   - typeName: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndIsTok: ExpressibleAsUnexpectedNodes? = nil, isTok: Token = Token.`is`, unexpectedBetweenIsTokAndTypeName: ExpressibleAsUnexpectedNodes? = nil, typeName: ExpressibleAsTypeBuildable) {
    assert(isTok.text == #"is"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeExpression: unexpectedBeforeExpression?.createUnexpectedNodes(), expression: expression.createExprBuildable(), unexpectedBetweenExpressionAndIsTok: unexpectedBetweenExpressionAndIsTok?.createUnexpectedNodes(), isTok: isTok, unexpectedBetweenIsTokAndTypeName: unexpectedBetweenIsTokAndTypeName?.createUnexpectedNodes(), typeName: typeName.createTypeBuildable()))
  }
  public init(_ constructedNode: IsExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `IsExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `IsExprSyntax`.
  func buildIsExpr(format: Format) -> IsExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = IsExprSyntax(buildableData.unexpectedBeforeExpression?.buildUnexpectedNodes(format: format), expression: buildableData.expression.buildExpr(format: format), buildableData.unexpectedBetweenExpressionAndIsTok?.buildUnexpectedNodes(format: format), isTok: buildableData.isTok.buildToken(format: format), buildableData.unexpectedBetweenIsTokAndTypeName?.buildUnexpectedNodes(format: format), typeName: buildableData.typeName.buildType(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildIsExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsIsExpr`.
  public func createIsExpr() -> IsExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `IsExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct UnresolvedAsExpr: ExprBuildable, ExpressibleAsUnresolvedAsExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeAsTok: UnexpectedNodes?
    var asTok: Token
    var unexpectedBetweenAsTokAndQuestionOrExclamationMark: UnexpectedNodes?
    var questionOrExclamationMark: Token?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(UnresolvedAsExprSyntax)
  }
  private var data: Data
  /// Creates a `UnresolvedAsExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAsTok: 
  ///   - asTok: 
  ///   - unexpectedBetweenAsTokAndQuestionOrExclamationMark: 
  ///   - questionOrExclamationMark: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAsTok: ExpressibleAsUnexpectedNodes? = nil, asTok: Token = Token.`as`, unexpectedBetweenAsTokAndQuestionOrExclamationMark: ExpressibleAsUnexpectedNodes? = nil, questionOrExclamationMark: Token? = nil) {
    assert(asTok.text == #"as"#)
    assert(questionOrExclamationMark == nil || questionOrExclamationMark!.text == #"?"# || questionOrExclamationMark!.text == #"!"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeAsTok: unexpectedBeforeAsTok?.createUnexpectedNodes(), asTok: asTok, unexpectedBetweenAsTokAndQuestionOrExclamationMark: unexpectedBetweenAsTokAndQuestionOrExclamationMark?.createUnexpectedNodes(), questionOrExclamationMark: questionOrExclamationMark))
  }
  public init(_ constructedNode: UnresolvedAsExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `UnresolvedAsExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `UnresolvedAsExprSyntax`.
  func buildUnresolvedAsExpr(format: Format) -> UnresolvedAsExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = UnresolvedAsExprSyntax(buildableData.unexpectedBeforeAsTok?.buildUnexpectedNodes(format: format), asTok: buildableData.asTok.buildToken(format: format), buildableData.unexpectedBetweenAsTokAndQuestionOrExclamationMark?.buildUnexpectedNodes(format: format), questionOrExclamationMark: buildableData.questionOrExclamationMark?.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildUnresolvedAsExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsUnresolvedAsExpr`.
  public func createUnresolvedAsExpr() -> UnresolvedAsExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `UnresolvedAsExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct AsExpr: ExprBuildable, ExpressibleAsAsExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeExpression: UnexpectedNodes?
    var expression: ExprBuildable
    var unexpectedBetweenExpressionAndAsTok: UnexpectedNodes?
    var asTok: Token
    var unexpectedBetweenAsTokAndQuestionOrExclamationMark: UnexpectedNodes?
    var questionOrExclamationMark: Token?
    var unexpectedBetweenQuestionOrExclamationMarkAndTypeName: UnexpectedNodes?
    var typeName: TypeBuildable
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(AsExprSyntax)
  }
  private var data: Data
  /// Creates a `AsExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeExpression: 
  ///   - expression: 
  ///   - unexpectedBetweenExpressionAndAsTok: 
  ///   - asTok: 
  ///   - unexpectedBetweenAsTokAndQuestionOrExclamationMark: 
  ///   - questionOrExclamationMark: 
  ///   - unexpectedBetweenQuestionOrExclamationMarkAndTypeName: 
  ///   - typeName: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndAsTok: ExpressibleAsUnexpectedNodes? = nil, asTok: Token = Token.`as`, unexpectedBetweenAsTokAndQuestionOrExclamationMark: ExpressibleAsUnexpectedNodes? = nil, questionOrExclamationMark: Token? = nil, unexpectedBetweenQuestionOrExclamationMarkAndTypeName: ExpressibleAsUnexpectedNodes? = nil, typeName: ExpressibleAsTypeBuildable) {
    assert(asTok.text == #"as"#)
    assert(questionOrExclamationMark == nil || questionOrExclamationMark!.text == #"?"# || questionOrExclamationMark!.text == #"!"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeExpression: unexpectedBeforeExpression?.createUnexpectedNodes(), expression: expression.createExprBuildable(), unexpectedBetweenExpressionAndAsTok: unexpectedBetweenExpressionAndAsTok?.createUnexpectedNodes(), asTok: asTok, unexpectedBetweenAsTokAndQuestionOrExclamationMark: unexpectedBetweenAsTokAndQuestionOrExclamationMark?.createUnexpectedNodes(), questionOrExclamationMark: questionOrExclamationMark, unexpectedBetweenQuestionOrExclamationMarkAndTypeName: unexpectedBetweenQuestionOrExclamationMarkAndTypeName?.createUnexpectedNodes(), typeName: typeName.createTypeBuildable()))
  }
  public init(_ constructedNode: AsExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `AsExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AsExprSyntax`.
  func buildAsExpr(format: Format) -> AsExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = AsExprSyntax(buildableData.unexpectedBeforeExpression?.buildUnexpectedNodes(format: format), expression: buildableData.expression.buildExpr(format: format), buildableData.unexpectedBetweenExpressionAndAsTok?.buildUnexpectedNodes(format: format), asTok: buildableData.asTok.buildToken(format: format), buildableData.unexpectedBetweenAsTokAndQuestionOrExclamationMark?.buildUnexpectedNodes(format: format), questionOrExclamationMark: buildableData.questionOrExclamationMark?.buildToken(format: format), buildableData.unexpectedBetweenQuestionOrExclamationMarkAndTypeName?.buildUnexpectedNodes(format: format), typeName: buildableData.typeName.buildType(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildAsExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsAsExpr`.
  public func createAsExpr() -> AsExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `AsExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct TypeExpr: ExprBuildable, ExpressibleAsTypeExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeType: UnexpectedNodes?
    var type: TypeBuildable
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(TypeExprSyntax)
  }
  private var data: Data
  /// Creates a `TypeExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeType: 
  ///   - type: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeType: ExpressibleAsUnexpectedNodes? = nil, type: ExpressibleAsTypeBuildable) {
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeType: unexpectedBeforeType?.createUnexpectedNodes(), type: type.createTypeBuildable()))
  }
  public init(_ constructedNode: TypeExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `TypeExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TypeExprSyntax`.
  func buildTypeExpr(format: Format) -> TypeExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = TypeExprSyntax(buildableData.unexpectedBeforeType?.buildUnexpectedNodes(format: format), type: buildableData.type.buildType(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildTypeExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsTypeExpr`.
  public func createTypeExpr() -> TypeExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `TypeExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct ClosureCaptureItem: SyntaxBuildable, ExpressibleAsClosureCaptureItem, HasTrailingComma {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeSpecifier: UnexpectedNodes?
    var specifier: TokenList?
    var unexpectedBetweenSpecifierAndName: UnexpectedNodes?
    var name: Token?
    var unexpectedBetweenNameAndAssignToken: UnexpectedNodes?
    var assignToken: Token?
    var unexpectedBetweenAssignTokenAndExpression: UnexpectedNodes?
    var expression: ExprBuildable
    var unexpectedBetweenExpressionAndTrailingComma: UnexpectedNodes?
    var trailingComma: Token?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ClosureCaptureItemSyntax)
  }
  private var data: Data
  var hasTrailingComma: Bool {
    switch data {
    case .buildable(let buildableData):
      return buildableData.trailingComma != nil
    case .constructed(let node):
      return node.trailingComma != nil
    }
  }
  /// Creates a `ClosureCaptureItem` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeSpecifier: 
  ///   - specifier: 
  ///   - unexpectedBetweenSpecifierAndName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndAssignToken: 
  ///   - assignToken: 
  ///   - unexpectedBetweenAssignTokenAndExpression: 
  ///   - expression: 
  ///   - unexpectedBetweenExpressionAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeSpecifier: ExpressibleAsUnexpectedNodes? = nil, specifier: ExpressibleAsTokenList? = nil, unexpectedBetweenSpecifierAndName: ExpressibleAsUnexpectedNodes? = nil, name: Token? = nil, unexpectedBetweenNameAndAssignToken: ExpressibleAsUnexpectedNodes? = nil, assignToken: Token? = nil, unexpectedBetweenAssignTokenAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    assert(assignToken == nil || assignToken!.text == #"="#)
    assert(trailingComma == nil || trailingComma!.text == #","#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeSpecifier: unexpectedBeforeSpecifier?.createUnexpectedNodes(), specifier: specifier?.createTokenList(), unexpectedBetweenSpecifierAndName: unexpectedBetweenSpecifierAndName?.createUnexpectedNodes(), name: name, unexpectedBetweenNameAndAssignToken: unexpectedBetweenNameAndAssignToken?.createUnexpectedNodes(), assignToken: assignToken, unexpectedBetweenAssignTokenAndExpression: unexpectedBetweenAssignTokenAndExpression?.createUnexpectedNodes(), expression: expression.createExprBuildable(), unexpectedBetweenExpressionAndTrailingComma: unexpectedBetweenExpressionAndTrailingComma?.createUnexpectedNodes(), trailingComma: trailingComma))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeSpecifier: ExpressibleAsUnexpectedNodes? = nil, specifier: ExpressibleAsTokenList? = nil, unexpectedBetweenSpecifierAndName: ExpressibleAsUnexpectedNodes? = nil, name: String?, unexpectedBetweenNameAndAssignToken: ExpressibleAsUnexpectedNodes? = nil, assignToken: Token? = nil, unexpectedBetweenAssignTokenAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeSpecifier: unexpectedBeforeSpecifier, specifier: specifier, unexpectedBetweenSpecifierAndName: unexpectedBetweenSpecifierAndName, name: name.map { Token.`identifier`($0) }, unexpectedBetweenNameAndAssignToken: unexpectedBetweenNameAndAssignToken, assignToken: assignToken, unexpectedBetweenAssignTokenAndExpression: unexpectedBetweenAssignTokenAndExpression, expression: expression, unexpectedBetweenExpressionAndTrailingComma: unexpectedBetweenExpressionAndTrailingComma, trailingComma: trailingComma)
  }
  public init(_ constructedNode: ClosureCaptureItemSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ClosureCaptureItemSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ClosureCaptureItemSyntax`.
  func buildClosureCaptureItem(format: Format) -> ClosureCaptureItemSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ClosureCaptureItemSyntax(buildableData.unexpectedBeforeSpecifier?.buildUnexpectedNodes(format: format), specifier: buildableData.specifier?.buildTokenList(format: format), buildableData.unexpectedBetweenSpecifierAndName?.buildUnexpectedNodes(format: format), name: buildableData.name?.buildToken(format: format), buildableData.unexpectedBetweenNameAndAssignToken?.buildUnexpectedNodes(format: format), assignToken: buildableData.assignToken?.buildToken(format: format), buildableData.unexpectedBetweenAssignTokenAndExpression?.buildUnexpectedNodes(format: format), expression: buildableData.expression.buildExpr(format: format), buildableData.unexpectedBetweenExpressionAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: buildableData.trailingComma?.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildClosureCaptureItem(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsClosureCaptureItem`.
  public func createClosureCaptureItem() -> ClosureCaptureItem {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ClosureCaptureItem` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingComma = withComma ? .comma : nil
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withComma = node.withTrailingComma(withComma ? .commaToken() : nil)
      var result = self
      result.data = .constructed(withComma)
      return result
    }
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct ClosureCaptureSignature: SyntaxBuildable, ExpressibleAsClosureCaptureSignature {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeLeftSquare: UnexpectedNodes?
    var leftSquare: Token
    var unexpectedBetweenLeftSquareAndItems: UnexpectedNodes?
    var items: ClosureCaptureItemList?
    var unexpectedBetweenItemsAndRightSquare: UnexpectedNodes?
    var rightSquare: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ClosureCaptureSignatureSyntax)
  }
  private var data: Data
  /// Creates a `ClosureCaptureSignature` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftSquare: 
  ///   - leftSquare: 
  ///   - unexpectedBetweenLeftSquareAndItems: 
  ///   - items: 
  ///   - unexpectedBetweenItemsAndRightSquare: 
  ///   - rightSquare: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftSquare: ExpressibleAsUnexpectedNodes? = nil, leftSquare: Token = Token.`leftSquareBracket`, unexpectedBetweenLeftSquareAndItems: ExpressibleAsUnexpectedNodes? = nil, items: ExpressibleAsClosureCaptureItemList? = nil, unexpectedBetweenItemsAndRightSquare: ExpressibleAsUnexpectedNodes? = nil, rightSquare: Token = Token.`rightSquareBracket`) {
    assert(leftSquare.text == #"["#)
    assert(rightSquare.text == #"]"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeLeftSquare: unexpectedBeforeLeftSquare?.createUnexpectedNodes(), leftSquare: leftSquare, unexpectedBetweenLeftSquareAndItems: unexpectedBetweenLeftSquareAndItems?.createUnexpectedNodes(), items: items?.createClosureCaptureItemList(), unexpectedBetweenItemsAndRightSquare: unexpectedBetweenItemsAndRightSquare?.createUnexpectedNodes(), rightSquare: rightSquare))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftSquare: ExpressibleAsUnexpectedNodes? = nil, leftSquare: Token = Token.`leftSquareBracket`, unexpectedBetweenLeftSquareAndItems: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenItemsAndRightSquare: ExpressibleAsUnexpectedNodes? = nil, rightSquare: Token = Token.`rightSquareBracket`, @ClosureCaptureItemListBuilder itemsBuilder: () -> ExpressibleAsClosureCaptureItemList? =  {
    nil
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftSquare: unexpectedBeforeLeftSquare, leftSquare: leftSquare, unexpectedBetweenLeftSquareAndItems: unexpectedBetweenLeftSquareAndItems, items: itemsBuilder(), unexpectedBetweenItemsAndRightSquare: unexpectedBetweenItemsAndRightSquare, rightSquare: rightSquare)
  }
  public init(_ constructedNode: ClosureCaptureSignatureSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ClosureCaptureSignatureSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ClosureCaptureSignatureSyntax`.
  func buildClosureCaptureSignature(format: Format) -> ClosureCaptureSignatureSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ClosureCaptureSignatureSyntax(buildableData.unexpectedBeforeLeftSquare?.buildUnexpectedNodes(format: format), leftSquare: buildableData.leftSquare.buildToken(format: format), buildableData.unexpectedBetweenLeftSquareAndItems?.buildUnexpectedNodes(format: format), items: buildableData.items?.buildClosureCaptureItemList(format: format), buildableData.unexpectedBetweenItemsAndRightSquare?.buildUnexpectedNodes(format: format), rightSquare: buildableData.rightSquare.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildClosureCaptureSignature(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsClosureCaptureSignature`.
  public func createClosureCaptureSignature() -> ClosureCaptureSignature {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ClosureCaptureSignature` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct ClosureParam: SyntaxBuildable, ExpressibleAsClosureParam, HasTrailingComma {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeName: UnexpectedNodes?
    var name: Token
    var unexpectedBetweenNameAndTrailingComma: UnexpectedNodes?
    var trailingComma: Token?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ClosureParamSyntax)
  }
  private var data: Data
  var hasTrailingComma: Bool {
    switch data {
    case .buildable(let buildableData):
      return buildableData.trailingComma != nil
    case .constructed(let node):
      return node.trailingComma != nil
    }
  }
  /// Creates a `ClosureParam` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    assert(trailingComma == nil || trailingComma!.text == #","#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeName: unexpectedBeforeName?.createUnexpectedNodes(), name: name, unexpectedBetweenNameAndTrailingComma: unexpectedBetweenNameAndTrailingComma?.createUnexpectedNodes(), trailingComma: trailingComma))
  }
  public init(_ constructedNode: ClosureParamSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ClosureParamSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ClosureParamSyntax`.
  func buildClosureParam(format: Format) -> ClosureParamSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ClosureParamSyntax(buildableData.unexpectedBeforeName?.buildUnexpectedNodes(format: format), name: buildableData.name.buildToken(format: format), buildableData.unexpectedBetweenNameAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: buildableData.trailingComma?.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildClosureParam(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsClosureParam`.
  public func createClosureParam() -> ClosureParam {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ClosureParam` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingComma = withComma ? .comma : nil
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withComma = node.withTrailingComma(withComma ? .commaToken() : nil)
      var result = self
      result.data = .constructed(withComma)
      return result
    }
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct ClosureSignature: SyntaxBuildable, ExpressibleAsClosureSignature {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeAttributes: UnexpectedNodes?
    var attributes: AttributeList?
    var unexpectedBetweenAttributesAndCapture: UnexpectedNodes?
    var capture: ClosureCaptureSignature?
    var unexpectedBetweenCaptureAndInput: UnexpectedNodes?
    var input: SyntaxBuildable?
    var unexpectedBetweenInputAndAsyncKeyword: UnexpectedNodes?
    var asyncKeyword: Token?
    var unexpectedBetweenAsyncKeywordAndThrowsTok: UnexpectedNodes?
    var throwsTok: Token?
    var unexpectedBetweenThrowsTokAndOutput: UnexpectedNodes?
    var output: ReturnClause?
    var unexpectedBetweenOutputAndInTok: UnexpectedNodes?
    var inTok: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ClosureSignatureSyntax)
  }
  private var data: Data
  /// Creates a `ClosureSignature` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndCapture: 
  ///   - capture: 
  ///   - unexpectedBetweenCaptureAndInput: 
  ///   - input: 
  ///   - unexpectedBetweenInputAndAsyncKeyword: 
  ///   - asyncKeyword: 
  ///   - unexpectedBetweenAsyncKeywordAndThrowsTok: 
  ///   - throwsTok: 
  ///   - unexpectedBetweenThrowsTokAndOutput: 
  ///   - output: 
  ///   - unexpectedBetweenOutputAndInTok: 
  ///   - inTok: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndCapture: ExpressibleAsUnexpectedNodes? = nil, capture: ExpressibleAsClosureCaptureSignature? = nil, unexpectedBetweenCaptureAndInput: ExpressibleAsUnexpectedNodes? = nil, input: ExpressibleAsSyntaxBuildable? = nil, unexpectedBetweenInputAndAsyncKeyword: ExpressibleAsUnexpectedNodes? = nil, asyncKeyword: Token? = nil, unexpectedBetweenAsyncKeywordAndThrowsTok: ExpressibleAsUnexpectedNodes? = nil, throwsTok: Token? = nil, unexpectedBetweenThrowsTokAndOutput: ExpressibleAsUnexpectedNodes? = nil, output: ExpressibleAsReturnClause? = nil, unexpectedBetweenOutputAndInTok: ExpressibleAsUnexpectedNodes? = nil, inTok: Token = Token.`in`) {
    assert(asyncKeyword == nil || asyncKeyword!.text == #"async"#)
    assert(throwsTok == nil || throwsTok!.text == #"throws"#)
    assert(inTok.text == #"in"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes?.createUnexpectedNodes(), attributes: attributes?.createAttributeList(), unexpectedBetweenAttributesAndCapture: unexpectedBetweenAttributesAndCapture?.createUnexpectedNodes(), capture: capture?.createClosureCaptureSignature(), unexpectedBetweenCaptureAndInput: unexpectedBetweenCaptureAndInput?.createUnexpectedNodes(), input: input?.createSyntaxBuildable(), unexpectedBetweenInputAndAsyncKeyword: unexpectedBetweenInputAndAsyncKeyword?.createUnexpectedNodes(), asyncKeyword: asyncKeyword, unexpectedBetweenAsyncKeywordAndThrowsTok: unexpectedBetweenAsyncKeywordAndThrowsTok?.createUnexpectedNodes(), throwsTok: throwsTok, unexpectedBetweenThrowsTokAndOutput: unexpectedBetweenThrowsTokAndOutput?.createUnexpectedNodes(), output: output?.createReturnClause(), unexpectedBetweenOutputAndInTok: unexpectedBetweenOutputAndInTok?.createUnexpectedNodes(), inTok: inTok))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndCapture: ExpressibleAsUnexpectedNodes? = nil, capture: ExpressibleAsClosureCaptureSignature? = nil, unexpectedBetweenCaptureAndInput: ExpressibleAsUnexpectedNodes? = nil, input: ExpressibleAsSyntaxBuildable? = nil, unexpectedBetweenInputAndAsyncKeyword: ExpressibleAsUnexpectedNodes? = nil, asyncKeyword: String?, unexpectedBetweenAsyncKeywordAndThrowsTok: ExpressibleAsUnexpectedNodes? = nil, throwsTok: Token? = nil, unexpectedBetweenThrowsTokAndOutput: ExpressibleAsUnexpectedNodes? = nil, output: ExpressibleAsReturnClause? = nil, unexpectedBetweenOutputAndInTok: ExpressibleAsUnexpectedNodes? = nil, inTok: Token = Token.`in`) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndCapture: unexpectedBetweenAttributesAndCapture, capture: capture, unexpectedBetweenCaptureAndInput: unexpectedBetweenCaptureAndInput, input: input, unexpectedBetweenInputAndAsyncKeyword: unexpectedBetweenInputAndAsyncKeyword, asyncKeyword: asyncKeyword.map { Token.`contextualKeyword`($0) }, unexpectedBetweenAsyncKeywordAndThrowsTok: unexpectedBetweenAsyncKeywordAndThrowsTok, throwsTok: throwsTok, unexpectedBetweenThrowsTokAndOutput: unexpectedBetweenThrowsTokAndOutput, output: output, unexpectedBetweenOutputAndInTok: unexpectedBetweenOutputAndInTok, inTok: inTok)
  }
  public init(_ constructedNode: ClosureSignatureSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ClosureSignatureSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ClosureSignatureSyntax`.
  func buildClosureSignature(format: Format) -> ClosureSignatureSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ClosureSignatureSyntax(buildableData.unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: buildableData.attributes?.buildAttributeList(format: format), buildableData.unexpectedBetweenAttributesAndCapture?.buildUnexpectedNodes(format: format), capture: buildableData.capture?.buildClosureCaptureSignature(format: format), buildableData.unexpectedBetweenCaptureAndInput?.buildUnexpectedNodes(format: format), input: buildableData.input?.buildSyntax(format: format), buildableData.unexpectedBetweenInputAndAsyncKeyword?.buildUnexpectedNodes(format: format), asyncKeyword: buildableData.asyncKeyword?.buildToken(format: format), buildableData.unexpectedBetweenAsyncKeywordAndThrowsTok?.buildUnexpectedNodes(format: format), throwsTok: buildableData.throwsTok?.buildToken(format: format), buildableData.unexpectedBetweenThrowsTokAndOutput?.buildUnexpectedNodes(format: format), output: buildableData.output?.buildReturnClause(format: format), buildableData.unexpectedBetweenOutputAndInTok?.buildUnexpectedNodes(format: format), inTok: buildableData.inTok.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildClosureSignature(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsClosureSignature`.
  public func createClosureSignature() -> ClosureSignature {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ClosureSignature` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct ClosureExpr: ExprBuildable, ExpressibleAsClosureExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeLeftBrace: UnexpectedNodes?
    var leftBrace: Token
    var unexpectedBetweenLeftBraceAndSignature: UnexpectedNodes?
    var signature: ClosureSignature?
    var unexpectedBetweenSignatureAndStatements: UnexpectedNodes?
    var statements: CodeBlockItemList
    var unexpectedBetweenStatementsAndRightBrace: UnexpectedNodes?
    var rightBrace: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ClosureExprSyntax)
  }
  private var data: Data
  /// Creates a `ClosureExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftBrace: 
  ///   - leftBrace: 
  ///   - unexpectedBetweenLeftBraceAndSignature: 
  ///   - signature: 
  ///   - unexpectedBetweenSignatureAndStatements: 
  ///   - statements: 
  ///   - unexpectedBetweenStatementsAndRightBrace: 
  ///   - rightBrace: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftBrace: ExpressibleAsUnexpectedNodes? = nil, leftBrace: Token = Token.`leftBrace`, unexpectedBetweenLeftBraceAndSignature: ExpressibleAsUnexpectedNodes? = nil, signature: ExpressibleAsClosureSignature? = nil, unexpectedBetweenSignatureAndStatements: ExpressibleAsUnexpectedNodes? = nil, statements: ExpressibleAsCodeBlockItemList, unexpectedBetweenStatementsAndRightBrace: ExpressibleAsUnexpectedNodes? = nil, rightBrace: Token = Token.`rightBrace`) {
    assert(leftBrace.text == #"{"#)
    assert(rightBrace.text == #"}"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeLeftBrace: unexpectedBeforeLeftBrace?.createUnexpectedNodes(), leftBrace: leftBrace, unexpectedBetweenLeftBraceAndSignature: unexpectedBetweenLeftBraceAndSignature?.createUnexpectedNodes(), signature: signature?.createClosureSignature(), unexpectedBetweenSignatureAndStatements: unexpectedBetweenSignatureAndStatements?.createUnexpectedNodes(), statements: statements.createCodeBlockItemList(), unexpectedBetweenStatementsAndRightBrace: unexpectedBetweenStatementsAndRightBrace?.createUnexpectedNodes(), rightBrace: rightBrace))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftBrace: ExpressibleAsUnexpectedNodes? = nil, leftBrace: Token = Token.`leftBrace`, unexpectedBetweenLeftBraceAndSignature: ExpressibleAsUnexpectedNodes? = nil, signature: ExpressibleAsClosureSignature? = nil, unexpectedBetweenSignatureAndStatements: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenStatementsAndRightBrace: ExpressibleAsUnexpectedNodes? = nil, rightBrace: Token = Token.`rightBrace`, @CodeBlockItemListBuilder statementsBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftBrace: unexpectedBeforeLeftBrace, leftBrace: leftBrace, unexpectedBetweenLeftBraceAndSignature: unexpectedBetweenLeftBraceAndSignature, signature: signature, unexpectedBetweenSignatureAndStatements: unexpectedBetweenSignatureAndStatements, statements: statementsBuilder(), unexpectedBetweenStatementsAndRightBrace: unexpectedBetweenStatementsAndRightBrace, rightBrace: rightBrace)
  }
  public init(_ constructedNode: ClosureExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ClosureExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ClosureExprSyntax`.
  func buildClosureExpr(format: Format) -> ClosureExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ClosureExprSyntax(buildableData.unexpectedBeforeLeftBrace?.buildUnexpectedNodes(format: format), leftBrace: buildableData.leftBrace.buildToken(format: format), buildableData.unexpectedBetweenLeftBraceAndSignature?.buildUnexpectedNodes(format: format), signature: buildableData.signature?.buildClosureSignature(format: format), buildableData.unexpectedBetweenSignatureAndStatements?.buildUnexpectedNodes(format: format), statements: buildableData.statements.buildCodeBlockItemList(format: format._indented), buildableData.unexpectedBetweenStatementsAndRightBrace?.buildUnexpectedNodes(format: format), rightBrace: buildableData.rightBrace.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildClosureExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsClosureExpr`.
  public func createClosureExpr() -> ClosureExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `ClosureExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct UnresolvedPatternExpr: ExprBuildable, ExpressibleAsUnresolvedPatternExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforePattern: UnexpectedNodes?
    var pattern: PatternBuildable
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(UnresolvedPatternExprSyntax)
  }
  private var data: Data
  /// Creates a `UnresolvedPatternExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePattern: 
  ///   - pattern: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePattern: ExpressibleAsUnexpectedNodes? = nil, pattern: ExpressibleAsPatternBuildable) {
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforePattern: unexpectedBeforePattern?.createUnexpectedNodes(), pattern: pattern.createPatternBuildable()))
  }
  public init(_ constructedNode: UnresolvedPatternExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `UnresolvedPatternExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `UnresolvedPatternExprSyntax`.
  func buildUnresolvedPatternExpr(format: Format) -> UnresolvedPatternExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = UnresolvedPatternExprSyntax(buildableData.unexpectedBeforePattern?.buildUnexpectedNodes(format: format), pattern: buildableData.pattern.buildPattern(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildUnresolvedPatternExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsUnresolvedPatternExpr`.
  public func createUnresolvedPatternExpr() -> UnresolvedPatternExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `UnresolvedPatternExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct MultipleTrailingClosureElement: SyntaxBuildable, ExpressibleAsMultipleTrailingClosureElement {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeLabel: UnexpectedNodes?
    var label: Token
    var unexpectedBetweenLabelAndColon: UnexpectedNodes?
    var colon: Token
    var unexpectedBetweenColonAndClosure: UnexpectedNodes?
    var closure: ClosureExpr
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(MultipleTrailingClosureElementSyntax)
  }
  private var data: Data
  /// Creates a `MultipleTrailingClosureElement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLabel: 
  ///   - label: 
  ///   - unexpectedBetweenLabelAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndClosure: 
  ///   - closure: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLabel: ExpressibleAsUnexpectedNodes? = nil, label: Token, unexpectedBetweenLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndClosure: ExpressibleAsUnexpectedNodes? = nil, closure: ExpressibleAsClosureExpr) {
    assert(colon.text == #":"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeLabel: unexpectedBeforeLabel?.createUnexpectedNodes(), label: label, unexpectedBetweenLabelAndColon: unexpectedBetweenLabelAndColon?.createUnexpectedNodes(), colon: colon, unexpectedBetweenColonAndClosure: unexpectedBetweenColonAndClosure?.createUnexpectedNodes(), closure: closure.createClosureExpr()))
  }
  public init(_ constructedNode: MultipleTrailingClosureElementSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `MultipleTrailingClosureElementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `MultipleTrailingClosureElementSyntax`.
  func buildMultipleTrailingClosureElement(format: Format) -> MultipleTrailingClosureElementSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = MultipleTrailingClosureElementSyntax(buildableData.unexpectedBeforeLabel?.buildUnexpectedNodes(format: format), label: buildableData.label.buildToken(format: format), buildableData.unexpectedBetweenLabelAndColon?.buildUnexpectedNodes(format: format), colon: buildableData.colon.buildToken(format: format), buildableData.unexpectedBetweenColonAndClosure?.buildUnexpectedNodes(format: format), closure: buildableData.closure.buildClosureExpr(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildMultipleTrailingClosureElement(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsMultipleTrailingClosureElement`.
  public func createMultipleTrailingClosureElement() -> MultipleTrailingClosureElement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `MultipleTrailingClosureElement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct FunctionCallExpr: ExprBuildable, ExpressibleAsFunctionCallExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeCalledExpression: UnexpectedNodes?
    var calledExpression: ExprBuildable
    var unexpectedBetweenCalledExpressionAndLeftParen: UnexpectedNodes?
    var leftParen: Token?
    var unexpectedBetweenLeftParenAndArgumentList: UnexpectedNodes?
    var argumentList: TupleExprElementList
    var unexpectedBetweenArgumentListAndRightParen: UnexpectedNodes?
    var rightParen: Token?
    var unexpectedBetweenRightParenAndTrailingClosure: UnexpectedNodes?
    var trailingClosure: ClosureExpr?
    var unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: UnexpectedNodes?
    var additionalTrailingClosures: MultipleTrailingClosureElementList?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(FunctionCallExprSyntax)
  }
  private var data: Data
  /// Creates a `FunctionCallExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeCalledExpression: 
  ///   - calledExpression: 
  ///   - unexpectedBetweenCalledExpressionAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndArgumentList: 
  ///   - argumentList: 
  ///   - unexpectedBetweenArgumentListAndRightParen: 
  ///   - rightParen: 
  ///   - unexpectedBetweenRightParenAndTrailingClosure: 
  ///   - trailingClosure: 
  ///   - unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: 
  ///   - additionalTrailingClosures: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeCalledExpression: ExpressibleAsUnexpectedNodes? = nil, calledExpression: ExpressibleAsExprBuildable, unexpectedBetweenCalledExpressionAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token? = nil, unexpectedBetweenLeftParenAndArgumentList: ExpressibleAsUnexpectedNodes? = nil, argumentList: ExpressibleAsTupleExprElementList, unexpectedBetweenArgumentListAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token? = nil, unexpectedBetweenRightParenAndTrailingClosure: ExpressibleAsUnexpectedNodes? = nil, trailingClosure: ExpressibleAsClosureExpr? = nil, unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: ExpressibleAsUnexpectedNodes? = nil, additionalTrailingClosures: ExpressibleAsMultipleTrailingClosureElementList? = nil) {
    assert(leftParen == nil || leftParen!.text == #"("#)
    assert(rightParen == nil || rightParen!.text == #")"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeCalledExpression: unexpectedBeforeCalledExpression?.createUnexpectedNodes(), calledExpression: calledExpression.createExprBuildable(), unexpectedBetweenCalledExpressionAndLeftParen: unexpectedBetweenCalledExpressionAndLeftParen?.createUnexpectedNodes(), leftParen: leftParen, unexpectedBetweenLeftParenAndArgumentList: unexpectedBetweenLeftParenAndArgumentList?.createUnexpectedNodes(), argumentList: argumentList.createTupleExprElementList(), unexpectedBetweenArgumentListAndRightParen: unexpectedBetweenArgumentListAndRightParen?.createUnexpectedNodes(), rightParen: rightParen, unexpectedBetweenRightParenAndTrailingClosure: unexpectedBetweenRightParenAndTrailingClosure?.createUnexpectedNodes(), trailingClosure: trailingClosure?.createClosureExpr(), unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures?.createUnexpectedNodes(), additionalTrailingClosures: additionalTrailingClosures?.createMultipleTrailingClosureElementList()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeCalledExpression: ExpressibleAsUnexpectedNodes? = nil, calledExpression: ExpressibleAsExprBuildable, unexpectedBetweenCalledExpressionAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token? = nil, unexpectedBetweenLeftParenAndArgumentList: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenArgumentListAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token? = nil, unexpectedBetweenRightParenAndTrailingClosure: ExpressibleAsUnexpectedNodes? = nil, trailingClosure: ExpressibleAsClosureExpr? = nil, unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: ExpressibleAsUnexpectedNodes? = nil, additionalTrailingClosures: ExpressibleAsMultipleTrailingClosureElementList? = nil, @TupleExprElementListBuilder argumentListBuilder: () -> ExpressibleAsTupleExprElementList =  {
    TupleExprElementList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeCalledExpression: unexpectedBeforeCalledExpression, calledExpression: calledExpression, unexpectedBetweenCalledExpressionAndLeftParen: unexpectedBetweenCalledExpressionAndLeftParen, leftParen: leftParen, unexpectedBetweenLeftParenAndArgumentList: unexpectedBetweenLeftParenAndArgumentList, argumentList: argumentListBuilder(), unexpectedBetweenArgumentListAndRightParen: unexpectedBetweenArgumentListAndRightParen, rightParen: rightParen, unexpectedBetweenRightParenAndTrailingClosure: unexpectedBetweenRightParenAndTrailingClosure, trailingClosure: trailingClosure, unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures, additionalTrailingClosures: additionalTrailingClosures)
  }
  public init(_ constructedNode: FunctionCallExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `FunctionCallExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `FunctionCallExprSyntax`.
  func buildFunctionCallExpr(format: Format) -> FunctionCallExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = FunctionCallExprSyntax(buildableData.unexpectedBeforeCalledExpression?.buildUnexpectedNodes(format: format), calledExpression: buildableData.calledExpression.buildExpr(format: format), buildableData.unexpectedBetweenCalledExpressionAndLeftParen?.buildUnexpectedNodes(format: format), leftParen: buildableData.leftParen?.buildToken(format: format), buildableData.unexpectedBetweenLeftParenAndArgumentList?.buildUnexpectedNodes(format: format), argumentList: buildableData.argumentList.buildTupleExprElementList(format: format), buildableData.unexpectedBetweenArgumentListAndRightParen?.buildUnexpectedNodes(format: format), rightParen: buildableData.rightParen?.buildToken(format: format), buildableData.unexpectedBetweenRightParenAndTrailingClosure?.buildUnexpectedNodes(format: format), trailingClosure: buildableData.trailingClosure?.buildClosureExpr(format: format), buildableData.unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures?.buildUnexpectedNodes(format: format), additionalTrailingClosures: buildableData.additionalTrailingClosures?.buildMultipleTrailingClosureElementList(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildFunctionCallExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsFunctionCallExpr`.
  public func createFunctionCallExpr() -> FunctionCallExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `FunctionCallExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct SubscriptExpr: ExprBuildable, ExpressibleAsSubscriptExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeCalledExpression: UnexpectedNodes?
    var calledExpression: ExprBuildable
    var unexpectedBetweenCalledExpressionAndLeftBracket: UnexpectedNodes?
    var leftBracket: Token
    var unexpectedBetweenLeftBracketAndArgumentList: UnexpectedNodes?
    var argumentList: TupleExprElementList
    var unexpectedBetweenArgumentListAndRightBracket: UnexpectedNodes?
    var rightBracket: Token
    var unexpectedBetweenRightBracketAndTrailingClosure: UnexpectedNodes?
    var trailingClosure: ClosureExpr?
    var unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: UnexpectedNodes?
    var additionalTrailingClosures: MultipleTrailingClosureElementList?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(SubscriptExprSyntax)
  }
  private var data: Data
  /// Creates a `SubscriptExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeCalledExpression: 
  ///   - calledExpression: 
  ///   - unexpectedBetweenCalledExpressionAndLeftBracket: 
  ///   - leftBracket: 
  ///   - unexpectedBetweenLeftBracketAndArgumentList: 
  ///   - argumentList: 
  ///   - unexpectedBetweenArgumentListAndRightBracket: 
  ///   - rightBracket: 
  ///   - unexpectedBetweenRightBracketAndTrailingClosure: 
  ///   - trailingClosure: 
  ///   - unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: 
  ///   - additionalTrailingClosures: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeCalledExpression: ExpressibleAsUnexpectedNodes? = nil, calledExpression: ExpressibleAsExprBuildable, unexpectedBetweenCalledExpressionAndLeftBracket: ExpressibleAsUnexpectedNodes? = nil, leftBracket: Token = Token.`leftSquareBracket`, unexpectedBetweenLeftBracketAndArgumentList: ExpressibleAsUnexpectedNodes? = nil, argumentList: ExpressibleAsTupleExprElementList, unexpectedBetweenArgumentListAndRightBracket: ExpressibleAsUnexpectedNodes? = nil, rightBracket: Token = Token.`rightSquareBracket`, unexpectedBetweenRightBracketAndTrailingClosure: ExpressibleAsUnexpectedNodes? = nil, trailingClosure: ExpressibleAsClosureExpr? = nil, unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: ExpressibleAsUnexpectedNodes? = nil, additionalTrailingClosures: ExpressibleAsMultipleTrailingClosureElementList? = nil) {
    assert(leftBracket.text == #"["#)
    assert(rightBracket.text == #"]"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeCalledExpression: unexpectedBeforeCalledExpression?.createUnexpectedNodes(), calledExpression: calledExpression.createExprBuildable(), unexpectedBetweenCalledExpressionAndLeftBracket: unexpectedBetweenCalledExpressionAndLeftBracket?.createUnexpectedNodes(), leftBracket: leftBracket, unexpectedBetweenLeftBracketAndArgumentList: unexpectedBetweenLeftBracketAndArgumentList?.createUnexpectedNodes(), argumentList: argumentList.createTupleExprElementList(), unexpectedBetweenArgumentListAndRightBracket: unexpectedBetweenArgumentListAndRightBracket?.createUnexpectedNodes(), rightBracket: rightBracket, unexpectedBetweenRightBracketAndTrailingClosure: unexpectedBetweenRightBracketAndTrailingClosure?.createUnexpectedNodes(), trailingClosure: trailingClosure?.createClosureExpr(), unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures?.createUnexpectedNodes(), additionalTrailingClosures: additionalTrailingClosures?.createMultipleTrailingClosureElementList()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeCalledExpression: ExpressibleAsUnexpectedNodes? = nil, calledExpression: ExpressibleAsExprBuildable, unexpectedBetweenCalledExpressionAndLeftBracket: ExpressibleAsUnexpectedNodes? = nil, leftBracket: Token = Token.`leftSquareBracket`, unexpectedBetweenLeftBracketAndArgumentList: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenArgumentListAndRightBracket: ExpressibleAsUnexpectedNodes? = nil, rightBracket: Token = Token.`rightSquareBracket`, unexpectedBetweenRightBracketAndTrailingClosure: ExpressibleAsUnexpectedNodes? = nil, trailingClosure: ExpressibleAsClosureExpr? = nil, unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: ExpressibleAsUnexpectedNodes? = nil, additionalTrailingClosures: ExpressibleAsMultipleTrailingClosureElementList? = nil, @TupleExprElementListBuilder argumentListBuilder: () -> ExpressibleAsTupleExprElementList =  {
    TupleExprElementList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeCalledExpression: unexpectedBeforeCalledExpression, calledExpression: calledExpression, unexpectedBetweenCalledExpressionAndLeftBracket: unexpectedBetweenCalledExpressionAndLeftBracket, leftBracket: leftBracket, unexpectedBetweenLeftBracketAndArgumentList: unexpectedBetweenLeftBracketAndArgumentList, argumentList: argumentListBuilder(), unexpectedBetweenArgumentListAndRightBracket: unexpectedBetweenArgumentListAndRightBracket, rightBracket: rightBracket, unexpectedBetweenRightBracketAndTrailingClosure: unexpectedBetweenRightBracketAndTrailingClosure, trailingClosure: trailingClosure, unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures: unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures, additionalTrailingClosures: additionalTrailingClosures)
  }
  public init(_ constructedNode: SubscriptExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `SubscriptExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SubscriptExprSyntax`.
  func buildSubscriptExpr(format: Format) -> SubscriptExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = SubscriptExprSyntax(buildableData.unexpectedBeforeCalledExpression?.buildUnexpectedNodes(format: format), calledExpression: buildableData.calledExpression.buildExpr(format: format), buildableData.unexpectedBetweenCalledExpressionAndLeftBracket?.buildUnexpectedNodes(format: format), leftBracket: buildableData.leftBracket.buildToken(format: format), buildableData.unexpectedBetweenLeftBracketAndArgumentList?.buildUnexpectedNodes(format: format), argumentList: buildableData.argumentList.buildTupleExprElementList(format: format), buildableData.unexpectedBetweenArgumentListAndRightBracket?.buildUnexpectedNodes(format: format), rightBracket: buildableData.rightBracket.buildToken(format: format), buildableData.unexpectedBetweenRightBracketAndTrailingClosure?.buildUnexpectedNodes(format: format), trailingClosure: buildableData.trailingClosure?.buildClosureExpr(format: format), buildableData.unexpectedBetweenTrailingClosureAndAdditionalTrailingClosures?.buildUnexpectedNodes(format: format), additionalTrailingClosures: buildableData.additionalTrailingClosures?.buildMultipleTrailingClosureElementList(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildSubscriptExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsSubscriptExpr`.
  public func createSubscriptExpr() -> SubscriptExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `SubscriptExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct OptionalChainingExpr: ExprBuildable, ExpressibleAsOptionalChainingExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeExpression: UnexpectedNodes?
    var expression: ExprBuildable
    var unexpectedBetweenExpressionAndQuestionMark: UnexpectedNodes?
    var questionMark: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(OptionalChainingExprSyntax)
  }
  private var data: Data
  /// Creates a `OptionalChainingExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeExpression: 
  ///   - expression: 
  ///   - unexpectedBetweenExpressionAndQuestionMark: 
  ///   - questionMark: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndQuestionMark: ExpressibleAsUnexpectedNodes? = nil, questionMark: Token = Token.`postfixQuestionMark`) {
    assert(questionMark.text == #"?"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeExpression: unexpectedBeforeExpression?.createUnexpectedNodes(), expression: expression.createExprBuildable(), unexpectedBetweenExpressionAndQuestionMark: unexpectedBetweenExpressionAndQuestionMark?.createUnexpectedNodes(), questionMark: questionMark))
  }
  public init(_ constructedNode: OptionalChainingExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `OptionalChainingExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `OptionalChainingExprSyntax`.
  func buildOptionalChainingExpr(format: Format) -> OptionalChainingExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = OptionalChainingExprSyntax(buildableData.unexpectedBeforeExpression?.buildUnexpectedNodes(format: format), expression: buildableData.expression.buildExpr(format: format), buildableData.unexpectedBetweenExpressionAndQuestionMark?.buildUnexpectedNodes(format: format), questionMark: buildableData.questionMark.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildOptionalChainingExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsOptionalChainingExpr`.
  public func createOptionalChainingExpr() -> OptionalChainingExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `OptionalChainingExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct ForcedValueExpr: ExprBuildable, ExpressibleAsForcedValueExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeExpression: UnexpectedNodes?
    var expression: ExprBuildable
    var unexpectedBetweenExpressionAndExclamationMark: UnexpectedNodes?
    var exclamationMark: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ForcedValueExprSyntax)
  }
  private var data: Data
  /// Creates a `ForcedValueExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeExpression: 
  ///   - expression: 
  ///   - unexpectedBetweenExpressionAndExclamationMark: 
  ///   - exclamationMark: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndExclamationMark: ExpressibleAsUnexpectedNodes? = nil, exclamationMark: Token = Token.`exclamationMark`) {
    assert(exclamationMark.text == #"!"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeExpression: unexpectedBeforeExpression?.createUnexpectedNodes(), expression: expression.createExprBuildable(), unexpectedBetweenExpressionAndExclamationMark: unexpectedBetweenExpressionAndExclamationMark?.createUnexpectedNodes(), exclamationMark: exclamationMark))
  }
  public init(_ constructedNode: ForcedValueExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ForcedValueExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ForcedValueExprSyntax`.
  func buildForcedValueExpr(format: Format) -> ForcedValueExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ForcedValueExprSyntax(buildableData.unexpectedBeforeExpression?.buildUnexpectedNodes(format: format), expression: buildableData.expression.buildExpr(format: format), buildableData.unexpectedBetweenExpressionAndExclamationMark?.buildUnexpectedNodes(format: format), exclamationMark: buildableData.exclamationMark.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildForcedValueExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsForcedValueExpr`.
  public func createForcedValueExpr() -> ForcedValueExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `ForcedValueExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct PostfixUnaryExpr: ExprBuildable, ExpressibleAsPostfixUnaryExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeExpression: UnexpectedNodes?
    var expression: ExprBuildable
    var unexpectedBetweenExpressionAndOperatorToken: UnexpectedNodes?
    var operatorToken: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(PostfixUnaryExprSyntax)
  }
  private var data: Data
  /// Creates a `PostfixUnaryExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeExpression: 
  ///   - expression: 
  ///   - unexpectedBetweenExpressionAndOperatorToken: 
  ///   - operatorToken: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndOperatorToken: ExpressibleAsUnexpectedNodes? = nil, operatorToken: Token) {
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeExpression: unexpectedBeforeExpression?.createUnexpectedNodes(), expression: expression.createExprBuildable(), unexpectedBetweenExpressionAndOperatorToken: unexpectedBetweenExpressionAndOperatorToken?.createUnexpectedNodes(), operatorToken: operatorToken))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndOperatorToken: ExpressibleAsUnexpectedNodes? = nil, operatorToken: String) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeExpression: unexpectedBeforeExpression, expression: expression, unexpectedBetweenExpressionAndOperatorToken: unexpectedBetweenExpressionAndOperatorToken, operatorToken: Token.`postfixOperator`(operatorToken))
  }
  public init(_ constructedNode: PostfixUnaryExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `PostfixUnaryExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PostfixUnaryExprSyntax`.
  func buildPostfixUnaryExpr(format: Format) -> PostfixUnaryExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = PostfixUnaryExprSyntax(buildableData.unexpectedBeforeExpression?.buildUnexpectedNodes(format: format), expression: buildableData.expression.buildExpr(format: format), buildableData.unexpectedBetweenExpressionAndOperatorToken?.buildUnexpectedNodes(format: format), operatorToken: buildableData.operatorToken.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildPostfixUnaryExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsPostfixUnaryExpr`.
  public func createPostfixUnaryExpr() -> PostfixUnaryExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `PostfixUnaryExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct SpecializeExpr: ExprBuildable, ExpressibleAsSpecializeExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeExpression: UnexpectedNodes?
    var expression: ExprBuildable
    var unexpectedBetweenExpressionAndGenericArgumentClause: UnexpectedNodes?
    var genericArgumentClause: GenericArgumentClause
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(SpecializeExprSyntax)
  }
  private var data: Data
  /// Creates a `SpecializeExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeExpression: 
  ///   - expression: 
  ///   - unexpectedBetweenExpressionAndGenericArgumentClause: 
  ///   - genericArgumentClause: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndGenericArgumentClause: ExpressibleAsUnexpectedNodes? = nil, genericArgumentClause: ExpressibleAsGenericArgumentClause) {
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeExpression: unexpectedBeforeExpression?.createUnexpectedNodes(), expression: expression.createExprBuildable(), unexpectedBetweenExpressionAndGenericArgumentClause: unexpectedBetweenExpressionAndGenericArgumentClause?.createUnexpectedNodes(), genericArgumentClause: genericArgumentClause.createGenericArgumentClause()))
  }
  public init(_ constructedNode: SpecializeExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `SpecializeExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SpecializeExprSyntax`.
  func buildSpecializeExpr(format: Format) -> SpecializeExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = SpecializeExprSyntax(buildableData.unexpectedBeforeExpression?.buildUnexpectedNodes(format: format), expression: buildableData.expression.buildExpr(format: format), buildableData.unexpectedBetweenExpressionAndGenericArgumentClause?.buildUnexpectedNodes(format: format), genericArgumentClause: buildableData.genericArgumentClause.buildGenericArgumentClause(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildSpecializeExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsSpecializeExpr`.
  public func createSpecializeExpr() -> SpecializeExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `SpecializeExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct StringSegment: SyntaxBuildable, ExpressibleAsStringSegment {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeContent: UnexpectedNodes?
    var content: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(StringSegmentSyntax)
  }
  private var data: Data
  /// Creates a `StringSegment` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeContent: 
  ///   - content: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeContent: ExpressibleAsUnexpectedNodes? = nil, content: Token) {
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeContent: unexpectedBeforeContent?.createUnexpectedNodes(), content: content))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeContent: ExpressibleAsUnexpectedNodes? = nil, content: String) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeContent: unexpectedBeforeContent, content: Token.`stringSegment`(content))
  }
  public init(_ constructedNode: StringSegmentSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `StringSegmentSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `StringSegmentSyntax`.
  func buildStringSegment(format: Format) -> StringSegmentSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = StringSegmentSyntax(buildableData.unexpectedBeforeContent?.buildUnexpectedNodes(format: format), content: buildableData.content.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildStringSegment(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsStringSegment`.
  public func createStringSegment() -> StringSegment {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StringSegment` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct ExpressionSegment: SyntaxBuildable, ExpressibleAsExpressionSegment {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeBackslash: UnexpectedNodes?
    var backslash: Token
    var unexpectedBetweenBackslashAndDelimiter: UnexpectedNodes?
    var delimiter: Token?
    var unexpectedBetweenDelimiterAndLeftParen: UnexpectedNodes?
    var leftParen: Token
    var unexpectedBetweenLeftParenAndExpressions: UnexpectedNodes?
    var expressions: TupleExprElementList
    var unexpectedBetweenExpressionsAndRightParen: UnexpectedNodes?
    var rightParen: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ExpressionSegmentSyntax)
  }
  private var data: Data
  /// Creates a `ExpressionSegment` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeBackslash: 
  ///   - backslash: 
  ///   - unexpectedBetweenBackslashAndDelimiter: 
  ///   - delimiter: 
  ///   - unexpectedBetweenDelimiterAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndExpressions: 
  ///   - expressions: 
  ///   - unexpectedBetweenExpressionsAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeBackslash: ExpressibleAsUnexpectedNodes? = nil, backslash: Token = Token.`backslash`, unexpectedBetweenBackslashAndDelimiter: ExpressibleAsUnexpectedNodes? = nil, delimiter: Token? = nil, unexpectedBetweenDelimiterAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndExpressions: ExpressibleAsUnexpectedNodes? = nil, expressions: ExpressibleAsTupleExprElementList, unexpectedBetweenExpressionsAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`stringInterpolationAnchor`) {
    assert(backslash.text == #"\"#)
    assert(leftParen.text == #"("#)
    assert(rightParen.text == #")"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeBackslash: unexpectedBeforeBackslash?.createUnexpectedNodes(), backslash: backslash, unexpectedBetweenBackslashAndDelimiter: unexpectedBetweenBackslashAndDelimiter?.createUnexpectedNodes(), delimiter: delimiter, unexpectedBetweenDelimiterAndLeftParen: unexpectedBetweenDelimiterAndLeftParen?.createUnexpectedNodes(), leftParen: leftParen, unexpectedBetweenLeftParenAndExpressions: unexpectedBetweenLeftParenAndExpressions?.createUnexpectedNodes(), expressions: expressions.createTupleExprElementList(), unexpectedBetweenExpressionsAndRightParen: unexpectedBetweenExpressionsAndRightParen?.createUnexpectedNodes(), rightParen: rightParen))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeBackslash: ExpressibleAsUnexpectedNodes? = nil, backslash: Token = Token.`backslash`, unexpectedBetweenBackslashAndDelimiter: ExpressibleAsUnexpectedNodes? = nil, delimiter: String?, unexpectedBetweenDelimiterAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndExpressions: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenExpressionsAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`stringInterpolationAnchor`, @TupleExprElementListBuilder expressionsBuilder: () -> ExpressibleAsTupleExprElementList =  {
    TupleExprElementList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeBackslash: unexpectedBeforeBackslash, backslash: backslash, unexpectedBetweenBackslashAndDelimiter: unexpectedBetweenBackslashAndDelimiter, delimiter: delimiter.map { Token.`rawStringDelimiter`($0) }, unexpectedBetweenDelimiterAndLeftParen: unexpectedBetweenDelimiterAndLeftParen, leftParen: leftParen, unexpectedBetweenLeftParenAndExpressions: unexpectedBetweenLeftParenAndExpressions, expressions: expressionsBuilder(), unexpectedBetweenExpressionsAndRightParen: unexpectedBetweenExpressionsAndRightParen, rightParen: rightParen)
  }
  public init(_ constructedNode: ExpressionSegmentSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ExpressionSegmentSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ExpressionSegmentSyntax`.
  func buildExpressionSegment(format: Format) -> ExpressionSegmentSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ExpressionSegmentSyntax(buildableData.unexpectedBeforeBackslash?.buildUnexpectedNodes(format: format), backslash: buildableData.backslash.buildToken(format: format), buildableData.unexpectedBetweenBackslashAndDelimiter?.buildUnexpectedNodes(format: format), delimiter: buildableData.delimiter?.buildToken(format: format), buildableData.unexpectedBetweenDelimiterAndLeftParen?.buildUnexpectedNodes(format: format), leftParen: buildableData.leftParen.buildToken(format: format), buildableData.unexpectedBetweenLeftParenAndExpressions?.buildUnexpectedNodes(format: format), expressions: buildableData.expressions.buildTupleExprElementList(format: format), buildableData.unexpectedBetweenExpressionsAndRightParen?.buildUnexpectedNodes(format: format), rightParen: buildableData.rightParen.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildExpressionSegment(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsExpressionSegment`.
  public func createExpressionSegment() -> ExpressionSegment {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExpressionSegment` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct StringLiteralExpr: ExprBuildable, ExpressibleAsStringLiteralExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeOpenDelimiter: UnexpectedNodes?
    var openDelimiter: Token?
    var unexpectedBetweenOpenDelimiterAndOpenQuote: UnexpectedNodes?
    var openQuote: Token
    var unexpectedBetweenOpenQuoteAndSegments: UnexpectedNodes?
    var segments: StringLiteralSegments
    var unexpectedBetweenSegmentsAndCloseQuote: UnexpectedNodes?
    var closeQuote: Token
    var unexpectedBetweenCloseQuoteAndCloseDelimiter: UnexpectedNodes?
    var closeDelimiter: Token?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(StringLiteralExprSyntax)
  }
  private var data: Data
  /// Creates a `StringLiteralExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeOpenDelimiter: 
  ///   - openDelimiter: 
  ///   - unexpectedBetweenOpenDelimiterAndOpenQuote: 
  ///   - openQuote: 
  ///   - unexpectedBetweenOpenQuoteAndSegments: 
  ///   - segments: 
  ///   - unexpectedBetweenSegmentsAndCloseQuote: 
  ///   - closeQuote: 
  ///   - unexpectedBetweenCloseQuoteAndCloseDelimiter: 
  ///   - closeDelimiter: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeOpenDelimiter: ExpressibleAsUnexpectedNodes? = nil, openDelimiter: Token? = nil, unexpectedBetweenOpenDelimiterAndOpenQuote: ExpressibleAsUnexpectedNodes? = nil, openQuote: Token, unexpectedBetweenOpenQuoteAndSegments: ExpressibleAsUnexpectedNodes? = nil, segments: ExpressibleAsStringLiteralSegments, unexpectedBetweenSegmentsAndCloseQuote: ExpressibleAsUnexpectedNodes? = nil, closeQuote: Token, unexpectedBetweenCloseQuoteAndCloseDelimiter: ExpressibleAsUnexpectedNodes? = nil, closeDelimiter: Token? = nil) {
    assert(openQuote.text == #"""# || openQuote.text == #"""""#)
    assert(closeQuote.text == #"""# || closeQuote.text == #"""""#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeOpenDelimiter: unexpectedBeforeOpenDelimiter?.createUnexpectedNodes(), openDelimiter: openDelimiter, unexpectedBetweenOpenDelimiterAndOpenQuote: unexpectedBetweenOpenDelimiterAndOpenQuote?.createUnexpectedNodes(), openQuote: openQuote, unexpectedBetweenOpenQuoteAndSegments: unexpectedBetweenOpenQuoteAndSegments?.createUnexpectedNodes(), segments: segments.createStringLiteralSegments(), unexpectedBetweenSegmentsAndCloseQuote: unexpectedBetweenSegmentsAndCloseQuote?.createUnexpectedNodes(), closeQuote: closeQuote, unexpectedBetweenCloseQuoteAndCloseDelimiter: unexpectedBetweenCloseQuoteAndCloseDelimiter?.createUnexpectedNodes(), closeDelimiter: closeDelimiter))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeOpenDelimiter: ExpressibleAsUnexpectedNodes? = nil, openDelimiter: String?, unexpectedBetweenOpenDelimiterAndOpenQuote: ExpressibleAsUnexpectedNodes? = nil, openQuote: Token, unexpectedBetweenOpenQuoteAndSegments: ExpressibleAsUnexpectedNodes? = nil, segments: ExpressibleAsStringLiteralSegments, unexpectedBetweenSegmentsAndCloseQuote: ExpressibleAsUnexpectedNodes? = nil, closeQuote: Token, unexpectedBetweenCloseQuoteAndCloseDelimiter: ExpressibleAsUnexpectedNodes? = nil, closeDelimiter: String?) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeOpenDelimiter: unexpectedBeforeOpenDelimiter, openDelimiter: openDelimiter.map { Token.`rawStringDelimiter`($0) }, unexpectedBetweenOpenDelimiterAndOpenQuote: unexpectedBetweenOpenDelimiterAndOpenQuote, openQuote: openQuote, unexpectedBetweenOpenQuoteAndSegments: unexpectedBetweenOpenQuoteAndSegments, segments: segments, unexpectedBetweenSegmentsAndCloseQuote: unexpectedBetweenSegmentsAndCloseQuote, closeQuote: closeQuote, unexpectedBetweenCloseQuoteAndCloseDelimiter: unexpectedBetweenCloseQuoteAndCloseDelimiter, closeDelimiter: closeDelimiter.map { Token.`rawStringDelimiter`($0) })
  }
  public init(_ constructedNode: StringLiteralExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `StringLiteralExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `StringLiteralExprSyntax`.
  func buildStringLiteralExpr(format: Format) -> StringLiteralExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = StringLiteralExprSyntax(buildableData.unexpectedBeforeOpenDelimiter?.buildUnexpectedNodes(format: format), openDelimiter: buildableData.openDelimiter?.buildToken(format: format), buildableData.unexpectedBetweenOpenDelimiterAndOpenQuote?.buildUnexpectedNodes(format: format), openQuote: buildableData.openQuote.buildToken(format: format), buildableData.unexpectedBetweenOpenQuoteAndSegments?.buildUnexpectedNodes(format: format), segments: buildableData.segments.buildStringLiteralSegments(format: format), buildableData.unexpectedBetweenSegmentsAndCloseQuote?.buildUnexpectedNodes(format: format), closeQuote: buildableData.closeQuote.buildToken(format: format), buildableData.unexpectedBetweenCloseQuoteAndCloseDelimiter?.buildUnexpectedNodes(format: format), closeDelimiter: buildableData.closeDelimiter?.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildStringLiteralExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsStringLiteralExpr`.
  public func createStringLiteralExpr() -> StringLiteralExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `StringLiteralExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct RegexLiteralExpr: ExprBuildable, ExpressibleAsRegexLiteralExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeRegex: UnexpectedNodes?
    var regex: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(RegexLiteralExprSyntax)
  }
  private var data: Data
  /// Creates a `RegexLiteralExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeRegex: 
  ///   - regex: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeRegex: ExpressibleAsUnexpectedNodes? = nil, regex: Token) {
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeRegex: unexpectedBeforeRegex?.createUnexpectedNodes(), regex: regex))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeRegex: ExpressibleAsUnexpectedNodes? = nil, regex: String) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeRegex: unexpectedBeforeRegex, regex: Token.`regexLiteral`(regex))
  }
  public init(_ constructedNode: RegexLiteralExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `RegexLiteralExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `RegexLiteralExprSyntax`.
  func buildRegexLiteralExpr(format: Format) -> RegexLiteralExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = RegexLiteralExprSyntax(buildableData.unexpectedBeforeRegex?.buildUnexpectedNodes(format: format), regex: buildableData.regex.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildRegexLiteralExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsRegexLiteralExpr`.
  public func createRegexLiteralExpr() -> RegexLiteralExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `RegexLiteralExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct KeyPathExpr: ExprBuildable, ExpressibleAsKeyPathExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeBackslash: UnexpectedNodes?
    var backslash: Token
    var unexpectedBetweenBackslashAndRoot: UnexpectedNodes?
    var root: TypeBuildable?
    var unexpectedBetweenRootAndComponents: UnexpectedNodes?
    var components: KeyPathComponentList
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(KeyPathExprSyntax)
  }
  private var data: Data
  /// Creates a `KeyPathExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeBackslash: 
  ///   - backslash: 
  ///   - unexpectedBetweenBackslashAndRoot: 
  ///   - root: 
  ///   - unexpectedBetweenRootAndComponents: 
  ///   - components: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeBackslash: ExpressibleAsUnexpectedNodes? = nil, backslash: Token = Token.`backslash`, unexpectedBetweenBackslashAndRoot: ExpressibleAsUnexpectedNodes? = nil, root: ExpressibleAsTypeBuildable? = nil, unexpectedBetweenRootAndComponents: ExpressibleAsUnexpectedNodes? = nil, components: ExpressibleAsKeyPathComponentList) {
    assert(backslash.text == #"\"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeBackslash: unexpectedBeforeBackslash?.createUnexpectedNodes(), backslash: backslash, unexpectedBetweenBackslashAndRoot: unexpectedBetweenBackslashAndRoot?.createUnexpectedNodes(), root: root?.createTypeBuildable(), unexpectedBetweenRootAndComponents: unexpectedBetweenRootAndComponents?.createUnexpectedNodes(), components: components.createKeyPathComponentList()))
  }
  public init(_ constructedNode: KeyPathExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `KeyPathExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `KeyPathExprSyntax`.
  func buildKeyPathExpr(format: Format) -> KeyPathExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = KeyPathExprSyntax(buildableData.unexpectedBeforeBackslash?.buildUnexpectedNodes(format: format), backslash: buildableData.backslash.buildToken(format: format), buildableData.unexpectedBetweenBackslashAndRoot?.buildUnexpectedNodes(format: format), root: buildableData.root?.buildType(format: format), buildableData.unexpectedBetweenRootAndComponents?.buildUnexpectedNodes(format: format), components: buildableData.components.buildKeyPathComponentList(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildKeyPathExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsKeyPathExpr`.
  public func createKeyPathExpr() -> KeyPathExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `KeyPathExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct KeyPathComponent: SyntaxBuildable, ExpressibleAsKeyPathComponent {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforePeriod: UnexpectedNodes?
    var period: Token?
    var unexpectedBetweenPeriodAndComponent: UnexpectedNodes?
    var component: SyntaxBuildable
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(KeyPathComponentSyntax)
  }
  private var data: Data
  /// Creates a `KeyPathComponent` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePeriod: 
  ///   - period: 
  ///   - unexpectedBetweenPeriodAndComponent: 
  ///   - component: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePeriod: ExpressibleAsUnexpectedNodes? = nil, period: Token? = nil, unexpectedBetweenPeriodAndComponent: ExpressibleAsUnexpectedNodes? = nil, component: ExpressibleAsSyntaxBuildable) {
    assert(period == nil || period!.text == #"."# || period!.text == #"."#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforePeriod: unexpectedBeforePeriod?.createUnexpectedNodes(), period: period, unexpectedBetweenPeriodAndComponent: unexpectedBetweenPeriodAndComponent?.createUnexpectedNodes(), component: component.createSyntaxBuildable()))
  }
  public init(_ constructedNode: KeyPathComponentSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `KeyPathComponentSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `KeyPathComponentSyntax`.
  func buildKeyPathComponent(format: Format) -> KeyPathComponentSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = KeyPathComponentSyntax(buildableData.unexpectedBeforePeriod?.buildUnexpectedNodes(format: format), period: buildableData.period?.buildToken(format: format), buildableData.unexpectedBetweenPeriodAndComponent?.buildUnexpectedNodes(format: format), component: buildableData.component.buildSyntax(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildKeyPathComponent(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsKeyPathComponent`.
  public func createKeyPathComponent() -> KeyPathComponent {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `KeyPathComponent` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct KeyPathPropertyComponent: SyntaxBuildable, ExpressibleAsKeyPathPropertyComponent {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeIdentifier: UnexpectedNodes?
    var identifier: Token
    var unexpectedBetweenIdentifierAndDeclNameArguments: UnexpectedNodes?
    var declNameArguments: DeclNameArguments?
    var unexpectedBetweenDeclNameArgumentsAndGenericArgumentClause: UnexpectedNodes?
    var genericArgumentClause: GenericArgumentClause?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(KeyPathPropertyComponentSyntax)
  }
  private var data: Data
  /// Creates a `KeyPathPropertyComponent` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeIdentifier: 
  ///   - identifier: 
  ///   - unexpectedBetweenIdentifierAndDeclNameArguments: 
  ///   - declNameArguments: 
  ///   - unexpectedBetweenDeclNameArgumentsAndGenericArgumentClause: 
  ///   - genericArgumentClause: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndDeclNameArguments: ExpressibleAsUnexpectedNodes? = nil, declNameArguments: ExpressibleAsDeclNameArguments? = nil, unexpectedBetweenDeclNameArgumentsAndGenericArgumentClause: ExpressibleAsUnexpectedNodes? = nil, genericArgumentClause: ExpressibleAsGenericArgumentClause? = nil) {
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeIdentifier: unexpectedBeforeIdentifier?.createUnexpectedNodes(), identifier: identifier, unexpectedBetweenIdentifierAndDeclNameArguments: unexpectedBetweenIdentifierAndDeclNameArguments?.createUnexpectedNodes(), declNameArguments: declNameArguments?.createDeclNameArguments(), unexpectedBetweenDeclNameArgumentsAndGenericArgumentClause: unexpectedBetweenDeclNameArgumentsAndGenericArgumentClause?.createUnexpectedNodes(), genericArgumentClause: genericArgumentClause?.createGenericArgumentClause()))
  }
  public init(_ constructedNode: KeyPathPropertyComponentSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `KeyPathPropertyComponentSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `KeyPathPropertyComponentSyntax`.
  func buildKeyPathPropertyComponent(format: Format) -> KeyPathPropertyComponentSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = KeyPathPropertyComponentSyntax(buildableData.unexpectedBeforeIdentifier?.buildUnexpectedNodes(format: format), identifier: buildableData.identifier.buildToken(format: format), buildableData.unexpectedBetweenIdentifierAndDeclNameArguments?.buildUnexpectedNodes(format: format), declNameArguments: buildableData.declNameArguments?.buildDeclNameArguments(format: format), buildableData.unexpectedBetweenDeclNameArgumentsAndGenericArgumentClause?.buildUnexpectedNodes(format: format), genericArgumentClause: buildableData.genericArgumentClause?.buildGenericArgumentClause(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildKeyPathPropertyComponent(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsKeyPathPropertyComponent`.
  public func createKeyPathPropertyComponent() -> KeyPathPropertyComponent {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `KeyPathPropertyComponent` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct KeyPathSubscriptComponent: SyntaxBuildable, ExpressibleAsKeyPathSubscriptComponent {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeLeftBracket: UnexpectedNodes?
    var leftBracket: Token
    var unexpectedBetweenLeftBracketAndArgumentList: UnexpectedNodes?
    var argumentList: TupleExprElementList
    var unexpectedBetweenArgumentListAndRightBracket: UnexpectedNodes?
    var rightBracket: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(KeyPathSubscriptComponentSyntax)
  }
  private var data: Data
  /// Creates a `KeyPathSubscriptComponent` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftBracket: 
  ///   - leftBracket: 
  ///   - unexpectedBetweenLeftBracketAndArgumentList: 
  ///   - argumentList: 
  ///   - unexpectedBetweenArgumentListAndRightBracket: 
  ///   - rightBracket: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftBracket: ExpressibleAsUnexpectedNodes? = nil, leftBracket: Token = Token.`leftSquareBracket`, unexpectedBetweenLeftBracketAndArgumentList: ExpressibleAsUnexpectedNodes? = nil, argumentList: ExpressibleAsTupleExprElementList, unexpectedBetweenArgumentListAndRightBracket: ExpressibleAsUnexpectedNodes? = nil, rightBracket: Token = Token.`rightSquareBracket`) {
    assert(leftBracket.text == #"["#)
    assert(rightBracket.text == #"]"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeLeftBracket: unexpectedBeforeLeftBracket?.createUnexpectedNodes(), leftBracket: leftBracket, unexpectedBetweenLeftBracketAndArgumentList: unexpectedBetweenLeftBracketAndArgumentList?.createUnexpectedNodes(), argumentList: argumentList.createTupleExprElementList(), unexpectedBetweenArgumentListAndRightBracket: unexpectedBetweenArgumentListAndRightBracket?.createUnexpectedNodes(), rightBracket: rightBracket))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftBracket: ExpressibleAsUnexpectedNodes? = nil, leftBracket: Token = Token.`leftSquareBracket`, unexpectedBetweenLeftBracketAndArgumentList: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenArgumentListAndRightBracket: ExpressibleAsUnexpectedNodes? = nil, rightBracket: Token = Token.`rightSquareBracket`, @TupleExprElementListBuilder argumentListBuilder: () -> ExpressibleAsTupleExprElementList =  {
    TupleExprElementList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftBracket: unexpectedBeforeLeftBracket, leftBracket: leftBracket, unexpectedBetweenLeftBracketAndArgumentList: unexpectedBetweenLeftBracketAndArgumentList, argumentList: argumentListBuilder(), unexpectedBetweenArgumentListAndRightBracket: unexpectedBetweenArgumentListAndRightBracket, rightBracket: rightBracket)
  }
  public init(_ constructedNode: KeyPathSubscriptComponentSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `KeyPathSubscriptComponentSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `KeyPathSubscriptComponentSyntax`.
  func buildKeyPathSubscriptComponent(format: Format) -> KeyPathSubscriptComponentSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = KeyPathSubscriptComponentSyntax(buildableData.unexpectedBeforeLeftBracket?.buildUnexpectedNodes(format: format), leftBracket: buildableData.leftBracket.buildToken(format: format), buildableData.unexpectedBetweenLeftBracketAndArgumentList?.buildUnexpectedNodes(format: format), argumentList: buildableData.argumentList.buildTupleExprElementList(format: format), buildableData.unexpectedBetweenArgumentListAndRightBracket?.buildUnexpectedNodes(format: format), rightBracket: buildableData.rightBracket.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildKeyPathSubscriptComponent(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsKeyPathSubscriptComponent`.
  public func createKeyPathSubscriptComponent() -> KeyPathSubscriptComponent {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `KeyPathSubscriptComponent` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct KeyPathOptionalComponent: SyntaxBuildable, ExpressibleAsKeyPathOptionalComponent {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeQuestionOrExclamationMark: UnexpectedNodes?
    var questionOrExclamationMark: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(KeyPathOptionalComponentSyntax)
  }
  private var data: Data
  /// Creates a `KeyPathOptionalComponent` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeQuestionOrExclamationMark: 
  ///   - questionOrExclamationMark: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeQuestionOrExclamationMark: ExpressibleAsUnexpectedNodes? = nil, questionOrExclamationMark: Token) {
    assert(questionOrExclamationMark.text == #"?"# || questionOrExclamationMark.text == #"!"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeQuestionOrExclamationMark: unexpectedBeforeQuestionOrExclamationMark?.createUnexpectedNodes(), questionOrExclamationMark: questionOrExclamationMark))
  }
  public init(_ constructedNode: KeyPathOptionalComponentSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `KeyPathOptionalComponentSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `KeyPathOptionalComponentSyntax`.
  func buildKeyPathOptionalComponent(format: Format) -> KeyPathOptionalComponentSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = KeyPathOptionalComponentSyntax(buildableData.unexpectedBeforeQuestionOrExclamationMark?.buildUnexpectedNodes(format: format), questionOrExclamationMark: buildableData.questionOrExclamationMark.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildKeyPathOptionalComponent(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsKeyPathOptionalComponent`.
  public func createKeyPathOptionalComponent() -> KeyPathOptionalComponent {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `KeyPathOptionalComponent` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct OldKeyPathExpr: ExprBuildable, ExpressibleAsOldKeyPathExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeBackslash: UnexpectedNodes?
    var backslash: Token
    var unexpectedBetweenBackslashAndRootExpr: UnexpectedNodes?
    var rootExpr: ExprBuildable?
    var unexpectedBetweenRootExprAndExpression: UnexpectedNodes?
    var expression: ExprBuildable
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(OldKeyPathExprSyntax)
  }
  private var data: Data
  /// Creates a `OldKeyPathExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeBackslash: 
  ///   - backslash: 
  ///   - unexpectedBetweenBackslashAndRootExpr: 
  ///   - rootExpr: 
  ///   - unexpectedBetweenRootExprAndExpression: 
  ///   - expression: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeBackslash: ExpressibleAsUnexpectedNodes? = nil, backslash: Token = Token.`backslash`, unexpectedBetweenBackslashAndRootExpr: ExpressibleAsUnexpectedNodes? = nil, rootExpr: ExpressibleAsExprBuildable? = nil, unexpectedBetweenRootExprAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable) {
    assert(backslash.text == #"\"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeBackslash: unexpectedBeforeBackslash?.createUnexpectedNodes(), backslash: backslash, unexpectedBetweenBackslashAndRootExpr: unexpectedBetweenBackslashAndRootExpr?.createUnexpectedNodes(), rootExpr: rootExpr?.createExprBuildable(), unexpectedBetweenRootExprAndExpression: unexpectedBetweenRootExprAndExpression?.createUnexpectedNodes(), expression: expression.createExprBuildable()))
  }
  public init(_ constructedNode: OldKeyPathExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `OldKeyPathExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `OldKeyPathExprSyntax`.
  func buildOldKeyPathExpr(format: Format) -> OldKeyPathExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = OldKeyPathExprSyntax(buildableData.unexpectedBeforeBackslash?.buildUnexpectedNodes(format: format), backslash: buildableData.backslash.buildToken(format: format), buildableData.unexpectedBetweenBackslashAndRootExpr?.buildUnexpectedNodes(format: format), rootExpr: buildableData.rootExpr?.buildExpr(format: format), buildableData.unexpectedBetweenRootExprAndExpression?.buildUnexpectedNodes(format: format), expression: buildableData.expression.buildExpr(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildOldKeyPathExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsOldKeyPathExpr`.
  public func createOldKeyPathExpr() -> OldKeyPathExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `OldKeyPathExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct KeyPathBaseExpr: ExprBuildable, ExpressibleAsKeyPathBaseExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforePeriod: UnexpectedNodes?
    var period: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(KeyPathBaseExprSyntax)
  }
  private var data: Data
  /// Creates a `KeyPathBaseExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePeriod: 
  ///   - period: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePeriod: ExpressibleAsUnexpectedNodes? = nil, period: Token = Token.`period`) {
    assert(period.text == #"."#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforePeriod: unexpectedBeforePeriod?.createUnexpectedNodes(), period: period))
  }
  public init(_ constructedNode: KeyPathBaseExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `KeyPathBaseExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `KeyPathBaseExprSyntax`.
  func buildKeyPathBaseExpr(format: Format) -> KeyPathBaseExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = KeyPathBaseExprSyntax(buildableData.unexpectedBeforePeriod?.buildUnexpectedNodes(format: format), period: buildableData.period.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildKeyPathBaseExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsKeyPathBaseExpr`.
  public func createKeyPathBaseExpr() -> KeyPathBaseExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `KeyPathBaseExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct ObjcNamePiece: SyntaxBuildable, ExpressibleAsObjcNamePiece {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeName: UnexpectedNodes?
    var name: Token
    var unexpectedBetweenNameAndDot: UnexpectedNodes?
    var dot: Token?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ObjcNamePieceSyntax)
  }
  private var data: Data
  /// Creates a `ObjcNamePiece` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndDot: 
  ///   - dot: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndDot: ExpressibleAsUnexpectedNodes? = nil, dot: Token? = nil) {
    assert(dot == nil || dot!.text == #"."#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeName: unexpectedBeforeName?.createUnexpectedNodes(), name: name, unexpectedBetweenNameAndDot: unexpectedBetweenNameAndDot?.createUnexpectedNodes(), dot: dot))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: String, unexpectedBetweenNameAndDot: ExpressibleAsUnexpectedNodes? = nil, dot: Token? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeName: unexpectedBeforeName, name: Token.`identifier`(name), unexpectedBetweenNameAndDot: unexpectedBetweenNameAndDot, dot: dot)
  }
  public init(_ constructedNode: ObjcNamePieceSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ObjcNamePieceSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ObjcNamePieceSyntax`.
  func buildObjcNamePiece(format: Format) -> ObjcNamePieceSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ObjcNamePieceSyntax(buildableData.unexpectedBeforeName?.buildUnexpectedNodes(format: format), name: buildableData.name.buildToken(format: format), buildableData.unexpectedBetweenNameAndDot?.buildUnexpectedNodes(format: format), dot: buildableData.dot?.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildObjcNamePiece(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsObjcNamePiece`.
  public func createObjcNamePiece() -> ObjcNamePiece {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ObjcNamePiece` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct ObjcKeyPathExpr: ExprBuildable, ExpressibleAsObjcKeyPathExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeKeyPath: UnexpectedNodes?
    var keyPath: Token
    var unexpectedBetweenKeyPathAndLeftParen: UnexpectedNodes?
    var leftParen: Token
    var unexpectedBetweenLeftParenAndName: UnexpectedNodes?
    var name: ObjcName
    var unexpectedBetweenNameAndRightParen: UnexpectedNodes?
    var rightParen: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ObjcKeyPathExprSyntax)
  }
  private var data: Data
  /// Creates a `ObjcKeyPathExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeKeyPath: 
  ///   - keyPath: 
  ///   - unexpectedBetweenKeyPathAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeKeyPath: ExpressibleAsUnexpectedNodes? = nil, keyPath: Token = Token.`poundKeyPath`, unexpectedBetweenKeyPathAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndName: ExpressibleAsUnexpectedNodes? = nil, name: ExpressibleAsObjcName, unexpectedBetweenNameAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    assert(keyPath.text == #"#keyPath"#)
    assert(leftParen.text == #"("#)
    assert(rightParen.text == #")"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeKeyPath: unexpectedBeforeKeyPath?.createUnexpectedNodes(), keyPath: keyPath, unexpectedBetweenKeyPathAndLeftParen: unexpectedBetweenKeyPathAndLeftParen?.createUnexpectedNodes(), leftParen: leftParen, unexpectedBetweenLeftParenAndName: unexpectedBetweenLeftParenAndName?.createUnexpectedNodes(), name: name.createObjcName(), unexpectedBetweenNameAndRightParen: unexpectedBetweenNameAndRightParen?.createUnexpectedNodes(), rightParen: rightParen))
  }
  public init(_ constructedNode: ObjcKeyPathExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ObjcKeyPathExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ObjcKeyPathExprSyntax`.
  func buildObjcKeyPathExpr(format: Format) -> ObjcKeyPathExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ObjcKeyPathExprSyntax(buildableData.unexpectedBeforeKeyPath?.buildUnexpectedNodes(format: format), keyPath: buildableData.keyPath.buildToken(format: format), buildableData.unexpectedBetweenKeyPathAndLeftParen?.buildUnexpectedNodes(format: format), leftParen: buildableData.leftParen.buildToken(format: format), buildableData.unexpectedBetweenLeftParenAndName?.buildUnexpectedNodes(format: format), name: buildableData.name.buildObjcName(format: format), buildableData.unexpectedBetweenNameAndRightParen?.buildUnexpectedNodes(format: format), rightParen: buildableData.rightParen.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildObjcKeyPathExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsObjcKeyPathExpr`.
  public func createObjcKeyPathExpr() -> ObjcKeyPathExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `ObjcKeyPathExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct ObjcSelectorExpr: ExprBuildable, ExpressibleAsObjcSelectorExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforePoundSelector: UnexpectedNodes?
    var poundSelector: Token
    var unexpectedBetweenPoundSelectorAndLeftParen: UnexpectedNodes?
    var leftParen: Token
    var unexpectedBetweenLeftParenAndKind: UnexpectedNodes?
    var kind: Token?
    var unexpectedBetweenKindAndColon: UnexpectedNodes?
    var colon: Token?
    var unexpectedBetweenColonAndName: UnexpectedNodes?
    var name: ExprBuildable
    var unexpectedBetweenNameAndRightParen: UnexpectedNodes?
    var rightParen: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ObjcSelectorExprSyntax)
  }
  private var data: Data
  /// Creates a `ObjcSelectorExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundSelector: 
  ///   - poundSelector: 
  ///   - unexpectedBetweenPoundSelectorAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndKind: 
  ///   - kind: 
  ///   - unexpectedBetweenKindAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePoundSelector: ExpressibleAsUnexpectedNodes? = nil, poundSelector: Token = Token.`poundSelector`, unexpectedBetweenPoundSelectorAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndKind: ExpressibleAsUnexpectedNodes? = nil, kind: Token? = nil, unexpectedBetweenKindAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token? = nil, unexpectedBetweenColonAndName: ExpressibleAsUnexpectedNodes? = nil, name: ExpressibleAsExprBuildable, unexpectedBetweenNameAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    assert(poundSelector.text == #"#selector"#)
    assert(leftParen.text == #"("#)
    assert(kind == nil || kind!.text == #"getter"# || kind!.text == #"setter"#)
    assert(colon == nil || colon!.text == #":"#)
    assert(rightParen.text == #")"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforePoundSelector: unexpectedBeforePoundSelector?.createUnexpectedNodes(), poundSelector: poundSelector, unexpectedBetweenPoundSelectorAndLeftParen: unexpectedBetweenPoundSelectorAndLeftParen?.createUnexpectedNodes(), leftParen: leftParen, unexpectedBetweenLeftParenAndKind: unexpectedBetweenLeftParenAndKind?.createUnexpectedNodes(), kind: kind, unexpectedBetweenKindAndColon: unexpectedBetweenKindAndColon?.createUnexpectedNodes(), colon: colon, unexpectedBetweenColonAndName: unexpectedBetweenColonAndName?.createUnexpectedNodes(), name: name.createExprBuildable(), unexpectedBetweenNameAndRightParen: unexpectedBetweenNameAndRightParen?.createUnexpectedNodes(), rightParen: rightParen))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforePoundSelector: ExpressibleAsUnexpectedNodes? = nil, poundSelector: Token = Token.`poundSelector`, unexpectedBetweenPoundSelectorAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndKind: ExpressibleAsUnexpectedNodes? = nil, kind: String?, unexpectedBetweenKindAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token? = nil, unexpectedBetweenColonAndName: ExpressibleAsUnexpectedNodes? = nil, name: ExpressibleAsExprBuildable, unexpectedBetweenNameAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforePoundSelector: unexpectedBeforePoundSelector, poundSelector: poundSelector, unexpectedBetweenPoundSelectorAndLeftParen: unexpectedBetweenPoundSelectorAndLeftParen, leftParen: leftParen, unexpectedBetweenLeftParenAndKind: unexpectedBetweenLeftParenAndKind, kind: kind.map { Token.`contextualKeyword`($0) }, unexpectedBetweenKindAndColon: unexpectedBetweenKindAndColon, colon: colon, unexpectedBetweenColonAndName: unexpectedBetweenColonAndName, name: name, unexpectedBetweenNameAndRightParen: unexpectedBetweenNameAndRightParen, rightParen: rightParen)
  }
  public init(_ constructedNode: ObjcSelectorExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ObjcSelectorExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ObjcSelectorExprSyntax`.
  func buildObjcSelectorExpr(format: Format) -> ObjcSelectorExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ObjcSelectorExprSyntax(buildableData.unexpectedBeforePoundSelector?.buildUnexpectedNodes(format: format), poundSelector: buildableData.poundSelector.buildToken(format: format), buildableData.unexpectedBetweenPoundSelectorAndLeftParen?.buildUnexpectedNodes(format: format), leftParen: buildableData.leftParen.buildToken(format: format), buildableData.unexpectedBetweenLeftParenAndKind?.buildUnexpectedNodes(format: format), kind: buildableData.kind?.buildToken(format: format), buildableData.unexpectedBetweenKindAndColon?.buildUnexpectedNodes(format: format), colon: buildableData.colon?.buildToken(format: format), buildableData.unexpectedBetweenColonAndName?.buildUnexpectedNodes(format: format), name: buildableData.name.buildExpr(format: format), buildableData.unexpectedBetweenNameAndRightParen?.buildUnexpectedNodes(format: format), rightParen: buildableData.rightParen.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildObjcSelectorExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsObjcSelectorExpr`.
  public func createObjcSelectorExpr() -> ObjcSelectorExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `ObjcSelectorExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct PostfixIfConfigExpr: ExprBuildable, ExpressibleAsPostfixIfConfigExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeBase: UnexpectedNodes?
    var base: ExprBuildable?
    var unexpectedBetweenBaseAndConfig: UnexpectedNodes?
    var config: IfConfigDecl
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(PostfixIfConfigExprSyntax)
  }
  private var data: Data
  /// Creates a `PostfixIfConfigExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeBase: 
  ///   - base: 
  ///   - unexpectedBetweenBaseAndConfig: 
  ///   - config: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeBase: ExpressibleAsUnexpectedNodes? = nil, base: ExpressibleAsExprBuildable? = nil, unexpectedBetweenBaseAndConfig: ExpressibleAsUnexpectedNodes? = nil, config: ExpressibleAsIfConfigDecl) {
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeBase: unexpectedBeforeBase?.createUnexpectedNodes(), base: base?.createExprBuildable(), unexpectedBetweenBaseAndConfig: unexpectedBetweenBaseAndConfig?.createUnexpectedNodes(), config: config.createIfConfigDecl()))
  }
  public init(_ constructedNode: PostfixIfConfigExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `PostfixIfConfigExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PostfixIfConfigExprSyntax`.
  func buildPostfixIfConfigExpr(format: Format) -> PostfixIfConfigExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = PostfixIfConfigExprSyntax(buildableData.unexpectedBeforeBase?.buildUnexpectedNodes(format: format), base: buildableData.base?.buildExpr(format: format), buildableData.unexpectedBetweenBaseAndConfig?.buildUnexpectedNodes(format: format), config: buildableData.config.buildIfConfigDecl(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildPostfixIfConfigExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsPostfixIfConfigExpr`.
  public func createPostfixIfConfigExpr() -> PostfixIfConfigExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `PostfixIfConfigExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct EditorPlaceholderExpr: ExprBuildable, ExpressibleAsEditorPlaceholderExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeIdentifier: UnexpectedNodes?
    var identifier: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(EditorPlaceholderExprSyntax)
  }
  private var data: Data
  /// Creates a `EditorPlaceholderExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeIdentifier: 
  ///   - identifier: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token) {
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeIdentifier: unexpectedBeforeIdentifier?.createUnexpectedNodes(), identifier: identifier))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: String) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeIdentifier: unexpectedBeforeIdentifier, identifier: Token.`identifier`(identifier))
  }
  public init(_ constructedNode: EditorPlaceholderExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `EditorPlaceholderExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `EditorPlaceholderExprSyntax`.
  func buildEditorPlaceholderExpr(format: Format) -> EditorPlaceholderExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = EditorPlaceholderExprSyntax(buildableData.unexpectedBeforeIdentifier?.buildUnexpectedNodes(format: format), identifier: buildableData.identifier.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildEditorPlaceholderExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsEditorPlaceholderExpr`.
  public func createEditorPlaceholderExpr() -> EditorPlaceholderExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `EditorPlaceholderExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct ObjectLiteralExpr: ExprBuildable, ExpressibleAsObjectLiteralExpr {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeIdentifier: UnexpectedNodes?
    var identifier: Token
    var unexpectedBetweenIdentifierAndLeftParen: UnexpectedNodes?
    var leftParen: Token
    var unexpectedBetweenLeftParenAndArguments: UnexpectedNodes?
    var arguments: TupleExprElementList
    var unexpectedBetweenArgumentsAndRightParen: UnexpectedNodes?
    var rightParen: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ObjectLiteralExprSyntax)
  }
  private var data: Data
  /// Creates a `ObjectLiteralExpr` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeIdentifier: 
  ///   - identifier: 
  ///   - unexpectedBetweenIdentifierAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndArguments: 
  ///   - arguments: 
  ///   - unexpectedBetweenArgumentsAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndArguments: ExpressibleAsUnexpectedNodes? = nil, arguments: ExpressibleAsTupleExprElementList, unexpectedBetweenArgumentsAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    assert(identifier.text == #"#colorLiteral"# || identifier.text == #"#fileLiteral"# || identifier.text == #"#imageLiteral"#)
    assert(leftParen.text == #"("#)
    assert(rightParen.text == #")"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeIdentifier: unexpectedBeforeIdentifier?.createUnexpectedNodes(), identifier: identifier, unexpectedBetweenIdentifierAndLeftParen: unexpectedBetweenIdentifierAndLeftParen?.createUnexpectedNodes(), leftParen: leftParen, unexpectedBetweenLeftParenAndArguments: unexpectedBetweenLeftParenAndArguments?.createUnexpectedNodes(), arguments: arguments.createTupleExprElementList(), unexpectedBetweenArgumentsAndRightParen: unexpectedBetweenArgumentsAndRightParen?.createUnexpectedNodes(), rightParen: rightParen))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndArguments: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenArgumentsAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`, @TupleExprElementListBuilder argumentsBuilder: () -> ExpressibleAsTupleExprElementList =  {
    TupleExprElementList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeIdentifier: unexpectedBeforeIdentifier, identifier: identifier, unexpectedBetweenIdentifierAndLeftParen: unexpectedBetweenIdentifierAndLeftParen, leftParen: leftParen, unexpectedBetweenLeftParenAndArguments: unexpectedBetweenLeftParenAndArguments, arguments: argumentsBuilder(), unexpectedBetweenArgumentsAndRightParen: unexpectedBetweenArgumentsAndRightParen, rightParen: rightParen)
  }
  public init(_ constructedNode: ObjectLiteralExprSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ObjectLiteralExprSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ObjectLiteralExprSyntax`.
  func buildObjectLiteralExpr(format: Format) -> ObjectLiteralExprSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ObjectLiteralExprSyntax(buildableData.unexpectedBeforeIdentifier?.buildUnexpectedNodes(format: format), identifier: buildableData.identifier.buildToken(format: format), buildableData.unexpectedBetweenIdentifierAndLeftParen?.buildUnexpectedNodes(format: format), leftParen: buildableData.leftParen.buildToken(format: format), buildableData.unexpectedBetweenLeftParenAndArguments?.buildUnexpectedNodes(format: format), arguments: buildableData.arguments.buildTupleExprElementList(format: format), buildableData.unexpectedBetweenArgumentsAndRightParen?.buildUnexpectedNodes(format: format), rightParen: buildableData.rightParen.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `ExprBuildable`.
  public func buildExpr(format: Format) -> ExprSyntax {
    let result = buildObjectLiteralExpr(format: format)
    return ExprSyntax(result)
  }
  /// Conformance to `ExpressibleAsObjectLiteralExpr`.
  public func createObjectLiteralExpr() -> ObjectLiteralExpr {
    return self
  }
  /// Conformance to `ExpressibleAsExprBuildable`.
  /// `ObjectLiteralExpr` may conform to `ExpressibleAsExprBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createExprBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createExprBuildable() -> ExprBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ExprBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct YieldExprListElement: SyntaxBuildable, ExpressibleAsYieldExprListElement {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeExpression: UnexpectedNodes?
    var expression: ExprBuildable
    var unexpectedBetweenExpressionAndComma: UnexpectedNodes?
    var comma: Token?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(YieldExprListElementSyntax)
  }
  private var data: Data
  /// Creates a `YieldExprListElement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeExpression: 
  ///   - expression: 
  ///   - unexpectedBetweenExpressionAndComma: 
  ///   - comma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndComma: ExpressibleAsUnexpectedNodes? = nil, comma: Token? = nil) {
    assert(comma == nil || comma!.text == #","#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeExpression: unexpectedBeforeExpression?.createUnexpectedNodes(), expression: expression.createExprBuildable(), unexpectedBetweenExpressionAndComma: unexpectedBetweenExpressionAndComma?.createUnexpectedNodes(), comma: comma))
  }
  public init(_ constructedNode: YieldExprListElementSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `YieldExprListElementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `YieldExprListElementSyntax`.
  func buildYieldExprListElement(format: Format) -> YieldExprListElementSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = YieldExprListElementSyntax(buildableData.unexpectedBeforeExpression?.buildUnexpectedNodes(format: format), expression: buildableData.expression.buildExpr(format: format), buildableData.unexpectedBetweenExpressionAndComma?.buildUnexpectedNodes(format: format), comma: buildableData.comma?.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildYieldExprListElement(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsYieldExprListElement`.
  public func createYieldExprListElement() -> YieldExprListElement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `YieldExprListElement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct TypeInitializerClause: SyntaxBuildable, ExpressibleAsTypeInitializerClause {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeEqual: UnexpectedNodes?
    var equal: Token
    var unexpectedBetweenEqualAndValue: UnexpectedNodes?
    var value: TypeBuildable
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(TypeInitializerClauseSyntax)
  }
  private var data: Data
  /// Creates a `TypeInitializerClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeEqual: 
  ///   - equal: 
  ///   - unexpectedBetweenEqualAndValue: 
  ///   - value: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeEqual: ExpressibleAsUnexpectedNodes? = nil, equal: Token = Token.`equal`, unexpectedBetweenEqualAndValue: ExpressibleAsUnexpectedNodes? = nil, value: ExpressibleAsTypeBuildable) {
    assert(equal.text == #"="#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeEqual: unexpectedBeforeEqual?.createUnexpectedNodes(), equal: equal, unexpectedBetweenEqualAndValue: unexpectedBetweenEqualAndValue?.createUnexpectedNodes(), value: value.createTypeBuildable()))
  }
  public init(_ constructedNode: TypeInitializerClauseSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `TypeInitializerClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TypeInitializerClauseSyntax`.
  func buildTypeInitializerClause(format: Format) -> TypeInitializerClauseSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = TypeInitializerClauseSyntax(buildableData.unexpectedBeforeEqual?.buildUnexpectedNodes(format: format), equal: buildableData.equal.buildToken(format: format), buildableData.unexpectedBetweenEqualAndValue?.buildUnexpectedNodes(format: format), value: buildableData.value.buildType(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildTypeInitializerClause(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsTypeInitializerClause`.
  public func createTypeInitializerClause() -> TypeInitializerClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeInitializerClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct TypealiasDecl: DeclBuildable, ExpressibleAsTypealiasDecl {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeAttributes: UnexpectedNodes?
    var attributes: AttributeList?
    var unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
    var modifiers: ModifierList?
    var unexpectedBetweenModifiersAndTypealiasKeyword: UnexpectedNodes?
    var typealiasKeyword: Token
    var unexpectedBetweenTypealiasKeywordAndIdentifier: UnexpectedNodes?
    var identifier: Token
    var unexpectedBetweenIdentifierAndGenericParameterClause: UnexpectedNodes?
    var genericParameterClause: GenericParameterClause?
    var unexpectedBetweenGenericParameterClauseAndInitializer: UnexpectedNodes?
    var initializer: TypeInitializerClause
    var unexpectedBetweenInitializerAndGenericWhereClause: UnexpectedNodes?
    var genericWhereClause: GenericWhereClause?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(TypealiasDeclSyntax)
  }
  private var data: Data
  /// Creates a `TypealiasDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndTypealiasKeyword: 
  ///   - typealiasKeyword: 
  ///   - unexpectedBetweenTypealiasKeywordAndIdentifier: 
  ///   - identifier: 
  ///   - unexpectedBetweenIdentifierAndGenericParameterClause: 
  ///   - genericParameterClause: 
  ///   - unexpectedBetweenGenericParameterClauseAndInitializer: 
  ///   - initializer: 
  ///   - unexpectedBetweenInitializerAndGenericWhereClause: 
  ///   - genericWhereClause: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndTypealiasKeyword: ExpressibleAsUnexpectedNodes? = nil, typealiasKeyword: Token = Token.`typealias`, unexpectedBetweenTypealiasKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndInitializer: ExpressibleAsUnexpectedNodes? = nil, initializer: ExpressibleAsTypeInitializerClause, unexpectedBetweenInitializerAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil) {
    assert(typealiasKeyword.text == #"typealias"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes?.createUnexpectedNodes(), attributes: attributes?.createAttributeList(), unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes(), modifiers: modifiers?.createModifierList(), unexpectedBetweenModifiersAndTypealiasKeyword: unexpectedBetweenModifiersAndTypealiasKeyword?.createUnexpectedNodes(), typealiasKeyword: typealiasKeyword, unexpectedBetweenTypealiasKeywordAndIdentifier: unexpectedBetweenTypealiasKeywordAndIdentifier?.createUnexpectedNodes(), identifier: identifier, unexpectedBetweenIdentifierAndGenericParameterClause: unexpectedBetweenIdentifierAndGenericParameterClause?.createUnexpectedNodes(), genericParameterClause: genericParameterClause?.createGenericParameterClause(), unexpectedBetweenGenericParameterClauseAndInitializer: unexpectedBetweenGenericParameterClauseAndInitializer?.createUnexpectedNodes(), initializer: initializer.createTypeInitializerClause(), unexpectedBetweenInitializerAndGenericWhereClause: unexpectedBetweenInitializerAndGenericWhereClause?.createUnexpectedNodes(), genericWhereClause: genericWhereClause?.createGenericWhereClause()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndTypealiasKeyword: ExpressibleAsUnexpectedNodes? = nil, typealiasKeyword: Token = Token.`typealias`, unexpectedBetweenTypealiasKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: String, unexpectedBetweenIdentifierAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndInitializer: ExpressibleAsUnexpectedNodes? = nil, initializer: ExpressibleAsTypeInitializerClause, unexpectedBetweenInitializerAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndTypealiasKeyword: unexpectedBetweenModifiersAndTypealiasKeyword, typealiasKeyword: typealiasKeyword, unexpectedBetweenTypealiasKeywordAndIdentifier: unexpectedBetweenTypealiasKeywordAndIdentifier, identifier: Token.`identifier`(identifier), unexpectedBetweenIdentifierAndGenericParameterClause: unexpectedBetweenIdentifierAndGenericParameterClause, genericParameterClause: genericParameterClause, unexpectedBetweenGenericParameterClauseAndInitializer: unexpectedBetweenGenericParameterClauseAndInitializer, initializer: initializer, unexpectedBetweenInitializerAndGenericWhereClause: unexpectedBetweenInitializerAndGenericWhereClause, genericWhereClause: genericWhereClause)
  }
  public init(_ constructedNode: TypealiasDeclSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `TypealiasDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TypealiasDeclSyntax`.
  func buildTypealiasDecl(format: Format) -> TypealiasDeclSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = TypealiasDeclSyntax(buildableData.unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: buildableData.attributes?.buildAttributeList(format: format), buildableData.unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format), modifiers: buildableData.modifiers?.buildModifierList(format: format), buildableData.unexpectedBetweenModifiersAndTypealiasKeyword?.buildUnexpectedNodes(format: format), typealiasKeyword: buildableData.typealiasKeyword.buildToken(format: format), buildableData.unexpectedBetweenTypealiasKeywordAndIdentifier?.buildUnexpectedNodes(format: format), identifier: buildableData.identifier.buildToken(format: format), buildableData.unexpectedBetweenIdentifierAndGenericParameterClause?.buildUnexpectedNodes(format: format), genericParameterClause: buildableData.genericParameterClause?.buildGenericParameterClause(format: format), buildableData.unexpectedBetweenGenericParameterClauseAndInitializer?.buildUnexpectedNodes(format: format), initializer: buildableData.initializer.buildTypeInitializerClause(format: format), buildableData.unexpectedBetweenInitializerAndGenericWhereClause?.buildUnexpectedNodes(format: format), genericWhereClause: buildableData.genericWhereClause?.buildGenericWhereClause(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildTypealiasDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsTypealiasDecl`.
  public func createTypealiasDecl() -> TypealiasDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `TypealiasDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct AssociatedtypeDecl: DeclBuildable, ExpressibleAsAssociatedtypeDecl {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeAttributes: UnexpectedNodes?
    var attributes: AttributeList?
    var unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
    var modifiers: ModifierList?
    var unexpectedBetweenModifiersAndAssociatedtypeKeyword: UnexpectedNodes?
    var associatedtypeKeyword: Token
    var unexpectedBetweenAssociatedtypeKeywordAndIdentifier: UnexpectedNodes?
    var identifier: Token
    var unexpectedBetweenIdentifierAndInheritanceClause: UnexpectedNodes?
    var inheritanceClause: TypeInheritanceClause?
    var unexpectedBetweenInheritanceClauseAndInitializer: UnexpectedNodes?
    var initializer: TypeInitializerClause?
    var unexpectedBetweenInitializerAndGenericWhereClause: UnexpectedNodes?
    var genericWhereClause: GenericWhereClause?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(AssociatedtypeDeclSyntax)
  }
  private var data: Data
  /// Creates a `AssociatedtypeDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndAssociatedtypeKeyword: 
  ///   - associatedtypeKeyword: 
  ///   - unexpectedBetweenAssociatedtypeKeywordAndIdentifier: 
  ///   - identifier: 
  ///   - unexpectedBetweenIdentifierAndInheritanceClause: 
  ///   - inheritanceClause: 
  ///   - unexpectedBetweenInheritanceClauseAndInitializer: 
  ///   - initializer: 
  ///   - unexpectedBetweenInitializerAndGenericWhereClause: 
  ///   - genericWhereClause: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndAssociatedtypeKeyword: ExpressibleAsUnexpectedNodes? = nil, associatedtypeKeyword: Token = Token.`associatedtype`, unexpectedBetweenAssociatedtypeKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndInitializer: ExpressibleAsUnexpectedNodes? = nil, initializer: ExpressibleAsTypeInitializerClause? = nil, unexpectedBetweenInitializerAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil) {
    assert(associatedtypeKeyword.text == #"associatedtype"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes?.createUnexpectedNodes(), attributes: attributes?.createAttributeList(), unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes(), modifiers: modifiers?.createModifierList(), unexpectedBetweenModifiersAndAssociatedtypeKeyword: unexpectedBetweenModifiersAndAssociatedtypeKeyword?.createUnexpectedNodes(), associatedtypeKeyword: associatedtypeKeyword, unexpectedBetweenAssociatedtypeKeywordAndIdentifier: unexpectedBetweenAssociatedtypeKeywordAndIdentifier?.createUnexpectedNodes(), identifier: identifier, unexpectedBetweenIdentifierAndInheritanceClause: unexpectedBetweenIdentifierAndInheritanceClause?.createUnexpectedNodes(), inheritanceClause: inheritanceClause?.createTypeInheritanceClause(), unexpectedBetweenInheritanceClauseAndInitializer: unexpectedBetweenInheritanceClauseAndInitializer?.createUnexpectedNodes(), initializer: initializer?.createTypeInitializerClause(), unexpectedBetweenInitializerAndGenericWhereClause: unexpectedBetweenInitializerAndGenericWhereClause?.createUnexpectedNodes(), genericWhereClause: genericWhereClause?.createGenericWhereClause()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndAssociatedtypeKeyword: ExpressibleAsUnexpectedNodes? = nil, associatedtypeKeyword: Token = Token.`associatedtype`, unexpectedBetweenAssociatedtypeKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: String, unexpectedBetweenIdentifierAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndInitializer: ExpressibleAsUnexpectedNodes? = nil, initializer: ExpressibleAsTypeInitializerClause? = nil, unexpectedBetweenInitializerAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndAssociatedtypeKeyword: unexpectedBetweenModifiersAndAssociatedtypeKeyword, associatedtypeKeyword: associatedtypeKeyword, unexpectedBetweenAssociatedtypeKeywordAndIdentifier: unexpectedBetweenAssociatedtypeKeywordAndIdentifier, identifier: Token.`identifier`(identifier), unexpectedBetweenIdentifierAndInheritanceClause: unexpectedBetweenIdentifierAndInheritanceClause, inheritanceClause: inheritanceClause, unexpectedBetweenInheritanceClauseAndInitializer: unexpectedBetweenInheritanceClauseAndInitializer, initializer: initializer, unexpectedBetweenInitializerAndGenericWhereClause: unexpectedBetweenInitializerAndGenericWhereClause, genericWhereClause: genericWhereClause)
  }
  public init(_ constructedNode: AssociatedtypeDeclSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `AssociatedtypeDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AssociatedtypeDeclSyntax`.
  func buildAssociatedtypeDecl(format: Format) -> AssociatedtypeDeclSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = AssociatedtypeDeclSyntax(buildableData.unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: buildableData.attributes?.buildAttributeList(format: format), buildableData.unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format), modifiers: buildableData.modifiers?.buildModifierList(format: format), buildableData.unexpectedBetweenModifiersAndAssociatedtypeKeyword?.buildUnexpectedNodes(format: format), associatedtypeKeyword: buildableData.associatedtypeKeyword.buildToken(format: format), buildableData.unexpectedBetweenAssociatedtypeKeywordAndIdentifier?.buildUnexpectedNodes(format: format), identifier: buildableData.identifier.buildToken(format: format), buildableData.unexpectedBetweenIdentifierAndInheritanceClause?.buildUnexpectedNodes(format: format), inheritanceClause: buildableData.inheritanceClause?.buildTypeInheritanceClause(format: format), buildableData.unexpectedBetweenInheritanceClauseAndInitializer?.buildUnexpectedNodes(format: format), initializer: buildableData.initializer?.buildTypeInitializerClause(format: format), buildableData.unexpectedBetweenInitializerAndGenericWhereClause?.buildUnexpectedNodes(format: format), genericWhereClause: buildableData.genericWhereClause?.buildGenericWhereClause(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildAssociatedtypeDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsAssociatedtypeDecl`.
  public func createAssociatedtypeDecl() -> AssociatedtypeDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `AssociatedtypeDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct ParameterClause: SyntaxBuildable, ExpressibleAsParameterClause {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeLeftParen: UnexpectedNodes?
    var leftParen: Token
    var unexpectedBetweenLeftParenAndParameterList: UnexpectedNodes?
    var parameterList: FunctionParameterList
    var unexpectedBetweenParameterListAndRightParen: UnexpectedNodes?
    var rightParen: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ParameterClauseSyntax)
  }
  private var data: Data
  /// Creates a `ParameterClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndParameterList: 
  ///   - parameterList: 
  ///   - unexpectedBetweenParameterListAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndParameterList: ExpressibleAsUnexpectedNodes? = nil, parameterList: ExpressibleAsFunctionParameterList, unexpectedBetweenParameterListAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    assert(leftParen.text == #"("#)
    assert(rightParen.text == #")"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeLeftParen: unexpectedBeforeLeftParen?.createUnexpectedNodes(), leftParen: leftParen, unexpectedBetweenLeftParenAndParameterList: unexpectedBetweenLeftParenAndParameterList?.createUnexpectedNodes(), parameterList: parameterList.createFunctionParameterList(), unexpectedBetweenParameterListAndRightParen: unexpectedBetweenParameterListAndRightParen?.createUnexpectedNodes(), rightParen: rightParen))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndParameterList: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenParameterListAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`, @FunctionParameterListBuilder parameterListBuilder: () -> ExpressibleAsFunctionParameterList =  {
    FunctionParameterList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftParen: unexpectedBeforeLeftParen, leftParen: leftParen, unexpectedBetweenLeftParenAndParameterList: unexpectedBetweenLeftParenAndParameterList, parameterList: parameterListBuilder(), unexpectedBetweenParameterListAndRightParen: unexpectedBetweenParameterListAndRightParen, rightParen: rightParen)
  }
  public init(_ constructedNode: ParameterClauseSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ParameterClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ParameterClauseSyntax`.
  func buildParameterClause(format: Format) -> ParameterClauseSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ParameterClauseSyntax(buildableData.unexpectedBeforeLeftParen?.buildUnexpectedNodes(format: format), leftParen: buildableData.leftParen.buildToken(format: format), buildableData.unexpectedBetweenLeftParenAndParameterList?.buildUnexpectedNodes(format: format), parameterList: buildableData.parameterList.buildFunctionParameterList(format: format), buildableData.unexpectedBetweenParameterListAndRightParen?.buildUnexpectedNodes(format: format), rightParen: buildableData.rightParen.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildParameterClause(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsParameterClause`.
  public func createParameterClause() -> ParameterClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ParameterClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct ReturnClause: SyntaxBuildable, ExpressibleAsReturnClause {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeArrow: UnexpectedNodes?
    var arrow: Token
    var unexpectedBetweenArrowAndReturnType: UnexpectedNodes?
    var returnType: TypeBuildable
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ReturnClauseSyntax)
  }
  private var data: Data
  /// Creates a `ReturnClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeArrow: 
  ///   - arrow: 
  ///   - unexpectedBetweenArrowAndReturnType: 
  ///   - returnType: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeArrow: ExpressibleAsUnexpectedNodes? = nil, arrow: Token = Token.`arrow`, unexpectedBetweenArrowAndReturnType: ExpressibleAsUnexpectedNodes? = nil, returnType: ExpressibleAsTypeBuildable) {
    assert(arrow.text == #"->"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeArrow: unexpectedBeforeArrow?.createUnexpectedNodes(), arrow: arrow, unexpectedBetweenArrowAndReturnType: unexpectedBetweenArrowAndReturnType?.createUnexpectedNodes(), returnType: returnType.createTypeBuildable()))
  }
  public init(_ constructedNode: ReturnClauseSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ReturnClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ReturnClauseSyntax`.
  func buildReturnClause(format: Format) -> ReturnClauseSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ReturnClauseSyntax(buildableData.unexpectedBeforeArrow?.buildUnexpectedNodes(format: format), arrow: buildableData.arrow.buildToken(format: format), buildableData.unexpectedBetweenArrowAndReturnType?.buildUnexpectedNodes(format: format), returnType: buildableData.returnType.buildType(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildReturnClause(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsReturnClause`.
  public func createReturnClause() -> ReturnClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ReturnClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct FunctionSignature: SyntaxBuildable, ExpressibleAsFunctionSignature {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeInput: UnexpectedNodes?
    var input: ParameterClause
    var unexpectedBetweenInputAndAsyncOrReasyncKeyword: UnexpectedNodes?
    var asyncOrReasyncKeyword: Token?
    var unexpectedBetweenAsyncOrReasyncKeywordAndThrowsOrRethrowsKeyword: UnexpectedNodes?
    var throwsOrRethrowsKeyword: Token?
    var unexpectedBetweenThrowsOrRethrowsKeywordAndOutput: UnexpectedNodes?
    var output: ReturnClause?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(FunctionSignatureSyntax)
  }
  private var data: Data
  /// Creates a `FunctionSignature` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeInput: 
  ///   - input: 
  ///   - unexpectedBetweenInputAndAsyncOrReasyncKeyword: 
  ///   - asyncOrReasyncKeyword: 
  ///   - unexpectedBetweenAsyncOrReasyncKeywordAndThrowsOrRethrowsKeyword: 
  ///   - throwsOrRethrowsKeyword: 
  ///   - unexpectedBetweenThrowsOrRethrowsKeywordAndOutput: 
  ///   - output: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeInput: ExpressibleAsUnexpectedNodes? = nil, input: ExpressibleAsParameterClause, unexpectedBetweenInputAndAsyncOrReasyncKeyword: ExpressibleAsUnexpectedNodes? = nil, asyncOrReasyncKeyword: Token? = nil, unexpectedBetweenAsyncOrReasyncKeywordAndThrowsOrRethrowsKeyword: ExpressibleAsUnexpectedNodes? = nil, throwsOrRethrowsKeyword: Token? = nil, unexpectedBetweenThrowsOrRethrowsKeywordAndOutput: ExpressibleAsUnexpectedNodes? = nil, output: ExpressibleAsReturnClause? = nil) {
    assert(asyncOrReasyncKeyword == nil || asyncOrReasyncKeyword!.text == #"async"# || asyncOrReasyncKeyword!.text == #"reasync"#)
    assert(throwsOrRethrowsKeyword == nil || throwsOrRethrowsKeyword!.text == #"throws"# || throwsOrRethrowsKeyword!.text == #"rethrows"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeInput: unexpectedBeforeInput?.createUnexpectedNodes(), input: input.createParameterClause(), unexpectedBetweenInputAndAsyncOrReasyncKeyword: unexpectedBetweenInputAndAsyncOrReasyncKeyword?.createUnexpectedNodes(), asyncOrReasyncKeyword: asyncOrReasyncKeyword, unexpectedBetweenAsyncOrReasyncKeywordAndThrowsOrRethrowsKeyword: unexpectedBetweenAsyncOrReasyncKeywordAndThrowsOrRethrowsKeyword?.createUnexpectedNodes(), throwsOrRethrowsKeyword: throwsOrRethrowsKeyword, unexpectedBetweenThrowsOrRethrowsKeywordAndOutput: unexpectedBetweenThrowsOrRethrowsKeywordAndOutput?.createUnexpectedNodes(), output: output?.createReturnClause()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeInput: ExpressibleAsUnexpectedNodes? = nil, input: ExpressibleAsParameterClause, unexpectedBetweenInputAndAsyncOrReasyncKeyword: ExpressibleAsUnexpectedNodes? = nil, asyncOrReasyncKeyword: String?, unexpectedBetweenAsyncOrReasyncKeywordAndThrowsOrRethrowsKeyword: ExpressibleAsUnexpectedNodes? = nil, throwsOrRethrowsKeyword: Token? = nil, unexpectedBetweenThrowsOrRethrowsKeywordAndOutput: ExpressibleAsUnexpectedNodes? = nil, output: ExpressibleAsReturnClause? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeInput: unexpectedBeforeInput, input: input, unexpectedBetweenInputAndAsyncOrReasyncKeyword: unexpectedBetweenInputAndAsyncOrReasyncKeyword, asyncOrReasyncKeyword: asyncOrReasyncKeyword.map { Token.`contextualKeyword`($0) }, unexpectedBetweenAsyncOrReasyncKeywordAndThrowsOrRethrowsKeyword: unexpectedBetweenAsyncOrReasyncKeywordAndThrowsOrRethrowsKeyword, throwsOrRethrowsKeyword: throwsOrRethrowsKeyword, unexpectedBetweenThrowsOrRethrowsKeywordAndOutput: unexpectedBetweenThrowsOrRethrowsKeywordAndOutput, output: output)
  }
  public init(_ constructedNode: FunctionSignatureSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `FunctionSignatureSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `FunctionSignatureSyntax`.
  func buildFunctionSignature(format: Format) -> FunctionSignatureSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = FunctionSignatureSyntax(buildableData.unexpectedBeforeInput?.buildUnexpectedNodes(format: format), input: buildableData.input.buildParameterClause(format: format), buildableData.unexpectedBetweenInputAndAsyncOrReasyncKeyword?.buildUnexpectedNodes(format: format), asyncOrReasyncKeyword: buildableData.asyncOrReasyncKeyword?.buildToken(format: format), buildableData.unexpectedBetweenAsyncOrReasyncKeywordAndThrowsOrRethrowsKeyword?.buildUnexpectedNodes(format: format), throwsOrRethrowsKeyword: buildableData.throwsOrRethrowsKeyword?.buildToken(format: format), buildableData.unexpectedBetweenThrowsOrRethrowsKeywordAndOutput?.buildUnexpectedNodes(format: format), output: buildableData.output?.buildReturnClause(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildFunctionSignature(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsFunctionSignature`.
  public func createFunctionSignature() -> FunctionSignature {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `FunctionSignature` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct IfConfigClause: SyntaxBuildable, ExpressibleAsIfConfigClause {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforePoundKeyword: UnexpectedNodes?
    var poundKeyword: Token
    var unexpectedBetweenPoundKeywordAndCondition: UnexpectedNodes?
    var condition: ExprBuildable?
    var unexpectedBetweenConditionAndElements: UnexpectedNodes?
    var elements: SyntaxBuildable
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(IfConfigClauseSyntax)
  }
  private var data: Data
  /// Creates a `IfConfigClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundKeyword: 
  ///   - poundKeyword: 
  ///   - unexpectedBetweenPoundKeywordAndCondition: 
  ///   - condition: 
  ///   - unexpectedBetweenConditionAndElements: 
  ///   - elements: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePoundKeyword: ExpressibleAsUnexpectedNodes? = nil, poundKeyword: Token, unexpectedBetweenPoundKeywordAndCondition: ExpressibleAsUnexpectedNodes? = nil, condition: ExpressibleAsExprBuildable? = nil, unexpectedBetweenConditionAndElements: ExpressibleAsUnexpectedNodes? = nil, elements: ExpressibleAsSyntaxBuildable) {
    assert(poundKeyword.text == #"#if"# || poundKeyword.text == #"#elseif"# || poundKeyword.text == #"#else"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforePoundKeyword: unexpectedBeforePoundKeyword?.createUnexpectedNodes(), poundKeyword: poundKeyword, unexpectedBetweenPoundKeywordAndCondition: unexpectedBetweenPoundKeywordAndCondition?.createUnexpectedNodes(), condition: condition?.createExprBuildable(), unexpectedBetweenConditionAndElements: unexpectedBetweenConditionAndElements?.createUnexpectedNodes(), elements: elements.createSyntaxBuildable()))
  }
  public init(_ constructedNode: IfConfigClauseSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `IfConfigClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `IfConfigClauseSyntax`.
  func buildIfConfigClause(format: Format) -> IfConfigClauseSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = IfConfigClauseSyntax(buildableData.unexpectedBeforePoundKeyword?.buildUnexpectedNodes(format: format), poundKeyword: buildableData.poundKeyword.buildToken(format: format), buildableData.unexpectedBetweenPoundKeywordAndCondition?.buildUnexpectedNodes(format: format), condition: buildableData.condition?.buildExpr(format: format), buildableData.unexpectedBetweenConditionAndElements?.buildUnexpectedNodes(format: format), elements: buildableData.elements.buildSyntax(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildIfConfigClause(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsIfConfigClause`.
  public func createIfConfigClause() -> IfConfigClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `IfConfigClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct IfConfigDecl: DeclBuildable, ExpressibleAsIfConfigDecl {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeClauses: UnexpectedNodes?
    var clauses: IfConfigClauseList
    var unexpectedBetweenClausesAndPoundEndif: UnexpectedNodes?
    var poundEndif: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(IfConfigDeclSyntax)
  }
  private var data: Data
  /// Creates a `IfConfigDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeClauses: 
  ///   - clauses: 
  ///   - unexpectedBetweenClausesAndPoundEndif: 
  ///   - poundEndif: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeClauses: ExpressibleAsUnexpectedNodes? = nil, clauses: ExpressibleAsIfConfigClauseList, unexpectedBetweenClausesAndPoundEndif: ExpressibleAsUnexpectedNodes? = nil, poundEndif: Token = Token.`poundEndif`) {
    assert(poundEndif.text == #"#endif"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeClauses: unexpectedBeforeClauses?.createUnexpectedNodes(), clauses: clauses.createIfConfigClauseList(), unexpectedBetweenClausesAndPoundEndif: unexpectedBetweenClausesAndPoundEndif?.createUnexpectedNodes(), poundEndif: poundEndif))
  }
  public init(_ constructedNode: IfConfigDeclSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `IfConfigDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `IfConfigDeclSyntax`.
  func buildIfConfigDecl(format: Format) -> IfConfigDeclSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = IfConfigDeclSyntax(buildableData.unexpectedBeforeClauses?.buildUnexpectedNodes(format: format), clauses: buildableData.clauses.buildIfConfigClauseList(format: format), buildableData.unexpectedBetweenClausesAndPoundEndif?.buildUnexpectedNodes(format: format), poundEndif: buildableData.poundEndif.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildIfConfigDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsIfConfigDecl`.
  public func createIfConfigDecl() -> IfConfigDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `IfConfigDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct PoundErrorDecl: DeclBuildable, ExpressibleAsPoundErrorDecl {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforePoundError: UnexpectedNodes?
    var poundError: Token
    var unexpectedBetweenPoundErrorAndLeftParen: UnexpectedNodes?
    var leftParen: Token
    var unexpectedBetweenLeftParenAndMessage: UnexpectedNodes?
    var message: StringLiteralExpr
    var unexpectedBetweenMessageAndRightParen: UnexpectedNodes?
    var rightParen: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(PoundErrorDeclSyntax)
  }
  private var data: Data
  /// Creates a `PoundErrorDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundError: 
  ///   - poundError: 
  ///   - unexpectedBetweenPoundErrorAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndMessage: 
  ///   - message: 
  ///   - unexpectedBetweenMessageAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePoundError: ExpressibleAsUnexpectedNodes? = nil, poundError: Token = Token.`poundError`, unexpectedBetweenPoundErrorAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndMessage: ExpressibleAsUnexpectedNodes? = nil, message: ExpressibleAsStringLiteralExpr, unexpectedBetweenMessageAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    assert(poundError.text == #"#error"#)
    assert(leftParen.text == #"("#)
    assert(rightParen.text == #")"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforePoundError: unexpectedBeforePoundError?.createUnexpectedNodes(), poundError: poundError, unexpectedBetweenPoundErrorAndLeftParen: unexpectedBetweenPoundErrorAndLeftParen?.createUnexpectedNodes(), leftParen: leftParen, unexpectedBetweenLeftParenAndMessage: unexpectedBetweenLeftParenAndMessage?.createUnexpectedNodes(), message: message.createStringLiteralExpr(), unexpectedBetweenMessageAndRightParen: unexpectedBetweenMessageAndRightParen?.createUnexpectedNodes(), rightParen: rightParen))
  }
  public init(_ constructedNode: PoundErrorDeclSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `PoundErrorDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PoundErrorDeclSyntax`.
  func buildPoundErrorDecl(format: Format) -> PoundErrorDeclSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = PoundErrorDeclSyntax(buildableData.unexpectedBeforePoundError?.buildUnexpectedNodes(format: format), poundError: buildableData.poundError.buildToken(format: format), buildableData.unexpectedBetweenPoundErrorAndLeftParen?.buildUnexpectedNodes(format: format), leftParen: buildableData.leftParen.buildToken(format: format), buildableData.unexpectedBetweenLeftParenAndMessage?.buildUnexpectedNodes(format: format), message: buildableData.message.buildStringLiteralExpr(format: format), buildableData.unexpectedBetweenMessageAndRightParen?.buildUnexpectedNodes(format: format), rightParen: buildableData.rightParen.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildPoundErrorDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsPoundErrorDecl`.
  public func createPoundErrorDecl() -> PoundErrorDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `PoundErrorDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct PoundWarningDecl: DeclBuildable, ExpressibleAsPoundWarningDecl {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforePoundWarning: UnexpectedNodes?
    var poundWarning: Token
    var unexpectedBetweenPoundWarningAndLeftParen: UnexpectedNodes?
    var leftParen: Token
    var unexpectedBetweenLeftParenAndMessage: UnexpectedNodes?
    var message: StringLiteralExpr
    var unexpectedBetweenMessageAndRightParen: UnexpectedNodes?
    var rightParen: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(PoundWarningDeclSyntax)
  }
  private var data: Data
  /// Creates a `PoundWarningDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundWarning: 
  ///   - poundWarning: 
  ///   - unexpectedBetweenPoundWarningAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndMessage: 
  ///   - message: 
  ///   - unexpectedBetweenMessageAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePoundWarning: ExpressibleAsUnexpectedNodes? = nil, poundWarning: Token = Token.`poundWarning`, unexpectedBetweenPoundWarningAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndMessage: ExpressibleAsUnexpectedNodes? = nil, message: ExpressibleAsStringLiteralExpr, unexpectedBetweenMessageAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    assert(poundWarning.text == #"#warning"#)
    assert(leftParen.text == #"("#)
    assert(rightParen.text == #")"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforePoundWarning: unexpectedBeforePoundWarning?.createUnexpectedNodes(), poundWarning: poundWarning, unexpectedBetweenPoundWarningAndLeftParen: unexpectedBetweenPoundWarningAndLeftParen?.createUnexpectedNodes(), leftParen: leftParen, unexpectedBetweenLeftParenAndMessage: unexpectedBetweenLeftParenAndMessage?.createUnexpectedNodes(), message: message.createStringLiteralExpr(), unexpectedBetweenMessageAndRightParen: unexpectedBetweenMessageAndRightParen?.createUnexpectedNodes(), rightParen: rightParen))
  }
  public init(_ constructedNode: PoundWarningDeclSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `PoundWarningDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PoundWarningDeclSyntax`.
  func buildPoundWarningDecl(format: Format) -> PoundWarningDeclSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = PoundWarningDeclSyntax(buildableData.unexpectedBeforePoundWarning?.buildUnexpectedNodes(format: format), poundWarning: buildableData.poundWarning.buildToken(format: format), buildableData.unexpectedBetweenPoundWarningAndLeftParen?.buildUnexpectedNodes(format: format), leftParen: buildableData.leftParen.buildToken(format: format), buildableData.unexpectedBetweenLeftParenAndMessage?.buildUnexpectedNodes(format: format), message: buildableData.message.buildStringLiteralExpr(format: format), buildableData.unexpectedBetweenMessageAndRightParen?.buildUnexpectedNodes(format: format), rightParen: buildableData.rightParen.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildPoundWarningDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsPoundWarningDecl`.
  public func createPoundWarningDecl() -> PoundWarningDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `PoundWarningDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct PoundSourceLocation: DeclBuildable, ExpressibleAsPoundSourceLocation {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforePoundSourceLocation: UnexpectedNodes?
    var poundSourceLocation: Token
    var unexpectedBetweenPoundSourceLocationAndLeftParen: UnexpectedNodes?
    var leftParen: Token
    var unexpectedBetweenLeftParenAndArgs: UnexpectedNodes?
    var args: PoundSourceLocationArgs?
    var unexpectedBetweenArgsAndRightParen: UnexpectedNodes?
    var rightParen: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(PoundSourceLocationSyntax)
  }
  private var data: Data
  /// Creates a `PoundSourceLocation` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundSourceLocation: 
  ///   - poundSourceLocation: 
  ///   - unexpectedBetweenPoundSourceLocationAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndArgs: 
  ///   - args: 
  ///   - unexpectedBetweenArgsAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePoundSourceLocation: ExpressibleAsUnexpectedNodes? = nil, poundSourceLocation: Token = Token.`poundSourceLocation`, unexpectedBetweenPoundSourceLocationAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndArgs: ExpressibleAsUnexpectedNodes? = nil, args: ExpressibleAsPoundSourceLocationArgs? = nil, unexpectedBetweenArgsAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    assert(poundSourceLocation.text == #"#sourceLocation"#)
    assert(leftParen.text == #"("#)
    assert(rightParen.text == #")"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforePoundSourceLocation: unexpectedBeforePoundSourceLocation?.createUnexpectedNodes(), poundSourceLocation: poundSourceLocation, unexpectedBetweenPoundSourceLocationAndLeftParen: unexpectedBetweenPoundSourceLocationAndLeftParen?.createUnexpectedNodes(), leftParen: leftParen, unexpectedBetweenLeftParenAndArgs: unexpectedBetweenLeftParenAndArgs?.createUnexpectedNodes(), args: args?.createPoundSourceLocationArgs(), unexpectedBetweenArgsAndRightParen: unexpectedBetweenArgsAndRightParen?.createUnexpectedNodes(), rightParen: rightParen))
  }
  public init(_ constructedNode: PoundSourceLocationSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `PoundSourceLocationSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PoundSourceLocationSyntax`.
  func buildPoundSourceLocation(format: Format) -> PoundSourceLocationSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = PoundSourceLocationSyntax(buildableData.unexpectedBeforePoundSourceLocation?.buildUnexpectedNodes(format: format), poundSourceLocation: buildableData.poundSourceLocation.buildToken(format: format), buildableData.unexpectedBetweenPoundSourceLocationAndLeftParen?.buildUnexpectedNodes(format: format), leftParen: buildableData.leftParen.buildToken(format: format), buildableData.unexpectedBetweenLeftParenAndArgs?.buildUnexpectedNodes(format: format), args: buildableData.args?.buildPoundSourceLocationArgs(format: format), buildableData.unexpectedBetweenArgsAndRightParen?.buildUnexpectedNodes(format: format), rightParen: buildableData.rightParen.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildPoundSourceLocation(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsPoundSourceLocation`.
  public func createPoundSourceLocation() -> PoundSourceLocation {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `PoundSourceLocation` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct PoundSourceLocationArgs: SyntaxBuildable, ExpressibleAsPoundSourceLocationArgs {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeFileArgLabel: UnexpectedNodes?
    var fileArgLabel: Token
    var unexpectedBetweenFileArgLabelAndFileArgColon: UnexpectedNodes?
    var fileArgColon: Token
    var unexpectedBetweenFileArgColonAndFileName: UnexpectedNodes?
    var fileName: Token
    var unexpectedBetweenFileNameAndComma: UnexpectedNodes?
    var comma: Token
    var unexpectedBetweenCommaAndLineArgLabel: UnexpectedNodes?
    var lineArgLabel: Token
    var unexpectedBetweenLineArgLabelAndLineArgColon: UnexpectedNodes?
    var lineArgColon: Token
    var unexpectedBetweenLineArgColonAndLineNumber: UnexpectedNodes?
    var lineNumber: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(PoundSourceLocationArgsSyntax)
  }
  private var data: Data
  /// Creates a `PoundSourceLocationArgs` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeFileArgLabel: 
  ///   - fileArgLabel: 
  ///   - unexpectedBetweenFileArgLabelAndFileArgColon: 
  ///   - fileArgColon: 
  ///   - unexpectedBetweenFileArgColonAndFileName: 
  ///   - fileName: 
  ///   - unexpectedBetweenFileNameAndComma: 
  ///   - comma: 
  ///   - unexpectedBetweenCommaAndLineArgLabel: 
  ///   - lineArgLabel: 
  ///   - unexpectedBetweenLineArgLabelAndLineArgColon: 
  ///   - lineArgColon: 
  ///   - unexpectedBetweenLineArgColonAndLineNumber: 
  ///   - lineNumber: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeFileArgLabel: ExpressibleAsUnexpectedNodes? = nil, fileArgLabel: Token, unexpectedBetweenFileArgLabelAndFileArgColon: ExpressibleAsUnexpectedNodes? = nil, fileArgColon: Token = Token.`colon`, unexpectedBetweenFileArgColonAndFileName: ExpressibleAsUnexpectedNodes? = nil, fileName: Token, unexpectedBetweenFileNameAndComma: ExpressibleAsUnexpectedNodes? = nil, comma: Token = Token.`comma`, unexpectedBetweenCommaAndLineArgLabel: ExpressibleAsUnexpectedNodes? = nil, lineArgLabel: Token, unexpectedBetweenLineArgLabelAndLineArgColon: ExpressibleAsUnexpectedNodes? = nil, lineArgColon: Token = Token.`colon`, unexpectedBetweenLineArgColonAndLineNumber: ExpressibleAsUnexpectedNodes? = nil, lineNumber: Token) {
    assert(fileArgLabel.text == #"file"#)
    assert(fileArgColon.text == #":"#)
    assert(comma.text == #","#)
    assert(lineArgLabel.text == #"line"#)
    assert(lineArgColon.text == #":"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeFileArgLabel: unexpectedBeforeFileArgLabel?.createUnexpectedNodes(), fileArgLabel: fileArgLabel, unexpectedBetweenFileArgLabelAndFileArgColon: unexpectedBetweenFileArgLabelAndFileArgColon?.createUnexpectedNodes(), fileArgColon: fileArgColon, unexpectedBetweenFileArgColonAndFileName: unexpectedBetweenFileArgColonAndFileName?.createUnexpectedNodes(), fileName: fileName, unexpectedBetweenFileNameAndComma: unexpectedBetweenFileNameAndComma?.createUnexpectedNodes(), comma: comma, unexpectedBetweenCommaAndLineArgLabel: unexpectedBetweenCommaAndLineArgLabel?.createUnexpectedNodes(), lineArgLabel: lineArgLabel, unexpectedBetweenLineArgLabelAndLineArgColon: unexpectedBetweenLineArgLabelAndLineArgColon?.createUnexpectedNodes(), lineArgColon: lineArgColon, unexpectedBetweenLineArgColonAndLineNumber: unexpectedBetweenLineArgColonAndLineNumber?.createUnexpectedNodes(), lineNumber: lineNumber))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeFileArgLabel: ExpressibleAsUnexpectedNodes? = nil, fileArgLabel: String, unexpectedBetweenFileArgLabelAndFileArgColon: ExpressibleAsUnexpectedNodes? = nil, fileArgColon: Token = Token.`colon`, unexpectedBetweenFileArgColonAndFileName: ExpressibleAsUnexpectedNodes? = nil, fileName: String, unexpectedBetweenFileNameAndComma: ExpressibleAsUnexpectedNodes? = nil, comma: Token = Token.`comma`, unexpectedBetweenCommaAndLineArgLabel: ExpressibleAsUnexpectedNodes? = nil, lineArgLabel: String, unexpectedBetweenLineArgLabelAndLineArgColon: ExpressibleAsUnexpectedNodes? = nil, lineArgColon: Token = Token.`colon`, unexpectedBetweenLineArgColonAndLineNumber: ExpressibleAsUnexpectedNodes? = nil, lineNumber: String) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeFileArgLabel: unexpectedBeforeFileArgLabel, fileArgLabel: Token.`identifier`(fileArgLabel), unexpectedBetweenFileArgLabelAndFileArgColon: unexpectedBetweenFileArgLabelAndFileArgColon, fileArgColon: fileArgColon, unexpectedBetweenFileArgColonAndFileName: unexpectedBetweenFileArgColonAndFileName, fileName: Token.`stringLiteral`(fileName), unexpectedBetweenFileNameAndComma: unexpectedBetweenFileNameAndComma, comma: comma, unexpectedBetweenCommaAndLineArgLabel: unexpectedBetweenCommaAndLineArgLabel, lineArgLabel: Token.`identifier`(lineArgLabel), unexpectedBetweenLineArgLabelAndLineArgColon: unexpectedBetweenLineArgLabelAndLineArgColon, lineArgColon: lineArgColon, unexpectedBetweenLineArgColonAndLineNumber: unexpectedBetweenLineArgColonAndLineNumber, lineNumber: Token.`integerLiteral`(lineNumber))
  }
  public init(_ constructedNode: PoundSourceLocationArgsSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `PoundSourceLocationArgsSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PoundSourceLocationArgsSyntax`.
  func buildPoundSourceLocationArgs(format: Format) -> PoundSourceLocationArgsSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = PoundSourceLocationArgsSyntax(buildableData.unexpectedBeforeFileArgLabel?.buildUnexpectedNodes(format: format), fileArgLabel: buildableData.fileArgLabel.buildToken(format: format), buildableData.unexpectedBetweenFileArgLabelAndFileArgColon?.buildUnexpectedNodes(format: format), fileArgColon: buildableData.fileArgColon.buildToken(format: format), buildableData.unexpectedBetweenFileArgColonAndFileName?.buildUnexpectedNodes(format: format), fileName: buildableData.fileName.buildToken(format: format), buildableData.unexpectedBetweenFileNameAndComma?.buildUnexpectedNodes(format: format), comma: buildableData.comma.buildToken(format: format), buildableData.unexpectedBetweenCommaAndLineArgLabel?.buildUnexpectedNodes(format: format), lineArgLabel: buildableData.lineArgLabel.buildToken(format: format), buildableData.unexpectedBetweenLineArgLabelAndLineArgColon?.buildUnexpectedNodes(format: format), lineArgColon: buildableData.lineArgColon.buildToken(format: format), buildableData.unexpectedBetweenLineArgColonAndLineNumber?.buildUnexpectedNodes(format: format), lineNumber: buildableData.lineNumber.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildPoundSourceLocationArgs(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsPoundSourceLocationArgs`.
  public func createPoundSourceLocationArgs() -> PoundSourceLocationArgs {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PoundSourceLocationArgs` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct DeclModifierDetail: SyntaxBuildable, ExpressibleAsDeclModifierDetail {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeLeftParen: UnexpectedNodes?
    var leftParen: Token
    var unexpectedBetweenLeftParenAndDetail: UnexpectedNodes?
    var detail: Token
    var unexpectedBetweenDetailAndRightParen: UnexpectedNodes?
    var rightParen: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(DeclModifierDetailSyntax)
  }
  private var data: Data
  /// Creates a `DeclModifierDetail` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndDetail: 
  ///   - detail: 
  ///   - unexpectedBetweenDetailAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndDetail: ExpressibleAsUnexpectedNodes? = nil, detail: Token, unexpectedBetweenDetailAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    assert(leftParen.text == #"("#)
    assert(rightParen.text == #")"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeLeftParen: unexpectedBeforeLeftParen?.createUnexpectedNodes(), leftParen: leftParen, unexpectedBetweenLeftParenAndDetail: unexpectedBetweenLeftParenAndDetail?.createUnexpectedNodes(), detail: detail, unexpectedBetweenDetailAndRightParen: unexpectedBetweenDetailAndRightParen?.createUnexpectedNodes(), rightParen: rightParen))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndDetail: ExpressibleAsUnexpectedNodes? = nil, detail: String, unexpectedBetweenDetailAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftParen: unexpectedBeforeLeftParen, leftParen: leftParen, unexpectedBetweenLeftParenAndDetail: unexpectedBetweenLeftParenAndDetail, detail: Token.`identifier`(detail), unexpectedBetweenDetailAndRightParen: unexpectedBetweenDetailAndRightParen, rightParen: rightParen)
  }
  public init(_ constructedNode: DeclModifierDetailSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `DeclModifierDetailSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DeclModifierDetailSyntax`.
  func buildDeclModifierDetail(format: Format) -> DeclModifierDetailSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = DeclModifierDetailSyntax(buildableData.unexpectedBeforeLeftParen?.buildUnexpectedNodes(format: format), leftParen: buildableData.leftParen.buildToken(format: format), buildableData.unexpectedBetweenLeftParenAndDetail?.buildUnexpectedNodes(format: format), detail: buildableData.detail.buildToken(format: format), buildableData.unexpectedBetweenDetailAndRightParen?.buildUnexpectedNodes(format: format), rightParen: buildableData.rightParen.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildDeclModifierDetail(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsDeclModifierDetail`.
  public func createDeclModifierDetail() -> DeclModifierDetail {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclModifierDetail` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct DeclModifier: SyntaxBuildable, ExpressibleAsDeclModifier {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeName: UnexpectedNodes?
    var name: Token
    var unexpectedBetweenNameAndDetail: UnexpectedNodes?
    var detail: DeclModifierDetail?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(DeclModifierSyntax)
  }
  private var data: Data
  /// Creates a `DeclModifier` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndDetail: 
  ///   - detail: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndDetail: ExpressibleAsUnexpectedNodes? = nil, detail: ExpressibleAsDeclModifierDetail? = nil) {
    assert(name.text == #"class"# || name.text == #"convenience"# || name.text == #"dynamic"# || name.text == #"final"# || name.text == #"infix"# || name.text == #"lazy"# || name.text == #"optional"# || name.text == #"override"# || name.text == #"postfix"# || name.text == #"prefix"# || name.text == #"required"# || name.text == #"static"# || name.text == #"unowned"# || name.text == #"weak"# || name.text == #"private"# || name.text == #"fileprivate"# || name.text == #"internal"# || name.text == #"public"# || name.text == #"open"# || name.text == #"mutating"# || name.text == #"nonmutating"# || name.text == #"indirect"# || name.text == #"__consuming"# || name.text == #"actor"# || name.text == #"async"# || name.text == #"distributed"# || name.text == #"isolated"# || name.text == #"nonisolated"# || name.text == #"_const"# || name.text == #"_local"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeName: unexpectedBeforeName?.createUnexpectedNodes(), name: name, unexpectedBetweenNameAndDetail: unexpectedBetweenNameAndDetail?.createUnexpectedNodes(), detail: detail?.createDeclModifierDetail()))
  }
  public init(_ constructedNode: DeclModifierSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `DeclModifierSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DeclModifierSyntax`.
  func buildDeclModifier(format: Format) -> DeclModifierSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = DeclModifierSyntax(buildableData.unexpectedBeforeName?.buildUnexpectedNodes(format: format), name: buildableData.name.buildToken(format: format), buildableData.unexpectedBetweenNameAndDetail?.buildUnexpectedNodes(format: format), detail: buildableData.detail?.buildDeclModifierDetail(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildDeclModifier(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsDeclModifier`.
  public func createDeclModifier() -> DeclModifier {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclModifier` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct InheritedType: SyntaxBuildable, ExpressibleAsInheritedType, HasTrailingComma {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeTypeName: UnexpectedNodes?
    var typeName: TypeBuildable
    var unexpectedBetweenTypeNameAndTrailingComma: UnexpectedNodes?
    var trailingComma: Token?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(InheritedTypeSyntax)
  }
  private var data: Data
  var hasTrailingComma: Bool {
    switch data {
    case .buildable(let buildableData):
      return buildableData.trailingComma != nil
    case .constructed(let node):
      return node.trailingComma != nil
    }
  }
  /// Creates a `InheritedType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeTypeName: 
  ///   - typeName: 
  ///   - unexpectedBetweenTypeNameAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeTypeName: ExpressibleAsUnexpectedNodes? = nil, typeName: ExpressibleAsTypeBuildable, unexpectedBetweenTypeNameAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    assert(trailingComma == nil || trailingComma!.text == #","#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeTypeName: unexpectedBeforeTypeName?.createUnexpectedNodes(), typeName: typeName.createTypeBuildable(), unexpectedBetweenTypeNameAndTrailingComma: unexpectedBetweenTypeNameAndTrailingComma?.createUnexpectedNodes(), trailingComma: trailingComma))
  }
  public init(_ constructedNode: InheritedTypeSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `InheritedTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `InheritedTypeSyntax`.
  func buildInheritedType(format: Format) -> InheritedTypeSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = InheritedTypeSyntax(buildableData.unexpectedBeforeTypeName?.buildUnexpectedNodes(format: format), typeName: buildableData.typeName.buildType(format: format), buildableData.unexpectedBetweenTypeNameAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: buildableData.trailingComma?.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildInheritedType(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsInheritedType`.
  public func createInheritedType() -> InheritedType {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `InheritedType` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingComma = withComma ? .comma : nil
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withComma = node.withTrailingComma(withComma ? .commaToken() : nil)
      var result = self
      result.data = .constructed(withComma)
      return result
    }
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct TypeInheritanceClause: SyntaxBuildable, ExpressibleAsTypeInheritanceClause {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeColon: UnexpectedNodes?
    var colon: Token
    var unexpectedBetweenColonAndInheritedTypeCollection: UnexpectedNodes?
    var inheritedTypeCollection: InheritedTypeList
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(TypeInheritanceClauseSyntax)
  }
  private var data: Data
  /// Creates a `TypeInheritanceClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndInheritedTypeCollection: 
  ///   - inheritedTypeCollection: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndInheritedTypeCollection: ExpressibleAsUnexpectedNodes? = nil, inheritedTypeCollection: ExpressibleAsInheritedTypeList) {
    assert(colon.text == #":"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeColon: unexpectedBeforeColon?.createUnexpectedNodes(), colon: colon, unexpectedBetweenColonAndInheritedTypeCollection: unexpectedBetweenColonAndInheritedTypeCollection?.createUnexpectedNodes(), inheritedTypeCollection: inheritedTypeCollection.createInheritedTypeList()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndInheritedTypeCollection: ExpressibleAsUnexpectedNodes? = nil, @InheritedTypeListBuilder inheritedTypeCollectionBuilder: () -> ExpressibleAsInheritedTypeList =  {
    InheritedTypeList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeColon: unexpectedBeforeColon, colon: colon, unexpectedBetweenColonAndInheritedTypeCollection: unexpectedBetweenColonAndInheritedTypeCollection, inheritedTypeCollection: inheritedTypeCollectionBuilder())
  }
  public init(_ constructedNode: TypeInheritanceClauseSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `TypeInheritanceClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TypeInheritanceClauseSyntax`.
  func buildTypeInheritanceClause(format: Format) -> TypeInheritanceClauseSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = TypeInheritanceClauseSyntax(buildableData.unexpectedBeforeColon?.buildUnexpectedNodes(format: format), colon: buildableData.colon.buildToken(format: format), buildableData.unexpectedBetweenColonAndInheritedTypeCollection?.buildUnexpectedNodes(format: format), inheritedTypeCollection: buildableData.inheritedTypeCollection.buildInheritedTypeList(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildTypeInheritanceClause(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsTypeInheritanceClause`.
  public func createTypeInheritanceClause() -> TypeInheritanceClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeInheritanceClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct ClassDecl: DeclBuildable, ExpressibleAsClassDecl {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeAttributes: UnexpectedNodes?
    var attributes: AttributeList?
    var unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
    var modifiers: ModifierList?
    var unexpectedBetweenModifiersAndClassKeyword: UnexpectedNodes?
    var classKeyword: Token
    var unexpectedBetweenClassKeywordAndIdentifier: UnexpectedNodes?
    var identifier: Token
    var unexpectedBetweenIdentifierAndGenericParameterClause: UnexpectedNodes?
    var genericParameterClause: GenericParameterClause?
    var unexpectedBetweenGenericParameterClauseAndInheritanceClause: UnexpectedNodes?
    var inheritanceClause: TypeInheritanceClause?
    var unexpectedBetweenInheritanceClauseAndGenericWhereClause: UnexpectedNodes?
    var genericWhereClause: GenericWhereClause?
    var unexpectedBetweenGenericWhereClauseAndMembers: UnexpectedNodes?
    var members: MemberDeclBlock
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ClassDeclSyntax)
  }
  private var data: Data
  /// Creates a `ClassDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndClassKeyword: 
  ///   - classKeyword: 
  ///   - unexpectedBetweenClassKeywordAndIdentifier: 
  ///   - identifier: 
  ///   - unexpectedBetweenIdentifierAndGenericParameterClause: 
  ///   - genericParameterClause: 
  ///   - unexpectedBetweenGenericParameterClauseAndInheritanceClause: 
  ///   - inheritanceClause: 
  ///   - unexpectedBetweenInheritanceClauseAndGenericWhereClause: 
  ///   - genericWhereClause: 
  ///   - unexpectedBetweenGenericWhereClauseAndMembers: 
  ///   - members: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndClassKeyword: ExpressibleAsUnexpectedNodes? = nil, classKeyword: Token = Token.`class`, unexpectedBetweenClassKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndMembers: ExpressibleAsUnexpectedNodes? = nil, members: ExpressibleAsMemberDeclBlock) {
    assert(classKeyword.text == #"class"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes?.createUnexpectedNodes(), attributes: attributes?.createAttributeList(), unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes(), modifiers: modifiers?.createModifierList(), unexpectedBetweenModifiersAndClassKeyword: unexpectedBetweenModifiersAndClassKeyword?.createUnexpectedNodes(), classKeyword: classKeyword, unexpectedBetweenClassKeywordAndIdentifier: unexpectedBetweenClassKeywordAndIdentifier?.createUnexpectedNodes(), identifier: identifier, unexpectedBetweenIdentifierAndGenericParameterClause: unexpectedBetweenIdentifierAndGenericParameterClause?.createUnexpectedNodes(), genericParameterClause: genericParameterClause?.createGenericParameterClause(), unexpectedBetweenGenericParameterClauseAndInheritanceClause: unexpectedBetweenGenericParameterClauseAndInheritanceClause?.createUnexpectedNodes(), inheritanceClause: inheritanceClause?.createTypeInheritanceClause(), unexpectedBetweenInheritanceClauseAndGenericWhereClause: unexpectedBetweenInheritanceClauseAndGenericWhereClause?.createUnexpectedNodes(), genericWhereClause: genericWhereClause?.createGenericWhereClause(), unexpectedBetweenGenericWhereClauseAndMembers: unexpectedBetweenGenericWhereClauseAndMembers?.createUnexpectedNodes(), members: members.createMemberDeclBlock()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndClassKeyword: ExpressibleAsUnexpectedNodes? = nil, classKeyword: Token = Token.`class`, unexpectedBetweenClassKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: String, unexpectedBetweenIdentifierAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndMembers: ExpressibleAsUnexpectedNodes? = nil, @MemberDeclListBuilder membersBuilder: () -> ExpressibleAsMemberDeclList =  {
    MemberDeclList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndClassKeyword: unexpectedBetweenModifiersAndClassKeyword, classKeyword: classKeyword, unexpectedBetweenClassKeywordAndIdentifier: unexpectedBetweenClassKeywordAndIdentifier, identifier: Token.`identifier`(identifier), unexpectedBetweenIdentifierAndGenericParameterClause: unexpectedBetweenIdentifierAndGenericParameterClause, genericParameterClause: genericParameterClause, unexpectedBetweenGenericParameterClauseAndInheritanceClause: unexpectedBetweenGenericParameterClauseAndInheritanceClause, inheritanceClause: inheritanceClause, unexpectedBetweenInheritanceClauseAndGenericWhereClause: unexpectedBetweenInheritanceClauseAndGenericWhereClause, genericWhereClause: genericWhereClause, unexpectedBetweenGenericWhereClauseAndMembers: unexpectedBetweenGenericWhereClauseAndMembers, members: membersBuilder())
  }
  public init(_ constructedNode: ClassDeclSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ClassDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ClassDeclSyntax`.
  func buildClassDecl(format: Format) -> ClassDeclSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ClassDeclSyntax(buildableData.unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: buildableData.attributes?.buildAttributeList(format: format), buildableData.unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format), modifiers: buildableData.modifiers?.buildModifierList(format: format), buildableData.unexpectedBetweenModifiersAndClassKeyword?.buildUnexpectedNodes(format: format), classKeyword: buildableData.classKeyword.buildToken(format: format), buildableData.unexpectedBetweenClassKeywordAndIdentifier?.buildUnexpectedNodes(format: format), identifier: buildableData.identifier.buildToken(format: format), buildableData.unexpectedBetweenIdentifierAndGenericParameterClause?.buildUnexpectedNodes(format: format), genericParameterClause: buildableData.genericParameterClause?.buildGenericParameterClause(format: format), buildableData.unexpectedBetweenGenericParameterClauseAndInheritanceClause?.buildUnexpectedNodes(format: format), inheritanceClause: buildableData.inheritanceClause?.buildTypeInheritanceClause(format: format), buildableData.unexpectedBetweenInheritanceClauseAndGenericWhereClause?.buildUnexpectedNodes(format: format), genericWhereClause: buildableData.genericWhereClause?.buildGenericWhereClause(format: format), buildableData.unexpectedBetweenGenericWhereClauseAndMembers?.buildUnexpectedNodes(format: format), members: buildableData.members.buildMemberDeclBlock(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildClassDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsClassDecl`.
  public func createClassDecl() -> ClassDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `ClassDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct ActorDecl: DeclBuildable, ExpressibleAsActorDecl {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeAttributes: UnexpectedNodes?
    var attributes: AttributeList?
    var unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
    var modifiers: ModifierList?
    var unexpectedBetweenModifiersAndActorKeyword: UnexpectedNodes?
    var actorKeyword: Token
    var unexpectedBetweenActorKeywordAndIdentifier: UnexpectedNodes?
    var identifier: Token
    var unexpectedBetweenIdentifierAndGenericParameterClause: UnexpectedNodes?
    var genericParameterClause: GenericParameterClause?
    var unexpectedBetweenGenericParameterClauseAndInheritanceClause: UnexpectedNodes?
    var inheritanceClause: TypeInheritanceClause?
    var unexpectedBetweenInheritanceClauseAndGenericWhereClause: UnexpectedNodes?
    var genericWhereClause: GenericWhereClause?
    var unexpectedBetweenGenericWhereClauseAndMembers: UnexpectedNodes?
    var members: MemberDeclBlock
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ActorDeclSyntax)
  }
  private var data: Data
  /// Creates a `ActorDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndActorKeyword: 
  ///   - actorKeyword: 
  ///   - unexpectedBetweenActorKeywordAndIdentifier: 
  ///   - identifier: 
  ///   - unexpectedBetweenIdentifierAndGenericParameterClause: 
  ///   - genericParameterClause: 
  ///   - unexpectedBetweenGenericParameterClauseAndInheritanceClause: 
  ///   - inheritanceClause: 
  ///   - unexpectedBetweenInheritanceClauseAndGenericWhereClause: 
  ///   - genericWhereClause: 
  ///   - unexpectedBetweenGenericWhereClauseAndMembers: 
  ///   - members: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndActorKeyword: ExpressibleAsUnexpectedNodes? = nil, actorKeyword: Token, unexpectedBetweenActorKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndMembers: ExpressibleAsUnexpectedNodes? = nil, members: ExpressibleAsMemberDeclBlock) {
    assert(actorKeyword.text == #"actor"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes?.createUnexpectedNodes(), attributes: attributes?.createAttributeList(), unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes(), modifiers: modifiers?.createModifierList(), unexpectedBetweenModifiersAndActorKeyword: unexpectedBetweenModifiersAndActorKeyword?.createUnexpectedNodes(), actorKeyword: actorKeyword, unexpectedBetweenActorKeywordAndIdentifier: unexpectedBetweenActorKeywordAndIdentifier?.createUnexpectedNodes(), identifier: identifier, unexpectedBetweenIdentifierAndGenericParameterClause: unexpectedBetweenIdentifierAndGenericParameterClause?.createUnexpectedNodes(), genericParameterClause: genericParameterClause?.createGenericParameterClause(), unexpectedBetweenGenericParameterClauseAndInheritanceClause: unexpectedBetweenGenericParameterClauseAndInheritanceClause?.createUnexpectedNodes(), inheritanceClause: inheritanceClause?.createTypeInheritanceClause(), unexpectedBetweenInheritanceClauseAndGenericWhereClause: unexpectedBetweenInheritanceClauseAndGenericWhereClause?.createUnexpectedNodes(), genericWhereClause: genericWhereClause?.createGenericWhereClause(), unexpectedBetweenGenericWhereClauseAndMembers: unexpectedBetweenGenericWhereClauseAndMembers?.createUnexpectedNodes(), members: members.createMemberDeclBlock()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndActorKeyword: ExpressibleAsUnexpectedNodes? = nil, actorKeyword: String, unexpectedBetweenActorKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: String, unexpectedBetweenIdentifierAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndMembers: ExpressibleAsUnexpectedNodes? = nil, @MemberDeclListBuilder membersBuilder: () -> ExpressibleAsMemberDeclList =  {
    MemberDeclList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndActorKeyword: unexpectedBetweenModifiersAndActorKeyword, actorKeyword: Token.`contextualKeyword`(actorKeyword), unexpectedBetweenActorKeywordAndIdentifier: unexpectedBetweenActorKeywordAndIdentifier, identifier: Token.`identifier`(identifier), unexpectedBetweenIdentifierAndGenericParameterClause: unexpectedBetweenIdentifierAndGenericParameterClause, genericParameterClause: genericParameterClause, unexpectedBetweenGenericParameterClauseAndInheritanceClause: unexpectedBetweenGenericParameterClauseAndInheritanceClause, inheritanceClause: inheritanceClause, unexpectedBetweenInheritanceClauseAndGenericWhereClause: unexpectedBetweenInheritanceClauseAndGenericWhereClause, genericWhereClause: genericWhereClause, unexpectedBetweenGenericWhereClauseAndMembers: unexpectedBetweenGenericWhereClauseAndMembers, members: membersBuilder())
  }
  public init(_ constructedNode: ActorDeclSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ActorDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ActorDeclSyntax`.
  func buildActorDecl(format: Format) -> ActorDeclSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ActorDeclSyntax(buildableData.unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: buildableData.attributes?.buildAttributeList(format: format), buildableData.unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format), modifiers: buildableData.modifiers?.buildModifierList(format: format), buildableData.unexpectedBetweenModifiersAndActorKeyword?.buildUnexpectedNodes(format: format), actorKeyword: buildableData.actorKeyword.buildToken(format: format), buildableData.unexpectedBetweenActorKeywordAndIdentifier?.buildUnexpectedNodes(format: format), identifier: buildableData.identifier.buildToken(format: format), buildableData.unexpectedBetweenIdentifierAndGenericParameterClause?.buildUnexpectedNodes(format: format), genericParameterClause: buildableData.genericParameterClause?.buildGenericParameterClause(format: format), buildableData.unexpectedBetweenGenericParameterClauseAndInheritanceClause?.buildUnexpectedNodes(format: format), inheritanceClause: buildableData.inheritanceClause?.buildTypeInheritanceClause(format: format), buildableData.unexpectedBetweenInheritanceClauseAndGenericWhereClause?.buildUnexpectedNodes(format: format), genericWhereClause: buildableData.genericWhereClause?.buildGenericWhereClause(format: format), buildableData.unexpectedBetweenGenericWhereClauseAndMembers?.buildUnexpectedNodes(format: format), members: buildableData.members.buildMemberDeclBlock(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildActorDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsActorDecl`.
  public func createActorDecl() -> ActorDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `ActorDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct StructDecl: DeclBuildable, ExpressibleAsStructDecl {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeAttributes: UnexpectedNodes?
    var attributes: AttributeList?
    var unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
    var modifiers: ModifierList?
    var unexpectedBetweenModifiersAndStructKeyword: UnexpectedNodes?
    var structKeyword: Token
    var unexpectedBetweenStructKeywordAndIdentifier: UnexpectedNodes?
    var identifier: Token
    var unexpectedBetweenIdentifierAndGenericParameterClause: UnexpectedNodes?
    var genericParameterClause: GenericParameterClause?
    var unexpectedBetweenGenericParameterClauseAndInheritanceClause: UnexpectedNodes?
    var inheritanceClause: TypeInheritanceClause?
    var unexpectedBetweenInheritanceClauseAndGenericWhereClause: UnexpectedNodes?
    var genericWhereClause: GenericWhereClause?
    var unexpectedBetweenGenericWhereClauseAndMembers: UnexpectedNodes?
    var members: MemberDeclBlock
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(StructDeclSyntax)
  }
  private var data: Data
  /// Creates a `StructDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndStructKeyword: 
  ///   - structKeyword: 
  ///   - unexpectedBetweenStructKeywordAndIdentifier: 
  ///   - identifier: 
  ///   - unexpectedBetweenIdentifierAndGenericParameterClause: 
  ///   - genericParameterClause: 
  ///   - unexpectedBetweenGenericParameterClauseAndInheritanceClause: 
  ///   - inheritanceClause: 
  ///   - unexpectedBetweenInheritanceClauseAndGenericWhereClause: 
  ///   - genericWhereClause: 
  ///   - unexpectedBetweenGenericWhereClauseAndMembers: 
  ///   - members: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndStructKeyword: ExpressibleAsUnexpectedNodes? = nil, structKeyword: Token = Token.`struct`, unexpectedBetweenStructKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndMembers: ExpressibleAsUnexpectedNodes? = nil, members: ExpressibleAsMemberDeclBlock) {
    assert(structKeyword.text == #"struct"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes?.createUnexpectedNodes(), attributes: attributes?.createAttributeList(), unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes(), modifiers: modifiers?.createModifierList(), unexpectedBetweenModifiersAndStructKeyword: unexpectedBetweenModifiersAndStructKeyword?.createUnexpectedNodes(), structKeyword: structKeyword, unexpectedBetweenStructKeywordAndIdentifier: unexpectedBetweenStructKeywordAndIdentifier?.createUnexpectedNodes(), identifier: identifier, unexpectedBetweenIdentifierAndGenericParameterClause: unexpectedBetweenIdentifierAndGenericParameterClause?.createUnexpectedNodes(), genericParameterClause: genericParameterClause?.createGenericParameterClause(), unexpectedBetweenGenericParameterClauseAndInheritanceClause: unexpectedBetweenGenericParameterClauseAndInheritanceClause?.createUnexpectedNodes(), inheritanceClause: inheritanceClause?.createTypeInheritanceClause(), unexpectedBetweenInheritanceClauseAndGenericWhereClause: unexpectedBetweenInheritanceClauseAndGenericWhereClause?.createUnexpectedNodes(), genericWhereClause: genericWhereClause?.createGenericWhereClause(), unexpectedBetweenGenericWhereClauseAndMembers: unexpectedBetweenGenericWhereClauseAndMembers?.createUnexpectedNodes(), members: members.createMemberDeclBlock()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndStructKeyword: ExpressibleAsUnexpectedNodes? = nil, structKeyword: Token = Token.`struct`, unexpectedBetweenStructKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: String, unexpectedBetweenIdentifierAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndMembers: ExpressibleAsUnexpectedNodes? = nil, @MemberDeclListBuilder membersBuilder: () -> ExpressibleAsMemberDeclList =  {
    MemberDeclList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndStructKeyword: unexpectedBetweenModifiersAndStructKeyword, structKeyword: structKeyword, unexpectedBetweenStructKeywordAndIdentifier: unexpectedBetweenStructKeywordAndIdentifier, identifier: Token.`identifier`(identifier), unexpectedBetweenIdentifierAndGenericParameterClause: unexpectedBetweenIdentifierAndGenericParameterClause, genericParameterClause: genericParameterClause, unexpectedBetweenGenericParameterClauseAndInheritanceClause: unexpectedBetweenGenericParameterClauseAndInheritanceClause, inheritanceClause: inheritanceClause, unexpectedBetweenInheritanceClauseAndGenericWhereClause: unexpectedBetweenInheritanceClauseAndGenericWhereClause, genericWhereClause: genericWhereClause, unexpectedBetweenGenericWhereClauseAndMembers: unexpectedBetweenGenericWhereClauseAndMembers, members: membersBuilder())
  }
  public init(_ constructedNode: StructDeclSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `StructDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `StructDeclSyntax`.
  func buildStructDecl(format: Format) -> StructDeclSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = StructDeclSyntax(buildableData.unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: buildableData.attributes?.buildAttributeList(format: format), buildableData.unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format), modifiers: buildableData.modifiers?.buildModifierList(format: format), buildableData.unexpectedBetweenModifiersAndStructKeyword?.buildUnexpectedNodes(format: format), structKeyword: buildableData.structKeyword.buildToken(format: format), buildableData.unexpectedBetweenStructKeywordAndIdentifier?.buildUnexpectedNodes(format: format), identifier: buildableData.identifier.buildToken(format: format), buildableData.unexpectedBetweenIdentifierAndGenericParameterClause?.buildUnexpectedNodes(format: format), genericParameterClause: buildableData.genericParameterClause?.buildGenericParameterClause(format: format), buildableData.unexpectedBetweenGenericParameterClauseAndInheritanceClause?.buildUnexpectedNodes(format: format), inheritanceClause: buildableData.inheritanceClause?.buildTypeInheritanceClause(format: format), buildableData.unexpectedBetweenInheritanceClauseAndGenericWhereClause?.buildUnexpectedNodes(format: format), genericWhereClause: buildableData.genericWhereClause?.buildGenericWhereClause(format: format), buildableData.unexpectedBetweenGenericWhereClauseAndMembers?.buildUnexpectedNodes(format: format), members: buildableData.members.buildMemberDeclBlock(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildStructDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsStructDecl`.
  public func createStructDecl() -> StructDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `StructDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct ProtocolDecl: DeclBuildable, ExpressibleAsProtocolDecl {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeAttributes: UnexpectedNodes?
    var attributes: AttributeList?
    var unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
    var modifiers: ModifierList?
    var unexpectedBetweenModifiersAndProtocolKeyword: UnexpectedNodes?
    var protocolKeyword: Token
    var unexpectedBetweenProtocolKeywordAndIdentifier: UnexpectedNodes?
    var identifier: Token
    var unexpectedBetweenIdentifierAndPrimaryAssociatedTypeClause: UnexpectedNodes?
    var primaryAssociatedTypeClause: PrimaryAssociatedTypeClause?
    var unexpectedBetweenPrimaryAssociatedTypeClauseAndInheritanceClause: UnexpectedNodes?
    var inheritanceClause: TypeInheritanceClause?
    var unexpectedBetweenInheritanceClauseAndGenericWhereClause: UnexpectedNodes?
    var genericWhereClause: GenericWhereClause?
    var unexpectedBetweenGenericWhereClauseAndMembers: UnexpectedNodes?
    var members: MemberDeclBlock
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ProtocolDeclSyntax)
  }
  private var data: Data
  /// Creates a `ProtocolDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndProtocolKeyword: 
  ///   - protocolKeyword: 
  ///   - unexpectedBetweenProtocolKeywordAndIdentifier: 
  ///   - identifier: 
  ///   - unexpectedBetweenIdentifierAndPrimaryAssociatedTypeClause: 
  ///   - primaryAssociatedTypeClause: 
  ///   - unexpectedBetweenPrimaryAssociatedTypeClauseAndInheritanceClause: 
  ///   - inheritanceClause: 
  ///   - unexpectedBetweenInheritanceClauseAndGenericWhereClause: 
  ///   - genericWhereClause: 
  ///   - unexpectedBetweenGenericWhereClauseAndMembers: 
  ///   - members: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndProtocolKeyword: ExpressibleAsUnexpectedNodes? = nil, protocolKeyword: Token = Token.`protocol`, unexpectedBetweenProtocolKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndPrimaryAssociatedTypeClause: ExpressibleAsUnexpectedNodes? = nil, primaryAssociatedTypeClause: ExpressibleAsPrimaryAssociatedTypeClause? = nil, unexpectedBetweenPrimaryAssociatedTypeClauseAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndMembers: ExpressibleAsUnexpectedNodes? = nil, members: ExpressibleAsMemberDeclBlock) {
    assert(protocolKeyword.text == #"protocol"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes?.createUnexpectedNodes(), attributes: attributes?.createAttributeList(), unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes(), modifiers: modifiers?.createModifierList(), unexpectedBetweenModifiersAndProtocolKeyword: unexpectedBetweenModifiersAndProtocolKeyword?.createUnexpectedNodes(), protocolKeyword: protocolKeyword, unexpectedBetweenProtocolKeywordAndIdentifier: unexpectedBetweenProtocolKeywordAndIdentifier?.createUnexpectedNodes(), identifier: identifier, unexpectedBetweenIdentifierAndPrimaryAssociatedTypeClause: unexpectedBetweenIdentifierAndPrimaryAssociatedTypeClause?.createUnexpectedNodes(), primaryAssociatedTypeClause: primaryAssociatedTypeClause?.createPrimaryAssociatedTypeClause(), unexpectedBetweenPrimaryAssociatedTypeClauseAndInheritanceClause: unexpectedBetweenPrimaryAssociatedTypeClauseAndInheritanceClause?.createUnexpectedNodes(), inheritanceClause: inheritanceClause?.createTypeInheritanceClause(), unexpectedBetweenInheritanceClauseAndGenericWhereClause: unexpectedBetweenInheritanceClauseAndGenericWhereClause?.createUnexpectedNodes(), genericWhereClause: genericWhereClause?.createGenericWhereClause(), unexpectedBetweenGenericWhereClauseAndMembers: unexpectedBetweenGenericWhereClauseAndMembers?.createUnexpectedNodes(), members: members.createMemberDeclBlock()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndProtocolKeyword: ExpressibleAsUnexpectedNodes? = nil, protocolKeyword: Token = Token.`protocol`, unexpectedBetweenProtocolKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: String, unexpectedBetweenIdentifierAndPrimaryAssociatedTypeClause: ExpressibleAsUnexpectedNodes? = nil, primaryAssociatedTypeClause: ExpressibleAsPrimaryAssociatedTypeClause? = nil, unexpectedBetweenPrimaryAssociatedTypeClauseAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndMembers: ExpressibleAsUnexpectedNodes? = nil, @MemberDeclListBuilder membersBuilder: () -> ExpressibleAsMemberDeclList =  {
    MemberDeclList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndProtocolKeyword: unexpectedBetweenModifiersAndProtocolKeyword, protocolKeyword: protocolKeyword, unexpectedBetweenProtocolKeywordAndIdentifier: unexpectedBetweenProtocolKeywordAndIdentifier, identifier: Token.`identifier`(identifier), unexpectedBetweenIdentifierAndPrimaryAssociatedTypeClause: unexpectedBetweenIdentifierAndPrimaryAssociatedTypeClause, primaryAssociatedTypeClause: primaryAssociatedTypeClause, unexpectedBetweenPrimaryAssociatedTypeClauseAndInheritanceClause: unexpectedBetweenPrimaryAssociatedTypeClauseAndInheritanceClause, inheritanceClause: inheritanceClause, unexpectedBetweenInheritanceClauseAndGenericWhereClause: unexpectedBetweenInheritanceClauseAndGenericWhereClause, genericWhereClause: genericWhereClause, unexpectedBetweenGenericWhereClauseAndMembers: unexpectedBetweenGenericWhereClauseAndMembers, members: membersBuilder())
  }
  public init(_ constructedNode: ProtocolDeclSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ProtocolDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ProtocolDeclSyntax`.
  func buildProtocolDecl(format: Format) -> ProtocolDeclSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ProtocolDeclSyntax(buildableData.unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: buildableData.attributes?.buildAttributeList(format: format), buildableData.unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format), modifiers: buildableData.modifiers?.buildModifierList(format: format), buildableData.unexpectedBetweenModifiersAndProtocolKeyword?.buildUnexpectedNodes(format: format), protocolKeyword: buildableData.protocolKeyword.buildToken(format: format), buildableData.unexpectedBetweenProtocolKeywordAndIdentifier?.buildUnexpectedNodes(format: format), identifier: buildableData.identifier.buildToken(format: format), buildableData.unexpectedBetweenIdentifierAndPrimaryAssociatedTypeClause?.buildUnexpectedNodes(format: format), primaryAssociatedTypeClause: buildableData.primaryAssociatedTypeClause?.buildPrimaryAssociatedTypeClause(format: format), buildableData.unexpectedBetweenPrimaryAssociatedTypeClauseAndInheritanceClause?.buildUnexpectedNodes(format: format), inheritanceClause: buildableData.inheritanceClause?.buildTypeInheritanceClause(format: format), buildableData.unexpectedBetweenInheritanceClauseAndGenericWhereClause?.buildUnexpectedNodes(format: format), genericWhereClause: buildableData.genericWhereClause?.buildGenericWhereClause(format: format), buildableData.unexpectedBetweenGenericWhereClauseAndMembers?.buildUnexpectedNodes(format: format), members: buildableData.members.buildMemberDeclBlock(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildProtocolDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsProtocolDecl`.
  public func createProtocolDecl() -> ProtocolDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `ProtocolDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct ExtensionDecl: DeclBuildable, ExpressibleAsExtensionDecl {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeAttributes: UnexpectedNodes?
    var attributes: AttributeList?
    var unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
    var modifiers: ModifierList?
    var unexpectedBetweenModifiersAndExtensionKeyword: UnexpectedNodes?
    var extensionKeyword: Token
    var unexpectedBetweenExtensionKeywordAndExtendedType: UnexpectedNodes?
    var extendedType: TypeBuildable
    var unexpectedBetweenExtendedTypeAndInheritanceClause: UnexpectedNodes?
    var inheritanceClause: TypeInheritanceClause?
    var unexpectedBetweenInheritanceClauseAndGenericWhereClause: UnexpectedNodes?
    var genericWhereClause: GenericWhereClause?
    var unexpectedBetweenGenericWhereClauseAndMembers: UnexpectedNodes?
    var members: MemberDeclBlock
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ExtensionDeclSyntax)
  }
  private var data: Data
  /// Creates a `ExtensionDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndExtensionKeyword: 
  ///   - extensionKeyword: 
  ///   - unexpectedBetweenExtensionKeywordAndExtendedType: 
  ///   - extendedType: 
  ///   - unexpectedBetweenExtendedTypeAndInheritanceClause: 
  ///   - inheritanceClause: 
  ///   - unexpectedBetweenInheritanceClauseAndGenericWhereClause: 
  ///   - genericWhereClause: 
  ///   - unexpectedBetweenGenericWhereClauseAndMembers: 
  ///   - members: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndExtensionKeyword: ExpressibleAsUnexpectedNodes? = nil, extensionKeyword: Token = Token.`extension`, unexpectedBetweenExtensionKeywordAndExtendedType: ExpressibleAsUnexpectedNodes? = nil, extendedType: ExpressibleAsTypeBuildable, unexpectedBetweenExtendedTypeAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndMembers: ExpressibleAsUnexpectedNodes? = nil, members: ExpressibleAsMemberDeclBlock) {
    assert(extensionKeyword.text == #"extension"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes?.createUnexpectedNodes(), attributes: attributes?.createAttributeList(), unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes(), modifiers: modifiers?.createModifierList(), unexpectedBetweenModifiersAndExtensionKeyword: unexpectedBetweenModifiersAndExtensionKeyword?.createUnexpectedNodes(), extensionKeyword: extensionKeyword, unexpectedBetweenExtensionKeywordAndExtendedType: unexpectedBetweenExtensionKeywordAndExtendedType?.createUnexpectedNodes(), extendedType: extendedType.createTypeBuildable(), unexpectedBetweenExtendedTypeAndInheritanceClause: unexpectedBetweenExtendedTypeAndInheritanceClause?.createUnexpectedNodes(), inheritanceClause: inheritanceClause?.createTypeInheritanceClause(), unexpectedBetweenInheritanceClauseAndGenericWhereClause: unexpectedBetweenInheritanceClauseAndGenericWhereClause?.createUnexpectedNodes(), genericWhereClause: genericWhereClause?.createGenericWhereClause(), unexpectedBetweenGenericWhereClauseAndMembers: unexpectedBetweenGenericWhereClauseAndMembers?.createUnexpectedNodes(), members: members.createMemberDeclBlock()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndExtensionKeyword: ExpressibleAsUnexpectedNodes? = nil, extensionKeyword: Token = Token.`extension`, unexpectedBetweenExtensionKeywordAndExtendedType: ExpressibleAsUnexpectedNodes? = nil, extendedType: ExpressibleAsTypeBuildable, unexpectedBetweenExtendedTypeAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndMembers: ExpressibleAsUnexpectedNodes? = nil, @MemberDeclListBuilder membersBuilder: () -> ExpressibleAsMemberDeclList =  {
    MemberDeclList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndExtensionKeyword: unexpectedBetweenModifiersAndExtensionKeyword, extensionKeyword: extensionKeyword, unexpectedBetweenExtensionKeywordAndExtendedType: unexpectedBetweenExtensionKeywordAndExtendedType, extendedType: extendedType, unexpectedBetweenExtendedTypeAndInheritanceClause: unexpectedBetweenExtendedTypeAndInheritanceClause, inheritanceClause: inheritanceClause, unexpectedBetweenInheritanceClauseAndGenericWhereClause: unexpectedBetweenInheritanceClauseAndGenericWhereClause, genericWhereClause: genericWhereClause, unexpectedBetweenGenericWhereClauseAndMembers: unexpectedBetweenGenericWhereClauseAndMembers, members: membersBuilder())
  }
  public init(_ constructedNode: ExtensionDeclSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ExtensionDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ExtensionDeclSyntax`.
  func buildExtensionDecl(format: Format) -> ExtensionDeclSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ExtensionDeclSyntax(buildableData.unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: buildableData.attributes?.buildAttributeList(format: format), buildableData.unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format), modifiers: buildableData.modifiers?.buildModifierList(format: format), buildableData.unexpectedBetweenModifiersAndExtensionKeyword?.buildUnexpectedNodes(format: format), extensionKeyword: buildableData.extensionKeyword.buildToken(format: format), buildableData.unexpectedBetweenExtensionKeywordAndExtendedType?.buildUnexpectedNodes(format: format), extendedType: buildableData.extendedType.buildType(format: format), buildableData.unexpectedBetweenExtendedTypeAndInheritanceClause?.buildUnexpectedNodes(format: format), inheritanceClause: buildableData.inheritanceClause?.buildTypeInheritanceClause(format: format), buildableData.unexpectedBetweenInheritanceClauseAndGenericWhereClause?.buildUnexpectedNodes(format: format), genericWhereClause: buildableData.genericWhereClause?.buildGenericWhereClause(format: format), buildableData.unexpectedBetweenGenericWhereClauseAndMembers?.buildUnexpectedNodes(format: format), members: buildableData.members.buildMemberDeclBlock(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildExtensionDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsExtensionDecl`.
  public func createExtensionDecl() -> ExtensionDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `ExtensionDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct MemberDeclBlock: SyntaxBuildable, ExpressibleAsMemberDeclBlock {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeLeftBrace: UnexpectedNodes?
    var leftBrace: Token
    var unexpectedBetweenLeftBraceAndMembers: UnexpectedNodes?
    var members: MemberDeclList
    var unexpectedBetweenMembersAndRightBrace: UnexpectedNodes?
    var rightBrace: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(MemberDeclBlockSyntax)
  }
  private var data: Data
  /// Creates a `MemberDeclBlock` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftBrace: 
  ///   - leftBrace: 
  ///   - unexpectedBetweenLeftBraceAndMembers: 
  ///   - members: 
  ///   - unexpectedBetweenMembersAndRightBrace: 
  ///   - rightBrace: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftBrace: ExpressibleAsUnexpectedNodes? = nil, leftBrace: Token = Token.`leftBrace`, unexpectedBetweenLeftBraceAndMembers: ExpressibleAsUnexpectedNodes? = nil, members: ExpressibleAsMemberDeclList, unexpectedBetweenMembersAndRightBrace: ExpressibleAsUnexpectedNodes? = nil, rightBrace: Token = Token.`rightBrace`) {
    assert(leftBrace.text == #"{"#)
    assert(rightBrace.text == #"}"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeLeftBrace: unexpectedBeforeLeftBrace?.createUnexpectedNodes(), leftBrace: leftBrace, unexpectedBetweenLeftBraceAndMembers: unexpectedBetweenLeftBraceAndMembers?.createUnexpectedNodes(), members: members.createMemberDeclList(), unexpectedBetweenMembersAndRightBrace: unexpectedBetweenMembersAndRightBrace?.createUnexpectedNodes(), rightBrace: rightBrace))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftBrace: ExpressibleAsUnexpectedNodes? = nil, leftBrace: Token = Token.`leftBrace`, unexpectedBetweenLeftBraceAndMembers: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenMembersAndRightBrace: ExpressibleAsUnexpectedNodes? = nil, rightBrace: Token = Token.`rightBrace`, @MemberDeclListBuilder membersBuilder: () -> ExpressibleAsMemberDeclList =  {
    MemberDeclList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftBrace: unexpectedBeforeLeftBrace, leftBrace: leftBrace, unexpectedBetweenLeftBraceAndMembers: unexpectedBetweenLeftBraceAndMembers, members: membersBuilder(), unexpectedBetweenMembersAndRightBrace: unexpectedBetweenMembersAndRightBrace, rightBrace: rightBrace)
  }
  public init(_ constructedNode: MemberDeclBlockSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `MemberDeclBlockSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `MemberDeclBlockSyntax`.
  func buildMemberDeclBlock(format: Format) -> MemberDeclBlockSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = MemberDeclBlockSyntax(buildableData.unexpectedBeforeLeftBrace?.buildUnexpectedNodes(format: format), leftBrace: buildableData.leftBrace.buildToken(format: format), buildableData.unexpectedBetweenLeftBraceAndMembers?.buildUnexpectedNodes(format: format), members: buildableData.members.buildMemberDeclList(format: format._indented), buildableData.unexpectedBetweenMembersAndRightBrace?.buildUnexpectedNodes(format: format), rightBrace: buildableData.rightBrace.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildMemberDeclBlock(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsMemberDeclBlock`.
  public func createMemberDeclBlock() -> MemberDeclBlock {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `MemberDeclBlock` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
/// A member declaration of a type consisting of a declaration and anoptional semicolon;
public struct MemberDeclListItem: SyntaxBuildable, ExpressibleAsMemberDeclListItem {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeDecl: UnexpectedNodes?
    var decl: DeclBuildable
    var unexpectedBetweenDeclAndSemicolon: UnexpectedNodes?
    var semicolon: Token?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(MemberDeclListItemSyntax)
  }
  private var data: Data
  /// Creates a `MemberDeclListItem` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeDecl: 
  ///   - decl: The declaration of the type member.
  ///   - unexpectedBetweenDeclAndSemicolon: 
  ///   - semicolon: An optional trailing semicolon.
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeDecl: ExpressibleAsUnexpectedNodes? = nil, decl: ExpressibleAsDeclBuildable, unexpectedBetweenDeclAndSemicolon: ExpressibleAsUnexpectedNodes? = nil, semicolon: Token? = nil) {
    assert(semicolon == nil || semicolon!.text == #";"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeDecl: unexpectedBeforeDecl?.createUnexpectedNodes(), decl: decl.createDeclBuildable(), unexpectedBetweenDeclAndSemicolon: unexpectedBetweenDeclAndSemicolon?.createUnexpectedNodes(), semicolon: semicolon))
  }
  public init(_ constructedNode: MemberDeclListItemSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `MemberDeclListItemSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `MemberDeclListItemSyntax`.
  func buildMemberDeclListItem(format: Format) -> MemberDeclListItemSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = MemberDeclListItemSyntax(buildableData.unexpectedBeforeDecl?.buildUnexpectedNodes(format: format), decl: buildableData.decl.buildDecl(format: format), buildableData.unexpectedBetweenDeclAndSemicolon?.buildUnexpectedNodes(format: format), semicolon: buildableData.semicolon?.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildMemberDeclListItem(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsMemberDeclListItem`.
  public func createMemberDeclListItem() -> MemberDeclListItem {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `MemberDeclListItem` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct SourceFile: SyntaxBuildable, ExpressibleAsSourceFile {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeStatements: UnexpectedNodes?
    var statements: CodeBlockItemList
    var unexpectedBetweenStatementsAndEOFToken: UnexpectedNodes?
    var eofToken: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(SourceFileSyntax)
  }
  private var data: Data
  /// Creates a `SourceFile` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeStatements: 
  ///   - statements: 
  ///   - unexpectedBetweenStatementsAndEOFToken: 
  ///   - eofToken: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeStatements: ExpressibleAsUnexpectedNodes? = nil, statements: ExpressibleAsCodeBlockItemList, unexpectedBetweenStatementsAndEOFToken: ExpressibleAsUnexpectedNodes? = nil, eofToken: Token = Token.eof) {
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeStatements: unexpectedBeforeStatements?.createUnexpectedNodes(), statements: statements.createCodeBlockItemList(), unexpectedBetweenStatementsAndEOFToken: unexpectedBetweenStatementsAndEOFToken?.createUnexpectedNodes(), eofToken: eofToken))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeStatements: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenStatementsAndEOFToken: ExpressibleAsUnexpectedNodes? = nil, eofToken: Token = Token.eof, @CodeBlockItemListBuilder statementsBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeStatements: unexpectedBeforeStatements, statements: statementsBuilder(), unexpectedBetweenStatementsAndEOFToken: unexpectedBetweenStatementsAndEOFToken, eofToken: eofToken)
  }
  public init(_ constructedNode: SourceFileSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `SourceFileSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SourceFileSyntax`.
  func buildSourceFile(format: Format) -> SourceFileSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = SourceFileSyntax(buildableData.unexpectedBeforeStatements?.buildUnexpectedNodes(format: format), statements: buildableData.statements.buildCodeBlockItemList(format: format), buildableData.unexpectedBetweenStatementsAndEOFToken?.buildUnexpectedNodes(format: format), eofToken: buildableData.eofToken.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildSourceFile(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsSourceFile`.
  public func createSourceFile() -> SourceFile {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `SourceFile` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct InitializerClause: SyntaxBuildable, ExpressibleAsInitializerClause {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeEqual: UnexpectedNodes?
    var equal: Token
    var unexpectedBetweenEqualAndValue: UnexpectedNodes?
    var value: ExprBuildable
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(InitializerClauseSyntax)
  }
  private var data: Data
  /// Creates a `InitializerClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeEqual: 
  ///   - equal: 
  ///   - unexpectedBetweenEqualAndValue: 
  ///   - value: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeEqual: ExpressibleAsUnexpectedNodes? = nil, equal: Token = Token.`equal`, unexpectedBetweenEqualAndValue: ExpressibleAsUnexpectedNodes? = nil, value: ExpressibleAsExprBuildable) {
    assert(equal.text == #"="#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeEqual: unexpectedBeforeEqual?.createUnexpectedNodes(), equal: equal, unexpectedBetweenEqualAndValue: unexpectedBetweenEqualAndValue?.createUnexpectedNodes(), value: value.createExprBuildable()))
  }
  public init(_ constructedNode: InitializerClauseSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `InitializerClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `InitializerClauseSyntax`.
  func buildInitializerClause(format: Format) -> InitializerClauseSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = InitializerClauseSyntax(buildableData.unexpectedBeforeEqual?.buildUnexpectedNodes(format: format), equal: buildableData.equal.buildToken(format: format), buildableData.unexpectedBetweenEqualAndValue?.buildUnexpectedNodes(format: format), value: buildableData.value.buildExpr(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildInitializerClause(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsInitializerClause`.
  public func createInitializerClause() -> InitializerClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `InitializerClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct FunctionParameter: SyntaxBuildable, ExpressibleAsFunctionParameter, HasTrailingComma {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeAttributes: UnexpectedNodes?
    var attributes: AttributeList?
    var unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
    var modifiers: ModifierList?
    var unexpectedBetweenModifiersAndFirstName: UnexpectedNodes?
    var firstName: Token?
    var unexpectedBetweenFirstNameAndSecondName: UnexpectedNodes?
    var secondName: Token?
    var unexpectedBetweenSecondNameAndColon: UnexpectedNodes?
    var colon: Token?
    var unexpectedBetweenColonAndType: UnexpectedNodes?
    var type: TypeBuildable?
    var unexpectedBetweenTypeAndEllipsis: UnexpectedNodes?
    var ellipsis: Token?
    var unexpectedBetweenEllipsisAndDefaultArgument: UnexpectedNodes?
    var defaultArgument: InitializerClause?
    var unexpectedBetweenDefaultArgumentAndTrailingComma: UnexpectedNodes?
    var trailingComma: Token?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(FunctionParameterSyntax)
  }
  private var data: Data
  var hasTrailingComma: Bool {
    switch data {
    case .buildable(let buildableData):
      return buildableData.trailingComma != nil
    case .constructed(let node):
      return node.trailingComma != nil
    }
  }
  /// Creates a `FunctionParameter` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndFirstName: 
  ///   - firstName: 
  ///   - unexpectedBetweenFirstNameAndSecondName: 
  ///   - secondName: 
  ///   - unexpectedBetweenSecondNameAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndType: 
  ///   - type: 
  ///   - unexpectedBetweenTypeAndEllipsis: 
  ///   - ellipsis: 
  ///   - unexpectedBetweenEllipsisAndDefaultArgument: 
  ///   - defaultArgument: 
  ///   - unexpectedBetweenDefaultArgumentAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndFirstName: ExpressibleAsUnexpectedNodes? = nil, firstName: Token? = nil, unexpectedBetweenFirstNameAndSecondName: ExpressibleAsUnexpectedNodes? = nil, secondName: Token? = nil, unexpectedBetweenSecondNameAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token? = nil, unexpectedBetweenColonAndType: ExpressibleAsUnexpectedNodes? = nil, type: ExpressibleAsTypeBuildable? = nil, unexpectedBetweenTypeAndEllipsis: ExpressibleAsUnexpectedNodes? = nil, ellipsis: Token? = nil, unexpectedBetweenEllipsisAndDefaultArgument: ExpressibleAsUnexpectedNodes? = nil, defaultArgument: ExpressibleAsInitializerClause? = nil, unexpectedBetweenDefaultArgumentAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    assert(colon == nil || colon!.text == #":"#)
    assert(ellipsis == nil || ellipsis!.text == #"..."#)
    assert(trailingComma == nil || trailingComma!.text == #","#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes?.createUnexpectedNodes(), attributes: attributes?.createAttributeList(), unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes(), modifiers: modifiers?.createModifierList(), unexpectedBetweenModifiersAndFirstName: unexpectedBetweenModifiersAndFirstName?.createUnexpectedNodes(), firstName: firstName, unexpectedBetweenFirstNameAndSecondName: unexpectedBetweenFirstNameAndSecondName?.createUnexpectedNodes(), secondName: secondName, unexpectedBetweenSecondNameAndColon: unexpectedBetweenSecondNameAndColon?.createUnexpectedNodes(), colon: colon, unexpectedBetweenColonAndType: unexpectedBetweenColonAndType?.createUnexpectedNodes(), type: type?.createTypeBuildable(), unexpectedBetweenTypeAndEllipsis: unexpectedBetweenTypeAndEllipsis?.createUnexpectedNodes(), ellipsis: ellipsis, unexpectedBetweenEllipsisAndDefaultArgument: unexpectedBetweenEllipsisAndDefaultArgument?.createUnexpectedNodes(), defaultArgument: defaultArgument?.createInitializerClause(), unexpectedBetweenDefaultArgumentAndTrailingComma: unexpectedBetweenDefaultArgumentAndTrailingComma?.createUnexpectedNodes(), trailingComma: trailingComma))
  }
  public init(_ constructedNode: FunctionParameterSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `FunctionParameterSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `FunctionParameterSyntax`.
  func buildFunctionParameter(format: Format) -> FunctionParameterSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = FunctionParameterSyntax(buildableData.unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: buildableData.attributes?.buildAttributeList(format: format), buildableData.unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format), modifiers: buildableData.modifiers?.buildModifierList(format: format), buildableData.unexpectedBetweenModifiersAndFirstName?.buildUnexpectedNodes(format: format), firstName: buildableData.firstName?.buildToken(format: format), buildableData.unexpectedBetweenFirstNameAndSecondName?.buildUnexpectedNodes(format: format), secondName: buildableData.secondName?.buildToken(format: format), buildableData.unexpectedBetweenSecondNameAndColon?.buildUnexpectedNodes(format: format), colon: buildableData.colon?.buildToken(format: format), buildableData.unexpectedBetweenColonAndType?.buildUnexpectedNodes(format: format), type: buildableData.type?.buildType(format: format), buildableData.unexpectedBetweenTypeAndEllipsis?.buildUnexpectedNodes(format: format), ellipsis: buildableData.ellipsis?.buildToken(format: format), buildableData.unexpectedBetweenEllipsisAndDefaultArgument?.buildUnexpectedNodes(format: format), defaultArgument: buildableData.defaultArgument?.buildInitializerClause(format: format), buildableData.unexpectedBetweenDefaultArgumentAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: buildableData.trailingComma?.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildFunctionParameter(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsFunctionParameter`.
  public func createFunctionParameter() -> FunctionParameter {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `FunctionParameter` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingComma = withComma ? .comma : nil
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withComma = node.withTrailingComma(withComma ? .commaToken() : nil)
      var result = self
      result.data = .constructed(withComma)
      return result
    }
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct FunctionDecl: DeclBuildable, ExpressibleAsFunctionDecl {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeAttributes: UnexpectedNodes?
    var attributes: AttributeList?
    var unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
    var modifiers: ModifierList?
    var unexpectedBetweenModifiersAndFuncKeyword: UnexpectedNodes?
    var funcKeyword: Token
    var unexpectedBetweenFuncKeywordAndIdentifier: UnexpectedNodes?
    var identifier: Token
    var unexpectedBetweenIdentifierAndGenericParameterClause: UnexpectedNodes?
    var genericParameterClause: GenericParameterClause?
    var unexpectedBetweenGenericParameterClauseAndSignature: UnexpectedNodes?
    var signature: FunctionSignature
    var unexpectedBetweenSignatureAndGenericWhereClause: UnexpectedNodes?
    var genericWhereClause: GenericWhereClause?
    var unexpectedBetweenGenericWhereClauseAndBody: UnexpectedNodes?
    var body: CodeBlock?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(FunctionDeclSyntax)
  }
  private var data: Data
  /// Creates a `FunctionDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndFuncKeyword: 
  ///   - funcKeyword: 
  ///   - unexpectedBetweenFuncKeywordAndIdentifier: 
  ///   - identifier: 
  ///   - unexpectedBetweenIdentifierAndGenericParameterClause: 
  ///   - genericParameterClause: 
  ///   - unexpectedBetweenGenericParameterClauseAndSignature: 
  ///   - signature: 
  ///   - unexpectedBetweenSignatureAndGenericWhereClause: 
  ///   - genericWhereClause: 
  ///   - unexpectedBetweenGenericWhereClauseAndBody: 
  ///   - body: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndFuncKeyword: ExpressibleAsUnexpectedNodes? = nil, funcKeyword: Token = Token.`func`, unexpectedBetweenFuncKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndSignature: ExpressibleAsUnexpectedNodes? = nil, signature: ExpressibleAsFunctionSignature, unexpectedBetweenSignatureAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock? = nil) {
    assert(funcKeyword.text == #"func"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes?.createUnexpectedNodes(), attributes: attributes?.createAttributeList(), unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes(), modifiers: modifiers?.createModifierList(), unexpectedBetweenModifiersAndFuncKeyword: unexpectedBetweenModifiersAndFuncKeyword?.createUnexpectedNodes(), funcKeyword: funcKeyword, unexpectedBetweenFuncKeywordAndIdentifier: unexpectedBetweenFuncKeywordAndIdentifier?.createUnexpectedNodes(), identifier: identifier, unexpectedBetweenIdentifierAndGenericParameterClause: unexpectedBetweenIdentifierAndGenericParameterClause?.createUnexpectedNodes(), genericParameterClause: genericParameterClause?.createGenericParameterClause(), unexpectedBetweenGenericParameterClauseAndSignature: unexpectedBetweenGenericParameterClauseAndSignature?.createUnexpectedNodes(), signature: signature.createFunctionSignature(), unexpectedBetweenSignatureAndGenericWhereClause: unexpectedBetweenSignatureAndGenericWhereClause?.createUnexpectedNodes(), genericWhereClause: genericWhereClause?.createGenericWhereClause(), unexpectedBetweenGenericWhereClauseAndBody: unexpectedBetweenGenericWhereClauseAndBody?.createUnexpectedNodes(), body: body?.createCodeBlock()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndFuncKeyword: ExpressibleAsUnexpectedNodes? = nil, funcKeyword: Token = Token.`func`, unexpectedBetweenFuncKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndSignature: ExpressibleAsUnexpectedNodes? = nil, signature: ExpressibleAsFunctionSignature, unexpectedBetweenSignatureAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndBody: ExpressibleAsUnexpectedNodes? = nil, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList? =  {
    nil
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndFuncKeyword: unexpectedBetweenModifiersAndFuncKeyword, funcKeyword: funcKeyword, unexpectedBetweenFuncKeywordAndIdentifier: unexpectedBetweenFuncKeywordAndIdentifier, identifier: identifier, unexpectedBetweenIdentifierAndGenericParameterClause: unexpectedBetweenIdentifierAndGenericParameterClause, genericParameterClause: genericParameterClause, unexpectedBetweenGenericParameterClauseAndSignature: unexpectedBetweenGenericParameterClauseAndSignature, signature: signature, unexpectedBetweenSignatureAndGenericWhereClause: unexpectedBetweenSignatureAndGenericWhereClause, genericWhereClause: genericWhereClause, unexpectedBetweenGenericWhereClauseAndBody: unexpectedBetweenGenericWhereClauseAndBody, body: bodyBuilder())
  }
  public init(_ constructedNode: FunctionDeclSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `FunctionDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `FunctionDeclSyntax`.
  func buildFunctionDecl(format: Format) -> FunctionDeclSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = FunctionDeclSyntax(buildableData.unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: buildableData.attributes?.buildAttributeList(format: format), buildableData.unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format), modifiers: buildableData.modifiers?.buildModifierList(format: format), buildableData.unexpectedBetweenModifiersAndFuncKeyword?.buildUnexpectedNodes(format: format), funcKeyword: buildableData.funcKeyword.buildToken(format: format), buildableData.unexpectedBetweenFuncKeywordAndIdentifier?.buildUnexpectedNodes(format: format), identifier: buildableData.identifier.buildToken(format: format), buildableData.unexpectedBetweenIdentifierAndGenericParameterClause?.buildUnexpectedNodes(format: format), genericParameterClause: buildableData.genericParameterClause?.buildGenericParameterClause(format: format), buildableData.unexpectedBetweenGenericParameterClauseAndSignature?.buildUnexpectedNodes(format: format), signature: buildableData.signature.buildFunctionSignature(format: format), buildableData.unexpectedBetweenSignatureAndGenericWhereClause?.buildUnexpectedNodes(format: format), genericWhereClause: buildableData.genericWhereClause?.buildGenericWhereClause(format: format), buildableData.unexpectedBetweenGenericWhereClauseAndBody?.buildUnexpectedNodes(format: format), body: buildableData.body?.buildCodeBlock(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildFunctionDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsFunctionDecl`.
  public func createFunctionDecl() -> FunctionDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `FunctionDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct InitializerDecl: DeclBuildable, ExpressibleAsInitializerDecl {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeAttributes: UnexpectedNodes?
    var attributes: AttributeList?
    var unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
    var modifiers: ModifierList?
    var unexpectedBetweenModifiersAndInitKeyword: UnexpectedNodes?
    var initKeyword: Token
    var unexpectedBetweenInitKeywordAndOptionalMark: UnexpectedNodes?
    var optionalMark: Token?
    var unexpectedBetweenOptionalMarkAndGenericParameterClause: UnexpectedNodes?
    var genericParameterClause: GenericParameterClause?
    var unexpectedBetweenGenericParameterClauseAndSignature: UnexpectedNodes?
    var signature: FunctionSignature
    var unexpectedBetweenSignatureAndGenericWhereClause: UnexpectedNodes?
    var genericWhereClause: GenericWhereClause?
    var unexpectedBetweenGenericWhereClauseAndBody: UnexpectedNodes?
    var body: CodeBlock?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(InitializerDeclSyntax)
  }
  private var data: Data
  /// Creates a `InitializerDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndInitKeyword: 
  ///   - initKeyword: 
  ///   - unexpectedBetweenInitKeywordAndOptionalMark: 
  ///   - optionalMark: 
  ///   - unexpectedBetweenOptionalMarkAndGenericParameterClause: 
  ///   - genericParameterClause: 
  ///   - unexpectedBetweenGenericParameterClauseAndSignature: 
  ///   - signature: 
  ///   - unexpectedBetweenSignatureAndGenericWhereClause: 
  ///   - genericWhereClause: 
  ///   - unexpectedBetweenGenericWhereClauseAndBody: 
  ///   - body: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndInitKeyword: ExpressibleAsUnexpectedNodes? = nil, initKeyword: Token = Token.`init`, unexpectedBetweenInitKeywordAndOptionalMark: ExpressibleAsUnexpectedNodes? = nil, optionalMark: Token? = nil, unexpectedBetweenOptionalMarkAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndSignature: ExpressibleAsUnexpectedNodes? = nil, signature: ExpressibleAsFunctionSignature, unexpectedBetweenSignatureAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock? = nil) {
    assert(initKeyword.text == #"init"#)
    assert(optionalMark == nil || optionalMark!.text == #"?"# || optionalMark!.text == #"?"# || optionalMark!.text == #"!"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes?.createUnexpectedNodes(), attributes: attributes?.createAttributeList(), unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes(), modifiers: modifiers?.createModifierList(), unexpectedBetweenModifiersAndInitKeyword: unexpectedBetweenModifiersAndInitKeyword?.createUnexpectedNodes(), initKeyword: initKeyword, unexpectedBetweenInitKeywordAndOptionalMark: unexpectedBetweenInitKeywordAndOptionalMark?.createUnexpectedNodes(), optionalMark: optionalMark, unexpectedBetweenOptionalMarkAndGenericParameterClause: unexpectedBetweenOptionalMarkAndGenericParameterClause?.createUnexpectedNodes(), genericParameterClause: genericParameterClause?.createGenericParameterClause(), unexpectedBetweenGenericParameterClauseAndSignature: unexpectedBetweenGenericParameterClauseAndSignature?.createUnexpectedNodes(), signature: signature.createFunctionSignature(), unexpectedBetweenSignatureAndGenericWhereClause: unexpectedBetweenSignatureAndGenericWhereClause?.createUnexpectedNodes(), genericWhereClause: genericWhereClause?.createGenericWhereClause(), unexpectedBetweenGenericWhereClauseAndBody: unexpectedBetweenGenericWhereClauseAndBody?.createUnexpectedNodes(), body: body?.createCodeBlock()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndInitKeyword: ExpressibleAsUnexpectedNodes? = nil, initKeyword: Token = Token.`init`, unexpectedBetweenInitKeywordAndOptionalMark: ExpressibleAsUnexpectedNodes? = nil, optionalMark: Token? = nil, unexpectedBetweenOptionalMarkAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndSignature: ExpressibleAsUnexpectedNodes? = nil, signature: ExpressibleAsFunctionSignature, unexpectedBetweenSignatureAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndBody: ExpressibleAsUnexpectedNodes? = nil, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList? =  {
    nil
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndInitKeyword: unexpectedBetweenModifiersAndInitKeyword, initKeyword: initKeyword, unexpectedBetweenInitKeywordAndOptionalMark: unexpectedBetweenInitKeywordAndOptionalMark, optionalMark: optionalMark, unexpectedBetweenOptionalMarkAndGenericParameterClause: unexpectedBetweenOptionalMarkAndGenericParameterClause, genericParameterClause: genericParameterClause, unexpectedBetweenGenericParameterClauseAndSignature: unexpectedBetweenGenericParameterClauseAndSignature, signature: signature, unexpectedBetweenSignatureAndGenericWhereClause: unexpectedBetweenSignatureAndGenericWhereClause, genericWhereClause: genericWhereClause, unexpectedBetweenGenericWhereClauseAndBody: unexpectedBetweenGenericWhereClauseAndBody, body: bodyBuilder())
  }
  public init(_ constructedNode: InitializerDeclSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `InitializerDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `InitializerDeclSyntax`.
  func buildInitializerDecl(format: Format) -> InitializerDeclSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = InitializerDeclSyntax(buildableData.unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: buildableData.attributes?.buildAttributeList(format: format), buildableData.unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format), modifiers: buildableData.modifiers?.buildModifierList(format: format), buildableData.unexpectedBetweenModifiersAndInitKeyword?.buildUnexpectedNodes(format: format), initKeyword: buildableData.initKeyword.buildToken(format: format), buildableData.unexpectedBetweenInitKeywordAndOptionalMark?.buildUnexpectedNodes(format: format), optionalMark: buildableData.optionalMark?.buildToken(format: format), buildableData.unexpectedBetweenOptionalMarkAndGenericParameterClause?.buildUnexpectedNodes(format: format), genericParameterClause: buildableData.genericParameterClause?.buildGenericParameterClause(format: format), buildableData.unexpectedBetweenGenericParameterClauseAndSignature?.buildUnexpectedNodes(format: format), signature: buildableData.signature.buildFunctionSignature(format: format), buildableData.unexpectedBetweenSignatureAndGenericWhereClause?.buildUnexpectedNodes(format: format), genericWhereClause: buildableData.genericWhereClause?.buildGenericWhereClause(format: format), buildableData.unexpectedBetweenGenericWhereClauseAndBody?.buildUnexpectedNodes(format: format), body: buildableData.body?.buildCodeBlock(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildInitializerDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsInitializerDecl`.
  public func createInitializerDecl() -> InitializerDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `InitializerDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct DeinitializerDecl: DeclBuildable, ExpressibleAsDeinitializerDecl {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeAttributes: UnexpectedNodes?
    var attributes: AttributeList?
    var unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
    var modifiers: ModifierList?
    var unexpectedBetweenModifiersAndDeinitKeyword: UnexpectedNodes?
    var deinitKeyword: Token
    var unexpectedBetweenDeinitKeywordAndBody: UnexpectedNodes?
    var body: CodeBlock?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(DeinitializerDeclSyntax)
  }
  private var data: Data
  /// Creates a `DeinitializerDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndDeinitKeyword: 
  ///   - deinitKeyword: 
  ///   - unexpectedBetweenDeinitKeywordAndBody: 
  ///   - body: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndDeinitKeyword: ExpressibleAsUnexpectedNodes? = nil, deinitKeyword: Token = Token.`deinit`, unexpectedBetweenDeinitKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock? = nil) {
    assert(deinitKeyword.text == #"deinit"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes?.createUnexpectedNodes(), attributes: attributes?.createAttributeList(), unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes(), modifiers: modifiers?.createModifierList(), unexpectedBetweenModifiersAndDeinitKeyword: unexpectedBetweenModifiersAndDeinitKeyword?.createUnexpectedNodes(), deinitKeyword: deinitKeyword, unexpectedBetweenDeinitKeywordAndBody: unexpectedBetweenDeinitKeywordAndBody?.createUnexpectedNodes(), body: body?.createCodeBlock()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndDeinitKeyword: ExpressibleAsUnexpectedNodes? = nil, deinitKeyword: Token = Token.`deinit`, unexpectedBetweenDeinitKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList? =  {
    nil
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndDeinitKeyword: unexpectedBetweenModifiersAndDeinitKeyword, deinitKeyword: deinitKeyword, unexpectedBetweenDeinitKeywordAndBody: unexpectedBetweenDeinitKeywordAndBody, body: bodyBuilder())
  }
  public init(_ constructedNode: DeinitializerDeclSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `DeinitializerDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DeinitializerDeclSyntax`.
  func buildDeinitializerDecl(format: Format) -> DeinitializerDeclSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = DeinitializerDeclSyntax(buildableData.unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: buildableData.attributes?.buildAttributeList(format: format), buildableData.unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format), modifiers: buildableData.modifiers?.buildModifierList(format: format), buildableData.unexpectedBetweenModifiersAndDeinitKeyword?.buildUnexpectedNodes(format: format), deinitKeyword: buildableData.deinitKeyword.buildToken(format: format), buildableData.unexpectedBetweenDeinitKeywordAndBody?.buildUnexpectedNodes(format: format), body: buildableData.body?.buildCodeBlock(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildDeinitializerDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsDeinitializerDecl`.
  public func createDeinitializerDecl() -> DeinitializerDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `DeinitializerDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct SubscriptDecl: DeclBuildable, ExpressibleAsSubscriptDecl {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeAttributes: UnexpectedNodes?
    var attributes: AttributeList?
    var unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
    var modifiers: ModifierList?
    var unexpectedBetweenModifiersAndSubscriptKeyword: UnexpectedNodes?
    var subscriptKeyword: Token
    var unexpectedBetweenSubscriptKeywordAndGenericParameterClause: UnexpectedNodes?
    var genericParameterClause: GenericParameterClause?
    var unexpectedBetweenGenericParameterClauseAndIndices: UnexpectedNodes?
    var indices: ParameterClause
    var unexpectedBetweenIndicesAndResult: UnexpectedNodes?
    var result: ReturnClause
    var unexpectedBetweenResultAndGenericWhereClause: UnexpectedNodes?
    var genericWhereClause: GenericWhereClause?
    var unexpectedBetweenGenericWhereClauseAndAccessor: UnexpectedNodes?
    var accessor: SyntaxBuildable?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(SubscriptDeclSyntax)
  }
  private var data: Data
  /// Creates a `SubscriptDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndSubscriptKeyword: 
  ///   - subscriptKeyword: 
  ///   - unexpectedBetweenSubscriptKeywordAndGenericParameterClause: 
  ///   - genericParameterClause: 
  ///   - unexpectedBetweenGenericParameterClauseAndIndices: 
  ///   - indices: 
  ///   - unexpectedBetweenIndicesAndResult: 
  ///   - result: 
  ///   - unexpectedBetweenResultAndGenericWhereClause: 
  ///   - genericWhereClause: 
  ///   - unexpectedBetweenGenericWhereClauseAndAccessor: 
  ///   - accessor: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndSubscriptKeyword: ExpressibleAsUnexpectedNodes? = nil, subscriptKeyword: Token = Token.`subscript`, unexpectedBetweenSubscriptKeywordAndGenericParameterClause: ExpressibleAsUnexpectedNodes? = nil, genericParameterClause: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParameterClauseAndIndices: ExpressibleAsUnexpectedNodes? = nil, indices: ExpressibleAsParameterClause, unexpectedBetweenIndicesAndResult: ExpressibleAsUnexpectedNodes? = nil, result: ExpressibleAsReturnClause, unexpectedBetweenResultAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndAccessor: ExpressibleAsUnexpectedNodes? = nil, accessor: ExpressibleAsSyntaxBuildable? = nil) {
    assert(subscriptKeyword.text == #"subscript"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes?.createUnexpectedNodes(), attributes: attributes?.createAttributeList(), unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes(), modifiers: modifiers?.createModifierList(), unexpectedBetweenModifiersAndSubscriptKeyword: unexpectedBetweenModifiersAndSubscriptKeyword?.createUnexpectedNodes(), subscriptKeyword: subscriptKeyword, unexpectedBetweenSubscriptKeywordAndGenericParameterClause: unexpectedBetweenSubscriptKeywordAndGenericParameterClause?.createUnexpectedNodes(), genericParameterClause: genericParameterClause?.createGenericParameterClause(), unexpectedBetweenGenericParameterClauseAndIndices: unexpectedBetweenGenericParameterClauseAndIndices?.createUnexpectedNodes(), indices: indices.createParameterClause(), unexpectedBetweenIndicesAndResult: unexpectedBetweenIndicesAndResult?.createUnexpectedNodes(), result: result.createReturnClause(), unexpectedBetweenResultAndGenericWhereClause: unexpectedBetweenResultAndGenericWhereClause?.createUnexpectedNodes(), genericWhereClause: genericWhereClause?.createGenericWhereClause(), unexpectedBetweenGenericWhereClauseAndAccessor: unexpectedBetweenGenericWhereClauseAndAccessor?.createUnexpectedNodes(), accessor: accessor?.createSyntaxBuildable()))
  }
  public init(_ constructedNode: SubscriptDeclSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `SubscriptDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SubscriptDeclSyntax`.
  func buildSubscriptDecl(format: Format) -> SubscriptDeclSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = SubscriptDeclSyntax(buildableData.unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: buildableData.attributes?.buildAttributeList(format: format), buildableData.unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format), modifiers: buildableData.modifiers?.buildModifierList(format: format), buildableData.unexpectedBetweenModifiersAndSubscriptKeyword?.buildUnexpectedNodes(format: format), subscriptKeyword: buildableData.subscriptKeyword.buildToken(format: format), buildableData.unexpectedBetweenSubscriptKeywordAndGenericParameterClause?.buildUnexpectedNodes(format: format), genericParameterClause: buildableData.genericParameterClause?.buildGenericParameterClause(format: format), buildableData.unexpectedBetweenGenericParameterClauseAndIndices?.buildUnexpectedNodes(format: format), indices: buildableData.indices.buildParameterClause(format: format), buildableData.unexpectedBetweenIndicesAndResult?.buildUnexpectedNodes(format: format), result: buildableData.result.buildReturnClause(format: format), buildableData.unexpectedBetweenResultAndGenericWhereClause?.buildUnexpectedNodes(format: format), genericWhereClause: buildableData.genericWhereClause?.buildGenericWhereClause(format: format), buildableData.unexpectedBetweenGenericWhereClauseAndAccessor?.buildUnexpectedNodes(format: format), accessor: buildableData.accessor?.buildSyntax(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildSubscriptDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsSubscriptDecl`.
  public func createSubscriptDecl() -> SubscriptDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `SubscriptDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct AccessLevelModifier: SyntaxBuildable, ExpressibleAsAccessLevelModifier {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeName: UnexpectedNodes?
    var name: Token
    var unexpectedBetweenNameAndModifier: UnexpectedNodes?
    var modifier: DeclModifierDetail?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(AccessLevelModifierSyntax)
  }
  private var data: Data
  /// Creates a `AccessLevelModifier` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndModifier: 
  ///   - modifier: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndModifier: ExpressibleAsUnexpectedNodes? = nil, modifier: ExpressibleAsDeclModifierDetail? = nil) {
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeName: unexpectedBeforeName?.createUnexpectedNodes(), name: name, unexpectedBetweenNameAndModifier: unexpectedBetweenNameAndModifier?.createUnexpectedNodes(), modifier: modifier?.createDeclModifierDetail()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: String, unexpectedBetweenNameAndModifier: ExpressibleAsUnexpectedNodes? = nil, modifier: ExpressibleAsDeclModifierDetail? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeName: unexpectedBeforeName, name: Token.`identifier`(name), unexpectedBetweenNameAndModifier: unexpectedBetweenNameAndModifier, modifier: modifier)
  }
  public init(_ constructedNode: AccessLevelModifierSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `AccessLevelModifierSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AccessLevelModifierSyntax`.
  func buildAccessLevelModifier(format: Format) -> AccessLevelModifierSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = AccessLevelModifierSyntax(buildableData.unexpectedBeforeName?.buildUnexpectedNodes(format: format), name: buildableData.name.buildToken(format: format), buildableData.unexpectedBetweenNameAndModifier?.buildUnexpectedNodes(format: format), modifier: buildableData.modifier?.buildDeclModifierDetail(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildAccessLevelModifier(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsAccessLevelModifier`.
  public func createAccessLevelModifier() -> AccessLevelModifier {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `AccessLevelModifier` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct AccessPathComponent: SyntaxBuildable, ExpressibleAsAccessPathComponent {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeName: UnexpectedNodes?
    var name: Token
    var unexpectedBetweenNameAndTrailingDot: UnexpectedNodes?
    var trailingDot: Token?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(AccessPathComponentSyntax)
  }
  private var data: Data
  /// Creates a `AccessPathComponent` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndTrailingDot: 
  ///   - trailingDot: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndTrailingDot: ExpressibleAsUnexpectedNodes? = nil, trailingDot: Token? = nil) {
    assert(trailingDot == nil || trailingDot!.text == #"."#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeName: unexpectedBeforeName?.createUnexpectedNodes(), name: name, unexpectedBetweenNameAndTrailingDot: unexpectedBetweenNameAndTrailingDot?.createUnexpectedNodes(), trailingDot: trailingDot))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: String, unexpectedBetweenNameAndTrailingDot: ExpressibleAsUnexpectedNodes? = nil, trailingDot: Token? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeName: unexpectedBeforeName, name: Token.`identifier`(name), unexpectedBetweenNameAndTrailingDot: unexpectedBetweenNameAndTrailingDot, trailingDot: trailingDot)
  }
  public init(_ constructedNode: AccessPathComponentSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `AccessPathComponentSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AccessPathComponentSyntax`.
  func buildAccessPathComponent(format: Format) -> AccessPathComponentSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = AccessPathComponentSyntax(buildableData.unexpectedBeforeName?.buildUnexpectedNodes(format: format), name: buildableData.name.buildToken(format: format), buildableData.unexpectedBetweenNameAndTrailingDot?.buildUnexpectedNodes(format: format), trailingDot: buildableData.trailingDot?.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildAccessPathComponent(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsAccessPathComponent`.
  public func createAccessPathComponent() -> AccessPathComponent {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `AccessPathComponent` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct ImportDecl: DeclBuildable, ExpressibleAsImportDecl {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeAttributes: UnexpectedNodes?
    var attributes: AttributeList?
    var unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
    var modifiers: ModifierList?
    var unexpectedBetweenModifiersAndImportTok: UnexpectedNodes?
    var importTok: Token
    var unexpectedBetweenImportTokAndImportKind: UnexpectedNodes?
    var importKind: Token?
    var unexpectedBetweenImportKindAndPath: UnexpectedNodes?
    var path: AccessPath
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ImportDeclSyntax)
  }
  private var data: Data
  /// Creates a `ImportDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndImportTok: 
  ///   - importTok: 
  ///   - unexpectedBetweenImportTokAndImportKind: 
  ///   - importKind: 
  ///   - unexpectedBetweenImportKindAndPath: 
  ///   - path: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndImportTok: ExpressibleAsUnexpectedNodes? = nil, importTok: Token = Token.`import`, unexpectedBetweenImportTokAndImportKind: ExpressibleAsUnexpectedNodes? = nil, importKind: Token? = nil, unexpectedBetweenImportKindAndPath: ExpressibleAsUnexpectedNodes? = nil, path: ExpressibleAsAccessPath) {
    assert(importTok.text == #"import"#)
    assert(importKind == nil || importKind!.text == #"typealias"# || importKind!.text == #"struct"# || importKind!.text == #"class"# || importKind!.text == #"enum"# || importKind!.text == #"protocol"# || importKind!.text == #"var"# || importKind!.text == #"let"# || importKind!.text == #"func"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes?.createUnexpectedNodes(), attributes: attributes?.createAttributeList(), unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes(), modifiers: modifiers?.createModifierList(), unexpectedBetweenModifiersAndImportTok: unexpectedBetweenModifiersAndImportTok?.createUnexpectedNodes(), importTok: importTok, unexpectedBetweenImportTokAndImportKind: unexpectedBetweenImportTokAndImportKind?.createUnexpectedNodes(), importKind: importKind, unexpectedBetweenImportKindAndPath: unexpectedBetweenImportKindAndPath?.createUnexpectedNodes(), path: path.createAccessPath()))
  }
  public init(_ constructedNode: ImportDeclSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ImportDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ImportDeclSyntax`.
  func buildImportDecl(format: Format) -> ImportDeclSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ImportDeclSyntax(buildableData.unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: buildableData.attributes?.buildAttributeList(format: format), buildableData.unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format), modifiers: buildableData.modifiers?.buildModifierList(format: format), buildableData.unexpectedBetweenModifiersAndImportTok?.buildUnexpectedNodes(format: format), importTok: buildableData.importTok.buildToken(format: format), buildableData.unexpectedBetweenImportTokAndImportKind?.buildUnexpectedNodes(format: format), importKind: buildableData.importKind?.buildToken(format: format), buildableData.unexpectedBetweenImportKindAndPath?.buildUnexpectedNodes(format: format), path: buildableData.path.buildAccessPath(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildImportDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsImportDecl`.
  public func createImportDecl() -> ImportDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `ImportDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct AccessorParameter: SyntaxBuildable, ExpressibleAsAccessorParameter {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeLeftParen: UnexpectedNodes?
    var leftParen: Token
    var unexpectedBetweenLeftParenAndName: UnexpectedNodes?
    var name: Token
    var unexpectedBetweenNameAndRightParen: UnexpectedNodes?
    var rightParen: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(AccessorParameterSyntax)
  }
  private var data: Data
  /// Creates a `AccessorParameter` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    assert(leftParen.text == #"("#)
    assert(rightParen.text == #")"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeLeftParen: unexpectedBeforeLeftParen?.createUnexpectedNodes(), leftParen: leftParen, unexpectedBetweenLeftParenAndName: unexpectedBetweenLeftParenAndName?.createUnexpectedNodes(), name: name, unexpectedBetweenNameAndRightParen: unexpectedBetweenNameAndRightParen?.createUnexpectedNodes(), rightParen: rightParen))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndName: ExpressibleAsUnexpectedNodes? = nil, name: String, unexpectedBetweenNameAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftParen: unexpectedBeforeLeftParen, leftParen: leftParen, unexpectedBetweenLeftParenAndName: unexpectedBetweenLeftParenAndName, name: Token.`identifier`(name), unexpectedBetweenNameAndRightParen: unexpectedBetweenNameAndRightParen, rightParen: rightParen)
  }
  public init(_ constructedNode: AccessorParameterSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `AccessorParameterSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AccessorParameterSyntax`.
  func buildAccessorParameter(format: Format) -> AccessorParameterSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = AccessorParameterSyntax(buildableData.unexpectedBeforeLeftParen?.buildUnexpectedNodes(format: format), leftParen: buildableData.leftParen.buildToken(format: format), buildableData.unexpectedBetweenLeftParenAndName?.buildUnexpectedNodes(format: format), name: buildableData.name.buildToken(format: format), buildableData.unexpectedBetweenNameAndRightParen?.buildUnexpectedNodes(format: format), rightParen: buildableData.rightParen.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildAccessorParameter(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsAccessorParameter`.
  public func createAccessorParameter() -> AccessorParameter {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `AccessorParameter` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct AccessorDecl: DeclBuildable, ExpressibleAsAccessorDecl {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeAttributes: UnexpectedNodes?
    var attributes: AttributeList?
    var unexpectedBetweenAttributesAndModifier: UnexpectedNodes?
    var modifier: DeclModifier?
    var unexpectedBetweenModifierAndAccessorKind: UnexpectedNodes?
    var accessorKind: Token
    var unexpectedBetweenAccessorKindAndParameter: UnexpectedNodes?
    var parameter: AccessorParameter?
    var unexpectedBetweenParameterAndAsyncKeyword: UnexpectedNodes?
    var asyncKeyword: Token?
    var unexpectedBetweenAsyncKeywordAndThrowsKeyword: UnexpectedNodes?
    var throwsKeyword: Token?
    var unexpectedBetweenThrowsKeywordAndBody: UnexpectedNodes?
    var body: CodeBlock?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(AccessorDeclSyntax)
  }
  private var data: Data
  /// Creates a `AccessorDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifier: 
  ///   - modifier: 
  ///   - unexpectedBetweenModifierAndAccessorKind: 
  ///   - accessorKind: 
  ///   - unexpectedBetweenAccessorKindAndParameter: 
  ///   - parameter: 
  ///   - unexpectedBetweenParameterAndAsyncKeyword: 
  ///   - asyncKeyword: 
  ///   - unexpectedBetweenAsyncKeywordAndThrowsKeyword: 
  ///   - throwsKeyword: 
  ///   - unexpectedBetweenThrowsKeywordAndBody: 
  ///   - body: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifier: ExpressibleAsUnexpectedNodes? = nil, modifier: ExpressibleAsDeclModifier? = nil, unexpectedBetweenModifierAndAccessorKind: ExpressibleAsUnexpectedNodes? = nil, accessorKind: Token, unexpectedBetweenAccessorKindAndParameter: ExpressibleAsUnexpectedNodes? = nil, parameter: ExpressibleAsAccessorParameter? = nil, unexpectedBetweenParameterAndAsyncKeyword: ExpressibleAsUnexpectedNodes? = nil, asyncKeyword: Token? = nil, unexpectedBetweenAsyncKeywordAndThrowsKeyword: ExpressibleAsUnexpectedNodes? = nil, throwsKeyword: Token? = nil, unexpectedBetweenThrowsKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock? = nil) {
    assert(accessorKind.text == #"get"# || accessorKind.text == #"set"# || accessorKind.text == #"didSet"# || accessorKind.text == #"willSet"# || accessorKind.text == #"unsafeAddress"# || accessorKind.text == #"addressWithOwner"# || accessorKind.text == #"addressWithNativeOwner"# || accessorKind.text == #"unsafeMutableAddress"# || accessorKind.text == #"mutableAddressWithOwner"# || accessorKind.text == #"mutableAddressWithNativeOwner"# || accessorKind.text == #"_read"# || accessorKind.text == #"_modify"#)
    assert(asyncKeyword == nil || asyncKeyword!.text == #"async"#)
    assert(throwsKeyword == nil || throwsKeyword!.text == #"throws"# || throwsKeyword!.text == #"rethrows"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes?.createUnexpectedNodes(), attributes: attributes?.createAttributeList(), unexpectedBetweenAttributesAndModifier: unexpectedBetweenAttributesAndModifier?.createUnexpectedNodes(), modifier: modifier?.createDeclModifier(), unexpectedBetweenModifierAndAccessorKind: unexpectedBetweenModifierAndAccessorKind?.createUnexpectedNodes(), accessorKind: accessorKind, unexpectedBetweenAccessorKindAndParameter: unexpectedBetweenAccessorKindAndParameter?.createUnexpectedNodes(), parameter: parameter?.createAccessorParameter(), unexpectedBetweenParameterAndAsyncKeyword: unexpectedBetweenParameterAndAsyncKeyword?.createUnexpectedNodes(), asyncKeyword: asyncKeyword, unexpectedBetweenAsyncKeywordAndThrowsKeyword: unexpectedBetweenAsyncKeywordAndThrowsKeyword?.createUnexpectedNodes(), throwsKeyword: throwsKeyword, unexpectedBetweenThrowsKeywordAndBody: unexpectedBetweenThrowsKeywordAndBody?.createUnexpectedNodes(), body: body?.createCodeBlock()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifier: ExpressibleAsUnexpectedNodes? = nil, modifier: ExpressibleAsDeclModifier? = nil, unexpectedBetweenModifierAndAccessorKind: ExpressibleAsUnexpectedNodes? = nil, accessorKind: Token, unexpectedBetweenAccessorKindAndParameter: ExpressibleAsUnexpectedNodes? = nil, parameter: ExpressibleAsAccessorParameter? = nil, unexpectedBetweenParameterAndAsyncKeyword: ExpressibleAsUnexpectedNodes? = nil, asyncKeyword: String?, unexpectedBetweenAsyncKeywordAndThrowsKeyword: ExpressibleAsUnexpectedNodes? = nil, throwsKeyword: Token? = nil, unexpectedBetweenThrowsKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList? =  {
    nil
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifier: unexpectedBetweenAttributesAndModifier, modifier: modifier, unexpectedBetweenModifierAndAccessorKind: unexpectedBetweenModifierAndAccessorKind, accessorKind: accessorKind, unexpectedBetweenAccessorKindAndParameter: unexpectedBetweenAccessorKindAndParameter, parameter: parameter, unexpectedBetweenParameterAndAsyncKeyword: unexpectedBetweenParameterAndAsyncKeyword, asyncKeyword: asyncKeyword.map { Token.`contextualKeyword`($0) }, unexpectedBetweenAsyncKeywordAndThrowsKeyword: unexpectedBetweenAsyncKeywordAndThrowsKeyword, throwsKeyword: throwsKeyword, unexpectedBetweenThrowsKeywordAndBody: unexpectedBetweenThrowsKeywordAndBody, body: bodyBuilder())
  }
  public init(_ constructedNode: AccessorDeclSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `AccessorDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AccessorDeclSyntax`.
  func buildAccessorDecl(format: Format) -> AccessorDeclSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = AccessorDeclSyntax(buildableData.unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: buildableData.attributes?.buildAttributeList(format: format), buildableData.unexpectedBetweenAttributesAndModifier?.buildUnexpectedNodes(format: format), modifier: buildableData.modifier?.buildDeclModifier(format: format), buildableData.unexpectedBetweenModifierAndAccessorKind?.buildUnexpectedNodes(format: format), accessorKind: buildableData.accessorKind.buildToken(format: format), buildableData.unexpectedBetweenAccessorKindAndParameter?.buildUnexpectedNodes(format: format), parameter: buildableData.parameter?.buildAccessorParameter(format: format), buildableData.unexpectedBetweenParameterAndAsyncKeyword?.buildUnexpectedNodes(format: format), asyncKeyword: buildableData.asyncKeyword?.buildToken(format: format), buildableData.unexpectedBetweenAsyncKeywordAndThrowsKeyword?.buildUnexpectedNodes(format: format), throwsKeyword: buildableData.throwsKeyword?.buildToken(format: format), buildableData.unexpectedBetweenThrowsKeywordAndBody?.buildUnexpectedNodes(format: format), body: buildableData.body?.buildCodeBlock(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildAccessorDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsAccessorDecl`.
  public func createAccessorDecl() -> AccessorDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `AccessorDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct AccessorBlock: SyntaxBuildable, ExpressibleAsAccessorBlock {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeLeftBrace: UnexpectedNodes?
    var leftBrace: Token
    var unexpectedBetweenLeftBraceAndAccessors: UnexpectedNodes?
    var accessors: AccessorList
    var unexpectedBetweenAccessorsAndRightBrace: UnexpectedNodes?
    var rightBrace: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(AccessorBlockSyntax)
  }
  private var data: Data
  /// Creates a `AccessorBlock` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftBrace: 
  ///   - leftBrace: 
  ///   - unexpectedBetweenLeftBraceAndAccessors: 
  ///   - accessors: 
  ///   - unexpectedBetweenAccessorsAndRightBrace: 
  ///   - rightBrace: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftBrace: ExpressibleAsUnexpectedNodes? = nil, leftBrace: Token = Token.`leftBrace`, unexpectedBetweenLeftBraceAndAccessors: ExpressibleAsUnexpectedNodes? = nil, accessors: ExpressibleAsAccessorList, unexpectedBetweenAccessorsAndRightBrace: ExpressibleAsUnexpectedNodes? = nil, rightBrace: Token = Token.`rightBrace`) {
    assert(leftBrace.text == #"{"#)
    assert(rightBrace.text == #"}"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeLeftBrace: unexpectedBeforeLeftBrace?.createUnexpectedNodes(), leftBrace: leftBrace, unexpectedBetweenLeftBraceAndAccessors: unexpectedBetweenLeftBraceAndAccessors?.createUnexpectedNodes(), accessors: accessors.createAccessorList(), unexpectedBetweenAccessorsAndRightBrace: unexpectedBetweenAccessorsAndRightBrace?.createUnexpectedNodes(), rightBrace: rightBrace))
  }
  public init(_ constructedNode: AccessorBlockSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `AccessorBlockSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AccessorBlockSyntax`.
  func buildAccessorBlock(format: Format) -> AccessorBlockSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = AccessorBlockSyntax(buildableData.unexpectedBeforeLeftBrace?.buildUnexpectedNodes(format: format), leftBrace: buildableData.leftBrace.buildToken(format: format), buildableData.unexpectedBetweenLeftBraceAndAccessors?.buildUnexpectedNodes(format: format), accessors: buildableData.accessors.buildAccessorList(format: format), buildableData.unexpectedBetweenAccessorsAndRightBrace?.buildUnexpectedNodes(format: format), rightBrace: buildableData.rightBrace.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildAccessorBlock(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsAccessorBlock`.
  public func createAccessorBlock() -> AccessorBlock {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `AccessorBlock` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct PatternBinding: SyntaxBuildable, ExpressibleAsPatternBinding, HasTrailingComma {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforePattern: UnexpectedNodes?
    var pattern: PatternBuildable
    var unexpectedBetweenPatternAndTypeAnnotation: UnexpectedNodes?
    var typeAnnotation: TypeAnnotation?
    var unexpectedBetweenTypeAnnotationAndInitializer: UnexpectedNodes?
    var initializer: InitializerClause?
    var unexpectedBetweenInitializerAndAccessor: UnexpectedNodes?
    var accessor: SyntaxBuildable?
    var unexpectedBetweenAccessorAndTrailingComma: UnexpectedNodes?
    var trailingComma: Token?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(PatternBindingSyntax)
  }
  private var data: Data
  var hasTrailingComma: Bool {
    switch data {
    case .buildable(let buildableData):
      return buildableData.trailingComma != nil
    case .constructed(let node):
      return node.trailingComma != nil
    }
  }
  /// Creates a `PatternBinding` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePattern: 
  ///   - pattern: 
  ///   - unexpectedBetweenPatternAndTypeAnnotation: 
  ///   - typeAnnotation: 
  ///   - unexpectedBetweenTypeAnnotationAndInitializer: 
  ///   - initializer: 
  ///   - unexpectedBetweenInitializerAndAccessor: 
  ///   - accessor: 
  ///   - unexpectedBetweenAccessorAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePattern: ExpressibleAsUnexpectedNodes? = nil, pattern: ExpressibleAsPatternBuildable, unexpectedBetweenPatternAndTypeAnnotation: ExpressibleAsUnexpectedNodes? = nil, typeAnnotation: ExpressibleAsTypeAnnotation? = nil, unexpectedBetweenTypeAnnotationAndInitializer: ExpressibleAsUnexpectedNodes? = nil, initializer: ExpressibleAsInitializerClause? = nil, unexpectedBetweenInitializerAndAccessor: ExpressibleAsUnexpectedNodes? = nil, accessor: ExpressibleAsSyntaxBuildable? = nil, unexpectedBetweenAccessorAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    assert(trailingComma == nil || trailingComma!.text == #","#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforePattern: unexpectedBeforePattern?.createUnexpectedNodes(), pattern: pattern.createPatternBuildable(), unexpectedBetweenPatternAndTypeAnnotation: unexpectedBetweenPatternAndTypeAnnotation?.createUnexpectedNodes(), typeAnnotation: typeAnnotation?.createTypeAnnotation(), unexpectedBetweenTypeAnnotationAndInitializer: unexpectedBetweenTypeAnnotationAndInitializer?.createUnexpectedNodes(), initializer: initializer?.createInitializerClause(), unexpectedBetweenInitializerAndAccessor: unexpectedBetweenInitializerAndAccessor?.createUnexpectedNodes(), accessor: accessor?.createSyntaxBuildable(), unexpectedBetweenAccessorAndTrailingComma: unexpectedBetweenAccessorAndTrailingComma?.createUnexpectedNodes(), trailingComma: trailingComma))
  }
  public init(_ constructedNode: PatternBindingSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `PatternBindingSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PatternBindingSyntax`.
  func buildPatternBinding(format: Format) -> PatternBindingSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = PatternBindingSyntax(buildableData.unexpectedBeforePattern?.buildUnexpectedNodes(format: format), pattern: buildableData.pattern.buildPattern(format: format), buildableData.unexpectedBetweenPatternAndTypeAnnotation?.buildUnexpectedNodes(format: format), typeAnnotation: buildableData.typeAnnotation?.buildTypeAnnotation(format: format), buildableData.unexpectedBetweenTypeAnnotationAndInitializer?.buildUnexpectedNodes(format: format), initializer: buildableData.initializer?.buildInitializerClause(format: format), buildableData.unexpectedBetweenInitializerAndAccessor?.buildUnexpectedNodes(format: format), accessor: buildableData.accessor?.buildSyntax(format: format), buildableData.unexpectedBetweenAccessorAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: buildableData.trailingComma?.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildPatternBinding(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsPatternBinding`.
  public func createPatternBinding() -> PatternBinding {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PatternBinding` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingComma = withComma ? .comma : nil
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withComma = node.withTrailingComma(withComma ? .commaToken() : nil)
      var result = self
      result.data = .constructed(withComma)
      return result
    }
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct VariableDecl: DeclBuildable, ExpressibleAsVariableDecl {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeAttributes: UnexpectedNodes?
    var attributes: AttributeList?
    var unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
    var modifiers: ModifierList?
    var unexpectedBetweenModifiersAndLetOrVarKeyword: UnexpectedNodes?
    var letOrVarKeyword: Token
    var unexpectedBetweenLetOrVarKeywordAndBindings: UnexpectedNodes?
    var bindings: PatternBindingList
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(VariableDeclSyntax)
  }
  private var data: Data
  /// Creates a `VariableDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: 
  ///   - unexpectedBetweenModifiersAndLetOrVarKeyword: 
  ///   - letOrVarKeyword: 
  ///   - unexpectedBetweenLetOrVarKeywordAndBindings: 
  ///   - bindings: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndLetOrVarKeyword: ExpressibleAsUnexpectedNodes? = nil, letOrVarKeyword: Token, unexpectedBetweenLetOrVarKeywordAndBindings: ExpressibleAsUnexpectedNodes? = nil, bindings: ExpressibleAsPatternBindingList) {
    assert(letOrVarKeyword.text == #"let"# || letOrVarKeyword.text == #"var"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes?.createUnexpectedNodes(), attributes: attributes?.createAttributeList(), unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes(), modifiers: modifiers?.createModifierList(), unexpectedBetweenModifiersAndLetOrVarKeyword: unexpectedBetweenModifiersAndLetOrVarKeyword?.createUnexpectedNodes(), letOrVarKeyword: letOrVarKeyword, unexpectedBetweenLetOrVarKeywordAndBindings: unexpectedBetweenLetOrVarKeywordAndBindings?.createUnexpectedNodes(), bindings: bindings.createPatternBindingList()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndLetOrVarKeyword: ExpressibleAsUnexpectedNodes? = nil, letOrVarKeyword: Token, unexpectedBetweenLetOrVarKeywordAndBindings: ExpressibleAsUnexpectedNodes? = nil, @PatternBindingListBuilder bindingsBuilder: () -> ExpressibleAsPatternBindingList =  {
    PatternBindingList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndLetOrVarKeyword: unexpectedBetweenModifiersAndLetOrVarKeyword, letOrVarKeyword: letOrVarKeyword, unexpectedBetweenLetOrVarKeywordAndBindings: unexpectedBetweenLetOrVarKeywordAndBindings, bindings: bindingsBuilder())
  }
  public init(_ constructedNode: VariableDeclSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `VariableDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `VariableDeclSyntax`.
  func buildVariableDecl(format: Format) -> VariableDeclSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = VariableDeclSyntax(buildableData.unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: buildableData.attributes?.buildAttributeList(format: format), buildableData.unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format), modifiers: buildableData.modifiers?.buildModifierList(format: format), buildableData.unexpectedBetweenModifiersAndLetOrVarKeyword?.buildUnexpectedNodes(format: format), letOrVarKeyword: buildableData.letOrVarKeyword.buildToken(format: format), buildableData.unexpectedBetweenLetOrVarKeywordAndBindings?.buildUnexpectedNodes(format: format), bindings: buildableData.bindings.buildPatternBindingList(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildVariableDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsVariableDecl`.
  public func createVariableDecl() -> VariableDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `VariableDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
/// An element of an enum case, containing the name of the case and,optionally, either associated values or an assignment to a raw value.
public struct EnumCaseElement: SyntaxBuildable, ExpressibleAsEnumCaseElement, HasTrailingComma {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeIdentifier: UnexpectedNodes?
    var identifier: Token
    var unexpectedBetweenIdentifierAndAssociatedValue: UnexpectedNodes?
    var associatedValue: ParameterClause?
    var unexpectedBetweenAssociatedValueAndRawValue: UnexpectedNodes?
    var rawValue: InitializerClause?
    var unexpectedBetweenRawValueAndTrailingComma: UnexpectedNodes?
    var trailingComma: Token?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(EnumCaseElementSyntax)
  }
  private var data: Data
  var hasTrailingComma: Bool {
    switch data {
    case .buildable(let buildableData):
      return buildableData.trailingComma != nil
    case .constructed(let node):
      return node.trailingComma != nil
    }
  }
  /// Creates a `EnumCaseElement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeIdentifier: 
  ///   - identifier: The name of this case.
  ///   - unexpectedBetweenIdentifierAndAssociatedValue: 
  ///   - associatedValue: The set of associated values of the case.
  ///   - unexpectedBetweenAssociatedValueAndRawValue: 
  ///   - rawValue: The raw value of this enum element, if present.
  ///   - unexpectedBetweenRawValueAndTrailingComma: 
  ///   - trailingComma: The trailing comma of this element, if the case hasmultiple elements.
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndAssociatedValue: ExpressibleAsUnexpectedNodes? = nil, associatedValue: ExpressibleAsParameterClause? = nil, unexpectedBetweenAssociatedValueAndRawValue: ExpressibleAsUnexpectedNodes? = nil, rawValue: ExpressibleAsInitializerClause? = nil, unexpectedBetweenRawValueAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    assert(trailingComma == nil || trailingComma!.text == #","#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeIdentifier: unexpectedBeforeIdentifier?.createUnexpectedNodes(), identifier: identifier, unexpectedBetweenIdentifierAndAssociatedValue: unexpectedBetweenIdentifierAndAssociatedValue?.createUnexpectedNodes(), associatedValue: associatedValue?.createParameterClause(), unexpectedBetweenAssociatedValueAndRawValue: unexpectedBetweenAssociatedValueAndRawValue?.createUnexpectedNodes(), rawValue: rawValue?.createInitializerClause(), unexpectedBetweenRawValueAndTrailingComma: unexpectedBetweenRawValueAndTrailingComma?.createUnexpectedNodes(), trailingComma: trailingComma))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: String, unexpectedBetweenIdentifierAndAssociatedValue: ExpressibleAsUnexpectedNodes? = nil, associatedValue: ExpressibleAsParameterClause? = nil, unexpectedBetweenAssociatedValueAndRawValue: ExpressibleAsUnexpectedNodes? = nil, rawValue: ExpressibleAsInitializerClause? = nil, unexpectedBetweenRawValueAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeIdentifier: unexpectedBeforeIdentifier, identifier: Token.`identifier`(identifier), unexpectedBetweenIdentifierAndAssociatedValue: unexpectedBetweenIdentifierAndAssociatedValue, associatedValue: associatedValue, unexpectedBetweenAssociatedValueAndRawValue: unexpectedBetweenAssociatedValueAndRawValue, rawValue: rawValue, unexpectedBetweenRawValueAndTrailingComma: unexpectedBetweenRawValueAndTrailingComma, trailingComma: trailingComma)
  }
  public init(_ constructedNode: EnumCaseElementSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `EnumCaseElementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `EnumCaseElementSyntax`.
  func buildEnumCaseElement(format: Format) -> EnumCaseElementSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = EnumCaseElementSyntax(buildableData.unexpectedBeforeIdentifier?.buildUnexpectedNodes(format: format), identifier: buildableData.identifier.buildToken(format: format), buildableData.unexpectedBetweenIdentifierAndAssociatedValue?.buildUnexpectedNodes(format: format), associatedValue: buildableData.associatedValue?.buildParameterClause(format: format), buildableData.unexpectedBetweenAssociatedValueAndRawValue?.buildUnexpectedNodes(format: format), rawValue: buildableData.rawValue?.buildInitializerClause(format: format), buildableData.unexpectedBetweenRawValueAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: buildableData.trailingComma?.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildEnumCaseElement(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsEnumCaseElement`.
  public func createEnumCaseElement() -> EnumCaseElement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `EnumCaseElement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingComma = withComma ? .comma : nil
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withComma = node.withTrailingComma(withComma ? .commaToken() : nil)
      var result = self
      result.data = .constructed(withComma)
      return result
    }
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
/// A `case` declaration of a Swift `enum`. It can have 1 or more`EnumCaseElement`s inside, each declaring a different case of theenum.
public struct EnumCaseDecl: DeclBuildable, ExpressibleAsEnumCaseDecl {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeAttributes: UnexpectedNodes?
    var attributes: AttributeList?
    var unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
    var modifiers: ModifierList?
    var unexpectedBetweenModifiersAndCaseKeyword: UnexpectedNodes?
    var caseKeyword: Token
    var unexpectedBetweenCaseKeywordAndElements: UnexpectedNodes?
    var elements: EnumCaseElementList
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(EnumCaseDeclSyntax)
  }
  private var data: Data
  /// Creates a `EnumCaseDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: The attributes applied to the case declaration.
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: The declaration modifiers applied to the case declaration.
  ///   - unexpectedBetweenModifiersAndCaseKeyword: 
  ///   - caseKeyword: The `case` keyword for this case.
  ///   - unexpectedBetweenCaseKeywordAndElements: 
  ///   - elements: The elements this case declares.
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndCaseKeyword: ExpressibleAsUnexpectedNodes? = nil, caseKeyword: Token = Token.`case`, unexpectedBetweenCaseKeywordAndElements: ExpressibleAsUnexpectedNodes? = nil, elements: ExpressibleAsEnumCaseElementList) {
    assert(caseKeyword.text == #"case"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes?.createUnexpectedNodes(), attributes: attributes?.createAttributeList(), unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes(), modifiers: modifiers?.createModifierList(), unexpectedBetweenModifiersAndCaseKeyword: unexpectedBetweenModifiersAndCaseKeyword?.createUnexpectedNodes(), caseKeyword: caseKeyword, unexpectedBetweenCaseKeywordAndElements: unexpectedBetweenCaseKeywordAndElements?.createUnexpectedNodes(), elements: elements.createEnumCaseElementList()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndCaseKeyword: ExpressibleAsUnexpectedNodes? = nil, caseKeyword: Token = Token.`case`, unexpectedBetweenCaseKeywordAndElements: ExpressibleAsUnexpectedNodes? = nil, @EnumCaseElementListBuilder elementsBuilder: () -> ExpressibleAsEnumCaseElementList =  {
    EnumCaseElementList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndCaseKeyword: unexpectedBetweenModifiersAndCaseKeyword, caseKeyword: caseKeyword, unexpectedBetweenCaseKeywordAndElements: unexpectedBetweenCaseKeywordAndElements, elements: elementsBuilder())
  }
  public init(_ constructedNode: EnumCaseDeclSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `EnumCaseDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `EnumCaseDeclSyntax`.
  func buildEnumCaseDecl(format: Format) -> EnumCaseDeclSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = EnumCaseDeclSyntax(buildableData.unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: buildableData.attributes?.buildAttributeList(format: format), buildableData.unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format), modifiers: buildableData.modifiers?.buildModifierList(format: format), buildableData.unexpectedBetweenModifiersAndCaseKeyword?.buildUnexpectedNodes(format: format), caseKeyword: buildableData.caseKeyword.buildToken(format: format), buildableData.unexpectedBetweenCaseKeywordAndElements?.buildUnexpectedNodes(format: format), elements: buildableData.elements.buildEnumCaseElementList(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildEnumCaseDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsEnumCaseDecl`.
  public func createEnumCaseDecl() -> EnumCaseDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `EnumCaseDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
/// A Swift `enum` declaration.
public struct EnumDecl: DeclBuildable, ExpressibleAsEnumDecl {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeAttributes: UnexpectedNodes?
    var attributes: AttributeList?
    var unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
    var modifiers: ModifierList?
    var unexpectedBetweenModifiersAndEnumKeyword: UnexpectedNodes?
    var enumKeyword: Token
    var unexpectedBetweenEnumKeywordAndIdentifier: UnexpectedNodes?
    var identifier: Token
    var unexpectedBetweenIdentifierAndGenericParameters: UnexpectedNodes?
    var genericParameters: GenericParameterClause?
    var unexpectedBetweenGenericParametersAndInheritanceClause: UnexpectedNodes?
    var inheritanceClause: TypeInheritanceClause?
    var unexpectedBetweenInheritanceClauseAndGenericWhereClause: UnexpectedNodes?
    var genericWhereClause: GenericWhereClause?
    var unexpectedBetweenGenericWhereClauseAndMembers: UnexpectedNodes?
    var members: MemberDeclBlock
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(EnumDeclSyntax)
  }
  private var data: Data
  /// Creates a `EnumDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: The attributes applied to the enum declaration.
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: The declaration modifiers applied to the enum declaration.
  ///   - unexpectedBetweenModifiersAndEnumKeyword: 
  ///   - enumKeyword: The `enum` keyword for this declaration.
  ///   - unexpectedBetweenEnumKeywordAndIdentifier: 
  ///   - identifier: The name of this enum.
  ///   - unexpectedBetweenIdentifierAndGenericParameters: 
  ///   - genericParameters: The generic parameters, if any, for this enum.
  ///   - unexpectedBetweenGenericParametersAndInheritanceClause: 
  ///   - inheritanceClause: The inheritance clause describing conformances or rawvalues for this enum.
  ///   - unexpectedBetweenInheritanceClauseAndGenericWhereClause: 
  ///   - genericWhereClause: The `where` clause that applies to the generic parameters ofthis enum.
  ///   - unexpectedBetweenGenericWhereClauseAndMembers: 
  ///   - members: The cases and other members of this enum.
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndEnumKeyword: ExpressibleAsUnexpectedNodes? = nil, enumKeyword: Token = Token.`enum`, unexpectedBetweenEnumKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndGenericParameters: ExpressibleAsUnexpectedNodes? = nil, genericParameters: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParametersAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndMembers: ExpressibleAsUnexpectedNodes? = nil, members: ExpressibleAsMemberDeclBlock) {
    assert(enumKeyword.text == #"enum"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes?.createUnexpectedNodes(), attributes: attributes?.createAttributeList(), unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes(), modifiers: modifiers?.createModifierList(), unexpectedBetweenModifiersAndEnumKeyword: unexpectedBetweenModifiersAndEnumKeyword?.createUnexpectedNodes(), enumKeyword: enumKeyword, unexpectedBetweenEnumKeywordAndIdentifier: unexpectedBetweenEnumKeywordAndIdentifier?.createUnexpectedNodes(), identifier: identifier, unexpectedBetweenIdentifierAndGenericParameters: unexpectedBetweenIdentifierAndGenericParameters?.createUnexpectedNodes(), genericParameters: genericParameters?.createGenericParameterClause(), unexpectedBetweenGenericParametersAndInheritanceClause: unexpectedBetweenGenericParametersAndInheritanceClause?.createUnexpectedNodes(), inheritanceClause: inheritanceClause?.createTypeInheritanceClause(), unexpectedBetweenInheritanceClauseAndGenericWhereClause: unexpectedBetweenInheritanceClauseAndGenericWhereClause?.createUnexpectedNodes(), genericWhereClause: genericWhereClause?.createGenericWhereClause(), unexpectedBetweenGenericWhereClauseAndMembers: unexpectedBetweenGenericWhereClauseAndMembers?.createUnexpectedNodes(), members: members.createMemberDeclBlock()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndEnumKeyword: ExpressibleAsUnexpectedNodes? = nil, enumKeyword: Token = Token.`enum`, unexpectedBetweenEnumKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: String, unexpectedBetweenIdentifierAndGenericParameters: ExpressibleAsUnexpectedNodes? = nil, genericParameters: ExpressibleAsGenericParameterClause? = nil, unexpectedBetweenGenericParametersAndInheritanceClause: ExpressibleAsUnexpectedNodes? = nil, inheritanceClause: ExpressibleAsTypeInheritanceClause? = nil, unexpectedBetweenInheritanceClauseAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndMembers: ExpressibleAsUnexpectedNodes? = nil, @MemberDeclListBuilder membersBuilder: () -> ExpressibleAsMemberDeclList =  {
    MemberDeclList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndEnumKeyword: unexpectedBetweenModifiersAndEnumKeyword, enumKeyword: enumKeyword, unexpectedBetweenEnumKeywordAndIdentifier: unexpectedBetweenEnumKeywordAndIdentifier, identifier: Token.`identifier`(identifier), unexpectedBetweenIdentifierAndGenericParameters: unexpectedBetweenIdentifierAndGenericParameters, genericParameters: genericParameters, unexpectedBetweenGenericParametersAndInheritanceClause: unexpectedBetweenGenericParametersAndInheritanceClause, inheritanceClause: inheritanceClause, unexpectedBetweenInheritanceClauseAndGenericWhereClause: unexpectedBetweenInheritanceClauseAndGenericWhereClause, genericWhereClause: genericWhereClause, unexpectedBetweenGenericWhereClauseAndMembers: unexpectedBetweenGenericWhereClauseAndMembers, members: membersBuilder())
  }
  public init(_ constructedNode: EnumDeclSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `EnumDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `EnumDeclSyntax`.
  func buildEnumDecl(format: Format) -> EnumDeclSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = EnumDeclSyntax(buildableData.unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: buildableData.attributes?.buildAttributeList(format: format), buildableData.unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format), modifiers: buildableData.modifiers?.buildModifierList(format: format), buildableData.unexpectedBetweenModifiersAndEnumKeyword?.buildUnexpectedNodes(format: format), enumKeyword: buildableData.enumKeyword.buildToken(format: format), buildableData.unexpectedBetweenEnumKeywordAndIdentifier?.buildUnexpectedNodes(format: format), identifier: buildableData.identifier.buildToken(format: format), buildableData.unexpectedBetweenIdentifierAndGenericParameters?.buildUnexpectedNodes(format: format), genericParameters: buildableData.genericParameters?.buildGenericParameterClause(format: format), buildableData.unexpectedBetweenGenericParametersAndInheritanceClause?.buildUnexpectedNodes(format: format), inheritanceClause: buildableData.inheritanceClause?.buildTypeInheritanceClause(format: format), buildableData.unexpectedBetweenInheritanceClauseAndGenericWhereClause?.buildUnexpectedNodes(format: format), genericWhereClause: buildableData.genericWhereClause?.buildGenericWhereClause(format: format), buildableData.unexpectedBetweenGenericWhereClauseAndMembers?.buildUnexpectedNodes(format: format), members: buildableData.members.buildMemberDeclBlock(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildEnumDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsEnumDecl`.
  public func createEnumDecl() -> EnumDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `EnumDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
/// A Swift `operator` declaration.
public struct OperatorDecl: DeclBuildable, ExpressibleAsOperatorDecl {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeAttributes: UnexpectedNodes?
    var attributes: AttributeList?
    var unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
    var modifiers: ModifierList?
    var unexpectedBetweenModifiersAndOperatorKeyword: UnexpectedNodes?
    var operatorKeyword: Token
    var unexpectedBetweenOperatorKeywordAndIdentifier: UnexpectedNodes?
    var identifier: Token
    var unexpectedBetweenIdentifierAndOperatorPrecedenceAndTypes: UnexpectedNodes?
    var operatorPrecedenceAndTypes: OperatorPrecedenceAndTypes?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(OperatorDeclSyntax)
  }
  private var data: Data
  /// Creates a `OperatorDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: The attributes applied to the 'operator' declaration.
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: The declaration modifiers applied to the 'operator'declaration.
  ///   - unexpectedBetweenModifiersAndOperatorKeyword: 
  ///   - operatorKeyword: 
  ///   - unexpectedBetweenOperatorKeywordAndIdentifier: 
  ///   - identifier: 
  ///   - unexpectedBetweenIdentifierAndOperatorPrecedenceAndTypes: 
  ///   - operatorPrecedenceAndTypes: Optionally specify a precedence group and designated types.
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndOperatorKeyword: ExpressibleAsUnexpectedNodes? = nil, operatorKeyword: Token = Token.`operator`, unexpectedBetweenOperatorKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndOperatorPrecedenceAndTypes: ExpressibleAsUnexpectedNodes? = nil, operatorPrecedenceAndTypes: ExpressibleAsOperatorPrecedenceAndTypes? = nil) {
    assert(operatorKeyword.text == #"operator"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes?.createUnexpectedNodes(), attributes: attributes?.createAttributeList(), unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes(), modifiers: modifiers?.createModifierList(), unexpectedBetweenModifiersAndOperatorKeyword: unexpectedBetweenModifiersAndOperatorKeyword?.createUnexpectedNodes(), operatorKeyword: operatorKeyword, unexpectedBetweenOperatorKeywordAndIdentifier: unexpectedBetweenOperatorKeywordAndIdentifier?.createUnexpectedNodes(), identifier: identifier, unexpectedBetweenIdentifierAndOperatorPrecedenceAndTypes: unexpectedBetweenIdentifierAndOperatorPrecedenceAndTypes?.createUnexpectedNodes(), operatorPrecedenceAndTypes: operatorPrecedenceAndTypes?.createOperatorPrecedenceAndTypes()))
  }
  public init(_ constructedNode: OperatorDeclSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `OperatorDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `OperatorDeclSyntax`.
  func buildOperatorDecl(format: Format) -> OperatorDeclSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = OperatorDeclSyntax(buildableData.unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: buildableData.attributes?.buildAttributeList(format: format), buildableData.unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format), modifiers: buildableData.modifiers?.buildModifierList(format: format), buildableData.unexpectedBetweenModifiersAndOperatorKeyword?.buildUnexpectedNodes(format: format), operatorKeyword: buildableData.operatorKeyword.buildToken(format: format), buildableData.unexpectedBetweenOperatorKeywordAndIdentifier?.buildUnexpectedNodes(format: format), identifier: buildableData.identifier.buildToken(format: format), buildableData.unexpectedBetweenIdentifierAndOperatorPrecedenceAndTypes?.buildUnexpectedNodes(format: format), operatorPrecedenceAndTypes: buildableData.operatorPrecedenceAndTypes?.buildOperatorPrecedenceAndTypes(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildOperatorDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsOperatorDecl`.
  public func createOperatorDecl() -> OperatorDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `OperatorDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct DesignatedTypeElement: SyntaxBuildable, ExpressibleAsDesignatedTypeElement {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeLeadingComma: UnexpectedNodes?
    var leadingComma: Token
    var unexpectedBetweenLeadingCommaAndName: UnexpectedNodes?
    var name: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(DesignatedTypeElementSyntax)
  }
  private var data: Data
  /// Creates a `DesignatedTypeElement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeadingComma: 
  ///   - leadingComma: 
  ///   - unexpectedBetweenLeadingCommaAndName: 
  ///   - name: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeadingComma: ExpressibleAsUnexpectedNodes? = nil, leadingComma: Token = Token.`comma`, unexpectedBetweenLeadingCommaAndName: ExpressibleAsUnexpectedNodes? = nil, name: Token) {
    assert(leadingComma.text == #","#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeLeadingComma: unexpectedBeforeLeadingComma?.createUnexpectedNodes(), leadingComma: leadingComma, unexpectedBetweenLeadingCommaAndName: unexpectedBetweenLeadingCommaAndName?.createUnexpectedNodes(), name: name))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeadingComma: ExpressibleAsUnexpectedNodes? = nil, leadingComma: Token = Token.`comma`, unexpectedBetweenLeadingCommaAndName: ExpressibleAsUnexpectedNodes? = nil, name: String) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeadingComma: unexpectedBeforeLeadingComma, leadingComma: leadingComma, unexpectedBetweenLeadingCommaAndName: unexpectedBetweenLeadingCommaAndName, name: Token.`identifier`(name))
  }
  public init(_ constructedNode: DesignatedTypeElementSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `DesignatedTypeElementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DesignatedTypeElementSyntax`.
  func buildDesignatedTypeElement(format: Format) -> DesignatedTypeElementSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = DesignatedTypeElementSyntax(buildableData.unexpectedBeforeLeadingComma?.buildUnexpectedNodes(format: format), leadingComma: buildableData.leadingComma.buildToken(format: format), buildableData.unexpectedBetweenLeadingCommaAndName?.buildUnexpectedNodes(format: format), name: buildableData.name.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildDesignatedTypeElement(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsDesignatedTypeElement`.
  public func createDesignatedTypeElement() -> DesignatedTypeElement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DesignatedTypeElement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
/// A clause to specify precedence group in infix operator declarations, and designated types in any operator declaration.
public struct OperatorPrecedenceAndTypes: SyntaxBuildable, ExpressibleAsOperatorPrecedenceAndTypes {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeColon: UnexpectedNodes?
    var colon: Token
    var unexpectedBetweenColonAndPrecedenceGroup: UnexpectedNodes?
    var precedenceGroup: Token
    var unexpectedBetweenPrecedenceGroupAndDesignatedTypes: UnexpectedNodes?
    var designatedTypes: DesignatedTypeList
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(OperatorPrecedenceAndTypesSyntax)
  }
  private var data: Data
  /// Creates a `OperatorPrecedenceAndTypes` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndPrecedenceGroup: 
  ///   - precedenceGroup: The precedence group for this operator
  ///   - unexpectedBetweenPrecedenceGroupAndDesignatedTypes: 
  ///   - designatedTypes: The designated types associated with this operator.
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndPrecedenceGroup: ExpressibleAsUnexpectedNodes? = nil, precedenceGroup: Token, unexpectedBetweenPrecedenceGroupAndDesignatedTypes: ExpressibleAsUnexpectedNodes? = nil, designatedTypes: ExpressibleAsDesignatedTypeList) {
    assert(colon.text == #":"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeColon: unexpectedBeforeColon?.createUnexpectedNodes(), colon: colon, unexpectedBetweenColonAndPrecedenceGroup: unexpectedBetweenColonAndPrecedenceGroup?.createUnexpectedNodes(), precedenceGroup: precedenceGroup, unexpectedBetweenPrecedenceGroupAndDesignatedTypes: unexpectedBetweenPrecedenceGroupAndDesignatedTypes?.createUnexpectedNodes(), designatedTypes: designatedTypes.createDesignatedTypeList()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndPrecedenceGroup: ExpressibleAsUnexpectedNodes? = nil, precedenceGroup: String, unexpectedBetweenPrecedenceGroupAndDesignatedTypes: ExpressibleAsUnexpectedNodes? = nil, designatedTypes: ExpressibleAsDesignatedTypeList) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeColon: unexpectedBeforeColon, colon: colon, unexpectedBetweenColonAndPrecedenceGroup: unexpectedBetweenColonAndPrecedenceGroup, precedenceGroup: Token.`identifier`(precedenceGroup), unexpectedBetweenPrecedenceGroupAndDesignatedTypes: unexpectedBetweenPrecedenceGroupAndDesignatedTypes, designatedTypes: designatedTypes)
  }
  public init(_ constructedNode: OperatorPrecedenceAndTypesSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `OperatorPrecedenceAndTypesSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `OperatorPrecedenceAndTypesSyntax`.
  func buildOperatorPrecedenceAndTypes(format: Format) -> OperatorPrecedenceAndTypesSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = OperatorPrecedenceAndTypesSyntax(buildableData.unexpectedBeforeColon?.buildUnexpectedNodes(format: format), colon: buildableData.colon.buildToken(format: format), buildableData.unexpectedBetweenColonAndPrecedenceGroup?.buildUnexpectedNodes(format: format), precedenceGroup: buildableData.precedenceGroup.buildToken(format: format), buildableData.unexpectedBetweenPrecedenceGroupAndDesignatedTypes?.buildUnexpectedNodes(format: format), designatedTypes: buildableData.designatedTypes.buildDesignatedTypeList(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildOperatorPrecedenceAndTypes(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsOperatorPrecedenceAndTypes`.
  public func createOperatorPrecedenceAndTypes() -> OperatorPrecedenceAndTypes {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `OperatorPrecedenceAndTypes` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
/// A Swift `precedencegroup` declaration.
public struct PrecedenceGroupDecl: DeclBuildable, ExpressibleAsPrecedenceGroupDecl {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeAttributes: UnexpectedNodes?
    var attributes: AttributeList?
    var unexpectedBetweenAttributesAndModifiers: UnexpectedNodes?
    var modifiers: ModifierList?
    var unexpectedBetweenModifiersAndPrecedencegroupKeyword: UnexpectedNodes?
    var precedencegroupKeyword: Token
    var unexpectedBetweenPrecedencegroupKeywordAndIdentifier: UnexpectedNodes?
    var identifier: Token
    var unexpectedBetweenIdentifierAndLeftBrace: UnexpectedNodes?
    var leftBrace: Token
    var unexpectedBetweenLeftBraceAndGroupAttributes: UnexpectedNodes?
    var groupAttributes: PrecedenceGroupAttributeList
    var unexpectedBetweenGroupAttributesAndRightBrace: UnexpectedNodes?
    var rightBrace: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(PrecedenceGroupDeclSyntax)
  }
  private var data: Data
  /// Creates a `PrecedenceGroupDecl` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: The attributes applied to the 'precedencegroup' declaration.
  ///   - unexpectedBetweenAttributesAndModifiers: 
  ///   - modifiers: The declaration modifiers applied to the 'precedencegroup'declaration.
  ///   - unexpectedBetweenModifiersAndPrecedencegroupKeyword: 
  ///   - precedencegroupKeyword: 
  ///   - unexpectedBetweenPrecedencegroupKeywordAndIdentifier: 
  ///   - identifier: The name of this precedence group.
  ///   - unexpectedBetweenIdentifierAndLeftBrace: 
  ///   - leftBrace: 
  ///   - unexpectedBetweenLeftBraceAndGroupAttributes: 
  ///   - groupAttributes: The characteristics of this precedence group.
  ///   - unexpectedBetweenGroupAttributesAndRightBrace: 
  ///   - rightBrace: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndPrecedencegroupKeyword: ExpressibleAsUnexpectedNodes? = nil, precedencegroupKeyword: Token = Token.`precedencegroup`, unexpectedBetweenPrecedencegroupKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token, unexpectedBetweenIdentifierAndLeftBrace: ExpressibleAsUnexpectedNodes? = nil, leftBrace: Token = Token.`leftBrace`, unexpectedBetweenLeftBraceAndGroupAttributes: ExpressibleAsUnexpectedNodes? = nil, groupAttributes: ExpressibleAsPrecedenceGroupAttributeList, unexpectedBetweenGroupAttributesAndRightBrace: ExpressibleAsUnexpectedNodes? = nil, rightBrace: Token = Token.`rightBrace`) {
    assert(precedencegroupKeyword.text == #"precedencegroup"#)
    assert(leftBrace.text == #"{"#)
    assert(rightBrace.text == #"}"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes?.createUnexpectedNodes(), attributes: attributes?.createAttributeList(), unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers?.createUnexpectedNodes(), modifiers: modifiers?.createModifierList(), unexpectedBetweenModifiersAndPrecedencegroupKeyword: unexpectedBetweenModifiersAndPrecedencegroupKeyword?.createUnexpectedNodes(), precedencegroupKeyword: precedencegroupKeyword, unexpectedBetweenPrecedencegroupKeywordAndIdentifier: unexpectedBetweenPrecedencegroupKeywordAndIdentifier?.createUnexpectedNodes(), identifier: identifier, unexpectedBetweenIdentifierAndLeftBrace: unexpectedBetweenIdentifierAndLeftBrace?.createUnexpectedNodes(), leftBrace: leftBrace, unexpectedBetweenLeftBraceAndGroupAttributes: unexpectedBetweenLeftBraceAndGroupAttributes?.createUnexpectedNodes(), groupAttributes: groupAttributes.createPrecedenceGroupAttributeList(), unexpectedBetweenGroupAttributesAndRightBrace: unexpectedBetweenGroupAttributesAndRightBrace?.createUnexpectedNodes(), rightBrace: rightBrace))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndModifiers: ExpressibleAsUnexpectedNodes? = nil, modifiers: ExpressibleAsModifierList? = nil, unexpectedBetweenModifiersAndPrecedencegroupKeyword: ExpressibleAsUnexpectedNodes? = nil, precedencegroupKeyword: Token = Token.`precedencegroup`, unexpectedBetweenPrecedencegroupKeywordAndIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: String, unexpectedBetweenIdentifierAndLeftBrace: ExpressibleAsUnexpectedNodes? = nil, leftBrace: Token = Token.`leftBrace`, unexpectedBetweenLeftBraceAndGroupAttributes: ExpressibleAsUnexpectedNodes? = nil, groupAttributes: ExpressibleAsPrecedenceGroupAttributeList, unexpectedBetweenGroupAttributesAndRightBrace: ExpressibleAsUnexpectedNodes? = nil, rightBrace: Token = Token.`rightBrace`) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndModifiers: unexpectedBetweenAttributesAndModifiers, modifiers: modifiers, unexpectedBetweenModifiersAndPrecedencegroupKeyword: unexpectedBetweenModifiersAndPrecedencegroupKeyword, precedencegroupKeyword: precedencegroupKeyword, unexpectedBetweenPrecedencegroupKeywordAndIdentifier: unexpectedBetweenPrecedencegroupKeywordAndIdentifier, identifier: Token.`identifier`(identifier), unexpectedBetweenIdentifierAndLeftBrace: unexpectedBetweenIdentifierAndLeftBrace, leftBrace: leftBrace, unexpectedBetweenLeftBraceAndGroupAttributes: unexpectedBetweenLeftBraceAndGroupAttributes, groupAttributes: groupAttributes, unexpectedBetweenGroupAttributesAndRightBrace: unexpectedBetweenGroupAttributesAndRightBrace, rightBrace: rightBrace)
  }
  public init(_ constructedNode: PrecedenceGroupDeclSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `PrecedenceGroupDeclSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PrecedenceGroupDeclSyntax`.
  func buildPrecedenceGroupDecl(format: Format) -> PrecedenceGroupDeclSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = PrecedenceGroupDeclSyntax(buildableData.unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: buildableData.attributes?.buildAttributeList(format: format), buildableData.unexpectedBetweenAttributesAndModifiers?.buildUnexpectedNodes(format: format), modifiers: buildableData.modifiers?.buildModifierList(format: format), buildableData.unexpectedBetweenModifiersAndPrecedencegroupKeyword?.buildUnexpectedNodes(format: format), precedencegroupKeyword: buildableData.precedencegroupKeyword.buildToken(format: format), buildableData.unexpectedBetweenPrecedencegroupKeywordAndIdentifier?.buildUnexpectedNodes(format: format), identifier: buildableData.identifier.buildToken(format: format), buildableData.unexpectedBetweenIdentifierAndLeftBrace?.buildUnexpectedNodes(format: format), leftBrace: buildableData.leftBrace.buildToken(format: format), buildableData.unexpectedBetweenLeftBraceAndGroupAttributes?.buildUnexpectedNodes(format: format), groupAttributes: buildableData.groupAttributes.buildPrecedenceGroupAttributeList(format: format), buildableData.unexpectedBetweenGroupAttributesAndRightBrace?.buildUnexpectedNodes(format: format), rightBrace: buildableData.rightBrace.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `DeclBuildable`.
  public func buildDecl(format: Format) -> DeclSyntax {
    let result = buildPrecedenceGroupDecl(format: format)
    return DeclSyntax(result)
  }
  /// Conformance to `ExpressibleAsPrecedenceGroupDecl`.
  public func createPrecedenceGroupDecl() -> PrecedenceGroupDecl {
    return self
  }
  /// Conformance to `ExpressibleAsDeclBuildable`.
  /// `PrecedenceGroupDecl` may conform to `ExpressibleAsDeclBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createDeclBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createDeclBuildable() -> DeclBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
/// Specify the new precedence group's relation to existing precedencegroups.
public struct PrecedenceGroupRelation: SyntaxBuildable, ExpressibleAsPrecedenceGroupRelation {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeHigherThanOrLowerThan: UnexpectedNodes?
    var higherThanOrLowerThan: Token
    var unexpectedBetweenHigherThanOrLowerThanAndColon: UnexpectedNodes?
    var colon: Token
    var unexpectedBetweenColonAndOtherNames: UnexpectedNodes?
    var otherNames: PrecedenceGroupNameList
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(PrecedenceGroupRelationSyntax)
  }
  private var data: Data
  /// Creates a `PrecedenceGroupRelation` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeHigherThanOrLowerThan: 
  ///   - higherThanOrLowerThan: The relation to specified other precedence groups.
  ///   - unexpectedBetweenHigherThanOrLowerThanAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndOtherNames: 
  ///   - otherNames: The name of other precedence group to which this precedencegroup relates.
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeHigherThanOrLowerThan: ExpressibleAsUnexpectedNodes? = nil, higherThanOrLowerThan: Token, unexpectedBetweenHigherThanOrLowerThanAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndOtherNames: ExpressibleAsUnexpectedNodes? = nil, otherNames: ExpressibleAsPrecedenceGroupNameList) {
    assert(higherThanOrLowerThan.text == #"higherThan"# || higherThanOrLowerThan.text == #"lowerThan"#)
    assert(colon.text == #":"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeHigherThanOrLowerThan: unexpectedBeforeHigherThanOrLowerThan?.createUnexpectedNodes(), higherThanOrLowerThan: higherThanOrLowerThan, unexpectedBetweenHigherThanOrLowerThanAndColon: unexpectedBetweenHigherThanOrLowerThanAndColon?.createUnexpectedNodes(), colon: colon, unexpectedBetweenColonAndOtherNames: unexpectedBetweenColonAndOtherNames?.createUnexpectedNodes(), otherNames: otherNames.createPrecedenceGroupNameList()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeHigherThanOrLowerThan: ExpressibleAsUnexpectedNodes? = nil, higherThanOrLowerThan: String, unexpectedBetweenHigherThanOrLowerThanAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndOtherNames: ExpressibleAsUnexpectedNodes? = nil, otherNames: ExpressibleAsPrecedenceGroupNameList) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeHigherThanOrLowerThan: unexpectedBeforeHigherThanOrLowerThan, higherThanOrLowerThan: Token.`identifier`(higherThanOrLowerThan), unexpectedBetweenHigherThanOrLowerThanAndColon: unexpectedBetweenHigherThanOrLowerThanAndColon, colon: colon, unexpectedBetweenColonAndOtherNames: unexpectedBetweenColonAndOtherNames, otherNames: otherNames)
  }
  public init(_ constructedNode: PrecedenceGroupRelationSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `PrecedenceGroupRelationSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PrecedenceGroupRelationSyntax`.
  func buildPrecedenceGroupRelation(format: Format) -> PrecedenceGroupRelationSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = PrecedenceGroupRelationSyntax(buildableData.unexpectedBeforeHigherThanOrLowerThan?.buildUnexpectedNodes(format: format), higherThanOrLowerThan: buildableData.higherThanOrLowerThan.buildToken(format: format), buildableData.unexpectedBetweenHigherThanOrLowerThanAndColon?.buildUnexpectedNodes(format: format), colon: buildableData.colon.buildToken(format: format), buildableData.unexpectedBetweenColonAndOtherNames?.buildUnexpectedNodes(format: format), otherNames: buildableData.otherNames.buildPrecedenceGroupNameList(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildPrecedenceGroupRelation(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsPrecedenceGroupRelation`.
  public func createPrecedenceGroupRelation() -> PrecedenceGroupRelation {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PrecedenceGroupRelation` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct PrecedenceGroupNameElement: SyntaxBuildable, ExpressibleAsPrecedenceGroupNameElement {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeName: UnexpectedNodes?
    var name: Token
    var unexpectedBetweenNameAndTrailingComma: UnexpectedNodes?
    var trailingComma: Token?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(PrecedenceGroupNameElementSyntax)
  }
  private var data: Data
  /// Creates a `PrecedenceGroupNameElement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    assert(trailingComma == nil || trailingComma!.text == #","#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeName: unexpectedBeforeName?.createUnexpectedNodes(), name: name, unexpectedBetweenNameAndTrailingComma: unexpectedBetweenNameAndTrailingComma?.createUnexpectedNodes(), trailingComma: trailingComma))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: String, unexpectedBetweenNameAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeName: unexpectedBeforeName, name: Token.`identifier`(name), unexpectedBetweenNameAndTrailingComma: unexpectedBetweenNameAndTrailingComma, trailingComma: trailingComma)
  }
  public init(_ constructedNode: PrecedenceGroupNameElementSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `PrecedenceGroupNameElementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PrecedenceGroupNameElementSyntax`.
  func buildPrecedenceGroupNameElement(format: Format) -> PrecedenceGroupNameElementSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = PrecedenceGroupNameElementSyntax(buildableData.unexpectedBeforeName?.buildUnexpectedNodes(format: format), name: buildableData.name.buildToken(format: format), buildableData.unexpectedBetweenNameAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: buildableData.trailingComma?.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildPrecedenceGroupNameElement(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsPrecedenceGroupNameElement`.
  public func createPrecedenceGroupNameElement() -> PrecedenceGroupNameElement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PrecedenceGroupNameElement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
/// Specifies the precedence of an operator when used in an operationthat includes optional chaining.
public struct PrecedenceGroupAssignment: SyntaxBuildable, ExpressibleAsPrecedenceGroupAssignment {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeAssignmentKeyword: UnexpectedNodes?
    var assignmentKeyword: Token
    var unexpectedBetweenAssignmentKeywordAndColon: UnexpectedNodes?
    var colon: Token
    var unexpectedBetweenColonAndFlag: UnexpectedNodes?
    var flag: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(PrecedenceGroupAssignmentSyntax)
  }
  private var data: Data
  /// Creates a `PrecedenceGroupAssignment` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAssignmentKeyword: 
  ///   - assignmentKeyword: 
  ///   - unexpectedBetweenAssignmentKeywordAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndFlag: 
  ///   - flag: When true, an operator in the corresponding precedence groupuses the same grouping rules during optional chaining as theassignment operators from the standard library. Otherwise,operators in the precedence group follows the same optionalchaining rules as operators that don't perform assignment.
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAssignmentKeyword: ExpressibleAsUnexpectedNodes? = nil, assignmentKeyword: Token, unexpectedBetweenAssignmentKeywordAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndFlag: ExpressibleAsUnexpectedNodes? = nil, flag: Token) {
    assert(assignmentKeyword.text == #"assignment"#)
    assert(colon.text == #":"#)
    assert(flag.text == #"true"# || flag.text == #"false"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeAssignmentKeyword: unexpectedBeforeAssignmentKeyword?.createUnexpectedNodes(), assignmentKeyword: assignmentKeyword, unexpectedBetweenAssignmentKeywordAndColon: unexpectedBetweenAssignmentKeywordAndColon?.createUnexpectedNodes(), colon: colon, unexpectedBetweenColonAndFlag: unexpectedBetweenColonAndFlag?.createUnexpectedNodes(), flag: flag))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAssignmentKeyword: ExpressibleAsUnexpectedNodes? = nil, assignmentKeyword: String, unexpectedBetweenAssignmentKeywordAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndFlag: ExpressibleAsUnexpectedNodes? = nil, flag: Token) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAssignmentKeyword: unexpectedBeforeAssignmentKeyword, assignmentKeyword: Token.`identifier`(assignmentKeyword), unexpectedBetweenAssignmentKeywordAndColon: unexpectedBetweenAssignmentKeywordAndColon, colon: colon, unexpectedBetweenColonAndFlag: unexpectedBetweenColonAndFlag, flag: flag)
  }
  public init(_ constructedNode: PrecedenceGroupAssignmentSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `PrecedenceGroupAssignmentSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PrecedenceGroupAssignmentSyntax`.
  func buildPrecedenceGroupAssignment(format: Format) -> PrecedenceGroupAssignmentSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = PrecedenceGroupAssignmentSyntax(buildableData.unexpectedBeforeAssignmentKeyword?.buildUnexpectedNodes(format: format), assignmentKeyword: buildableData.assignmentKeyword.buildToken(format: format), buildableData.unexpectedBetweenAssignmentKeywordAndColon?.buildUnexpectedNodes(format: format), colon: buildableData.colon.buildToken(format: format), buildableData.unexpectedBetweenColonAndFlag?.buildUnexpectedNodes(format: format), flag: buildableData.flag.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildPrecedenceGroupAssignment(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsPrecedenceGroupAssignment`.
  public func createPrecedenceGroupAssignment() -> PrecedenceGroupAssignment {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PrecedenceGroupAssignment` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
/// Specifies how a sequence of operators with the same precedence levelare grouped together in the absence of grouping parentheses.
public struct PrecedenceGroupAssociativity: SyntaxBuildable, ExpressibleAsPrecedenceGroupAssociativity {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeAssociativityKeyword: UnexpectedNodes?
    var associativityKeyword: Token
    var unexpectedBetweenAssociativityKeywordAndColon: UnexpectedNodes?
    var colon: Token
    var unexpectedBetweenColonAndValue: UnexpectedNodes?
    var value: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(PrecedenceGroupAssociativitySyntax)
  }
  private var data: Data
  /// Creates a `PrecedenceGroupAssociativity` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAssociativityKeyword: 
  ///   - associativityKeyword: 
  ///   - unexpectedBetweenAssociativityKeywordAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndValue: 
  ///   - value: Operators that are `left`-associative group left-to-right.Operators that are `right`-associative group right-to-left.Operators that are specified with an associativity of `none`don't associate at all
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAssociativityKeyword: ExpressibleAsUnexpectedNodes? = nil, associativityKeyword: Token, unexpectedBetweenAssociativityKeywordAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndValue: ExpressibleAsUnexpectedNodes? = nil, value: Token) {
    assert(associativityKeyword.text == #"associativity"#)
    assert(colon.text == #":"#)
    assert(value.text == #"left"# || value.text == #"right"# || value.text == #"none"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeAssociativityKeyword: unexpectedBeforeAssociativityKeyword?.createUnexpectedNodes(), associativityKeyword: associativityKeyword, unexpectedBetweenAssociativityKeywordAndColon: unexpectedBetweenAssociativityKeywordAndColon?.createUnexpectedNodes(), colon: colon, unexpectedBetweenColonAndValue: unexpectedBetweenColonAndValue?.createUnexpectedNodes(), value: value))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAssociativityKeyword: ExpressibleAsUnexpectedNodes? = nil, associativityKeyword: String, unexpectedBetweenAssociativityKeywordAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndValue: ExpressibleAsUnexpectedNodes? = nil, value: String) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAssociativityKeyword: unexpectedBeforeAssociativityKeyword, associativityKeyword: Token.`identifier`(associativityKeyword), unexpectedBetweenAssociativityKeywordAndColon: unexpectedBetweenAssociativityKeywordAndColon, colon: colon, unexpectedBetweenColonAndValue: unexpectedBetweenColonAndValue, value: Token.`identifier`(value))
  }
  public init(_ constructedNode: PrecedenceGroupAssociativitySyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `PrecedenceGroupAssociativitySyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PrecedenceGroupAssociativitySyntax`.
  func buildPrecedenceGroupAssociativity(format: Format) -> PrecedenceGroupAssociativitySyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = PrecedenceGroupAssociativitySyntax(buildableData.unexpectedBeforeAssociativityKeyword?.buildUnexpectedNodes(format: format), associativityKeyword: buildableData.associativityKeyword.buildToken(format: format), buildableData.unexpectedBetweenAssociativityKeywordAndColon?.buildUnexpectedNodes(format: format), colon: buildableData.colon.buildToken(format: format), buildableData.unexpectedBetweenColonAndValue?.buildUnexpectedNodes(format: format), value: buildableData.value.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildPrecedenceGroupAssociativity(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsPrecedenceGroupAssociativity`.
  public func createPrecedenceGroupAssociativity() -> PrecedenceGroupAssociativity {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PrecedenceGroupAssociativity` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
/// A custom `@` attribute.
public struct CustomAttribute: SyntaxBuildable, ExpressibleAsCustomAttribute {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeAtSignToken: UnexpectedNodes?
    var atSignToken: Token
    var unexpectedBetweenAtSignTokenAndAttributeName: UnexpectedNodes?
    var attributeName: TypeBuildable
    var unexpectedBetweenAttributeNameAndLeftParen: UnexpectedNodes?
    var leftParen: Token?
    var unexpectedBetweenLeftParenAndArgumentList: UnexpectedNodes?
    var argumentList: TupleExprElementList?
    var unexpectedBetweenArgumentListAndRightParen: UnexpectedNodes?
    var rightParen: Token?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(CustomAttributeSyntax)
  }
  private var data: Data
  /// Creates a `CustomAttribute` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAtSignToken: 
  ///   - atSignToken: The `@` sign.
  ///   - unexpectedBetweenAtSignTokenAndAttributeName: 
  ///   - attributeName: The name of the attribute.
  ///   - unexpectedBetweenAttributeNameAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndArgumentList: 
  ///   - argumentList: 
  ///   - unexpectedBetweenArgumentListAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAtSignToken: ExpressibleAsUnexpectedNodes? = nil, atSignToken: Token = Token.`atSign`, unexpectedBetweenAtSignTokenAndAttributeName: ExpressibleAsUnexpectedNodes? = nil, attributeName: ExpressibleAsTypeBuildable, unexpectedBetweenAttributeNameAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token? = nil, unexpectedBetweenLeftParenAndArgumentList: ExpressibleAsUnexpectedNodes? = nil, argumentList: ExpressibleAsTupleExprElementList? = nil, unexpectedBetweenArgumentListAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token? = nil) {
    assert(atSignToken.text == #"@"#)
    assert(leftParen == nil || leftParen!.text == #"("#)
    assert(rightParen == nil || rightParen!.text == #")"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeAtSignToken: unexpectedBeforeAtSignToken?.createUnexpectedNodes(), atSignToken: atSignToken, unexpectedBetweenAtSignTokenAndAttributeName: unexpectedBetweenAtSignTokenAndAttributeName?.createUnexpectedNodes(), attributeName: attributeName.createTypeBuildable(), unexpectedBetweenAttributeNameAndLeftParen: unexpectedBetweenAttributeNameAndLeftParen?.createUnexpectedNodes(), leftParen: leftParen, unexpectedBetweenLeftParenAndArgumentList: unexpectedBetweenLeftParenAndArgumentList?.createUnexpectedNodes(), argumentList: argumentList?.createTupleExprElementList(), unexpectedBetweenArgumentListAndRightParen: unexpectedBetweenArgumentListAndRightParen?.createUnexpectedNodes(), rightParen: rightParen))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAtSignToken: ExpressibleAsUnexpectedNodes? = nil, atSignToken: Token = Token.`atSign`, unexpectedBetweenAtSignTokenAndAttributeName: ExpressibleAsUnexpectedNodes? = nil, attributeName: ExpressibleAsTypeBuildable, unexpectedBetweenAttributeNameAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token? = nil, unexpectedBetweenLeftParenAndArgumentList: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenArgumentListAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token? = nil, @TupleExprElementListBuilder argumentListBuilder: () -> ExpressibleAsTupleExprElementList? =  {
    nil
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAtSignToken: unexpectedBeforeAtSignToken, atSignToken: atSignToken, unexpectedBetweenAtSignTokenAndAttributeName: unexpectedBetweenAtSignTokenAndAttributeName, attributeName: attributeName, unexpectedBetweenAttributeNameAndLeftParen: unexpectedBetweenAttributeNameAndLeftParen, leftParen: leftParen, unexpectedBetweenLeftParenAndArgumentList: unexpectedBetweenLeftParenAndArgumentList, argumentList: argumentListBuilder(), unexpectedBetweenArgumentListAndRightParen: unexpectedBetweenArgumentListAndRightParen, rightParen: rightParen)
  }
  public init(_ constructedNode: CustomAttributeSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `CustomAttributeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `CustomAttributeSyntax`.
  func buildCustomAttribute(format: Format) -> CustomAttributeSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = CustomAttributeSyntax(buildableData.unexpectedBeforeAtSignToken?.buildUnexpectedNodes(format: format), atSignToken: buildableData.atSignToken.buildToken(format: format), buildableData.unexpectedBetweenAtSignTokenAndAttributeName?.buildUnexpectedNodes(format: format), attributeName: buildableData.attributeName.buildType(format: format), buildableData.unexpectedBetweenAttributeNameAndLeftParen?.buildUnexpectedNodes(format: format), leftParen: buildableData.leftParen?.buildToken(format: format), buildableData.unexpectedBetweenLeftParenAndArgumentList?.buildUnexpectedNodes(format: format), argumentList: buildableData.argumentList?.buildTupleExprElementList(format: format), buildableData.unexpectedBetweenArgumentListAndRightParen?.buildUnexpectedNodes(format: format), rightParen: buildableData.rightParen?.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildCustomAttribute(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsCustomAttribute`.
  public func createCustomAttribute() -> CustomAttribute {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `CustomAttribute` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
/// An `@` attribute.
public struct Attribute: SyntaxBuildable, ExpressibleAsAttribute {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeAtSignToken: UnexpectedNodes?
    var atSignToken: Token
    var unexpectedBetweenAtSignTokenAndAttributeName: UnexpectedNodes?
    var attributeName: Token
    var unexpectedBetweenAttributeNameAndLeftParen: UnexpectedNodes?
    var leftParen: Token?
    var unexpectedBetweenLeftParenAndArgument: UnexpectedNodes?
    var argument: SyntaxBuildable?
    var unexpectedBetweenArgumentAndRightParen: UnexpectedNodes?
    var rightParen: Token?
    var unexpectedBetweenRightParenAndTokenList: UnexpectedNodes?
    var tokenList: TokenList?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(AttributeSyntax)
  }
  private var data: Data
  /// Creates a `Attribute` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAtSignToken: 
  ///   - atSignToken: The `@` sign.
  ///   - unexpectedBetweenAtSignTokenAndAttributeName: 
  ///   - attributeName: The name of the attribute.
  ///   - unexpectedBetweenAttributeNameAndLeftParen: 
  ///   - leftParen: If the attribute takes arguments, the opening parenthesis.
  ///   - unexpectedBetweenLeftParenAndArgument: 
  ///   - argument: The arguments of the attribute. In case the attributetakes multiple arguments, they are gather in theappropriate takes first.
  ///   - unexpectedBetweenArgumentAndRightParen: 
  ///   - rightParen: If the attribute takes arguments, the closing parenthesis.
  ///   - unexpectedBetweenRightParenAndTokenList: 
  ///   - tokenList: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAtSignToken: ExpressibleAsUnexpectedNodes? = nil, atSignToken: Token = Token.`atSign`, unexpectedBetweenAtSignTokenAndAttributeName: ExpressibleAsUnexpectedNodes? = nil, attributeName: Token, unexpectedBetweenAttributeNameAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token? = nil, unexpectedBetweenLeftParenAndArgument: ExpressibleAsUnexpectedNodes? = nil, argument: ExpressibleAsSyntaxBuildable? = nil, unexpectedBetweenArgumentAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token? = nil, unexpectedBetweenRightParenAndTokenList: ExpressibleAsUnexpectedNodes? = nil, tokenList: ExpressibleAsTokenList? = nil) {
    assert(atSignToken.text == #"@"#)
    assert(leftParen == nil || leftParen!.text == #"("#)
    assert(rightParen == nil || rightParen!.text == #")"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeAtSignToken: unexpectedBeforeAtSignToken?.createUnexpectedNodes(), atSignToken: atSignToken, unexpectedBetweenAtSignTokenAndAttributeName: unexpectedBetweenAtSignTokenAndAttributeName?.createUnexpectedNodes(), attributeName: attributeName, unexpectedBetweenAttributeNameAndLeftParen: unexpectedBetweenAttributeNameAndLeftParen?.createUnexpectedNodes(), leftParen: leftParen, unexpectedBetweenLeftParenAndArgument: unexpectedBetweenLeftParenAndArgument?.createUnexpectedNodes(), argument: argument?.createSyntaxBuildable(), unexpectedBetweenArgumentAndRightParen: unexpectedBetweenArgumentAndRightParen?.createUnexpectedNodes(), rightParen: rightParen, unexpectedBetweenRightParenAndTokenList: unexpectedBetweenRightParenAndTokenList?.createUnexpectedNodes(), tokenList: tokenList?.createTokenList()))
  }
  public init(_ constructedNode: AttributeSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `AttributeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AttributeSyntax`.
  func buildAttribute(format: Format) -> AttributeSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = AttributeSyntax(buildableData.unexpectedBeforeAtSignToken?.buildUnexpectedNodes(format: format), atSignToken: buildableData.atSignToken.buildToken(format: format), buildableData.unexpectedBetweenAtSignTokenAndAttributeName?.buildUnexpectedNodes(format: format), attributeName: buildableData.attributeName.buildToken(format: format), buildableData.unexpectedBetweenAttributeNameAndLeftParen?.buildUnexpectedNodes(format: format), leftParen: buildableData.leftParen?.buildToken(format: format), buildableData.unexpectedBetweenLeftParenAndArgument?.buildUnexpectedNodes(format: format), argument: buildableData.argument?.buildSyntax(format: format), buildableData.unexpectedBetweenArgumentAndRightParen?.buildUnexpectedNodes(format: format), rightParen: buildableData.rightParen?.buildToken(format: format), buildableData.unexpectedBetweenRightParenAndTokenList?.buildUnexpectedNodes(format: format), tokenList: buildableData.tokenList?.buildTokenList(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildAttribute(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsAttribute`.
  public func createAttribute() -> Attribute {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `Attribute` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
/// The availability argument for the _specialize attribute
public struct AvailabilityEntry: SyntaxBuildable, ExpressibleAsAvailabilityEntry {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeLabel: UnexpectedNodes?
    var label: Token
    var unexpectedBetweenLabelAndColon: UnexpectedNodes?
    var colon: Token
    var unexpectedBetweenColonAndAvailabilityList: UnexpectedNodes?
    var availabilityList: AvailabilitySpecList
    var unexpectedBetweenAvailabilityListAndSemicolon: UnexpectedNodes?
    var semicolon: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(AvailabilityEntrySyntax)
  }
  private var data: Data
  /// Creates a `AvailabilityEntry` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLabel: 
  ///   - label: The label of the argument
  ///   - unexpectedBetweenLabelAndColon: 
  ///   - colon: The colon separating the label and the value
  ///   - unexpectedBetweenColonAndAvailabilityList: 
  ///   - availabilityList: 
  ///   - unexpectedBetweenAvailabilityListAndSemicolon: 
  ///   - semicolon: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLabel: ExpressibleAsUnexpectedNodes? = nil, label: Token, unexpectedBetweenLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndAvailabilityList: ExpressibleAsUnexpectedNodes? = nil, availabilityList: ExpressibleAsAvailabilitySpecList, unexpectedBetweenAvailabilityListAndSemicolon: ExpressibleAsUnexpectedNodes? = nil, semicolon: Token = Token.`semicolon`) {
    assert(colon.text == #":"#)
    assert(semicolon.text == #";"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeLabel: unexpectedBeforeLabel?.createUnexpectedNodes(), label: label, unexpectedBetweenLabelAndColon: unexpectedBetweenLabelAndColon?.createUnexpectedNodes(), colon: colon, unexpectedBetweenColonAndAvailabilityList: unexpectedBetweenColonAndAvailabilityList?.createUnexpectedNodes(), availabilityList: availabilityList.createAvailabilitySpecList(), unexpectedBetweenAvailabilityListAndSemicolon: unexpectedBetweenAvailabilityListAndSemicolon?.createUnexpectedNodes(), semicolon: semicolon))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLabel: ExpressibleAsUnexpectedNodes? = nil, label: String, unexpectedBetweenLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndAvailabilityList: ExpressibleAsUnexpectedNodes? = nil, availabilityList: ExpressibleAsAvailabilitySpecList, unexpectedBetweenAvailabilityListAndSemicolon: ExpressibleAsUnexpectedNodes? = nil, semicolon: Token = Token.`semicolon`) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLabel: unexpectedBeforeLabel, label: Token.`identifier`(label), unexpectedBetweenLabelAndColon: unexpectedBetweenLabelAndColon, colon: colon, unexpectedBetweenColonAndAvailabilityList: unexpectedBetweenColonAndAvailabilityList, availabilityList: availabilityList, unexpectedBetweenAvailabilityListAndSemicolon: unexpectedBetweenAvailabilityListAndSemicolon, semicolon: semicolon)
  }
  public init(_ constructedNode: AvailabilityEntrySyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `AvailabilityEntrySyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AvailabilityEntrySyntax`.
  func buildAvailabilityEntry(format: Format) -> AvailabilityEntrySyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = AvailabilityEntrySyntax(buildableData.unexpectedBeforeLabel?.buildUnexpectedNodes(format: format), label: buildableData.label.buildToken(format: format), buildableData.unexpectedBetweenLabelAndColon?.buildUnexpectedNodes(format: format), colon: buildableData.colon.buildToken(format: format), buildableData.unexpectedBetweenColonAndAvailabilityList?.buildUnexpectedNodes(format: format), availabilityList: buildableData.availabilityList.buildAvailabilitySpecList(format: format), buildableData.unexpectedBetweenAvailabilityListAndSemicolon?.buildUnexpectedNodes(format: format), semicolon: buildableData.semicolon.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildAvailabilityEntry(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsAvailabilityEntry`.
  public func createAvailabilityEntry() -> AvailabilityEntry {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `AvailabilityEntry` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
/// A labeled argument for the `@_specialize` attribute like`exported: true`
public struct LabeledSpecializeEntry: SyntaxBuildable, ExpressibleAsLabeledSpecializeEntry, HasTrailingComma {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeLabel: UnexpectedNodes?
    var label: Token
    var unexpectedBetweenLabelAndColon: UnexpectedNodes?
    var colon: Token
    var unexpectedBetweenColonAndValue: UnexpectedNodes?
    var value: Token
    var unexpectedBetweenValueAndTrailingComma: UnexpectedNodes?
    var trailingComma: Token?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(LabeledSpecializeEntrySyntax)
  }
  private var data: Data
  var hasTrailingComma: Bool {
    switch data {
    case .buildable(let buildableData):
      return buildableData.trailingComma != nil
    case .constructed(let node):
      return node.trailingComma != nil
    }
  }
  /// Creates a `LabeledSpecializeEntry` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLabel: 
  ///   - label: The label of the argument
  ///   - unexpectedBetweenLabelAndColon: 
  ///   - colon: The colon separating the label and the value
  ///   - unexpectedBetweenColonAndValue: 
  ///   - value: The value for this argument
  ///   - unexpectedBetweenValueAndTrailingComma: 
  ///   - trailingComma: A trailing comma if this argument is followed by another one
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLabel: ExpressibleAsUnexpectedNodes? = nil, label: Token, unexpectedBetweenLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndValue: ExpressibleAsUnexpectedNodes? = nil, value: Token, unexpectedBetweenValueAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    assert(colon.text == #":"#)
    assert(trailingComma == nil || trailingComma!.text == #","#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeLabel: unexpectedBeforeLabel?.createUnexpectedNodes(), label: label, unexpectedBetweenLabelAndColon: unexpectedBetweenLabelAndColon?.createUnexpectedNodes(), colon: colon, unexpectedBetweenColonAndValue: unexpectedBetweenColonAndValue?.createUnexpectedNodes(), value: value, unexpectedBetweenValueAndTrailingComma: unexpectedBetweenValueAndTrailingComma?.createUnexpectedNodes(), trailingComma: trailingComma))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLabel: ExpressibleAsUnexpectedNodes? = nil, label: String, unexpectedBetweenLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndValue: ExpressibleAsUnexpectedNodes? = nil, value: Token, unexpectedBetweenValueAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLabel: unexpectedBeforeLabel, label: Token.`identifier`(label), unexpectedBetweenLabelAndColon: unexpectedBetweenLabelAndColon, colon: colon, unexpectedBetweenColonAndValue: unexpectedBetweenColonAndValue, value: value, unexpectedBetweenValueAndTrailingComma: unexpectedBetweenValueAndTrailingComma, trailingComma: trailingComma)
  }
  public init(_ constructedNode: LabeledSpecializeEntrySyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `LabeledSpecializeEntrySyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `LabeledSpecializeEntrySyntax`.
  func buildLabeledSpecializeEntry(format: Format) -> LabeledSpecializeEntrySyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = LabeledSpecializeEntrySyntax(buildableData.unexpectedBeforeLabel?.buildUnexpectedNodes(format: format), label: buildableData.label.buildToken(format: format), buildableData.unexpectedBetweenLabelAndColon?.buildUnexpectedNodes(format: format), colon: buildableData.colon.buildToken(format: format), buildableData.unexpectedBetweenColonAndValue?.buildUnexpectedNodes(format: format), value: buildableData.value.buildToken(format: format), buildableData.unexpectedBetweenValueAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: buildableData.trailingComma?.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildLabeledSpecializeEntry(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsLabeledSpecializeEntry`.
  public func createLabeledSpecializeEntry() -> LabeledSpecializeEntry {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `LabeledSpecializeEntry` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingComma = withComma ? .comma : nil
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withComma = node.withTrailingComma(withComma ? .commaToken() : nil)
      var result = self
      result.data = .constructed(withComma)
      return result
    }
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
/// A labeled argument for the `@_specialize` attribute with a functiondecl value like`target: myFunc(_:)`
public struct TargetFunctionEntry: SyntaxBuildable, ExpressibleAsTargetFunctionEntry, HasTrailingComma {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeLabel: UnexpectedNodes?
    var label: Token
    var unexpectedBetweenLabelAndColon: UnexpectedNodes?
    var colon: Token
    var unexpectedBetweenColonAndDeclname: UnexpectedNodes?
    var declname: DeclName
    var unexpectedBetweenDeclnameAndTrailingComma: UnexpectedNodes?
    var trailingComma: Token?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(TargetFunctionEntrySyntax)
  }
  private var data: Data
  var hasTrailingComma: Bool {
    switch data {
    case .buildable(let buildableData):
      return buildableData.trailingComma != nil
    case .constructed(let node):
      return node.trailingComma != nil
    }
  }
  /// Creates a `TargetFunctionEntry` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLabel: 
  ///   - label: The label of the argument
  ///   - unexpectedBetweenLabelAndColon: 
  ///   - colon: The colon separating the label and the value
  ///   - unexpectedBetweenColonAndDeclname: 
  ///   - declname: The value for this argument
  ///   - unexpectedBetweenDeclnameAndTrailingComma: 
  ///   - trailingComma: A trailing comma if this argument is followed by another one
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLabel: ExpressibleAsUnexpectedNodes? = nil, label: Token, unexpectedBetweenLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndDeclname: ExpressibleAsUnexpectedNodes? = nil, declname: ExpressibleAsDeclName, unexpectedBetweenDeclnameAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    assert(colon.text == #":"#)
    assert(trailingComma == nil || trailingComma!.text == #","#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeLabel: unexpectedBeforeLabel?.createUnexpectedNodes(), label: label, unexpectedBetweenLabelAndColon: unexpectedBetweenLabelAndColon?.createUnexpectedNodes(), colon: colon, unexpectedBetweenColonAndDeclname: unexpectedBetweenColonAndDeclname?.createUnexpectedNodes(), declname: declname.createDeclName(), unexpectedBetweenDeclnameAndTrailingComma: unexpectedBetweenDeclnameAndTrailingComma?.createUnexpectedNodes(), trailingComma: trailingComma))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLabel: ExpressibleAsUnexpectedNodes? = nil, label: String, unexpectedBetweenLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndDeclname: ExpressibleAsUnexpectedNodes? = nil, declname: ExpressibleAsDeclName, unexpectedBetweenDeclnameAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLabel: unexpectedBeforeLabel, label: Token.`identifier`(label), unexpectedBetweenLabelAndColon: unexpectedBetweenLabelAndColon, colon: colon, unexpectedBetweenColonAndDeclname: unexpectedBetweenColonAndDeclname, declname: declname, unexpectedBetweenDeclnameAndTrailingComma: unexpectedBetweenDeclnameAndTrailingComma, trailingComma: trailingComma)
  }
  public init(_ constructedNode: TargetFunctionEntrySyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `TargetFunctionEntrySyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TargetFunctionEntrySyntax`.
  func buildTargetFunctionEntry(format: Format) -> TargetFunctionEntrySyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = TargetFunctionEntrySyntax(buildableData.unexpectedBeforeLabel?.buildUnexpectedNodes(format: format), label: buildableData.label.buildToken(format: format), buildableData.unexpectedBetweenLabelAndColon?.buildUnexpectedNodes(format: format), colon: buildableData.colon.buildToken(format: format), buildableData.unexpectedBetweenColonAndDeclname?.buildUnexpectedNodes(format: format), declname: buildableData.declname.buildDeclName(format: format), buildableData.unexpectedBetweenDeclnameAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: buildableData.trailingComma?.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildTargetFunctionEntry(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsTargetFunctionEntry`.
  public func createTargetFunctionEntry() -> TargetFunctionEntry {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TargetFunctionEntry` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingComma = withComma ? .comma : nil
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withComma = node.withTrailingComma(withComma ? .commaToken() : nil)
      var result = self
      result.data = .constructed(withComma)
      return result
    }
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
/// The argument for the `@_dynamic_replacement` or `@_private`attribute of the form `for: "function()"` or `sourceFile:"Src.swift"`
public struct NamedAttributeStringArgument: SyntaxBuildable, ExpressibleAsNamedAttributeStringArgument {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeNameTok: UnexpectedNodes?
    var nameTok: Token
    var unexpectedBetweenNameTokAndColon: UnexpectedNodes?
    var colon: Token
    var unexpectedBetweenColonAndStringOrDeclname: UnexpectedNodes?
    var stringOrDeclname: SyntaxBuildable
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(NamedAttributeStringArgumentSyntax)
  }
  private var data: Data
  /// Creates a `NamedAttributeStringArgument` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeNameTok: 
  ///   - nameTok: The label of the argument
  ///   - unexpectedBetweenNameTokAndColon: 
  ///   - colon: The colon separating the label and the value
  ///   - unexpectedBetweenColonAndStringOrDeclname: 
  ///   - stringOrDeclname: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeNameTok: ExpressibleAsUnexpectedNodes? = nil, nameTok: Token, unexpectedBetweenNameTokAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndStringOrDeclname: ExpressibleAsUnexpectedNodes? = nil, stringOrDeclname: ExpressibleAsSyntaxBuildable) {
    assert(colon.text == #":"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeNameTok: unexpectedBeforeNameTok?.createUnexpectedNodes(), nameTok: nameTok, unexpectedBetweenNameTokAndColon: unexpectedBetweenNameTokAndColon?.createUnexpectedNodes(), colon: colon, unexpectedBetweenColonAndStringOrDeclname: unexpectedBetweenColonAndStringOrDeclname?.createUnexpectedNodes(), stringOrDeclname: stringOrDeclname.createSyntaxBuildable()))
  }
  public init(_ constructedNode: NamedAttributeStringArgumentSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `NamedAttributeStringArgumentSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `NamedAttributeStringArgumentSyntax`.
  func buildNamedAttributeStringArgument(format: Format) -> NamedAttributeStringArgumentSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = NamedAttributeStringArgumentSyntax(buildableData.unexpectedBeforeNameTok?.buildUnexpectedNodes(format: format), nameTok: buildableData.nameTok.buildToken(format: format), buildableData.unexpectedBetweenNameTokAndColon?.buildUnexpectedNodes(format: format), colon: buildableData.colon.buildToken(format: format), buildableData.unexpectedBetweenColonAndStringOrDeclname?.buildUnexpectedNodes(format: format), stringOrDeclname: buildableData.stringOrDeclname.buildSyntax(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildNamedAttributeStringArgument(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsNamedAttributeStringArgument`.
  public func createNamedAttributeStringArgument() -> NamedAttributeStringArgument {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `NamedAttributeStringArgument` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct DeclName: SyntaxBuildable, ExpressibleAsDeclName {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeDeclBaseName: UnexpectedNodes?
    var declBaseName: SyntaxBuildable
    var unexpectedBetweenDeclBaseNameAndDeclNameArguments: UnexpectedNodes?
    var declNameArguments: DeclNameArguments?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(DeclNameSyntax)
  }
  private var data: Data
  /// Creates a `DeclName` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeDeclBaseName: 
  ///   - declBaseName: The base name of the protocol's requirement.
  ///   - unexpectedBetweenDeclBaseNameAndDeclNameArguments: 
  ///   - declNameArguments: The argument labels of the protocol's requirement if itis a function requirement.
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeDeclBaseName: ExpressibleAsUnexpectedNodes? = nil, declBaseName: ExpressibleAsSyntaxBuildable, unexpectedBetweenDeclBaseNameAndDeclNameArguments: ExpressibleAsUnexpectedNodes? = nil, declNameArguments: ExpressibleAsDeclNameArguments? = nil) {
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeDeclBaseName: unexpectedBeforeDeclBaseName?.createUnexpectedNodes(), declBaseName: declBaseName.createSyntaxBuildable(), unexpectedBetweenDeclBaseNameAndDeclNameArguments: unexpectedBetweenDeclBaseNameAndDeclNameArguments?.createUnexpectedNodes(), declNameArguments: declNameArguments?.createDeclNameArguments()))
  }
  public init(_ constructedNode: DeclNameSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `DeclNameSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DeclNameSyntax`.
  func buildDeclName(format: Format) -> DeclNameSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = DeclNameSyntax(buildableData.unexpectedBeforeDeclBaseName?.buildUnexpectedNodes(format: format), declBaseName: buildableData.declBaseName.buildSyntax(format: format), buildableData.unexpectedBetweenDeclBaseNameAndDeclNameArguments?.buildUnexpectedNodes(format: format), declNameArguments: buildableData.declNameArguments?.buildDeclNameArguments(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildDeclName(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsDeclName`.
  public func createDeclName() -> DeclName {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DeclName` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
/// The arguments for the `@_implements` attribute of the form`Type, methodName(arg1Label:arg2Label:)`
public struct ImplementsAttributeArguments: SyntaxBuildable, ExpressibleAsImplementsAttributeArguments {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeType: UnexpectedNodes?
    var type: TypeBuildable
    var unexpectedBetweenTypeAndComma: UnexpectedNodes?
    var comma: Token
    var unexpectedBetweenCommaAndDeclBaseName: UnexpectedNodes?
    var declBaseName: Token
    var unexpectedBetweenDeclBaseNameAndDeclNameArguments: UnexpectedNodes?
    var declNameArguments: DeclNameArguments?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ImplementsAttributeArgumentsSyntax)
  }
  private var data: Data
  /// Creates a `ImplementsAttributeArguments` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeType: 
  ///   - type: The type for which the method with this attributeimplements a requirement.
  ///   - unexpectedBetweenTypeAndComma: 
  ///   - comma: The comma separating the type and method name
  ///   - unexpectedBetweenCommaAndDeclBaseName: 
  ///   - declBaseName: The base name of the protocol's requirement.
  ///   - unexpectedBetweenDeclBaseNameAndDeclNameArguments: 
  ///   - declNameArguments: The argument labels of the protocol's requirement if itis a function requirement.
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeType: ExpressibleAsUnexpectedNodes? = nil, type: ExpressibleAsTypeBuildable, unexpectedBetweenTypeAndComma: ExpressibleAsUnexpectedNodes? = nil, comma: Token = Token.`comma`, unexpectedBetweenCommaAndDeclBaseName: ExpressibleAsUnexpectedNodes? = nil, declBaseName: Token, unexpectedBetweenDeclBaseNameAndDeclNameArguments: ExpressibleAsUnexpectedNodes? = nil, declNameArguments: ExpressibleAsDeclNameArguments? = nil) {
    assert(comma.text == #","#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeType: unexpectedBeforeType?.createUnexpectedNodes(), type: type.createTypeBuildable(), unexpectedBetweenTypeAndComma: unexpectedBetweenTypeAndComma?.createUnexpectedNodes(), comma: comma, unexpectedBetweenCommaAndDeclBaseName: unexpectedBetweenCommaAndDeclBaseName?.createUnexpectedNodes(), declBaseName: declBaseName, unexpectedBetweenDeclBaseNameAndDeclNameArguments: unexpectedBetweenDeclBaseNameAndDeclNameArguments?.createUnexpectedNodes(), declNameArguments: declNameArguments?.createDeclNameArguments()))
  }
  public init(_ constructedNode: ImplementsAttributeArgumentsSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ImplementsAttributeArgumentsSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ImplementsAttributeArgumentsSyntax`.
  func buildImplementsAttributeArguments(format: Format) -> ImplementsAttributeArgumentsSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ImplementsAttributeArgumentsSyntax(buildableData.unexpectedBeforeType?.buildUnexpectedNodes(format: format), type: buildableData.type.buildType(format: format), buildableData.unexpectedBetweenTypeAndComma?.buildUnexpectedNodes(format: format), comma: buildableData.comma.buildToken(format: format), buildableData.unexpectedBetweenCommaAndDeclBaseName?.buildUnexpectedNodes(format: format), declBaseName: buildableData.declBaseName.buildToken(format: format), buildableData.unexpectedBetweenDeclBaseNameAndDeclNameArguments?.buildUnexpectedNodes(format: format), declNameArguments: buildableData.declNameArguments?.buildDeclNameArguments(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildImplementsAttributeArguments(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsImplementsAttributeArguments`.
  public func createImplementsAttributeArguments() -> ImplementsAttributeArguments {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ImplementsAttributeArguments` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
/// A piece of an Objective-C selector. Either consisting of just anidentifier for a nullary selector, an identifier and a colon for alabeled argument or just a colon for an unlabeled argument
public struct ObjCSelectorPiece: SyntaxBuildable, ExpressibleAsObjCSelectorPiece {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeName: UnexpectedNodes?
    var name: Token?
    var unexpectedBetweenNameAndColon: UnexpectedNodes?
    var colon: Token?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ObjCSelectorPieceSyntax)
  }
  private var data: Data
  /// Creates a `ObjCSelectorPiece` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndColon: 
  ///   - colon: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: Token? = nil, unexpectedBetweenNameAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token? = nil) {
    assert(colon == nil || colon!.text == #":"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeName: unexpectedBeforeName?.createUnexpectedNodes(), name: name, unexpectedBetweenNameAndColon: unexpectedBetweenNameAndColon?.createUnexpectedNodes(), colon: colon))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: String?, unexpectedBetweenNameAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeName: unexpectedBeforeName, name: name.map { Token.`identifier`($0) }, unexpectedBetweenNameAndColon: unexpectedBetweenNameAndColon, colon: colon)
  }
  public init(_ constructedNode: ObjCSelectorPieceSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ObjCSelectorPieceSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ObjCSelectorPieceSyntax`.
  func buildObjCSelectorPiece(format: Format) -> ObjCSelectorPieceSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ObjCSelectorPieceSyntax(buildableData.unexpectedBeforeName?.buildUnexpectedNodes(format: format), name: buildableData.name?.buildToken(format: format), buildableData.unexpectedBetweenNameAndColon?.buildUnexpectedNodes(format: format), colon: buildableData.colon?.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildObjCSelectorPiece(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsObjCSelectorPiece`.
  public func createObjCSelectorPiece() -> ObjCSelectorPiece {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ObjCSelectorPiece` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
/// The arguments for the `@differentiable` attribute: an optionaldifferentiability kind, an optional differentiability parameter clause,and an optional 'where' clause.
public struct DifferentiableAttributeArguments: SyntaxBuildable, ExpressibleAsDifferentiableAttributeArguments {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeDiffKind: UnexpectedNodes?
    var diffKind: Token?
    var unexpectedBetweenDiffKindAndDiffKindComma: UnexpectedNodes?
    var diffKindComma: Token?
    var unexpectedBetweenDiffKindCommaAndDiffParams: UnexpectedNodes?
    var diffParams: DifferentiabilityParamsClause?
    var unexpectedBetweenDiffParamsAndDiffParamsComma: UnexpectedNodes?
    var diffParamsComma: Token?
    var unexpectedBetweenDiffParamsCommaAndWhereClause: UnexpectedNodes?
    var whereClause: GenericWhereClause?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(DifferentiableAttributeArgumentsSyntax)
  }
  private var data: Data
  /// Creates a `DifferentiableAttributeArguments` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeDiffKind: 
  ///   - diffKind: 
  ///   - unexpectedBetweenDiffKindAndDiffKindComma: 
  ///   - diffKindComma: The comma following the differentiability kind, if it exists.
  ///   - unexpectedBetweenDiffKindCommaAndDiffParams: 
  ///   - diffParams: 
  ///   - unexpectedBetweenDiffParamsAndDiffParamsComma: 
  ///   - diffParamsComma: The comma following the differentiability parameters clause,if it exists.
  ///   - unexpectedBetweenDiffParamsCommaAndWhereClause: 
  ///   - whereClause: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeDiffKind: ExpressibleAsUnexpectedNodes? = nil, diffKind: Token? = nil, unexpectedBetweenDiffKindAndDiffKindComma: ExpressibleAsUnexpectedNodes? = nil, diffKindComma: Token? = nil, unexpectedBetweenDiffKindCommaAndDiffParams: ExpressibleAsUnexpectedNodes? = nil, diffParams: ExpressibleAsDifferentiabilityParamsClause? = nil, unexpectedBetweenDiffParamsAndDiffParamsComma: ExpressibleAsUnexpectedNodes? = nil, diffParamsComma: Token? = nil, unexpectedBetweenDiffParamsCommaAndWhereClause: ExpressibleAsUnexpectedNodes? = nil, whereClause: ExpressibleAsGenericWhereClause? = nil) {
    assert(diffKind == nil || diffKind!.text == #"forward"# || diffKind!.text == #"reverse"# || diffKind!.text == #"linear"#)
    assert(diffKindComma == nil || diffKindComma!.text == #","#)
    assert(diffParamsComma == nil || diffParamsComma!.text == #","#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeDiffKind: unexpectedBeforeDiffKind?.createUnexpectedNodes(), diffKind: diffKind, unexpectedBetweenDiffKindAndDiffKindComma: unexpectedBetweenDiffKindAndDiffKindComma?.createUnexpectedNodes(), diffKindComma: diffKindComma, unexpectedBetweenDiffKindCommaAndDiffParams: unexpectedBetweenDiffKindCommaAndDiffParams?.createUnexpectedNodes(), diffParams: diffParams?.createDifferentiabilityParamsClause(), unexpectedBetweenDiffParamsAndDiffParamsComma: unexpectedBetweenDiffParamsAndDiffParamsComma?.createUnexpectedNodes(), diffParamsComma: diffParamsComma, unexpectedBetweenDiffParamsCommaAndWhereClause: unexpectedBetweenDiffParamsCommaAndWhereClause?.createUnexpectedNodes(), whereClause: whereClause?.createGenericWhereClause()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeDiffKind: ExpressibleAsUnexpectedNodes? = nil, diffKind: String?, unexpectedBetweenDiffKindAndDiffKindComma: ExpressibleAsUnexpectedNodes? = nil, diffKindComma: Token? = nil, unexpectedBetweenDiffKindCommaAndDiffParams: ExpressibleAsUnexpectedNodes? = nil, diffParams: ExpressibleAsDifferentiabilityParamsClause? = nil, unexpectedBetweenDiffParamsAndDiffParamsComma: ExpressibleAsUnexpectedNodes? = nil, diffParamsComma: Token? = nil, unexpectedBetweenDiffParamsCommaAndWhereClause: ExpressibleAsUnexpectedNodes? = nil, whereClause: ExpressibleAsGenericWhereClause? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeDiffKind: unexpectedBeforeDiffKind, diffKind: diffKind.map { Token.`identifier`($0) }, unexpectedBetweenDiffKindAndDiffKindComma: unexpectedBetweenDiffKindAndDiffKindComma, diffKindComma: diffKindComma, unexpectedBetweenDiffKindCommaAndDiffParams: unexpectedBetweenDiffKindCommaAndDiffParams, diffParams: diffParams, unexpectedBetweenDiffParamsAndDiffParamsComma: unexpectedBetweenDiffParamsAndDiffParamsComma, diffParamsComma: diffParamsComma, unexpectedBetweenDiffParamsCommaAndWhereClause: unexpectedBetweenDiffParamsCommaAndWhereClause, whereClause: whereClause)
  }
  public init(_ constructedNode: DifferentiableAttributeArgumentsSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `DifferentiableAttributeArgumentsSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DifferentiableAttributeArgumentsSyntax`.
  func buildDifferentiableAttributeArguments(format: Format) -> DifferentiableAttributeArgumentsSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = DifferentiableAttributeArgumentsSyntax(buildableData.unexpectedBeforeDiffKind?.buildUnexpectedNodes(format: format), diffKind: buildableData.diffKind?.buildToken(format: format), buildableData.unexpectedBetweenDiffKindAndDiffKindComma?.buildUnexpectedNodes(format: format), diffKindComma: buildableData.diffKindComma?.buildToken(format: format), buildableData.unexpectedBetweenDiffKindCommaAndDiffParams?.buildUnexpectedNodes(format: format), diffParams: buildableData.diffParams?.buildDifferentiabilityParamsClause(format: format), buildableData.unexpectedBetweenDiffParamsAndDiffParamsComma?.buildUnexpectedNodes(format: format), diffParamsComma: buildableData.diffParamsComma?.buildToken(format: format), buildableData.unexpectedBetweenDiffParamsCommaAndWhereClause?.buildUnexpectedNodes(format: format), whereClause: buildableData.whereClause?.buildGenericWhereClause(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildDifferentiableAttributeArguments(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsDifferentiableAttributeArguments`.
  public func createDifferentiableAttributeArguments() -> DifferentiableAttributeArguments {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DifferentiableAttributeArguments` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
/// A clause containing differentiability parameters.
public struct DifferentiabilityParamsClause: SyntaxBuildable, ExpressibleAsDifferentiabilityParamsClause {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeWrtLabel: UnexpectedNodes?
    var wrtLabel: Token
    var unexpectedBetweenWrtLabelAndColon: UnexpectedNodes?
    var colon: Token
    var unexpectedBetweenColonAndParameters: UnexpectedNodes?
    var parameters: SyntaxBuildable
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(DifferentiabilityParamsClauseSyntax)
  }
  private var data: Data
  /// Creates a `DifferentiabilityParamsClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeWrtLabel: 
  ///   - wrtLabel: The "wrt" label.
  ///   - unexpectedBetweenWrtLabelAndColon: 
  ///   - colon: The colon separating "wrt" and the parameter list.
  ///   - unexpectedBetweenColonAndParameters: 
  ///   - parameters: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeWrtLabel: ExpressibleAsUnexpectedNodes? = nil, wrtLabel: Token, unexpectedBetweenWrtLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndParameters: ExpressibleAsUnexpectedNodes? = nil, parameters: ExpressibleAsSyntaxBuildable) {
    assert(wrtLabel.text == #"wrt"#)
    assert(colon.text == #":"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeWrtLabel: unexpectedBeforeWrtLabel?.createUnexpectedNodes(), wrtLabel: wrtLabel, unexpectedBetweenWrtLabelAndColon: unexpectedBetweenWrtLabelAndColon?.createUnexpectedNodes(), colon: colon, unexpectedBetweenColonAndParameters: unexpectedBetweenColonAndParameters?.createUnexpectedNodes(), parameters: parameters.createSyntaxBuildable()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeWrtLabel: ExpressibleAsUnexpectedNodes? = nil, wrtLabel: String, unexpectedBetweenWrtLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndParameters: ExpressibleAsUnexpectedNodes? = nil, parameters: ExpressibleAsSyntaxBuildable) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeWrtLabel: unexpectedBeforeWrtLabel, wrtLabel: Token.`identifier`(wrtLabel), unexpectedBetweenWrtLabelAndColon: unexpectedBetweenWrtLabelAndColon, colon: colon, unexpectedBetweenColonAndParameters: unexpectedBetweenColonAndParameters, parameters: parameters)
  }
  public init(_ constructedNode: DifferentiabilityParamsClauseSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `DifferentiabilityParamsClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DifferentiabilityParamsClauseSyntax`.
  func buildDifferentiabilityParamsClause(format: Format) -> DifferentiabilityParamsClauseSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = DifferentiabilityParamsClauseSyntax(buildableData.unexpectedBeforeWrtLabel?.buildUnexpectedNodes(format: format), wrtLabel: buildableData.wrtLabel.buildToken(format: format), buildableData.unexpectedBetweenWrtLabelAndColon?.buildUnexpectedNodes(format: format), colon: buildableData.colon.buildToken(format: format), buildableData.unexpectedBetweenColonAndParameters?.buildUnexpectedNodes(format: format), parameters: buildableData.parameters.buildSyntax(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildDifferentiabilityParamsClause(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsDifferentiabilityParamsClause`.
  public func createDifferentiabilityParamsClause() -> DifferentiabilityParamsClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DifferentiabilityParamsClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
/// The differentiability parameters.
public struct DifferentiabilityParams: SyntaxBuildable, ExpressibleAsDifferentiabilityParams {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeLeftParen: UnexpectedNodes?
    var leftParen: Token
    var unexpectedBetweenLeftParenAndDiffParams: UnexpectedNodes?
    var diffParams: DifferentiabilityParamList
    var unexpectedBetweenDiffParamsAndRightParen: UnexpectedNodes?
    var rightParen: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(DifferentiabilityParamsSyntax)
  }
  private var data: Data
  /// Creates a `DifferentiabilityParams` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndDiffParams: 
  ///   - diffParams: The parameters for differentiation.
  ///   - unexpectedBetweenDiffParamsAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndDiffParams: ExpressibleAsUnexpectedNodes? = nil, diffParams: ExpressibleAsDifferentiabilityParamList, unexpectedBetweenDiffParamsAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    assert(leftParen.text == #"("#)
    assert(rightParen.text == #")"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeLeftParen: unexpectedBeforeLeftParen?.createUnexpectedNodes(), leftParen: leftParen, unexpectedBetweenLeftParenAndDiffParams: unexpectedBetweenLeftParenAndDiffParams?.createUnexpectedNodes(), diffParams: diffParams.createDifferentiabilityParamList(), unexpectedBetweenDiffParamsAndRightParen: unexpectedBetweenDiffParamsAndRightParen?.createUnexpectedNodes(), rightParen: rightParen))
  }
  public init(_ constructedNode: DifferentiabilityParamsSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `DifferentiabilityParamsSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DifferentiabilityParamsSyntax`.
  func buildDifferentiabilityParams(format: Format) -> DifferentiabilityParamsSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = DifferentiabilityParamsSyntax(buildableData.unexpectedBeforeLeftParen?.buildUnexpectedNodes(format: format), leftParen: buildableData.leftParen.buildToken(format: format), buildableData.unexpectedBetweenLeftParenAndDiffParams?.buildUnexpectedNodes(format: format), diffParams: buildableData.diffParams.buildDifferentiabilityParamList(format: format), buildableData.unexpectedBetweenDiffParamsAndRightParen?.buildUnexpectedNodes(format: format), rightParen: buildableData.rightParen.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildDifferentiabilityParams(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsDifferentiabilityParams`.
  public func createDifferentiabilityParams() -> DifferentiabilityParams {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DifferentiabilityParams` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
/// A differentiability parameter: either the "self" identifier, a functionparameter name, or a function parameter index.
public struct DifferentiabilityParam: SyntaxBuildable, ExpressibleAsDifferentiabilityParam, HasTrailingComma {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeParameter: UnexpectedNodes?
    var parameter: SyntaxBuildable
    var unexpectedBetweenParameterAndTrailingComma: UnexpectedNodes?
    var trailingComma: Token?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(DifferentiabilityParamSyntax)
  }
  private var data: Data
  var hasTrailingComma: Bool {
    switch data {
    case .buildable(let buildableData):
      return buildableData.trailingComma != nil
    case .constructed(let node):
      return node.trailingComma != nil
    }
  }
  /// Creates a `DifferentiabilityParam` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeParameter: 
  ///   - parameter: 
  ///   - unexpectedBetweenParameterAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeParameter: ExpressibleAsUnexpectedNodes? = nil, parameter: ExpressibleAsSyntaxBuildable, unexpectedBetweenParameterAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    assert(trailingComma == nil || trailingComma!.text == #","#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeParameter: unexpectedBeforeParameter?.createUnexpectedNodes(), parameter: parameter.createSyntaxBuildable(), unexpectedBetweenParameterAndTrailingComma: unexpectedBetweenParameterAndTrailingComma?.createUnexpectedNodes(), trailingComma: trailingComma))
  }
  public init(_ constructedNode: DifferentiabilityParamSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `DifferentiabilityParamSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DifferentiabilityParamSyntax`.
  func buildDifferentiabilityParam(format: Format) -> DifferentiabilityParamSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = DifferentiabilityParamSyntax(buildableData.unexpectedBeforeParameter?.buildUnexpectedNodes(format: format), parameter: buildableData.parameter.buildSyntax(format: format), buildableData.unexpectedBetweenParameterAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: buildableData.trailingComma?.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildDifferentiabilityParam(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsDifferentiabilityParam`.
  public func createDifferentiabilityParam() -> DifferentiabilityParam {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DifferentiabilityParam` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingComma = withComma ? .comma : nil
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withComma = node.withTrailingComma(withComma ? .commaToken() : nil)
      var result = self
      result.data = .constructed(withComma)
      return result
    }
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
/// The arguments for the '@derivative(of:)' and '@transpose(of:)'attributes: the 'of:' label, the original declaration name, and anoptional differentiability parameter list.
public struct DerivativeRegistrationAttributeArguments: SyntaxBuildable, ExpressibleAsDerivativeRegistrationAttributeArguments {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeOfLabel: UnexpectedNodes?
    var ofLabel: Token
    var unexpectedBetweenOfLabelAndColon: UnexpectedNodes?
    var colon: Token
    var unexpectedBetweenColonAndOriginalDeclName: UnexpectedNodes?
    var originalDeclName: QualifiedDeclName
    var unexpectedBetweenOriginalDeclNameAndPeriod: UnexpectedNodes?
    var period: Token?
    var unexpectedBetweenPeriodAndAccessorKind: UnexpectedNodes?
    var accessorKind: Token?
    var unexpectedBetweenAccessorKindAndComma: UnexpectedNodes?
    var comma: Token?
    var unexpectedBetweenCommaAndDiffParams: UnexpectedNodes?
    var diffParams: DifferentiabilityParamsClause?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(DerivativeRegistrationAttributeArgumentsSyntax)
  }
  private var data: Data
  /// Creates a `DerivativeRegistrationAttributeArguments` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeOfLabel: 
  ///   - ofLabel: The "of" label.
  ///   - unexpectedBetweenOfLabelAndColon: 
  ///   - colon: The colon separating the "of" label and the originaldeclaration name.
  ///   - unexpectedBetweenColonAndOriginalDeclName: 
  ///   - originalDeclName: The referenced original declaration name.
  ///   - unexpectedBetweenOriginalDeclNameAndPeriod: 
  ///   - period: The period separating the original declaration name and theaccessor name.
  ///   - unexpectedBetweenPeriodAndAccessorKind: 
  ///   - accessorKind: The accessor name.
  ///   - unexpectedBetweenAccessorKindAndComma: 
  ///   - comma: 
  ///   - unexpectedBetweenCommaAndDiffParams: 
  ///   - diffParams: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeOfLabel: ExpressibleAsUnexpectedNodes? = nil, ofLabel: Token, unexpectedBetweenOfLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndOriginalDeclName: ExpressibleAsUnexpectedNodes? = nil, originalDeclName: ExpressibleAsQualifiedDeclName, unexpectedBetweenOriginalDeclNameAndPeriod: ExpressibleAsUnexpectedNodes? = nil, period: Token? = nil, unexpectedBetweenPeriodAndAccessorKind: ExpressibleAsUnexpectedNodes? = nil, accessorKind: Token? = nil, unexpectedBetweenAccessorKindAndComma: ExpressibleAsUnexpectedNodes? = nil, comma: Token? = nil, unexpectedBetweenCommaAndDiffParams: ExpressibleAsUnexpectedNodes? = nil, diffParams: ExpressibleAsDifferentiabilityParamsClause? = nil) {
    assert(ofLabel.text == #"of"#)
    assert(colon.text == #":"#)
    assert(period == nil || period!.text == #"."#)
    assert(accessorKind == nil || accessorKind!.text == #"get"# || accessorKind!.text == #"set"#)
    assert(comma == nil || comma!.text == #","#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeOfLabel: unexpectedBeforeOfLabel?.createUnexpectedNodes(), ofLabel: ofLabel, unexpectedBetweenOfLabelAndColon: unexpectedBetweenOfLabelAndColon?.createUnexpectedNodes(), colon: colon, unexpectedBetweenColonAndOriginalDeclName: unexpectedBetweenColonAndOriginalDeclName?.createUnexpectedNodes(), originalDeclName: originalDeclName.createQualifiedDeclName(), unexpectedBetweenOriginalDeclNameAndPeriod: unexpectedBetweenOriginalDeclNameAndPeriod?.createUnexpectedNodes(), period: period, unexpectedBetweenPeriodAndAccessorKind: unexpectedBetweenPeriodAndAccessorKind?.createUnexpectedNodes(), accessorKind: accessorKind, unexpectedBetweenAccessorKindAndComma: unexpectedBetweenAccessorKindAndComma?.createUnexpectedNodes(), comma: comma, unexpectedBetweenCommaAndDiffParams: unexpectedBetweenCommaAndDiffParams?.createUnexpectedNodes(), diffParams: diffParams?.createDifferentiabilityParamsClause()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeOfLabel: ExpressibleAsUnexpectedNodes? = nil, ofLabel: String, unexpectedBetweenOfLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndOriginalDeclName: ExpressibleAsUnexpectedNodes? = nil, originalDeclName: ExpressibleAsQualifiedDeclName, unexpectedBetweenOriginalDeclNameAndPeriod: ExpressibleAsUnexpectedNodes? = nil, period: Token? = nil, unexpectedBetweenPeriodAndAccessorKind: ExpressibleAsUnexpectedNodes? = nil, accessorKind: String?, unexpectedBetweenAccessorKindAndComma: ExpressibleAsUnexpectedNodes? = nil, comma: Token? = nil, unexpectedBetweenCommaAndDiffParams: ExpressibleAsUnexpectedNodes? = nil, diffParams: ExpressibleAsDifferentiabilityParamsClause? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeOfLabel: unexpectedBeforeOfLabel, ofLabel: Token.`identifier`(ofLabel), unexpectedBetweenOfLabelAndColon: unexpectedBetweenOfLabelAndColon, colon: colon, unexpectedBetweenColonAndOriginalDeclName: unexpectedBetweenColonAndOriginalDeclName, originalDeclName: originalDeclName, unexpectedBetweenOriginalDeclNameAndPeriod: unexpectedBetweenOriginalDeclNameAndPeriod, period: period, unexpectedBetweenPeriodAndAccessorKind: unexpectedBetweenPeriodAndAccessorKind, accessorKind: accessorKind.map { Token.`identifier`($0) }, unexpectedBetweenAccessorKindAndComma: unexpectedBetweenAccessorKindAndComma, comma: comma, unexpectedBetweenCommaAndDiffParams: unexpectedBetweenCommaAndDiffParams, diffParams: diffParams)
  }
  public init(_ constructedNode: DerivativeRegistrationAttributeArgumentsSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `DerivativeRegistrationAttributeArgumentsSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DerivativeRegistrationAttributeArgumentsSyntax`.
  func buildDerivativeRegistrationAttributeArguments(format: Format) -> DerivativeRegistrationAttributeArgumentsSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = DerivativeRegistrationAttributeArgumentsSyntax(buildableData.unexpectedBeforeOfLabel?.buildUnexpectedNodes(format: format), ofLabel: buildableData.ofLabel.buildToken(format: format), buildableData.unexpectedBetweenOfLabelAndColon?.buildUnexpectedNodes(format: format), colon: buildableData.colon.buildToken(format: format), buildableData.unexpectedBetweenColonAndOriginalDeclName?.buildUnexpectedNodes(format: format), originalDeclName: buildableData.originalDeclName.buildQualifiedDeclName(format: format), buildableData.unexpectedBetweenOriginalDeclNameAndPeriod?.buildUnexpectedNodes(format: format), period: buildableData.period?.buildToken(format: format), buildableData.unexpectedBetweenPeriodAndAccessorKind?.buildUnexpectedNodes(format: format), accessorKind: buildableData.accessorKind?.buildToken(format: format), buildableData.unexpectedBetweenAccessorKindAndComma?.buildUnexpectedNodes(format: format), comma: buildableData.comma?.buildToken(format: format), buildableData.unexpectedBetweenCommaAndDiffParams?.buildUnexpectedNodes(format: format), diffParams: buildableData.diffParams?.buildDifferentiabilityParamsClause(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildDerivativeRegistrationAttributeArguments(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsDerivativeRegistrationAttributeArguments`.
  public func createDerivativeRegistrationAttributeArguments() -> DerivativeRegistrationAttributeArguments {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `DerivativeRegistrationAttributeArguments` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
/// An optionally qualified function declaration name (e.g. `+(_:_:)`,`A.B.C.foo(_:_:)`).
public struct QualifiedDeclName: SyntaxBuildable, ExpressibleAsQualifiedDeclName {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeBaseType: UnexpectedNodes?
    var baseType: TypeBuildable?
    var unexpectedBetweenBaseTypeAndDot: UnexpectedNodes?
    var dot: Token?
    var unexpectedBetweenDotAndName: UnexpectedNodes?
    var name: Token
    var unexpectedBetweenNameAndArguments: UnexpectedNodes?
    var arguments: DeclNameArguments?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(QualifiedDeclNameSyntax)
  }
  private var data: Data
  /// Creates a `QualifiedDeclName` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeBaseType: 
  ///   - baseType: The base type of the qualified name, optionally specified.
  ///   - unexpectedBetweenBaseTypeAndDot: 
  ///   - dot: 
  ///   - unexpectedBetweenDotAndName: 
  ///   - name: The base name of the referenced function.
  ///   - unexpectedBetweenNameAndArguments: 
  ///   - arguments: The argument labels of the referenced function, optionallyspecified.
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeBaseType: ExpressibleAsUnexpectedNodes? = nil, baseType: ExpressibleAsTypeBuildable? = nil, unexpectedBetweenBaseTypeAndDot: ExpressibleAsUnexpectedNodes? = nil, dot: Token? = nil, unexpectedBetweenDotAndName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndArguments: ExpressibleAsUnexpectedNodes? = nil, arguments: ExpressibleAsDeclNameArguments? = nil) {
    assert(dot == nil || dot!.text == #"."# || dot!.text == #"."#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeBaseType: unexpectedBeforeBaseType?.createUnexpectedNodes(), baseType: baseType?.createTypeBuildable(), unexpectedBetweenBaseTypeAndDot: unexpectedBetweenBaseTypeAndDot?.createUnexpectedNodes(), dot: dot, unexpectedBetweenDotAndName: unexpectedBetweenDotAndName?.createUnexpectedNodes(), name: name, unexpectedBetweenNameAndArguments: unexpectedBetweenNameAndArguments?.createUnexpectedNodes(), arguments: arguments?.createDeclNameArguments()))
  }
  public init(_ constructedNode: QualifiedDeclNameSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `QualifiedDeclNameSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `QualifiedDeclNameSyntax`.
  func buildQualifiedDeclName(format: Format) -> QualifiedDeclNameSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = QualifiedDeclNameSyntax(buildableData.unexpectedBeforeBaseType?.buildUnexpectedNodes(format: format), baseType: buildableData.baseType?.buildType(format: format), buildableData.unexpectedBetweenBaseTypeAndDot?.buildUnexpectedNodes(format: format), dot: buildableData.dot?.buildToken(format: format), buildableData.unexpectedBetweenDotAndName?.buildUnexpectedNodes(format: format), name: buildableData.name.buildToken(format: format), buildableData.unexpectedBetweenNameAndArguments?.buildUnexpectedNodes(format: format), arguments: buildableData.arguments?.buildDeclNameArguments(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildQualifiedDeclName(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsQualifiedDeclName`.
  public func createQualifiedDeclName() -> QualifiedDeclName {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `QualifiedDeclName` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
/// A function declaration name (e.g. `foo(_:_:)`).
public struct FunctionDeclName: SyntaxBuildable, ExpressibleAsFunctionDeclName {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeName: UnexpectedNodes?
    var name: SyntaxBuildable
    var unexpectedBetweenNameAndArguments: UnexpectedNodes?
    var arguments: DeclNameArguments?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(FunctionDeclNameSyntax)
  }
  private var data: Data
  /// Creates a `FunctionDeclName` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeName: 
  ///   - name: The base name of the referenced function.
  ///   - unexpectedBetweenNameAndArguments: 
  ///   - arguments: The argument labels of the referenced function, optionallyspecified.
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: ExpressibleAsSyntaxBuildable, unexpectedBetweenNameAndArguments: ExpressibleAsUnexpectedNodes? = nil, arguments: ExpressibleAsDeclNameArguments? = nil) {
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeName: unexpectedBeforeName?.createUnexpectedNodes(), name: name.createSyntaxBuildable(), unexpectedBetweenNameAndArguments: unexpectedBetweenNameAndArguments?.createUnexpectedNodes(), arguments: arguments?.createDeclNameArguments()))
  }
  public init(_ constructedNode: FunctionDeclNameSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `FunctionDeclNameSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `FunctionDeclNameSyntax`.
  func buildFunctionDeclName(format: Format) -> FunctionDeclNameSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = FunctionDeclNameSyntax(buildableData.unexpectedBeforeName?.buildUnexpectedNodes(format: format), name: buildableData.name.buildSyntax(format: format), buildableData.unexpectedBetweenNameAndArguments?.buildUnexpectedNodes(format: format), arguments: buildableData.arguments?.buildDeclNameArguments(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildFunctionDeclName(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsFunctionDeclName`.
  public func createFunctionDeclName() -> FunctionDeclName {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `FunctionDeclName` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
/// A collection of arguments for the `@_backDeploy` attribute
public struct BackDeployAttributeSpecList: SyntaxBuildable, ExpressibleAsBackDeployAttributeSpecList {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeBeforeLabel: UnexpectedNodes?
    var beforeLabel: Token
    var unexpectedBetweenBeforeLabelAndColon: UnexpectedNodes?
    var colon: Token
    var unexpectedBetweenColonAndVersionList: UnexpectedNodes?
    var versionList: BackDeployVersionList
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(BackDeployAttributeSpecListSyntax)
  }
  private var data: Data
  /// Creates a `BackDeployAttributeSpecList` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeBeforeLabel: 
  ///   - beforeLabel: The "before" label.
  ///   - unexpectedBetweenBeforeLabelAndColon: 
  ///   - colon: The colon separating "before" and the parameter list.
  ///   - unexpectedBetweenColonAndVersionList: 
  ///   - versionList: The list of OS versions in which the declaration became ABIstable.
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeBeforeLabel: ExpressibleAsUnexpectedNodes? = nil, beforeLabel: Token, unexpectedBetweenBeforeLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndVersionList: ExpressibleAsUnexpectedNodes? = nil, versionList: ExpressibleAsBackDeployVersionList) {
    assert(beforeLabel.text == #"before"#)
    assert(colon.text == #":"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeBeforeLabel: unexpectedBeforeBeforeLabel?.createUnexpectedNodes(), beforeLabel: beforeLabel, unexpectedBetweenBeforeLabelAndColon: unexpectedBetweenBeforeLabelAndColon?.createUnexpectedNodes(), colon: colon, unexpectedBetweenColonAndVersionList: unexpectedBetweenColonAndVersionList?.createUnexpectedNodes(), versionList: versionList.createBackDeployVersionList()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeBeforeLabel: ExpressibleAsUnexpectedNodes? = nil, beforeLabel: String, unexpectedBetweenBeforeLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndVersionList: ExpressibleAsUnexpectedNodes? = nil, versionList: ExpressibleAsBackDeployVersionList) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeBeforeLabel: unexpectedBeforeBeforeLabel, beforeLabel: Token.`identifier`(beforeLabel), unexpectedBetweenBeforeLabelAndColon: unexpectedBetweenBeforeLabelAndColon, colon: colon, unexpectedBetweenColonAndVersionList: unexpectedBetweenColonAndVersionList, versionList: versionList)
  }
  public init(_ constructedNode: BackDeployAttributeSpecListSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `BackDeployAttributeSpecListSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `BackDeployAttributeSpecListSyntax`.
  func buildBackDeployAttributeSpecList(format: Format) -> BackDeployAttributeSpecListSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = BackDeployAttributeSpecListSyntax(buildableData.unexpectedBeforeBeforeLabel?.buildUnexpectedNodes(format: format), beforeLabel: buildableData.beforeLabel.buildToken(format: format), buildableData.unexpectedBetweenBeforeLabelAndColon?.buildUnexpectedNodes(format: format), colon: buildableData.colon.buildToken(format: format), buildableData.unexpectedBetweenColonAndVersionList?.buildUnexpectedNodes(format: format), versionList: buildableData.versionList.buildBackDeployVersionList(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildBackDeployAttributeSpecList(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsBackDeployAttributeSpecList`.
  public func createBackDeployAttributeSpecList() -> BackDeployAttributeSpecList {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `BackDeployAttributeSpecList` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
/// A single platform/version pair in a `@_backDeploy` attribute,e.g. `iOS 10.1`.
public struct BackDeployVersionArgument: SyntaxBuildable, ExpressibleAsBackDeployVersionArgument {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeAvailabilityVersionRestriction: UnexpectedNodes?
    var availabilityVersionRestriction: AvailabilityVersionRestriction
    var unexpectedBetweenAvailabilityVersionRestrictionAndTrailingComma: UnexpectedNodes?
    var trailingComma: Token?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(BackDeployVersionArgumentSyntax)
  }
  private var data: Data
  /// Creates a `BackDeployVersionArgument` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAvailabilityVersionRestriction: 
  ///   - availabilityVersionRestriction: 
  ///   - unexpectedBetweenAvailabilityVersionRestrictionAndTrailingComma: 
  ///   - trailingComma: A trailing comma if the argument is followed by anotherargument
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAvailabilityVersionRestriction: ExpressibleAsUnexpectedNodes? = nil, availabilityVersionRestriction: ExpressibleAsAvailabilityVersionRestriction, unexpectedBetweenAvailabilityVersionRestrictionAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    assert(trailingComma == nil || trailingComma!.text == #","#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeAvailabilityVersionRestriction: unexpectedBeforeAvailabilityVersionRestriction?.createUnexpectedNodes(), availabilityVersionRestriction: availabilityVersionRestriction.createAvailabilityVersionRestriction(), unexpectedBetweenAvailabilityVersionRestrictionAndTrailingComma: unexpectedBetweenAvailabilityVersionRestrictionAndTrailingComma?.createUnexpectedNodes(), trailingComma: trailingComma))
  }
  public init(_ constructedNode: BackDeployVersionArgumentSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `BackDeployVersionArgumentSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `BackDeployVersionArgumentSyntax`.
  func buildBackDeployVersionArgument(format: Format) -> BackDeployVersionArgumentSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = BackDeployVersionArgumentSyntax(buildableData.unexpectedBeforeAvailabilityVersionRestriction?.buildUnexpectedNodes(format: format), availabilityVersionRestriction: buildableData.availabilityVersionRestriction.buildAvailabilityVersionRestriction(format: format), buildableData.unexpectedBetweenAvailabilityVersionRestrictionAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: buildableData.trailingComma?.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildBackDeployVersionArgument(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsBackDeployVersionArgument`.
  public func createBackDeployVersionArgument() -> BackDeployVersionArgument {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `BackDeployVersionArgument` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
/// The arguments for the '@_opaqueReturnTypeOf()'.
public struct OpaqueReturnTypeOfAttributeArguments: SyntaxBuildable, ExpressibleAsOpaqueReturnTypeOfAttributeArguments {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeMangledName: UnexpectedNodes?
    var mangledName: Token
    var unexpectedBetweenMangledNameAndComma: UnexpectedNodes?
    var comma: Token
    var unexpectedBetweenCommaAndOrdinal: UnexpectedNodes?
    var ordinal: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(OpaqueReturnTypeOfAttributeArgumentsSyntax)
  }
  private var data: Data
  /// Creates a `OpaqueReturnTypeOfAttributeArguments` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeMangledName: 
  ///   - mangledName: The mangled name of a declaration.
  ///   - unexpectedBetweenMangledNameAndComma: 
  ///   - comma: 
  ///   - unexpectedBetweenCommaAndOrdinal: 
  ///   - ordinal: The ordinal corresponding to the 'some' keyword that introduced this opaque type.
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeMangledName: ExpressibleAsUnexpectedNodes? = nil, mangledName: Token, unexpectedBetweenMangledNameAndComma: ExpressibleAsUnexpectedNodes? = nil, comma: Token = Token.`comma`, unexpectedBetweenCommaAndOrdinal: ExpressibleAsUnexpectedNodes? = nil, ordinal: Token) {
    assert(comma.text == #","#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeMangledName: unexpectedBeforeMangledName?.createUnexpectedNodes(), mangledName: mangledName, unexpectedBetweenMangledNameAndComma: unexpectedBetweenMangledNameAndComma?.createUnexpectedNodes(), comma: comma, unexpectedBetweenCommaAndOrdinal: unexpectedBetweenCommaAndOrdinal?.createUnexpectedNodes(), ordinal: ordinal))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeMangledName: ExpressibleAsUnexpectedNodes? = nil, mangledName: String, unexpectedBetweenMangledNameAndComma: ExpressibleAsUnexpectedNodes? = nil, comma: Token = Token.`comma`, unexpectedBetweenCommaAndOrdinal: ExpressibleAsUnexpectedNodes? = nil, ordinal: String) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeMangledName: unexpectedBeforeMangledName, mangledName: Token.`stringLiteral`(mangledName), unexpectedBetweenMangledNameAndComma: unexpectedBetweenMangledNameAndComma, comma: comma, unexpectedBetweenCommaAndOrdinal: unexpectedBetweenCommaAndOrdinal, ordinal: Token.`integerLiteral`(ordinal))
  }
  public init(_ constructedNode: OpaqueReturnTypeOfAttributeArgumentsSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `OpaqueReturnTypeOfAttributeArgumentsSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `OpaqueReturnTypeOfAttributeArgumentsSyntax`.
  func buildOpaqueReturnTypeOfAttributeArguments(format: Format) -> OpaqueReturnTypeOfAttributeArgumentsSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = OpaqueReturnTypeOfAttributeArgumentsSyntax(buildableData.unexpectedBeforeMangledName?.buildUnexpectedNodes(format: format), mangledName: buildableData.mangledName.buildToken(format: format), buildableData.unexpectedBetweenMangledNameAndComma?.buildUnexpectedNodes(format: format), comma: buildableData.comma.buildToken(format: format), buildableData.unexpectedBetweenCommaAndOrdinal?.buildUnexpectedNodes(format: format), ordinal: buildableData.ordinal.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildOpaqueReturnTypeOfAttributeArguments(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsOpaqueReturnTypeOfAttributeArguments`.
  public func createOpaqueReturnTypeOfAttributeArguments() -> OpaqueReturnTypeOfAttributeArguments {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `OpaqueReturnTypeOfAttributeArguments` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
/// The arguments for the '@convention(...)'.
public struct ConventionAttributeArguments: SyntaxBuildable, ExpressibleAsConventionAttributeArguments {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeConventionLabel: UnexpectedNodes?
    var conventionLabel: Token
    var unexpectedBetweenConventionLabelAndComma: UnexpectedNodes?
    var comma: Token?
    var unexpectedBetweenCommaAndCTypeLabel: UnexpectedNodes?
    var cTypeLabel: Token?
    var unexpectedBetweenCTypeLabelAndColon: UnexpectedNodes?
    var colon: Token?
    var unexpectedBetweenColonAndCTypeString: UnexpectedNodes?
    var cTypeString: Token?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ConventionAttributeArgumentsSyntax)
  }
  private var data: Data
  /// Creates a `ConventionAttributeArguments` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeConventionLabel: 
  ///   - conventionLabel: The convention label.
  ///   - unexpectedBetweenConventionLabelAndComma: 
  ///   - comma: 
  ///   - unexpectedBetweenCommaAndCTypeLabel: 
  ///   - cTypeLabel: 
  ///   - unexpectedBetweenCTypeLabelAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndCTypeString: 
  ///   - cTypeString: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeConventionLabel: ExpressibleAsUnexpectedNodes? = nil, conventionLabel: Token, unexpectedBetweenConventionLabelAndComma: ExpressibleAsUnexpectedNodes? = nil, comma: Token? = nil, unexpectedBetweenCommaAndCTypeLabel: ExpressibleAsUnexpectedNodes? = nil, cTypeLabel: Token? = nil, unexpectedBetweenCTypeLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token? = nil, unexpectedBetweenColonAndCTypeString: ExpressibleAsUnexpectedNodes? = nil, cTypeString: Token? = nil) {
    assert(conventionLabel.text == #"block"# || conventionLabel.text == #"c"# || conventionLabel.text == #"objc_method"# || conventionLabel.text == #"thin"# || conventionLabel.text == #"thick"#)
    assert(comma == nil || comma!.text == #","#)
    assert(cTypeLabel == nil || cTypeLabel!.text == #"cType"#)
    assert(colon == nil || colon!.text == #":"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeConventionLabel: unexpectedBeforeConventionLabel?.createUnexpectedNodes(), conventionLabel: conventionLabel, unexpectedBetweenConventionLabelAndComma: unexpectedBetweenConventionLabelAndComma?.createUnexpectedNodes(), comma: comma, unexpectedBetweenCommaAndCTypeLabel: unexpectedBetweenCommaAndCTypeLabel?.createUnexpectedNodes(), cTypeLabel: cTypeLabel, unexpectedBetweenCTypeLabelAndColon: unexpectedBetweenCTypeLabelAndColon?.createUnexpectedNodes(), colon: colon, unexpectedBetweenColonAndCTypeString: unexpectedBetweenColonAndCTypeString?.createUnexpectedNodes(), cTypeString: cTypeString))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeConventionLabel: ExpressibleAsUnexpectedNodes? = nil, conventionLabel: String, unexpectedBetweenConventionLabelAndComma: ExpressibleAsUnexpectedNodes? = nil, comma: Token? = nil, unexpectedBetweenCommaAndCTypeLabel: ExpressibleAsUnexpectedNodes? = nil, cTypeLabel: String?, unexpectedBetweenCTypeLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token? = nil, unexpectedBetweenColonAndCTypeString: ExpressibleAsUnexpectedNodes? = nil, cTypeString: String?) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeConventionLabel: unexpectedBeforeConventionLabel, conventionLabel: Token.`identifier`(conventionLabel), unexpectedBetweenConventionLabelAndComma: unexpectedBetweenConventionLabelAndComma, comma: comma, unexpectedBetweenCommaAndCTypeLabel: unexpectedBetweenCommaAndCTypeLabel, cTypeLabel: cTypeLabel.map { Token.`identifier`($0) }, unexpectedBetweenCTypeLabelAndColon: unexpectedBetweenCTypeLabelAndColon, colon: colon, unexpectedBetweenColonAndCTypeString: unexpectedBetweenColonAndCTypeString, cTypeString: cTypeString.map { Token.`stringLiteral`($0) })
  }
  public init(_ constructedNode: ConventionAttributeArgumentsSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ConventionAttributeArgumentsSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ConventionAttributeArgumentsSyntax`.
  func buildConventionAttributeArguments(format: Format) -> ConventionAttributeArgumentsSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ConventionAttributeArgumentsSyntax(buildableData.unexpectedBeforeConventionLabel?.buildUnexpectedNodes(format: format), conventionLabel: buildableData.conventionLabel.buildToken(format: format), buildableData.unexpectedBetweenConventionLabelAndComma?.buildUnexpectedNodes(format: format), comma: buildableData.comma?.buildToken(format: format), buildableData.unexpectedBetweenCommaAndCTypeLabel?.buildUnexpectedNodes(format: format), cTypeLabel: buildableData.cTypeLabel?.buildToken(format: format), buildableData.unexpectedBetweenCTypeLabelAndColon?.buildUnexpectedNodes(format: format), colon: buildableData.colon?.buildToken(format: format), buildableData.unexpectedBetweenColonAndCTypeString?.buildUnexpectedNodes(format: format), cTypeString: buildableData.cTypeString?.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildConventionAttributeArguments(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsConventionAttributeArguments`.
  public func createConventionAttributeArguments() -> ConventionAttributeArguments {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ConventionAttributeArguments` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
/// The arguments for the '@convention(witness_method: ...)'.
public struct ConventionWitnessMethodAttributeArguments: SyntaxBuildable, ExpressibleAsConventionWitnessMethodAttributeArguments {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeWitnessMethodLabel: UnexpectedNodes?
    var witnessMethodLabel: Token
    var unexpectedBetweenWitnessMethodLabelAndColon: UnexpectedNodes?
    var colon: Token
    var unexpectedBetweenColonAndProtocolName: UnexpectedNodes?
    var protocolName: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ConventionWitnessMethodAttributeArgumentsSyntax)
  }
  private var data: Data
  /// Creates a `ConventionWitnessMethodAttributeArguments` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeWitnessMethodLabel: 
  ///   - witnessMethodLabel: 
  ///   - unexpectedBetweenWitnessMethodLabelAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndProtocolName: 
  ///   - protocolName: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeWitnessMethodLabel: ExpressibleAsUnexpectedNodes? = nil, witnessMethodLabel: Token, unexpectedBetweenWitnessMethodLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndProtocolName: ExpressibleAsUnexpectedNodes? = nil, protocolName: Token) {
    assert(colon.text == #":"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeWitnessMethodLabel: unexpectedBeforeWitnessMethodLabel?.createUnexpectedNodes(), witnessMethodLabel: witnessMethodLabel, unexpectedBetweenWitnessMethodLabelAndColon: unexpectedBetweenWitnessMethodLabelAndColon?.createUnexpectedNodes(), colon: colon, unexpectedBetweenColonAndProtocolName: unexpectedBetweenColonAndProtocolName?.createUnexpectedNodes(), protocolName: protocolName))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeWitnessMethodLabel: ExpressibleAsUnexpectedNodes? = nil, witnessMethodLabel: String, unexpectedBetweenWitnessMethodLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndProtocolName: ExpressibleAsUnexpectedNodes? = nil, protocolName: String) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeWitnessMethodLabel: unexpectedBeforeWitnessMethodLabel, witnessMethodLabel: Token.`identifier`(witnessMethodLabel), unexpectedBetweenWitnessMethodLabelAndColon: unexpectedBetweenWitnessMethodLabelAndColon, colon: colon, unexpectedBetweenColonAndProtocolName: unexpectedBetweenColonAndProtocolName, protocolName: Token.`identifier`(protocolName))
  }
  public init(_ constructedNode: ConventionWitnessMethodAttributeArgumentsSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ConventionWitnessMethodAttributeArgumentsSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ConventionWitnessMethodAttributeArgumentsSyntax`.
  func buildConventionWitnessMethodAttributeArguments(format: Format) -> ConventionWitnessMethodAttributeArgumentsSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ConventionWitnessMethodAttributeArgumentsSyntax(buildableData.unexpectedBeforeWitnessMethodLabel?.buildUnexpectedNodes(format: format), witnessMethodLabel: buildableData.witnessMethodLabel.buildToken(format: format), buildableData.unexpectedBetweenWitnessMethodLabelAndColon?.buildUnexpectedNodes(format: format), colon: buildableData.colon.buildToken(format: format), buildableData.unexpectedBetweenColonAndProtocolName?.buildUnexpectedNodes(format: format), protocolName: buildableData.protocolName.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildConventionWitnessMethodAttributeArguments(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsConventionWitnessMethodAttributeArguments`.
  public func createConventionWitnessMethodAttributeArguments() -> ConventionWitnessMethodAttributeArguments {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ConventionWitnessMethodAttributeArguments` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct LabeledStmt: StmtBuildable, ExpressibleAsLabeledStmt {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeLabelName: UnexpectedNodes?
    var labelName: Token
    var unexpectedBetweenLabelNameAndLabelColon: UnexpectedNodes?
    var labelColon: Token
    var unexpectedBetweenLabelColonAndStatement: UnexpectedNodes?
    var statement: StmtBuildable
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(LabeledStmtSyntax)
  }
  private var data: Data
  /// Creates a `LabeledStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLabelName: 
  ///   - labelName: 
  ///   - unexpectedBetweenLabelNameAndLabelColon: 
  ///   - labelColon: 
  ///   - unexpectedBetweenLabelColonAndStatement: 
  ///   - statement: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLabelName: ExpressibleAsUnexpectedNodes? = nil, labelName: Token, unexpectedBetweenLabelNameAndLabelColon: ExpressibleAsUnexpectedNodes? = nil, labelColon: Token = Token.`colon`, unexpectedBetweenLabelColonAndStatement: ExpressibleAsUnexpectedNodes? = nil, statement: ExpressibleAsStmtBuildable) {
    assert(labelColon.text == #":"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeLabelName: unexpectedBeforeLabelName?.createUnexpectedNodes(), labelName: labelName, unexpectedBetweenLabelNameAndLabelColon: unexpectedBetweenLabelNameAndLabelColon?.createUnexpectedNodes(), labelColon: labelColon, unexpectedBetweenLabelColonAndStatement: unexpectedBetweenLabelColonAndStatement?.createUnexpectedNodes(), statement: statement.createStmtBuildable()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLabelName: ExpressibleAsUnexpectedNodes? = nil, labelName: String, unexpectedBetweenLabelNameAndLabelColon: ExpressibleAsUnexpectedNodes? = nil, labelColon: Token = Token.`colon`, unexpectedBetweenLabelColonAndStatement: ExpressibleAsUnexpectedNodes? = nil, statement: ExpressibleAsStmtBuildable) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLabelName: unexpectedBeforeLabelName, labelName: Token.`identifier`(labelName), unexpectedBetweenLabelNameAndLabelColon: unexpectedBetweenLabelNameAndLabelColon, labelColon: labelColon, unexpectedBetweenLabelColonAndStatement: unexpectedBetweenLabelColonAndStatement, statement: statement)
  }
  public init(_ constructedNode: LabeledStmtSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `LabeledStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `LabeledStmtSyntax`.
  func buildLabeledStmt(format: Format) -> LabeledStmtSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = LabeledStmtSyntax(buildableData.unexpectedBeforeLabelName?.buildUnexpectedNodes(format: format), labelName: buildableData.labelName.buildToken(format: format), buildableData.unexpectedBetweenLabelNameAndLabelColon?.buildUnexpectedNodes(format: format), labelColon: buildableData.labelColon.buildToken(format: format), buildableData.unexpectedBetweenLabelColonAndStatement?.buildUnexpectedNodes(format: format), statement: buildableData.statement.buildStmt(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format) -> StmtSyntax {
    let result = buildLabeledStmt(format: format)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsLabeledStmt`.
  public func createLabeledStmt() -> LabeledStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `LabeledStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct ContinueStmt: StmtBuildable, ExpressibleAsContinueStmt {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeContinueKeyword: UnexpectedNodes?
    var continueKeyword: Token
    var unexpectedBetweenContinueKeywordAndLabel: UnexpectedNodes?
    var label: Token?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ContinueStmtSyntax)
  }
  private var data: Data
  /// Creates a `ContinueStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeContinueKeyword: 
  ///   - continueKeyword: 
  ///   - unexpectedBetweenContinueKeywordAndLabel: 
  ///   - label: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeContinueKeyword: ExpressibleAsUnexpectedNodes? = nil, continueKeyword: Token = Token.`continue`, unexpectedBetweenContinueKeywordAndLabel: ExpressibleAsUnexpectedNodes? = nil, label: Token? = nil) {
    assert(continueKeyword.text == #"continue"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeContinueKeyword: unexpectedBeforeContinueKeyword?.createUnexpectedNodes(), continueKeyword: continueKeyword, unexpectedBetweenContinueKeywordAndLabel: unexpectedBetweenContinueKeywordAndLabel?.createUnexpectedNodes(), label: label))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeContinueKeyword: ExpressibleAsUnexpectedNodes? = nil, continueKeyword: Token = Token.`continue`, unexpectedBetweenContinueKeywordAndLabel: ExpressibleAsUnexpectedNodes? = nil, label: String?) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeContinueKeyword: unexpectedBeforeContinueKeyword, continueKeyword: continueKeyword, unexpectedBetweenContinueKeywordAndLabel: unexpectedBetweenContinueKeywordAndLabel, label: label.map { Token.`identifier`($0) })
  }
  public init(_ constructedNode: ContinueStmtSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ContinueStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ContinueStmtSyntax`.
  func buildContinueStmt(format: Format) -> ContinueStmtSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ContinueStmtSyntax(buildableData.unexpectedBeforeContinueKeyword?.buildUnexpectedNodes(format: format), continueKeyword: buildableData.continueKeyword.buildToken(format: format), buildableData.unexpectedBetweenContinueKeywordAndLabel?.buildUnexpectedNodes(format: format), label: buildableData.label?.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format) -> StmtSyntax {
    let result = buildContinueStmt(format: format)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsContinueStmt`.
  public func createContinueStmt() -> ContinueStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `ContinueStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct WhileStmt: StmtBuildable, ExpressibleAsWhileStmt {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeWhileKeyword: UnexpectedNodes?
    var whileKeyword: Token
    var unexpectedBetweenWhileKeywordAndConditions: UnexpectedNodes?
    var conditions: ConditionElementList
    var unexpectedBetweenConditionsAndBody: UnexpectedNodes?
    var body: CodeBlock
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(WhileStmtSyntax)
  }
  private var data: Data
  /// Creates a `WhileStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeWhileKeyword: 
  ///   - whileKeyword: 
  ///   - unexpectedBetweenWhileKeywordAndConditions: 
  ///   - conditions: 
  ///   - unexpectedBetweenConditionsAndBody: 
  ///   - body: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeWhileKeyword: ExpressibleAsUnexpectedNodes? = nil, whileKeyword: Token = Token.`while`, unexpectedBetweenWhileKeywordAndConditions: ExpressibleAsUnexpectedNodes? = nil, conditions: ExpressibleAsConditionElementList, unexpectedBetweenConditionsAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock) {
    assert(whileKeyword.text == #"while"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeWhileKeyword: unexpectedBeforeWhileKeyword?.createUnexpectedNodes(), whileKeyword: whileKeyword, unexpectedBetweenWhileKeywordAndConditions: unexpectedBetweenWhileKeywordAndConditions?.createUnexpectedNodes(), conditions: conditions.createConditionElementList(), unexpectedBetweenConditionsAndBody: unexpectedBetweenConditionsAndBody?.createUnexpectedNodes(), body: body.createCodeBlock()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeWhileKeyword: ExpressibleAsUnexpectedNodes? = nil, whileKeyword: Token = Token.`while`, unexpectedBetweenWhileKeywordAndConditions: ExpressibleAsUnexpectedNodes? = nil, conditions: ExpressibleAsConditionElementList, unexpectedBetweenConditionsAndBody: ExpressibleAsUnexpectedNodes? = nil, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeWhileKeyword: unexpectedBeforeWhileKeyword, whileKeyword: whileKeyword, unexpectedBetweenWhileKeywordAndConditions: unexpectedBetweenWhileKeywordAndConditions, conditions: conditions, unexpectedBetweenConditionsAndBody: unexpectedBetweenConditionsAndBody, body: bodyBuilder())
  }
  public init(_ constructedNode: WhileStmtSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `WhileStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `WhileStmtSyntax`.
  func buildWhileStmt(format: Format) -> WhileStmtSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = WhileStmtSyntax(buildableData.unexpectedBeforeWhileKeyword?.buildUnexpectedNodes(format: format), whileKeyword: buildableData.whileKeyword.buildToken(format: format), buildableData.unexpectedBetweenWhileKeywordAndConditions?.buildUnexpectedNodes(format: format), conditions: buildableData.conditions.buildConditionElementList(format: format), buildableData.unexpectedBetweenConditionsAndBody?.buildUnexpectedNodes(format: format), body: buildableData.body.buildCodeBlock(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format) -> StmtSyntax {
    let result = buildWhileStmt(format: format)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsWhileStmt`.
  public func createWhileStmt() -> WhileStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `WhileStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct DeferStmt: StmtBuildable, ExpressibleAsDeferStmt {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeDeferKeyword: UnexpectedNodes?
    var deferKeyword: Token
    var unexpectedBetweenDeferKeywordAndBody: UnexpectedNodes?
    var body: CodeBlock
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(DeferStmtSyntax)
  }
  private var data: Data
  /// Creates a `DeferStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeDeferKeyword: 
  ///   - deferKeyword: 
  ///   - unexpectedBetweenDeferKeywordAndBody: 
  ///   - body: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeDeferKeyword: ExpressibleAsUnexpectedNodes? = nil, deferKeyword: Token = Token.`defer`, unexpectedBetweenDeferKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock) {
    assert(deferKeyword.text == #"defer"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeDeferKeyword: unexpectedBeforeDeferKeyword?.createUnexpectedNodes(), deferKeyword: deferKeyword, unexpectedBetweenDeferKeywordAndBody: unexpectedBetweenDeferKeywordAndBody?.createUnexpectedNodes(), body: body.createCodeBlock()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeDeferKeyword: ExpressibleAsUnexpectedNodes? = nil, deferKeyword: Token = Token.`defer`, unexpectedBetweenDeferKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeDeferKeyword: unexpectedBeforeDeferKeyword, deferKeyword: deferKeyword, unexpectedBetweenDeferKeywordAndBody: unexpectedBetweenDeferKeywordAndBody, body: bodyBuilder())
  }
  public init(_ constructedNode: DeferStmtSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `DeferStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DeferStmtSyntax`.
  func buildDeferStmt(format: Format) -> DeferStmtSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = DeferStmtSyntax(buildableData.unexpectedBeforeDeferKeyword?.buildUnexpectedNodes(format: format), deferKeyword: buildableData.deferKeyword.buildToken(format: format), buildableData.unexpectedBetweenDeferKeywordAndBody?.buildUnexpectedNodes(format: format), body: buildableData.body.buildCodeBlock(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format) -> StmtSyntax {
    let result = buildDeferStmt(format: format)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsDeferStmt`.
  public func createDeferStmt() -> DeferStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `DeferStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct ExpressionStmt: StmtBuildable, ExpressibleAsExpressionStmt {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeExpression: UnexpectedNodes?
    var expression: ExprBuildable
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ExpressionStmtSyntax)
  }
  private var data: Data
  /// Creates a `ExpressionStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeExpression: 
  ///   - expression: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable) {
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeExpression: unexpectedBeforeExpression?.createUnexpectedNodes(), expression: expression.createExprBuildable()))
  }
  public init(_ constructedNode: ExpressionStmtSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ExpressionStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ExpressionStmtSyntax`.
  func buildExpressionStmt(format: Format) -> ExpressionStmtSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ExpressionStmtSyntax(buildableData.unexpectedBeforeExpression?.buildUnexpectedNodes(format: format), expression: buildableData.expression.buildExpr(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format) -> StmtSyntax {
    let result = buildExpressionStmt(format: format)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsExpressionStmt`.
  public func createExpressionStmt() -> ExpressionStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `ExpressionStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct RepeatWhileStmt: StmtBuildable, ExpressibleAsRepeatWhileStmt {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeRepeatKeyword: UnexpectedNodes?
    var repeatKeyword: Token
    var unexpectedBetweenRepeatKeywordAndBody: UnexpectedNodes?
    var body: CodeBlock
    var unexpectedBetweenBodyAndWhileKeyword: UnexpectedNodes?
    var whileKeyword: Token
    var unexpectedBetweenWhileKeywordAndCondition: UnexpectedNodes?
    var condition: ExprBuildable
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(RepeatWhileStmtSyntax)
  }
  private var data: Data
  /// Creates a `RepeatWhileStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeRepeatKeyword: 
  ///   - repeatKeyword: 
  ///   - unexpectedBetweenRepeatKeywordAndBody: 
  ///   - body: 
  ///   - unexpectedBetweenBodyAndWhileKeyword: 
  ///   - whileKeyword: 
  ///   - unexpectedBetweenWhileKeywordAndCondition: 
  ///   - condition: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeRepeatKeyword: ExpressibleAsUnexpectedNodes? = nil, repeatKeyword: Token = Token.`repeat`, unexpectedBetweenRepeatKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock, unexpectedBetweenBodyAndWhileKeyword: ExpressibleAsUnexpectedNodes? = nil, whileKeyword: Token = Token.`while`, unexpectedBetweenWhileKeywordAndCondition: ExpressibleAsUnexpectedNodes? = nil, condition: ExpressibleAsExprBuildable) {
    assert(repeatKeyword.text == #"repeat"#)
    assert(whileKeyword.text == #"while"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeRepeatKeyword: unexpectedBeforeRepeatKeyword?.createUnexpectedNodes(), repeatKeyword: repeatKeyword, unexpectedBetweenRepeatKeywordAndBody: unexpectedBetweenRepeatKeywordAndBody?.createUnexpectedNodes(), body: body.createCodeBlock(), unexpectedBetweenBodyAndWhileKeyword: unexpectedBetweenBodyAndWhileKeyword?.createUnexpectedNodes(), whileKeyword: whileKeyword, unexpectedBetweenWhileKeywordAndCondition: unexpectedBetweenWhileKeywordAndCondition?.createUnexpectedNodes(), condition: condition.createExprBuildable()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeRepeatKeyword: ExpressibleAsUnexpectedNodes? = nil, repeatKeyword: Token = Token.`repeat`, unexpectedBetweenRepeatKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenBodyAndWhileKeyword: ExpressibleAsUnexpectedNodes? = nil, whileKeyword: Token = Token.`while`, unexpectedBetweenWhileKeywordAndCondition: ExpressibleAsUnexpectedNodes? = nil, condition: ExpressibleAsExprBuildable, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeRepeatKeyword: unexpectedBeforeRepeatKeyword, repeatKeyword: repeatKeyword, unexpectedBetweenRepeatKeywordAndBody: unexpectedBetweenRepeatKeywordAndBody, body: bodyBuilder(), unexpectedBetweenBodyAndWhileKeyword: unexpectedBetweenBodyAndWhileKeyword, whileKeyword: whileKeyword, unexpectedBetweenWhileKeywordAndCondition: unexpectedBetweenWhileKeywordAndCondition, condition: condition)
  }
  public init(_ constructedNode: RepeatWhileStmtSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `RepeatWhileStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `RepeatWhileStmtSyntax`.
  func buildRepeatWhileStmt(format: Format) -> RepeatWhileStmtSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = RepeatWhileStmtSyntax(buildableData.unexpectedBeforeRepeatKeyword?.buildUnexpectedNodes(format: format), repeatKeyword: buildableData.repeatKeyword.buildToken(format: format), buildableData.unexpectedBetweenRepeatKeywordAndBody?.buildUnexpectedNodes(format: format), body: buildableData.body.buildCodeBlock(format: format), buildableData.unexpectedBetweenBodyAndWhileKeyword?.buildUnexpectedNodes(format: format), whileKeyword: buildableData.whileKeyword.buildToken(format: format), buildableData.unexpectedBetweenWhileKeywordAndCondition?.buildUnexpectedNodes(format: format), condition: buildableData.condition.buildExpr(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format) -> StmtSyntax {
    let result = buildRepeatWhileStmt(format: format)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsRepeatWhileStmt`.
  public func createRepeatWhileStmt() -> RepeatWhileStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `RepeatWhileStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct GuardStmt: StmtBuildable, ExpressibleAsGuardStmt {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeGuardKeyword: UnexpectedNodes?
    var guardKeyword: Token
    var unexpectedBetweenGuardKeywordAndConditions: UnexpectedNodes?
    var conditions: ConditionElementList
    var unexpectedBetweenConditionsAndElseKeyword: UnexpectedNodes?
    var elseKeyword: Token
    var unexpectedBetweenElseKeywordAndBody: UnexpectedNodes?
    var body: CodeBlock
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(GuardStmtSyntax)
  }
  private var data: Data
  /// Creates a `GuardStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeGuardKeyword: 
  ///   - guardKeyword: 
  ///   - unexpectedBetweenGuardKeywordAndConditions: 
  ///   - conditions: 
  ///   - unexpectedBetweenConditionsAndElseKeyword: 
  ///   - elseKeyword: 
  ///   - unexpectedBetweenElseKeywordAndBody: 
  ///   - body: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeGuardKeyword: ExpressibleAsUnexpectedNodes? = nil, guardKeyword: Token = Token.`guard`, unexpectedBetweenGuardKeywordAndConditions: ExpressibleAsUnexpectedNodes? = nil, conditions: ExpressibleAsConditionElementList, unexpectedBetweenConditionsAndElseKeyword: ExpressibleAsUnexpectedNodes? = nil, elseKeyword: Token = Token.`else`, unexpectedBetweenElseKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock) {
    assert(guardKeyword.text == #"guard"#)
    assert(elseKeyword.text == #"else"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeGuardKeyword: unexpectedBeforeGuardKeyword?.createUnexpectedNodes(), guardKeyword: guardKeyword, unexpectedBetweenGuardKeywordAndConditions: unexpectedBetweenGuardKeywordAndConditions?.createUnexpectedNodes(), conditions: conditions.createConditionElementList(), unexpectedBetweenConditionsAndElseKeyword: unexpectedBetweenConditionsAndElseKeyword?.createUnexpectedNodes(), elseKeyword: elseKeyword, unexpectedBetweenElseKeywordAndBody: unexpectedBetweenElseKeywordAndBody?.createUnexpectedNodes(), body: body.createCodeBlock()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeGuardKeyword: ExpressibleAsUnexpectedNodes? = nil, guardKeyword: Token = Token.`guard`, unexpectedBetweenGuardKeywordAndConditions: ExpressibleAsUnexpectedNodes? = nil, conditions: ExpressibleAsConditionElementList, unexpectedBetweenConditionsAndElseKeyword: ExpressibleAsUnexpectedNodes? = nil, elseKeyword: Token = Token.`else`, unexpectedBetweenElseKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeGuardKeyword: unexpectedBeforeGuardKeyword, guardKeyword: guardKeyword, unexpectedBetweenGuardKeywordAndConditions: unexpectedBetweenGuardKeywordAndConditions, conditions: conditions, unexpectedBetweenConditionsAndElseKeyword: unexpectedBetweenConditionsAndElseKeyword, elseKeyword: elseKeyword, unexpectedBetweenElseKeywordAndBody: unexpectedBetweenElseKeywordAndBody, body: bodyBuilder())
  }
  public init(_ constructedNode: GuardStmtSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `GuardStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `GuardStmtSyntax`.
  func buildGuardStmt(format: Format) -> GuardStmtSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = GuardStmtSyntax(buildableData.unexpectedBeforeGuardKeyword?.buildUnexpectedNodes(format: format), guardKeyword: buildableData.guardKeyword.buildToken(format: format), buildableData.unexpectedBetweenGuardKeywordAndConditions?.buildUnexpectedNodes(format: format), conditions: buildableData.conditions.buildConditionElementList(format: format), buildableData.unexpectedBetweenConditionsAndElseKeyword?.buildUnexpectedNodes(format: format), elseKeyword: buildableData.elseKeyword.buildToken(format: format), buildableData.unexpectedBetweenElseKeywordAndBody?.buildUnexpectedNodes(format: format), body: buildableData.body.buildCodeBlock(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format) -> StmtSyntax {
    let result = buildGuardStmt(format: format)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsGuardStmt`.
  public func createGuardStmt() -> GuardStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `GuardStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct WhereClause: SyntaxBuildable, ExpressibleAsWhereClause {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeWhereKeyword: UnexpectedNodes?
    var whereKeyword: Token
    var unexpectedBetweenWhereKeywordAndGuardResult: UnexpectedNodes?
    var guardResult: ExprBuildable
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(WhereClauseSyntax)
  }
  private var data: Data
  /// Creates a `WhereClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeWhereKeyword: 
  ///   - whereKeyword: 
  ///   - unexpectedBetweenWhereKeywordAndGuardResult: 
  ///   - guardResult: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeWhereKeyword: ExpressibleAsUnexpectedNodes? = nil, whereKeyword: Token = Token.`where`, unexpectedBetweenWhereKeywordAndGuardResult: ExpressibleAsUnexpectedNodes? = nil, guardResult: ExpressibleAsExprBuildable) {
    assert(whereKeyword.text == #"where"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeWhereKeyword: unexpectedBeforeWhereKeyword?.createUnexpectedNodes(), whereKeyword: whereKeyword, unexpectedBetweenWhereKeywordAndGuardResult: unexpectedBetweenWhereKeywordAndGuardResult?.createUnexpectedNodes(), guardResult: guardResult.createExprBuildable()))
  }
  public init(_ constructedNode: WhereClauseSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `WhereClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `WhereClauseSyntax`.
  func buildWhereClause(format: Format) -> WhereClauseSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = WhereClauseSyntax(buildableData.unexpectedBeforeWhereKeyword?.buildUnexpectedNodes(format: format), whereKeyword: buildableData.whereKeyword.buildToken(format: format), buildableData.unexpectedBetweenWhereKeywordAndGuardResult?.buildUnexpectedNodes(format: format), guardResult: buildableData.guardResult.buildExpr(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildWhereClause(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsWhereClause`.
  public func createWhereClause() -> WhereClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `WhereClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct ForInStmt: StmtBuildable, ExpressibleAsForInStmt {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeForKeyword: UnexpectedNodes?
    var forKeyword: Token
    var unexpectedBetweenForKeywordAndTryKeyword: UnexpectedNodes?
    var tryKeyword: Token?
    var unexpectedBetweenTryKeywordAndAwaitKeyword: UnexpectedNodes?
    var awaitKeyword: Token?
    var unexpectedBetweenAwaitKeywordAndCaseKeyword: UnexpectedNodes?
    var caseKeyword: Token?
    var unexpectedBetweenCaseKeywordAndPattern: UnexpectedNodes?
    var pattern: PatternBuildable
    var unexpectedBetweenPatternAndTypeAnnotation: UnexpectedNodes?
    var typeAnnotation: TypeAnnotation?
    var unexpectedBetweenTypeAnnotationAndInKeyword: UnexpectedNodes?
    var inKeyword: Token
    var unexpectedBetweenInKeywordAndSequenceExpr: UnexpectedNodes?
    var sequenceExpr: ExprBuildable
    var unexpectedBetweenSequenceExprAndWhereClause: UnexpectedNodes?
    var whereClause: WhereClause?
    var unexpectedBetweenWhereClauseAndBody: UnexpectedNodes?
    var body: CodeBlock
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ForInStmtSyntax)
  }
  private var data: Data
  /// Creates a `ForInStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeForKeyword: 
  ///   - forKeyword: 
  ///   - unexpectedBetweenForKeywordAndTryKeyword: 
  ///   - tryKeyword: 
  ///   - unexpectedBetweenTryKeywordAndAwaitKeyword: 
  ///   - awaitKeyword: 
  ///   - unexpectedBetweenAwaitKeywordAndCaseKeyword: 
  ///   - caseKeyword: 
  ///   - unexpectedBetweenCaseKeywordAndPattern: 
  ///   - pattern: 
  ///   - unexpectedBetweenPatternAndTypeAnnotation: 
  ///   - typeAnnotation: 
  ///   - unexpectedBetweenTypeAnnotationAndInKeyword: 
  ///   - inKeyword: 
  ///   - unexpectedBetweenInKeywordAndSequenceExpr: 
  ///   - sequenceExpr: 
  ///   - unexpectedBetweenSequenceExprAndWhereClause: 
  ///   - whereClause: 
  ///   - unexpectedBetweenWhereClauseAndBody: 
  ///   - body: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeForKeyword: ExpressibleAsUnexpectedNodes? = nil, forKeyword: Token = Token.`for`, unexpectedBetweenForKeywordAndTryKeyword: ExpressibleAsUnexpectedNodes? = nil, tryKeyword: Token? = nil, unexpectedBetweenTryKeywordAndAwaitKeyword: ExpressibleAsUnexpectedNodes? = nil, awaitKeyword: Token? = nil, unexpectedBetweenAwaitKeywordAndCaseKeyword: ExpressibleAsUnexpectedNodes? = nil, caseKeyword: Token? = nil, unexpectedBetweenCaseKeywordAndPattern: ExpressibleAsUnexpectedNodes? = nil, pattern: ExpressibleAsPatternBuildable, unexpectedBetweenPatternAndTypeAnnotation: ExpressibleAsUnexpectedNodes? = nil, typeAnnotation: ExpressibleAsTypeAnnotation? = nil, unexpectedBetweenTypeAnnotationAndInKeyword: ExpressibleAsUnexpectedNodes? = nil, inKeyword: Token = Token.`in`, unexpectedBetweenInKeywordAndSequenceExpr: ExpressibleAsUnexpectedNodes? = nil, sequenceExpr: ExpressibleAsExprBuildable, unexpectedBetweenSequenceExprAndWhereClause: ExpressibleAsUnexpectedNodes? = nil, whereClause: ExpressibleAsWhereClause? = nil, unexpectedBetweenWhereClauseAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock) {
    assert(forKeyword.text == #"for"#)
    assert(tryKeyword == nil || tryKeyword!.text == #"try"#)
    assert(awaitKeyword == nil || awaitKeyword!.text == #"await"#)
    assert(caseKeyword == nil || caseKeyword!.text == #"case"#)
    assert(inKeyword.text == #"in"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeForKeyword: unexpectedBeforeForKeyword?.createUnexpectedNodes(), forKeyword: forKeyword, unexpectedBetweenForKeywordAndTryKeyword: unexpectedBetweenForKeywordAndTryKeyword?.createUnexpectedNodes(), tryKeyword: tryKeyword, unexpectedBetweenTryKeywordAndAwaitKeyword: unexpectedBetweenTryKeywordAndAwaitKeyword?.createUnexpectedNodes(), awaitKeyword: awaitKeyword, unexpectedBetweenAwaitKeywordAndCaseKeyword: unexpectedBetweenAwaitKeywordAndCaseKeyword?.createUnexpectedNodes(), caseKeyword: caseKeyword, unexpectedBetweenCaseKeywordAndPattern: unexpectedBetweenCaseKeywordAndPattern?.createUnexpectedNodes(), pattern: pattern.createPatternBuildable(), unexpectedBetweenPatternAndTypeAnnotation: unexpectedBetweenPatternAndTypeAnnotation?.createUnexpectedNodes(), typeAnnotation: typeAnnotation?.createTypeAnnotation(), unexpectedBetweenTypeAnnotationAndInKeyword: unexpectedBetweenTypeAnnotationAndInKeyword?.createUnexpectedNodes(), inKeyword: inKeyword, unexpectedBetweenInKeywordAndSequenceExpr: unexpectedBetweenInKeywordAndSequenceExpr?.createUnexpectedNodes(), sequenceExpr: sequenceExpr.createExprBuildable(), unexpectedBetweenSequenceExprAndWhereClause: unexpectedBetweenSequenceExprAndWhereClause?.createUnexpectedNodes(), whereClause: whereClause?.createWhereClause(), unexpectedBetweenWhereClauseAndBody: unexpectedBetweenWhereClauseAndBody?.createUnexpectedNodes(), body: body.createCodeBlock()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeForKeyword: ExpressibleAsUnexpectedNodes? = nil, forKeyword: Token = Token.`for`, unexpectedBetweenForKeywordAndTryKeyword: ExpressibleAsUnexpectedNodes? = nil, tryKeyword: Token? = nil, unexpectedBetweenTryKeywordAndAwaitKeyword: ExpressibleAsUnexpectedNodes? = nil, awaitKeyword: String?, unexpectedBetweenAwaitKeywordAndCaseKeyword: ExpressibleAsUnexpectedNodes? = nil, caseKeyword: Token? = nil, unexpectedBetweenCaseKeywordAndPattern: ExpressibleAsUnexpectedNodes? = nil, pattern: ExpressibleAsPatternBuildable, unexpectedBetweenPatternAndTypeAnnotation: ExpressibleAsUnexpectedNodes? = nil, typeAnnotation: ExpressibleAsTypeAnnotation? = nil, unexpectedBetweenTypeAnnotationAndInKeyword: ExpressibleAsUnexpectedNodes? = nil, inKeyword: Token = Token.`in`, unexpectedBetweenInKeywordAndSequenceExpr: ExpressibleAsUnexpectedNodes? = nil, sequenceExpr: ExpressibleAsExprBuildable, unexpectedBetweenSequenceExprAndWhereClause: ExpressibleAsUnexpectedNodes? = nil, whereClause: ExpressibleAsWhereClause? = nil, unexpectedBetweenWhereClauseAndBody: ExpressibleAsUnexpectedNodes? = nil, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeForKeyword: unexpectedBeforeForKeyword, forKeyword: forKeyword, unexpectedBetweenForKeywordAndTryKeyword: unexpectedBetweenForKeywordAndTryKeyword, tryKeyword: tryKeyword, unexpectedBetweenTryKeywordAndAwaitKeyword: unexpectedBetweenTryKeywordAndAwaitKeyword, awaitKeyword: awaitKeyword.map { Token.`identifier`($0) }, unexpectedBetweenAwaitKeywordAndCaseKeyword: unexpectedBetweenAwaitKeywordAndCaseKeyword, caseKeyword: caseKeyword, unexpectedBetweenCaseKeywordAndPattern: unexpectedBetweenCaseKeywordAndPattern, pattern: pattern, unexpectedBetweenPatternAndTypeAnnotation: unexpectedBetweenPatternAndTypeAnnotation, typeAnnotation: typeAnnotation, unexpectedBetweenTypeAnnotationAndInKeyword: unexpectedBetweenTypeAnnotationAndInKeyword, inKeyword: inKeyword, unexpectedBetweenInKeywordAndSequenceExpr: unexpectedBetweenInKeywordAndSequenceExpr, sequenceExpr: sequenceExpr, unexpectedBetweenSequenceExprAndWhereClause: unexpectedBetweenSequenceExprAndWhereClause, whereClause: whereClause, unexpectedBetweenWhereClauseAndBody: unexpectedBetweenWhereClauseAndBody, body: bodyBuilder())
  }
  public init(_ constructedNode: ForInStmtSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ForInStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ForInStmtSyntax`.
  func buildForInStmt(format: Format) -> ForInStmtSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ForInStmtSyntax(buildableData.unexpectedBeforeForKeyword?.buildUnexpectedNodes(format: format), forKeyword: buildableData.forKeyword.buildToken(format: format), buildableData.unexpectedBetweenForKeywordAndTryKeyword?.buildUnexpectedNodes(format: format), tryKeyword: buildableData.tryKeyword?.buildToken(format: format), buildableData.unexpectedBetweenTryKeywordAndAwaitKeyword?.buildUnexpectedNodes(format: format), awaitKeyword: buildableData.awaitKeyword?.buildToken(format: format), buildableData.unexpectedBetweenAwaitKeywordAndCaseKeyword?.buildUnexpectedNodes(format: format), caseKeyword: buildableData.caseKeyword?.buildToken(format: format), buildableData.unexpectedBetweenCaseKeywordAndPattern?.buildUnexpectedNodes(format: format), pattern: buildableData.pattern.buildPattern(format: format), buildableData.unexpectedBetweenPatternAndTypeAnnotation?.buildUnexpectedNodes(format: format), typeAnnotation: buildableData.typeAnnotation?.buildTypeAnnotation(format: format), buildableData.unexpectedBetweenTypeAnnotationAndInKeyword?.buildUnexpectedNodes(format: format), inKeyword: buildableData.inKeyword.buildToken(format: format), buildableData.unexpectedBetweenInKeywordAndSequenceExpr?.buildUnexpectedNodes(format: format), sequenceExpr: buildableData.sequenceExpr.buildExpr(format: format), buildableData.unexpectedBetweenSequenceExprAndWhereClause?.buildUnexpectedNodes(format: format), whereClause: buildableData.whereClause?.buildWhereClause(format: format), buildableData.unexpectedBetweenWhereClauseAndBody?.buildUnexpectedNodes(format: format), body: buildableData.body.buildCodeBlock(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format) -> StmtSyntax {
    let result = buildForInStmt(format: format)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsForInStmt`.
  public func createForInStmt() -> ForInStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `ForInStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct SwitchStmt: StmtBuildable, ExpressibleAsSwitchStmt {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeSwitchKeyword: UnexpectedNodes?
    var switchKeyword: Token
    var unexpectedBetweenSwitchKeywordAndExpression: UnexpectedNodes?
    var expression: ExprBuildable
    var unexpectedBetweenExpressionAndLeftBrace: UnexpectedNodes?
    var leftBrace: Token
    var unexpectedBetweenLeftBraceAndCases: UnexpectedNodes?
    var cases: SwitchCaseList
    var unexpectedBetweenCasesAndRightBrace: UnexpectedNodes?
    var rightBrace: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(SwitchStmtSyntax)
  }
  private var data: Data
  /// Creates a `SwitchStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeSwitchKeyword: 
  ///   - switchKeyword: 
  ///   - unexpectedBetweenSwitchKeywordAndExpression: 
  ///   - expression: 
  ///   - unexpectedBetweenExpressionAndLeftBrace: 
  ///   - leftBrace: 
  ///   - unexpectedBetweenLeftBraceAndCases: 
  ///   - cases: 
  ///   - unexpectedBetweenCasesAndRightBrace: 
  ///   - rightBrace: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeSwitchKeyword: ExpressibleAsUnexpectedNodes? = nil, switchKeyword: Token = Token.`switch`, unexpectedBetweenSwitchKeywordAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndLeftBrace: ExpressibleAsUnexpectedNodes? = nil, leftBrace: Token = Token.`leftBrace`, unexpectedBetweenLeftBraceAndCases: ExpressibleAsUnexpectedNodes? = nil, cases: ExpressibleAsSwitchCaseList, unexpectedBetweenCasesAndRightBrace: ExpressibleAsUnexpectedNodes? = nil, rightBrace: Token = Token.`rightBrace`) {
    assert(switchKeyword.text == #"switch"#)
    assert(leftBrace.text == #"{"#)
    assert(rightBrace.text == #"}"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeSwitchKeyword: unexpectedBeforeSwitchKeyword?.createUnexpectedNodes(), switchKeyword: switchKeyword, unexpectedBetweenSwitchKeywordAndExpression: unexpectedBetweenSwitchKeywordAndExpression?.createUnexpectedNodes(), expression: expression.createExprBuildable(), unexpectedBetweenExpressionAndLeftBrace: unexpectedBetweenExpressionAndLeftBrace?.createUnexpectedNodes(), leftBrace: leftBrace, unexpectedBetweenLeftBraceAndCases: unexpectedBetweenLeftBraceAndCases?.createUnexpectedNodes(), cases: cases.createSwitchCaseList(), unexpectedBetweenCasesAndRightBrace: unexpectedBetweenCasesAndRightBrace?.createUnexpectedNodes(), rightBrace: rightBrace))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeSwitchKeyword: ExpressibleAsUnexpectedNodes? = nil, switchKeyword: Token = Token.`switch`, unexpectedBetweenSwitchKeywordAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndLeftBrace: ExpressibleAsUnexpectedNodes? = nil, leftBrace: Token = Token.`leftBrace`, unexpectedBetweenLeftBraceAndCases: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenCasesAndRightBrace: ExpressibleAsUnexpectedNodes? = nil, rightBrace: Token = Token.`rightBrace`, @SwitchCaseListBuilder casesBuilder: () -> ExpressibleAsSwitchCaseList =  {
    SwitchCaseList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeSwitchKeyword: unexpectedBeforeSwitchKeyword, switchKeyword: switchKeyword, unexpectedBetweenSwitchKeywordAndExpression: unexpectedBetweenSwitchKeywordAndExpression, expression: expression, unexpectedBetweenExpressionAndLeftBrace: unexpectedBetweenExpressionAndLeftBrace, leftBrace: leftBrace, unexpectedBetweenLeftBraceAndCases: unexpectedBetweenLeftBraceAndCases, cases: casesBuilder(), unexpectedBetweenCasesAndRightBrace: unexpectedBetweenCasesAndRightBrace, rightBrace: rightBrace)
  }
  public init(_ constructedNode: SwitchStmtSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `SwitchStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SwitchStmtSyntax`.
  func buildSwitchStmt(format: Format) -> SwitchStmtSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = SwitchStmtSyntax(buildableData.unexpectedBeforeSwitchKeyword?.buildUnexpectedNodes(format: format), switchKeyword: buildableData.switchKeyword.buildToken(format: format), buildableData.unexpectedBetweenSwitchKeywordAndExpression?.buildUnexpectedNodes(format: format), expression: buildableData.expression.buildExpr(format: format), buildableData.unexpectedBetweenExpressionAndLeftBrace?.buildUnexpectedNodes(format: format), leftBrace: buildableData.leftBrace.buildToken(format: format), buildableData.unexpectedBetweenLeftBraceAndCases?.buildUnexpectedNodes(format: format), cases: buildableData.cases.buildSwitchCaseList(format: format), buildableData.unexpectedBetweenCasesAndRightBrace?.buildUnexpectedNodes(format: format), rightBrace: buildableData.rightBrace.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format) -> StmtSyntax {
    let result = buildSwitchStmt(format: format)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsSwitchStmt`.
  public func createSwitchStmt() -> SwitchStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `SwitchStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct DoStmt: StmtBuildable, ExpressibleAsDoStmt {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeDoKeyword: UnexpectedNodes?
    var doKeyword: Token
    var unexpectedBetweenDoKeywordAndBody: UnexpectedNodes?
    var body: CodeBlock
    var unexpectedBetweenBodyAndCatchClauses: UnexpectedNodes?
    var catchClauses: CatchClauseList?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(DoStmtSyntax)
  }
  private var data: Data
  /// Creates a `DoStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeDoKeyword: 
  ///   - doKeyword: 
  ///   - unexpectedBetweenDoKeywordAndBody: 
  ///   - body: 
  ///   - unexpectedBetweenBodyAndCatchClauses: 
  ///   - catchClauses: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeDoKeyword: ExpressibleAsUnexpectedNodes? = nil, doKeyword: Token = Token.`do`, unexpectedBetweenDoKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock, unexpectedBetweenBodyAndCatchClauses: ExpressibleAsUnexpectedNodes? = nil, catchClauses: ExpressibleAsCatchClauseList? = nil) {
    assert(doKeyword.text == #"do"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeDoKeyword: unexpectedBeforeDoKeyword?.createUnexpectedNodes(), doKeyword: doKeyword, unexpectedBetweenDoKeywordAndBody: unexpectedBetweenDoKeywordAndBody?.createUnexpectedNodes(), body: body.createCodeBlock(), unexpectedBetweenBodyAndCatchClauses: unexpectedBetweenBodyAndCatchClauses?.createUnexpectedNodes(), catchClauses: catchClauses?.createCatchClauseList()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeDoKeyword: ExpressibleAsUnexpectedNodes? = nil, doKeyword: Token = Token.`do`, unexpectedBetweenDoKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenBodyAndCatchClauses: ExpressibleAsUnexpectedNodes? = nil, catchClauses: ExpressibleAsCatchClauseList? = nil, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeDoKeyword: unexpectedBeforeDoKeyword, doKeyword: doKeyword, unexpectedBetweenDoKeywordAndBody: unexpectedBetweenDoKeywordAndBody, body: bodyBuilder(), unexpectedBetweenBodyAndCatchClauses: unexpectedBetweenBodyAndCatchClauses, catchClauses: catchClauses)
  }
  public init(_ constructedNode: DoStmtSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `DoStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DoStmtSyntax`.
  func buildDoStmt(format: Format) -> DoStmtSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = DoStmtSyntax(buildableData.unexpectedBeforeDoKeyword?.buildUnexpectedNodes(format: format), doKeyword: buildableData.doKeyword.buildToken(format: format), buildableData.unexpectedBetweenDoKeywordAndBody?.buildUnexpectedNodes(format: format), body: buildableData.body.buildCodeBlock(format: format), buildableData.unexpectedBetweenBodyAndCatchClauses?.buildUnexpectedNodes(format: format), catchClauses: buildableData.catchClauses?.buildCatchClauseList(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format) -> StmtSyntax {
    let result = buildDoStmt(format: format)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsDoStmt`.
  public func createDoStmt() -> DoStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `DoStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct ReturnStmt: StmtBuildable, ExpressibleAsReturnStmt {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeReturnKeyword: UnexpectedNodes?
    var returnKeyword: Token
    var unexpectedBetweenReturnKeywordAndExpression: UnexpectedNodes?
    var expression: ExprBuildable?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ReturnStmtSyntax)
  }
  private var data: Data
  /// Creates a `ReturnStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeReturnKeyword: 
  ///   - returnKeyword: 
  ///   - unexpectedBetweenReturnKeywordAndExpression: 
  ///   - expression: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeReturnKeyword: ExpressibleAsUnexpectedNodes? = nil, returnKeyword: Token = Token.`return`, unexpectedBetweenReturnKeywordAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable? = nil) {
    assert(returnKeyword.text == #"return"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeReturnKeyword: unexpectedBeforeReturnKeyword?.createUnexpectedNodes(), returnKeyword: returnKeyword, unexpectedBetweenReturnKeywordAndExpression: unexpectedBetweenReturnKeywordAndExpression?.createUnexpectedNodes(), expression: expression?.createExprBuildable()))
  }
  public init(_ constructedNode: ReturnStmtSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ReturnStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ReturnStmtSyntax`.
  func buildReturnStmt(format: Format) -> ReturnStmtSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ReturnStmtSyntax(buildableData.unexpectedBeforeReturnKeyword?.buildUnexpectedNodes(format: format), returnKeyword: buildableData.returnKeyword.buildToken(format: format), buildableData.unexpectedBetweenReturnKeywordAndExpression?.buildUnexpectedNodes(format: format), expression: buildableData.expression?.buildExpr(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format) -> StmtSyntax {
    let result = buildReturnStmt(format: format)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsReturnStmt`.
  public func createReturnStmt() -> ReturnStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `ReturnStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct YieldStmt: StmtBuildable, ExpressibleAsYieldStmt {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeYieldKeyword: UnexpectedNodes?
    var yieldKeyword: Token
    var unexpectedBetweenYieldKeywordAndYields: UnexpectedNodes?
    var yields: SyntaxBuildable
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(YieldStmtSyntax)
  }
  private var data: Data
  /// Creates a `YieldStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeYieldKeyword: 
  ///   - yieldKeyword: 
  ///   - unexpectedBetweenYieldKeywordAndYields: 
  ///   - yields: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeYieldKeyword: ExpressibleAsUnexpectedNodes? = nil, yieldKeyword: Token = Token.`yield`, unexpectedBetweenYieldKeywordAndYields: ExpressibleAsUnexpectedNodes? = nil, yields: ExpressibleAsSyntaxBuildable) {
    assert(yieldKeyword.text == #"yield"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeYieldKeyword: unexpectedBeforeYieldKeyword?.createUnexpectedNodes(), yieldKeyword: yieldKeyword, unexpectedBetweenYieldKeywordAndYields: unexpectedBetweenYieldKeywordAndYields?.createUnexpectedNodes(), yields: yields.createSyntaxBuildable()))
  }
  public init(_ constructedNode: YieldStmtSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `YieldStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `YieldStmtSyntax`.
  func buildYieldStmt(format: Format) -> YieldStmtSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = YieldStmtSyntax(buildableData.unexpectedBeforeYieldKeyword?.buildUnexpectedNodes(format: format), yieldKeyword: buildableData.yieldKeyword.buildToken(format: format), buildableData.unexpectedBetweenYieldKeywordAndYields?.buildUnexpectedNodes(format: format), yields: buildableData.yields.buildSyntax(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format) -> StmtSyntax {
    let result = buildYieldStmt(format: format)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsYieldStmt`.
  public func createYieldStmt() -> YieldStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `YieldStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct YieldList: SyntaxBuildable, ExpressibleAsYieldList {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeLeftParen: UnexpectedNodes?
    var leftParen: Token
    var unexpectedBetweenLeftParenAndElementList: UnexpectedNodes?
    var elementList: YieldExprList
    var unexpectedBetweenElementListAndRightParen: UnexpectedNodes?
    var rightParen: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(YieldListSyntax)
  }
  private var data: Data
  /// Creates a `YieldList` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndElementList: 
  ///   - elementList: 
  ///   - unexpectedBetweenElementListAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndElementList: ExpressibleAsUnexpectedNodes? = nil, elementList: ExpressibleAsYieldExprList, unexpectedBetweenElementListAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    assert(leftParen.text == #"("#)
    assert(rightParen.text == #")"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeLeftParen: unexpectedBeforeLeftParen?.createUnexpectedNodes(), leftParen: leftParen, unexpectedBetweenLeftParenAndElementList: unexpectedBetweenLeftParenAndElementList?.createUnexpectedNodes(), elementList: elementList.createYieldExprList(), unexpectedBetweenElementListAndRightParen: unexpectedBetweenElementListAndRightParen?.createUnexpectedNodes(), rightParen: rightParen))
  }
  public init(_ constructedNode: YieldListSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `YieldListSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `YieldListSyntax`.
  func buildYieldList(format: Format) -> YieldListSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = YieldListSyntax(buildableData.unexpectedBeforeLeftParen?.buildUnexpectedNodes(format: format), leftParen: buildableData.leftParen.buildToken(format: format), buildableData.unexpectedBetweenLeftParenAndElementList?.buildUnexpectedNodes(format: format), elementList: buildableData.elementList.buildYieldExprList(format: format), buildableData.unexpectedBetweenElementListAndRightParen?.buildUnexpectedNodes(format: format), rightParen: buildableData.rightParen.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildYieldList(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsYieldList`.
  public func createYieldList() -> YieldList {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `YieldList` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct FallthroughStmt: StmtBuildable, ExpressibleAsFallthroughStmt {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeFallthroughKeyword: UnexpectedNodes?
    var fallthroughKeyword: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(FallthroughStmtSyntax)
  }
  private var data: Data
  /// Creates a `FallthroughStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeFallthroughKeyword: 
  ///   - fallthroughKeyword: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeFallthroughKeyword: ExpressibleAsUnexpectedNodes? = nil, fallthroughKeyword: Token = Token.`fallthrough`) {
    assert(fallthroughKeyword.text == #"fallthrough"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeFallthroughKeyword: unexpectedBeforeFallthroughKeyword?.createUnexpectedNodes(), fallthroughKeyword: fallthroughKeyword))
  }
  public init(_ constructedNode: FallthroughStmtSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `FallthroughStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `FallthroughStmtSyntax`.
  func buildFallthroughStmt(format: Format) -> FallthroughStmtSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = FallthroughStmtSyntax(buildableData.unexpectedBeforeFallthroughKeyword?.buildUnexpectedNodes(format: format), fallthroughKeyword: buildableData.fallthroughKeyword.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format) -> StmtSyntax {
    let result = buildFallthroughStmt(format: format)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsFallthroughStmt`.
  public func createFallthroughStmt() -> FallthroughStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `FallthroughStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct BreakStmt: StmtBuildable, ExpressibleAsBreakStmt {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeBreakKeyword: UnexpectedNodes?
    var breakKeyword: Token
    var unexpectedBetweenBreakKeywordAndLabel: UnexpectedNodes?
    var label: Token?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(BreakStmtSyntax)
  }
  private var data: Data
  /// Creates a `BreakStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeBreakKeyword: 
  ///   - breakKeyword: 
  ///   - unexpectedBetweenBreakKeywordAndLabel: 
  ///   - label: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeBreakKeyword: ExpressibleAsUnexpectedNodes? = nil, breakKeyword: Token = Token.`break`, unexpectedBetweenBreakKeywordAndLabel: ExpressibleAsUnexpectedNodes? = nil, label: Token? = nil) {
    assert(breakKeyword.text == #"break"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeBreakKeyword: unexpectedBeforeBreakKeyword?.createUnexpectedNodes(), breakKeyword: breakKeyword, unexpectedBetweenBreakKeywordAndLabel: unexpectedBetweenBreakKeywordAndLabel?.createUnexpectedNodes(), label: label))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeBreakKeyword: ExpressibleAsUnexpectedNodes? = nil, breakKeyword: Token = Token.`break`, unexpectedBetweenBreakKeywordAndLabel: ExpressibleAsUnexpectedNodes? = nil, label: String?) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeBreakKeyword: unexpectedBeforeBreakKeyword, breakKeyword: breakKeyword, unexpectedBetweenBreakKeywordAndLabel: unexpectedBetweenBreakKeywordAndLabel, label: label.map { Token.`identifier`($0) })
  }
  public init(_ constructedNode: BreakStmtSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `BreakStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `BreakStmtSyntax`.
  func buildBreakStmt(format: Format) -> BreakStmtSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = BreakStmtSyntax(buildableData.unexpectedBeforeBreakKeyword?.buildUnexpectedNodes(format: format), breakKeyword: buildableData.breakKeyword.buildToken(format: format), buildableData.unexpectedBetweenBreakKeywordAndLabel?.buildUnexpectedNodes(format: format), label: buildableData.label?.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format) -> StmtSyntax {
    let result = buildBreakStmt(format: format)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsBreakStmt`.
  public func createBreakStmt() -> BreakStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `BreakStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct ConditionElement: SyntaxBuildable, ExpressibleAsConditionElement, HasTrailingComma {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeCondition: UnexpectedNodes?
    var condition: SyntaxBuildable
    var unexpectedBetweenConditionAndTrailingComma: UnexpectedNodes?
    var trailingComma: Token?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ConditionElementSyntax)
  }
  private var data: Data
  var hasTrailingComma: Bool {
    switch data {
    case .buildable(let buildableData):
      return buildableData.trailingComma != nil
    case .constructed(let node):
      return node.trailingComma != nil
    }
  }
  /// Creates a `ConditionElement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeCondition: 
  ///   - condition: 
  ///   - unexpectedBetweenConditionAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeCondition: ExpressibleAsUnexpectedNodes? = nil, condition: ExpressibleAsSyntaxBuildable, unexpectedBetweenConditionAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    assert(trailingComma == nil || trailingComma!.text == #","#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeCondition: unexpectedBeforeCondition?.createUnexpectedNodes(), condition: condition.createSyntaxBuildable(), unexpectedBetweenConditionAndTrailingComma: unexpectedBetweenConditionAndTrailingComma?.createUnexpectedNodes(), trailingComma: trailingComma))
  }
  public init(_ constructedNode: ConditionElementSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ConditionElementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ConditionElementSyntax`.
  func buildConditionElement(format: Format) -> ConditionElementSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ConditionElementSyntax(buildableData.unexpectedBeforeCondition?.buildUnexpectedNodes(format: format), condition: buildableData.condition.buildSyntax(format: format), buildableData.unexpectedBetweenConditionAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: buildableData.trailingComma?.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildConditionElement(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsConditionElement`.
  public func createConditionElement() -> ConditionElement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ConditionElement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingComma = withComma ? .comma : nil
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withComma = node.withTrailingComma(withComma ? .commaToken() : nil)
      var result = self
      result.data = .constructed(withComma)
      return result
    }
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct AvailabilityCondition: SyntaxBuildable, ExpressibleAsAvailabilityCondition {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforePoundAvailableKeyword: UnexpectedNodes?
    var poundAvailableKeyword: Token
    var unexpectedBetweenPoundAvailableKeywordAndLeftParen: UnexpectedNodes?
    var leftParen: Token
    var unexpectedBetweenLeftParenAndAvailabilitySpec: UnexpectedNodes?
    var availabilitySpec: AvailabilitySpecList
    var unexpectedBetweenAvailabilitySpecAndRightParen: UnexpectedNodes?
    var rightParen: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(AvailabilityConditionSyntax)
  }
  private var data: Data
  /// Creates a `AvailabilityCondition` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundAvailableKeyword: 
  ///   - poundAvailableKeyword: 
  ///   - unexpectedBetweenPoundAvailableKeywordAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndAvailabilitySpec: 
  ///   - availabilitySpec: 
  ///   - unexpectedBetweenAvailabilitySpecAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePoundAvailableKeyword: ExpressibleAsUnexpectedNodes? = nil, poundAvailableKeyword: Token = Token.`poundAvailable`, unexpectedBetweenPoundAvailableKeywordAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndAvailabilitySpec: ExpressibleAsUnexpectedNodes? = nil, availabilitySpec: ExpressibleAsAvailabilitySpecList, unexpectedBetweenAvailabilitySpecAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    assert(poundAvailableKeyword.text == #"#available"#)
    assert(leftParen.text == #"("#)
    assert(rightParen.text == #")"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforePoundAvailableKeyword: unexpectedBeforePoundAvailableKeyword?.createUnexpectedNodes(), poundAvailableKeyword: poundAvailableKeyword, unexpectedBetweenPoundAvailableKeywordAndLeftParen: unexpectedBetweenPoundAvailableKeywordAndLeftParen?.createUnexpectedNodes(), leftParen: leftParen, unexpectedBetweenLeftParenAndAvailabilitySpec: unexpectedBetweenLeftParenAndAvailabilitySpec?.createUnexpectedNodes(), availabilitySpec: availabilitySpec.createAvailabilitySpecList(), unexpectedBetweenAvailabilitySpecAndRightParen: unexpectedBetweenAvailabilitySpecAndRightParen?.createUnexpectedNodes(), rightParen: rightParen))
  }
  public init(_ constructedNode: AvailabilityConditionSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `AvailabilityConditionSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AvailabilityConditionSyntax`.
  func buildAvailabilityCondition(format: Format) -> AvailabilityConditionSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = AvailabilityConditionSyntax(buildableData.unexpectedBeforePoundAvailableKeyword?.buildUnexpectedNodes(format: format), poundAvailableKeyword: buildableData.poundAvailableKeyword.buildToken(format: format), buildableData.unexpectedBetweenPoundAvailableKeywordAndLeftParen?.buildUnexpectedNodes(format: format), leftParen: buildableData.leftParen.buildToken(format: format), buildableData.unexpectedBetweenLeftParenAndAvailabilitySpec?.buildUnexpectedNodes(format: format), availabilitySpec: buildableData.availabilitySpec.buildAvailabilitySpecList(format: format), buildableData.unexpectedBetweenAvailabilitySpecAndRightParen?.buildUnexpectedNodes(format: format), rightParen: buildableData.rightParen.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildAvailabilityCondition(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsAvailabilityCondition`.
  public func createAvailabilityCondition() -> AvailabilityCondition {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `AvailabilityCondition` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct MatchingPatternCondition: SyntaxBuildable, ExpressibleAsMatchingPatternCondition {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeCaseKeyword: UnexpectedNodes?
    var caseKeyword: Token
    var unexpectedBetweenCaseKeywordAndPattern: UnexpectedNodes?
    var pattern: PatternBuildable
    var unexpectedBetweenPatternAndTypeAnnotation: UnexpectedNodes?
    var typeAnnotation: TypeAnnotation?
    var unexpectedBetweenTypeAnnotationAndInitializer: UnexpectedNodes?
    var initializer: InitializerClause
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(MatchingPatternConditionSyntax)
  }
  private var data: Data
  /// Creates a `MatchingPatternCondition` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeCaseKeyword: 
  ///   - caseKeyword: 
  ///   - unexpectedBetweenCaseKeywordAndPattern: 
  ///   - pattern: 
  ///   - unexpectedBetweenPatternAndTypeAnnotation: 
  ///   - typeAnnotation: 
  ///   - unexpectedBetweenTypeAnnotationAndInitializer: 
  ///   - initializer: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeCaseKeyword: ExpressibleAsUnexpectedNodes? = nil, caseKeyword: Token = Token.`case`, unexpectedBetweenCaseKeywordAndPattern: ExpressibleAsUnexpectedNodes? = nil, pattern: ExpressibleAsPatternBuildable, unexpectedBetweenPatternAndTypeAnnotation: ExpressibleAsUnexpectedNodes? = nil, typeAnnotation: ExpressibleAsTypeAnnotation? = nil, unexpectedBetweenTypeAnnotationAndInitializer: ExpressibleAsUnexpectedNodes? = nil, initializer: ExpressibleAsInitializerClause) {
    assert(caseKeyword.text == #"case"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeCaseKeyword: unexpectedBeforeCaseKeyword?.createUnexpectedNodes(), caseKeyword: caseKeyword, unexpectedBetweenCaseKeywordAndPattern: unexpectedBetweenCaseKeywordAndPattern?.createUnexpectedNodes(), pattern: pattern.createPatternBuildable(), unexpectedBetweenPatternAndTypeAnnotation: unexpectedBetweenPatternAndTypeAnnotation?.createUnexpectedNodes(), typeAnnotation: typeAnnotation?.createTypeAnnotation(), unexpectedBetweenTypeAnnotationAndInitializer: unexpectedBetweenTypeAnnotationAndInitializer?.createUnexpectedNodes(), initializer: initializer.createInitializerClause()))
  }
  public init(_ constructedNode: MatchingPatternConditionSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `MatchingPatternConditionSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `MatchingPatternConditionSyntax`.
  func buildMatchingPatternCondition(format: Format) -> MatchingPatternConditionSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = MatchingPatternConditionSyntax(buildableData.unexpectedBeforeCaseKeyword?.buildUnexpectedNodes(format: format), caseKeyword: buildableData.caseKeyword.buildToken(format: format), buildableData.unexpectedBetweenCaseKeywordAndPattern?.buildUnexpectedNodes(format: format), pattern: buildableData.pattern.buildPattern(format: format), buildableData.unexpectedBetweenPatternAndTypeAnnotation?.buildUnexpectedNodes(format: format), typeAnnotation: buildableData.typeAnnotation?.buildTypeAnnotation(format: format), buildableData.unexpectedBetweenTypeAnnotationAndInitializer?.buildUnexpectedNodes(format: format), initializer: buildableData.initializer.buildInitializerClause(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildMatchingPatternCondition(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsMatchingPatternCondition`.
  public func createMatchingPatternCondition() -> MatchingPatternCondition {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `MatchingPatternCondition` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct OptionalBindingCondition: SyntaxBuildable, ExpressibleAsOptionalBindingCondition {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeLetOrVarKeyword: UnexpectedNodes?
    var letOrVarKeyword: Token
    var unexpectedBetweenLetOrVarKeywordAndPattern: UnexpectedNodes?
    var pattern: PatternBuildable
    var unexpectedBetweenPatternAndTypeAnnotation: UnexpectedNodes?
    var typeAnnotation: TypeAnnotation?
    var unexpectedBetweenTypeAnnotationAndInitializer: UnexpectedNodes?
    var initializer: InitializerClause?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(OptionalBindingConditionSyntax)
  }
  private var data: Data
  /// Creates a `OptionalBindingCondition` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLetOrVarKeyword: 
  ///   - letOrVarKeyword: 
  ///   - unexpectedBetweenLetOrVarKeywordAndPattern: 
  ///   - pattern: 
  ///   - unexpectedBetweenPatternAndTypeAnnotation: 
  ///   - typeAnnotation: 
  ///   - unexpectedBetweenTypeAnnotationAndInitializer: 
  ///   - initializer: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLetOrVarKeyword: ExpressibleAsUnexpectedNodes? = nil, letOrVarKeyword: Token, unexpectedBetweenLetOrVarKeywordAndPattern: ExpressibleAsUnexpectedNodes? = nil, pattern: ExpressibleAsPatternBuildable, unexpectedBetweenPatternAndTypeAnnotation: ExpressibleAsUnexpectedNodes? = nil, typeAnnotation: ExpressibleAsTypeAnnotation? = nil, unexpectedBetweenTypeAnnotationAndInitializer: ExpressibleAsUnexpectedNodes? = nil, initializer: ExpressibleAsInitializerClause? = nil) {
    assert(letOrVarKeyword.text == #"let"# || letOrVarKeyword.text == #"var"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeLetOrVarKeyword: unexpectedBeforeLetOrVarKeyword?.createUnexpectedNodes(), letOrVarKeyword: letOrVarKeyword, unexpectedBetweenLetOrVarKeywordAndPattern: unexpectedBetweenLetOrVarKeywordAndPattern?.createUnexpectedNodes(), pattern: pattern.createPatternBuildable(), unexpectedBetweenPatternAndTypeAnnotation: unexpectedBetweenPatternAndTypeAnnotation?.createUnexpectedNodes(), typeAnnotation: typeAnnotation?.createTypeAnnotation(), unexpectedBetweenTypeAnnotationAndInitializer: unexpectedBetweenTypeAnnotationAndInitializer?.createUnexpectedNodes(), initializer: initializer?.createInitializerClause()))
  }
  public init(_ constructedNode: OptionalBindingConditionSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `OptionalBindingConditionSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `OptionalBindingConditionSyntax`.
  func buildOptionalBindingCondition(format: Format) -> OptionalBindingConditionSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = OptionalBindingConditionSyntax(buildableData.unexpectedBeforeLetOrVarKeyword?.buildUnexpectedNodes(format: format), letOrVarKeyword: buildableData.letOrVarKeyword.buildToken(format: format), buildableData.unexpectedBetweenLetOrVarKeywordAndPattern?.buildUnexpectedNodes(format: format), pattern: buildableData.pattern.buildPattern(format: format), buildableData.unexpectedBetweenPatternAndTypeAnnotation?.buildUnexpectedNodes(format: format), typeAnnotation: buildableData.typeAnnotation?.buildTypeAnnotation(format: format), buildableData.unexpectedBetweenTypeAnnotationAndInitializer?.buildUnexpectedNodes(format: format), initializer: buildableData.initializer?.buildInitializerClause(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildOptionalBindingCondition(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsOptionalBindingCondition`.
  public func createOptionalBindingCondition() -> OptionalBindingCondition {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `OptionalBindingCondition` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct UnavailabilityCondition: SyntaxBuildable, ExpressibleAsUnavailabilityCondition {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforePoundUnavailableKeyword: UnexpectedNodes?
    var poundUnavailableKeyword: Token
    var unexpectedBetweenPoundUnavailableKeywordAndLeftParen: UnexpectedNodes?
    var leftParen: Token
    var unexpectedBetweenLeftParenAndAvailabilitySpec: UnexpectedNodes?
    var availabilitySpec: AvailabilitySpecList
    var unexpectedBetweenAvailabilitySpecAndRightParen: UnexpectedNodes?
    var rightParen: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(UnavailabilityConditionSyntax)
  }
  private var data: Data
  /// Creates a `UnavailabilityCondition` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundUnavailableKeyword: 
  ///   - poundUnavailableKeyword: 
  ///   - unexpectedBetweenPoundUnavailableKeywordAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndAvailabilitySpec: 
  ///   - availabilitySpec: 
  ///   - unexpectedBetweenAvailabilitySpecAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePoundUnavailableKeyword: ExpressibleAsUnexpectedNodes? = nil, poundUnavailableKeyword: Token = Token.`poundUnavailable`, unexpectedBetweenPoundUnavailableKeywordAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndAvailabilitySpec: ExpressibleAsUnexpectedNodes? = nil, availabilitySpec: ExpressibleAsAvailabilitySpecList, unexpectedBetweenAvailabilitySpecAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    assert(poundUnavailableKeyword.text == #"#unavailable"#)
    assert(leftParen.text == #"("#)
    assert(rightParen.text == #")"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforePoundUnavailableKeyword: unexpectedBeforePoundUnavailableKeyword?.createUnexpectedNodes(), poundUnavailableKeyword: poundUnavailableKeyword, unexpectedBetweenPoundUnavailableKeywordAndLeftParen: unexpectedBetweenPoundUnavailableKeywordAndLeftParen?.createUnexpectedNodes(), leftParen: leftParen, unexpectedBetweenLeftParenAndAvailabilitySpec: unexpectedBetweenLeftParenAndAvailabilitySpec?.createUnexpectedNodes(), availabilitySpec: availabilitySpec.createAvailabilitySpecList(), unexpectedBetweenAvailabilitySpecAndRightParen: unexpectedBetweenAvailabilitySpecAndRightParen?.createUnexpectedNodes(), rightParen: rightParen))
  }
  public init(_ constructedNode: UnavailabilityConditionSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `UnavailabilityConditionSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `UnavailabilityConditionSyntax`.
  func buildUnavailabilityCondition(format: Format) -> UnavailabilityConditionSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = UnavailabilityConditionSyntax(buildableData.unexpectedBeforePoundUnavailableKeyword?.buildUnexpectedNodes(format: format), poundUnavailableKeyword: buildableData.poundUnavailableKeyword.buildToken(format: format), buildableData.unexpectedBetweenPoundUnavailableKeywordAndLeftParen?.buildUnexpectedNodes(format: format), leftParen: buildableData.leftParen.buildToken(format: format), buildableData.unexpectedBetweenLeftParenAndAvailabilitySpec?.buildUnexpectedNodes(format: format), availabilitySpec: buildableData.availabilitySpec.buildAvailabilitySpecList(format: format), buildableData.unexpectedBetweenAvailabilitySpecAndRightParen?.buildUnexpectedNodes(format: format), rightParen: buildableData.rightParen.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildUnavailabilityCondition(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsUnavailabilityCondition`.
  public func createUnavailabilityCondition() -> UnavailabilityCondition {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `UnavailabilityCondition` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct HasSymbolCondition: SyntaxBuildable, ExpressibleAsHasSymbolCondition {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeHasSymbolKeyword: UnexpectedNodes?
    var hasSymbolKeyword: Token
    var unexpectedBetweenHasSymbolKeywordAndLeftParen: UnexpectedNodes?
    var leftParen: Token
    var unexpectedBetweenLeftParenAndExpression: UnexpectedNodes?
    var expression: ExprBuildable
    var unexpectedBetweenExpressionAndRightParen: UnexpectedNodes?
    var rightParen: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(HasSymbolConditionSyntax)
  }
  private var data: Data
  /// Creates a `HasSymbolCondition` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeHasSymbolKeyword: 
  ///   - hasSymbolKeyword: 
  ///   - unexpectedBetweenHasSymbolKeywordAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndExpression: 
  ///   - expression: 
  ///   - unexpectedBetweenExpressionAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeHasSymbolKeyword: ExpressibleAsUnexpectedNodes? = nil, hasSymbolKeyword: Token, unexpectedBetweenHasSymbolKeywordAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable, unexpectedBetweenExpressionAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    assert(leftParen.text == #"("#)
    assert(rightParen.text == #")"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeHasSymbolKeyword: unexpectedBeforeHasSymbolKeyword?.createUnexpectedNodes(), hasSymbolKeyword: hasSymbolKeyword, unexpectedBetweenHasSymbolKeywordAndLeftParen: unexpectedBetweenHasSymbolKeywordAndLeftParen?.createUnexpectedNodes(), leftParen: leftParen, unexpectedBetweenLeftParenAndExpression: unexpectedBetweenLeftParenAndExpression?.createUnexpectedNodes(), expression: expression.createExprBuildable(), unexpectedBetweenExpressionAndRightParen: unexpectedBetweenExpressionAndRightParen?.createUnexpectedNodes(), rightParen: rightParen))
  }
  public init(_ constructedNode: HasSymbolConditionSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `HasSymbolConditionSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `HasSymbolConditionSyntax`.
  func buildHasSymbolCondition(format: Format) -> HasSymbolConditionSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = HasSymbolConditionSyntax(buildableData.unexpectedBeforeHasSymbolKeyword?.buildUnexpectedNodes(format: format), hasSymbolKeyword: buildableData.hasSymbolKeyword.buildToken(format: format), buildableData.unexpectedBetweenHasSymbolKeywordAndLeftParen?.buildUnexpectedNodes(format: format), leftParen: buildableData.leftParen.buildToken(format: format), buildableData.unexpectedBetweenLeftParenAndExpression?.buildUnexpectedNodes(format: format), expression: buildableData.expression.buildExpr(format: format), buildableData.unexpectedBetweenExpressionAndRightParen?.buildUnexpectedNodes(format: format), rightParen: buildableData.rightParen.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildHasSymbolCondition(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsHasSymbolCondition`.
  public func createHasSymbolCondition() -> HasSymbolCondition {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `HasSymbolCondition` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct DeclarationStmt: StmtBuildable, ExpressibleAsDeclarationStmt {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeDeclaration: UnexpectedNodes?
    var declaration: DeclBuildable
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(DeclarationStmtSyntax)
  }
  private var data: Data
  /// Creates a `DeclarationStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeDeclaration: 
  ///   - declaration: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeDeclaration: ExpressibleAsUnexpectedNodes? = nil, declaration: ExpressibleAsDeclBuildable) {
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeDeclaration: unexpectedBeforeDeclaration?.createUnexpectedNodes(), declaration: declaration.createDeclBuildable()))
  }
  public init(_ constructedNode: DeclarationStmtSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `DeclarationStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DeclarationStmtSyntax`.
  func buildDeclarationStmt(format: Format) -> DeclarationStmtSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = DeclarationStmtSyntax(buildableData.unexpectedBeforeDeclaration?.buildUnexpectedNodes(format: format), declaration: buildableData.declaration.buildDecl(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format) -> StmtSyntax {
    let result = buildDeclarationStmt(format: format)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsDeclarationStmt`.
  public func createDeclarationStmt() -> DeclarationStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `DeclarationStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct ThrowStmt: StmtBuildable, ExpressibleAsThrowStmt {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeThrowKeyword: UnexpectedNodes?
    var throwKeyword: Token
    var unexpectedBetweenThrowKeywordAndExpression: UnexpectedNodes?
    var expression: ExprBuildable
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ThrowStmtSyntax)
  }
  private var data: Data
  /// Creates a `ThrowStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeThrowKeyword: 
  ///   - throwKeyword: 
  ///   - unexpectedBetweenThrowKeywordAndExpression: 
  ///   - expression: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeThrowKeyword: ExpressibleAsUnexpectedNodes? = nil, throwKeyword: Token = Token.`throw`, unexpectedBetweenThrowKeywordAndExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable) {
    assert(throwKeyword.text == #"throw"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeThrowKeyword: unexpectedBeforeThrowKeyword?.createUnexpectedNodes(), throwKeyword: throwKeyword, unexpectedBetweenThrowKeywordAndExpression: unexpectedBetweenThrowKeywordAndExpression?.createUnexpectedNodes(), expression: expression.createExprBuildable()))
  }
  public init(_ constructedNode: ThrowStmtSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ThrowStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ThrowStmtSyntax`.
  func buildThrowStmt(format: Format) -> ThrowStmtSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ThrowStmtSyntax(buildableData.unexpectedBeforeThrowKeyword?.buildUnexpectedNodes(format: format), throwKeyword: buildableData.throwKeyword.buildToken(format: format), buildableData.unexpectedBetweenThrowKeywordAndExpression?.buildUnexpectedNodes(format: format), expression: buildableData.expression.buildExpr(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format) -> StmtSyntax {
    let result = buildThrowStmt(format: format)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsThrowStmt`.
  public func createThrowStmt() -> ThrowStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `ThrowStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct IfStmt: StmtBuildable, ExpressibleAsIfStmt {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeIfKeyword: UnexpectedNodes?
    var ifKeyword: Token
    var unexpectedBetweenIfKeywordAndConditions: UnexpectedNodes?
    var conditions: ConditionElementList
    var unexpectedBetweenConditionsAndBody: UnexpectedNodes?
    var body: CodeBlock
    var unexpectedBetweenBodyAndElseKeyword: UnexpectedNodes?
    var elseKeyword: Token?
    var unexpectedBetweenElseKeywordAndElseBody: UnexpectedNodes?
    var elseBody: SyntaxBuildable?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(IfStmtSyntax)
  }
  private var data: Data
  /// Creates a `IfStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeIfKeyword: 
  ///   - ifKeyword: 
  ///   - unexpectedBetweenIfKeywordAndConditions: 
  ///   - conditions: 
  ///   - unexpectedBetweenConditionsAndBody: 
  ///   - body: 
  ///   - unexpectedBetweenBodyAndElseKeyword: 
  ///   - elseKeyword: 
  ///   - unexpectedBetweenElseKeywordAndElseBody: 
  ///   - elseBody: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeIfKeyword: ExpressibleAsUnexpectedNodes? = nil, ifKeyword: Token = Token.`if`, unexpectedBetweenIfKeywordAndConditions: ExpressibleAsUnexpectedNodes? = nil, conditions: ExpressibleAsConditionElementList, unexpectedBetweenConditionsAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock, unexpectedBetweenBodyAndElseKeyword: ExpressibleAsUnexpectedNodes? = nil, elseKeyword: Token? = nil, unexpectedBetweenElseKeywordAndElseBody: ExpressibleAsUnexpectedNodes? = nil, elseBody: ExpressibleAsSyntaxBuildable? = nil) {
    assert(ifKeyword.text == #"if"#)
    assert(elseKeyword == nil || elseKeyword!.text == #"else"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeIfKeyword: unexpectedBeforeIfKeyword?.createUnexpectedNodes(), ifKeyword: ifKeyword, unexpectedBetweenIfKeywordAndConditions: unexpectedBetweenIfKeywordAndConditions?.createUnexpectedNodes(), conditions: conditions.createConditionElementList(), unexpectedBetweenConditionsAndBody: unexpectedBetweenConditionsAndBody?.createUnexpectedNodes(), body: body.createCodeBlock(), unexpectedBetweenBodyAndElseKeyword: unexpectedBetweenBodyAndElseKeyword?.createUnexpectedNodes(), elseKeyword: elseKeyword, unexpectedBetweenElseKeywordAndElseBody: unexpectedBetweenElseKeywordAndElseBody?.createUnexpectedNodes(), elseBody: elseBody?.createSyntaxBuildable()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeIfKeyword: ExpressibleAsUnexpectedNodes? = nil, ifKeyword: Token = Token.`if`, unexpectedBetweenIfKeywordAndConditions: ExpressibleAsUnexpectedNodes? = nil, conditions: ExpressibleAsConditionElementList, unexpectedBetweenConditionsAndBody: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenBodyAndElseKeyword: ExpressibleAsUnexpectedNodes? = nil, elseKeyword: Token? = nil, unexpectedBetweenElseKeywordAndElseBody: ExpressibleAsUnexpectedNodes? = nil, elseBody: ExpressibleAsSyntaxBuildable? = nil, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeIfKeyword: unexpectedBeforeIfKeyword, ifKeyword: ifKeyword, unexpectedBetweenIfKeywordAndConditions: unexpectedBetweenIfKeywordAndConditions, conditions: conditions, unexpectedBetweenConditionsAndBody: unexpectedBetweenConditionsAndBody, body: bodyBuilder(), unexpectedBetweenBodyAndElseKeyword: unexpectedBetweenBodyAndElseKeyword, elseKeyword: elseKeyword, unexpectedBetweenElseKeywordAndElseBody: unexpectedBetweenElseKeywordAndElseBody, elseBody: elseBody)
  }
  public init(_ constructedNode: IfStmtSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `IfStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `IfStmtSyntax`.
  func buildIfStmt(format: Format) -> IfStmtSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = IfStmtSyntax(buildableData.unexpectedBeforeIfKeyword?.buildUnexpectedNodes(format: format), ifKeyword: buildableData.ifKeyword.buildToken(format: format), buildableData.unexpectedBetweenIfKeywordAndConditions?.buildUnexpectedNodes(format: format), conditions: buildableData.conditions.buildConditionElementList(format: format), buildableData.unexpectedBetweenConditionsAndBody?.buildUnexpectedNodes(format: format), body: buildableData.body.buildCodeBlock(format: format), buildableData.unexpectedBetweenBodyAndElseKeyword?.buildUnexpectedNodes(format: format), elseKeyword: buildableData.elseKeyword?.buildToken(format: format), buildableData.unexpectedBetweenElseKeywordAndElseBody?.buildUnexpectedNodes(format: format), elseBody: buildableData.elseBody?.buildSyntax(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format) -> StmtSyntax {
    let result = buildIfStmt(format: format)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsIfStmt`.
  public func createIfStmt() -> IfStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `IfStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct ElseIfContinuation: SyntaxBuildable, ExpressibleAsElseIfContinuation {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeIfStatement: UnexpectedNodes?
    var ifStatement: IfStmt
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ElseIfContinuationSyntax)
  }
  private var data: Data
  /// Creates a `ElseIfContinuation` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeIfStatement: 
  ///   - ifStatement: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeIfStatement: ExpressibleAsUnexpectedNodes? = nil, ifStatement: ExpressibleAsIfStmt) {
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeIfStatement: unexpectedBeforeIfStatement?.createUnexpectedNodes(), ifStatement: ifStatement.createIfStmt()))
  }
  public init(_ constructedNode: ElseIfContinuationSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ElseIfContinuationSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ElseIfContinuationSyntax`.
  func buildElseIfContinuation(format: Format) -> ElseIfContinuationSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ElseIfContinuationSyntax(buildableData.unexpectedBeforeIfStatement?.buildUnexpectedNodes(format: format), ifStatement: buildableData.ifStatement.buildIfStmt(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildElseIfContinuation(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsElseIfContinuation`.
  public func createElseIfContinuation() -> ElseIfContinuation {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ElseIfContinuation` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct ElseBlock: SyntaxBuildable, ExpressibleAsElseBlock {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeElseKeyword: UnexpectedNodes?
    var elseKeyword: Token
    var unexpectedBetweenElseKeywordAndBody: UnexpectedNodes?
    var body: CodeBlock
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ElseBlockSyntax)
  }
  private var data: Data
  /// Creates a `ElseBlock` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeElseKeyword: 
  ///   - elseKeyword: 
  ///   - unexpectedBetweenElseKeywordAndBody: 
  ///   - body: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeElseKeyword: ExpressibleAsUnexpectedNodes? = nil, elseKeyword: Token = Token.`else`, unexpectedBetweenElseKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock) {
    assert(elseKeyword.text == #"else"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeElseKeyword: unexpectedBeforeElseKeyword?.createUnexpectedNodes(), elseKeyword: elseKeyword, unexpectedBetweenElseKeywordAndBody: unexpectedBetweenElseKeywordAndBody?.createUnexpectedNodes(), body: body.createCodeBlock()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeElseKeyword: ExpressibleAsUnexpectedNodes? = nil, elseKeyword: Token = Token.`else`, unexpectedBetweenElseKeywordAndBody: ExpressibleAsUnexpectedNodes? = nil, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeElseKeyword: unexpectedBeforeElseKeyword, elseKeyword: elseKeyword, unexpectedBetweenElseKeywordAndBody: unexpectedBetweenElseKeywordAndBody, body: bodyBuilder())
  }
  public init(_ constructedNode: ElseBlockSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ElseBlockSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ElseBlockSyntax`.
  func buildElseBlock(format: Format) -> ElseBlockSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ElseBlockSyntax(buildableData.unexpectedBeforeElseKeyword?.buildUnexpectedNodes(format: format), elseKeyword: buildableData.elseKeyword.buildToken(format: format), buildableData.unexpectedBetweenElseKeywordAndBody?.buildUnexpectedNodes(format: format), body: buildableData.body.buildCodeBlock(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildElseBlock(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsElseBlock`.
  public func createElseBlock() -> ElseBlock {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ElseBlock` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct SwitchCase: SyntaxBuildable, ExpressibleAsSwitchCase {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeUnknownAttr: UnexpectedNodes?
    var unknownAttr: Attribute?
    var unexpectedBetweenUnknownAttrAndLabel: UnexpectedNodes?
    var label: SyntaxBuildable
    var unexpectedBetweenLabelAndStatements: UnexpectedNodes?
    var statements: CodeBlockItemList
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(SwitchCaseSyntax)
  }
  private var data: Data
  /// Creates a `SwitchCase` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeUnknownAttr: 
  ///   - unknownAttr: 
  ///   - unexpectedBetweenUnknownAttrAndLabel: 
  ///   - label: 
  ///   - unexpectedBetweenLabelAndStatements: 
  ///   - statements: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeUnknownAttr: ExpressibleAsUnexpectedNodes? = nil, unknownAttr: ExpressibleAsAttribute? = nil, unexpectedBetweenUnknownAttrAndLabel: ExpressibleAsUnexpectedNodes? = nil, label: ExpressibleAsSyntaxBuildable, unexpectedBetweenLabelAndStatements: ExpressibleAsUnexpectedNodes? = nil, statements: ExpressibleAsCodeBlockItemList) {
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeUnknownAttr: unexpectedBeforeUnknownAttr?.createUnexpectedNodes(), unknownAttr: unknownAttr?.createAttribute(), unexpectedBetweenUnknownAttrAndLabel: unexpectedBetweenUnknownAttrAndLabel?.createUnexpectedNodes(), label: label.createSyntaxBuildable(), unexpectedBetweenLabelAndStatements: unexpectedBetweenLabelAndStatements?.createUnexpectedNodes(), statements: statements.createCodeBlockItemList()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeUnknownAttr: ExpressibleAsUnexpectedNodes? = nil, unknownAttr: ExpressibleAsAttribute? = nil, unexpectedBetweenUnknownAttrAndLabel: ExpressibleAsUnexpectedNodes? = nil, label: ExpressibleAsSyntaxBuildable, unexpectedBetweenLabelAndStatements: ExpressibleAsUnexpectedNodes? = nil, @CodeBlockItemListBuilder statementsBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeUnknownAttr: unexpectedBeforeUnknownAttr, unknownAttr: unknownAttr, unexpectedBetweenUnknownAttrAndLabel: unexpectedBetweenUnknownAttrAndLabel, label: label, unexpectedBetweenLabelAndStatements: unexpectedBetweenLabelAndStatements, statements: statementsBuilder())
  }
  public init(_ constructedNode: SwitchCaseSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `SwitchCaseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SwitchCaseSyntax`.
  func buildSwitchCase(format: Format) -> SwitchCaseSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = SwitchCaseSyntax(buildableData.unexpectedBeforeUnknownAttr?.buildUnexpectedNodes(format: format), unknownAttr: buildableData.unknownAttr?.buildAttribute(format: format), buildableData.unexpectedBetweenUnknownAttrAndLabel?.buildUnexpectedNodes(format: format), label: buildableData.label.buildSyntax(format: format), buildableData.unexpectedBetweenLabelAndStatements?.buildUnexpectedNodes(format: format), statements: buildableData.statements.buildCodeBlockItemList(format: format._indented))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildSwitchCase(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsSwitchCase`.
  public func createSwitchCase() -> SwitchCase {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `SwitchCase` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct SwitchDefaultLabel: SyntaxBuildable, ExpressibleAsSwitchDefaultLabel {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeDefaultKeyword: UnexpectedNodes?
    var defaultKeyword: Token
    var unexpectedBetweenDefaultKeywordAndColon: UnexpectedNodes?
    var colon: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(SwitchDefaultLabelSyntax)
  }
  private var data: Data
  /// Creates a `SwitchDefaultLabel` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeDefaultKeyword: 
  ///   - defaultKeyword: 
  ///   - unexpectedBetweenDefaultKeywordAndColon: 
  ///   - colon: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeDefaultKeyword: ExpressibleAsUnexpectedNodes? = nil, defaultKeyword: Token = Token.`default`, unexpectedBetweenDefaultKeywordAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`) {
    assert(defaultKeyword.text == #"default"#)
    assert(colon.text == #":"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeDefaultKeyword: unexpectedBeforeDefaultKeyword?.createUnexpectedNodes(), defaultKeyword: defaultKeyword, unexpectedBetweenDefaultKeywordAndColon: unexpectedBetweenDefaultKeywordAndColon?.createUnexpectedNodes(), colon: colon))
  }
  public init(_ constructedNode: SwitchDefaultLabelSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `SwitchDefaultLabelSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SwitchDefaultLabelSyntax`.
  func buildSwitchDefaultLabel(format: Format) -> SwitchDefaultLabelSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = SwitchDefaultLabelSyntax(buildableData.unexpectedBeforeDefaultKeyword?.buildUnexpectedNodes(format: format), defaultKeyword: buildableData.defaultKeyword.buildToken(format: format), buildableData.unexpectedBetweenDefaultKeywordAndColon?.buildUnexpectedNodes(format: format), colon: buildableData.colon.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildSwitchDefaultLabel(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsSwitchDefaultLabel`.
  public func createSwitchDefaultLabel() -> SwitchDefaultLabel {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `SwitchDefaultLabel` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct CaseItem: SyntaxBuildable, ExpressibleAsCaseItem, HasTrailingComma {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforePattern: UnexpectedNodes?
    var pattern: PatternBuildable
    var unexpectedBetweenPatternAndWhereClause: UnexpectedNodes?
    var whereClause: WhereClause?
    var unexpectedBetweenWhereClauseAndTrailingComma: UnexpectedNodes?
    var trailingComma: Token?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(CaseItemSyntax)
  }
  private var data: Data
  var hasTrailingComma: Bool {
    switch data {
    case .buildable(let buildableData):
      return buildableData.trailingComma != nil
    case .constructed(let node):
      return node.trailingComma != nil
    }
  }
  /// Creates a `CaseItem` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePattern: 
  ///   - pattern: 
  ///   - unexpectedBetweenPatternAndWhereClause: 
  ///   - whereClause: 
  ///   - unexpectedBetweenWhereClauseAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePattern: ExpressibleAsUnexpectedNodes? = nil, pattern: ExpressibleAsPatternBuildable, unexpectedBetweenPatternAndWhereClause: ExpressibleAsUnexpectedNodes? = nil, whereClause: ExpressibleAsWhereClause? = nil, unexpectedBetweenWhereClauseAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    assert(trailingComma == nil || trailingComma!.text == #","#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforePattern: unexpectedBeforePattern?.createUnexpectedNodes(), pattern: pattern.createPatternBuildable(), unexpectedBetweenPatternAndWhereClause: unexpectedBetweenPatternAndWhereClause?.createUnexpectedNodes(), whereClause: whereClause?.createWhereClause(), unexpectedBetweenWhereClauseAndTrailingComma: unexpectedBetweenWhereClauseAndTrailingComma?.createUnexpectedNodes(), trailingComma: trailingComma))
  }
  public init(_ constructedNode: CaseItemSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `CaseItemSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `CaseItemSyntax`.
  func buildCaseItem(format: Format) -> CaseItemSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = CaseItemSyntax(buildableData.unexpectedBeforePattern?.buildUnexpectedNodes(format: format), pattern: buildableData.pattern.buildPattern(format: format), buildableData.unexpectedBetweenPatternAndWhereClause?.buildUnexpectedNodes(format: format), whereClause: buildableData.whereClause?.buildWhereClause(format: format), buildableData.unexpectedBetweenWhereClauseAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: buildableData.trailingComma?.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildCaseItem(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsCaseItem`.
  public func createCaseItem() -> CaseItem {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `CaseItem` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingComma = withComma ? .comma : nil
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withComma = node.withTrailingComma(withComma ? .commaToken() : nil)
      var result = self
      result.data = .constructed(withComma)
      return result
    }
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct CatchItem: SyntaxBuildable, ExpressibleAsCatchItem, HasTrailingComma {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforePattern: UnexpectedNodes?
    var pattern: PatternBuildable?
    var unexpectedBetweenPatternAndWhereClause: UnexpectedNodes?
    var whereClause: WhereClause?
    var unexpectedBetweenWhereClauseAndTrailingComma: UnexpectedNodes?
    var trailingComma: Token?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(CatchItemSyntax)
  }
  private var data: Data
  var hasTrailingComma: Bool {
    switch data {
    case .buildable(let buildableData):
      return buildableData.trailingComma != nil
    case .constructed(let node):
      return node.trailingComma != nil
    }
  }
  /// Creates a `CatchItem` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePattern: 
  ///   - pattern: 
  ///   - unexpectedBetweenPatternAndWhereClause: 
  ///   - whereClause: 
  ///   - unexpectedBetweenWhereClauseAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePattern: ExpressibleAsUnexpectedNodes? = nil, pattern: ExpressibleAsPatternBuildable? = nil, unexpectedBetweenPatternAndWhereClause: ExpressibleAsUnexpectedNodes? = nil, whereClause: ExpressibleAsWhereClause? = nil, unexpectedBetweenWhereClauseAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    assert(trailingComma == nil || trailingComma!.text == #","#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforePattern: unexpectedBeforePattern?.createUnexpectedNodes(), pattern: pattern?.createPatternBuildable(), unexpectedBetweenPatternAndWhereClause: unexpectedBetweenPatternAndWhereClause?.createUnexpectedNodes(), whereClause: whereClause?.createWhereClause(), unexpectedBetweenWhereClauseAndTrailingComma: unexpectedBetweenWhereClauseAndTrailingComma?.createUnexpectedNodes(), trailingComma: trailingComma))
  }
  public init(_ constructedNode: CatchItemSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `CatchItemSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `CatchItemSyntax`.
  func buildCatchItem(format: Format) -> CatchItemSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = CatchItemSyntax(buildableData.unexpectedBeforePattern?.buildUnexpectedNodes(format: format), pattern: buildableData.pattern?.buildPattern(format: format), buildableData.unexpectedBetweenPatternAndWhereClause?.buildUnexpectedNodes(format: format), whereClause: buildableData.whereClause?.buildWhereClause(format: format), buildableData.unexpectedBetweenWhereClauseAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: buildableData.trailingComma?.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildCatchItem(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsCatchItem`.
  public func createCatchItem() -> CatchItem {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `CatchItem` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingComma = withComma ? .comma : nil
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withComma = node.withTrailingComma(withComma ? .commaToken() : nil)
      var result = self
      result.data = .constructed(withComma)
      return result
    }
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct SwitchCaseLabel: SyntaxBuildable, ExpressibleAsSwitchCaseLabel {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeCaseKeyword: UnexpectedNodes?
    var caseKeyword: Token
    var unexpectedBetweenCaseKeywordAndCaseItems: UnexpectedNodes?
    var caseItems: CaseItemList
    var unexpectedBetweenCaseItemsAndColon: UnexpectedNodes?
    var colon: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(SwitchCaseLabelSyntax)
  }
  private var data: Data
  /// Creates a `SwitchCaseLabel` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeCaseKeyword: 
  ///   - caseKeyword: 
  ///   - unexpectedBetweenCaseKeywordAndCaseItems: 
  ///   - caseItems: 
  ///   - unexpectedBetweenCaseItemsAndColon: 
  ///   - colon: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeCaseKeyword: ExpressibleAsUnexpectedNodes? = nil, caseKeyword: Token = Token.`case`, unexpectedBetweenCaseKeywordAndCaseItems: ExpressibleAsUnexpectedNodes? = nil, caseItems: ExpressibleAsCaseItemList, unexpectedBetweenCaseItemsAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`) {
    assert(caseKeyword.text == #"case"#)
    assert(colon.text == #":"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeCaseKeyword: unexpectedBeforeCaseKeyword?.createUnexpectedNodes(), caseKeyword: caseKeyword, unexpectedBetweenCaseKeywordAndCaseItems: unexpectedBetweenCaseKeywordAndCaseItems?.createUnexpectedNodes(), caseItems: caseItems.createCaseItemList(), unexpectedBetweenCaseItemsAndColon: unexpectedBetweenCaseItemsAndColon?.createUnexpectedNodes(), colon: colon))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeCaseKeyword: ExpressibleAsUnexpectedNodes? = nil, caseKeyword: Token = Token.`case`, unexpectedBetweenCaseKeywordAndCaseItems: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenCaseItemsAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, @CaseItemListBuilder caseItemsBuilder: () -> ExpressibleAsCaseItemList =  {
    CaseItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeCaseKeyword: unexpectedBeforeCaseKeyword, caseKeyword: caseKeyword, unexpectedBetweenCaseKeywordAndCaseItems: unexpectedBetweenCaseKeywordAndCaseItems, caseItems: caseItemsBuilder(), unexpectedBetweenCaseItemsAndColon: unexpectedBetweenCaseItemsAndColon, colon: colon)
  }
  public init(_ constructedNode: SwitchCaseLabelSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `SwitchCaseLabelSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SwitchCaseLabelSyntax`.
  func buildSwitchCaseLabel(format: Format) -> SwitchCaseLabelSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = SwitchCaseLabelSyntax(buildableData.unexpectedBeforeCaseKeyword?.buildUnexpectedNodes(format: format), caseKeyword: buildableData.caseKeyword.buildToken(format: format), buildableData.unexpectedBetweenCaseKeywordAndCaseItems?.buildUnexpectedNodes(format: format), caseItems: buildableData.caseItems.buildCaseItemList(format: format), buildableData.unexpectedBetweenCaseItemsAndColon?.buildUnexpectedNodes(format: format), colon: buildableData.colon.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildSwitchCaseLabel(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsSwitchCaseLabel`.
  public func createSwitchCaseLabel() -> SwitchCaseLabel {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `SwitchCaseLabel` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct CatchClause: SyntaxBuildable, ExpressibleAsCatchClause {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeCatchKeyword: UnexpectedNodes?
    var catchKeyword: Token
    var unexpectedBetweenCatchKeywordAndCatchItems: UnexpectedNodes?
    var catchItems: CatchItemList?
    var unexpectedBetweenCatchItemsAndBody: UnexpectedNodes?
    var body: CodeBlock
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(CatchClauseSyntax)
  }
  private var data: Data
  /// Creates a `CatchClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeCatchKeyword: 
  ///   - catchKeyword: 
  ///   - unexpectedBetweenCatchKeywordAndCatchItems: 
  ///   - catchItems: 
  ///   - unexpectedBetweenCatchItemsAndBody: 
  ///   - body: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeCatchKeyword: ExpressibleAsUnexpectedNodes? = nil, catchKeyword: Token = Token.`catch`, unexpectedBetweenCatchKeywordAndCatchItems: ExpressibleAsUnexpectedNodes? = nil, catchItems: ExpressibleAsCatchItemList? = nil, unexpectedBetweenCatchItemsAndBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsCodeBlock) {
    assert(catchKeyword.text == #"catch"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeCatchKeyword: unexpectedBeforeCatchKeyword?.createUnexpectedNodes(), catchKeyword: catchKeyword, unexpectedBetweenCatchKeywordAndCatchItems: unexpectedBetweenCatchKeywordAndCatchItems?.createUnexpectedNodes(), catchItems: catchItems?.createCatchItemList(), unexpectedBetweenCatchItemsAndBody: unexpectedBetweenCatchItemsAndBody?.createUnexpectedNodes(), body: body.createCodeBlock()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeCatchKeyword: ExpressibleAsUnexpectedNodes? = nil, catchKeyword: Token = Token.`catch`, unexpectedBetweenCatchKeywordAndCatchItems: ExpressibleAsUnexpectedNodes? = nil, catchItems: ExpressibleAsCatchItemList? = nil, unexpectedBetweenCatchItemsAndBody: ExpressibleAsUnexpectedNodes? = nil, @CodeBlockItemListBuilder bodyBuilder: () -> ExpressibleAsCodeBlockItemList =  {
    CodeBlockItemList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeCatchKeyword: unexpectedBeforeCatchKeyword, catchKeyword: catchKeyword, unexpectedBetweenCatchKeywordAndCatchItems: unexpectedBetweenCatchKeywordAndCatchItems, catchItems: catchItems, unexpectedBetweenCatchItemsAndBody: unexpectedBetweenCatchItemsAndBody, body: bodyBuilder())
  }
  public init(_ constructedNode: CatchClauseSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `CatchClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `CatchClauseSyntax`.
  func buildCatchClause(format: Format) -> CatchClauseSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = CatchClauseSyntax(buildableData.unexpectedBeforeCatchKeyword?.buildUnexpectedNodes(format: format), catchKeyword: buildableData.catchKeyword.buildToken(format: format), buildableData.unexpectedBetweenCatchKeywordAndCatchItems?.buildUnexpectedNodes(format: format), catchItems: buildableData.catchItems?.buildCatchItemList(format: format), buildableData.unexpectedBetweenCatchItemsAndBody?.buildUnexpectedNodes(format: format), body: buildableData.body.buildCodeBlock(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildCatchClause(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsCatchClause`.
  public func createCatchClause() -> CatchClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `CatchClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct PoundAssertStmt: StmtBuildable, ExpressibleAsPoundAssertStmt {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforePoundAssert: UnexpectedNodes?
    var poundAssert: Token
    var unexpectedBetweenPoundAssertAndLeftParen: UnexpectedNodes?
    var leftParen: Token
    var unexpectedBetweenLeftParenAndCondition: UnexpectedNodes?
    var condition: ExprBuildable
    var unexpectedBetweenConditionAndComma: UnexpectedNodes?
    var comma: Token?
    var unexpectedBetweenCommaAndMessage: UnexpectedNodes?
    var message: Token?
    var unexpectedBetweenMessageAndRightParen: UnexpectedNodes?
    var rightParen: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(PoundAssertStmtSyntax)
  }
  private var data: Data
  /// Creates a `PoundAssertStmt` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePoundAssert: 
  ///   - poundAssert: 
  ///   - unexpectedBetweenPoundAssertAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndCondition: 
  ///   - condition: The assertion condition.
  ///   - unexpectedBetweenConditionAndComma: 
  ///   - comma: The comma after the assertion condition.
  ///   - unexpectedBetweenCommaAndMessage: 
  ///   - message: The assertion message.
  ///   - unexpectedBetweenMessageAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePoundAssert: ExpressibleAsUnexpectedNodes? = nil, poundAssert: Token = Token.`poundAssert`, unexpectedBetweenPoundAssertAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndCondition: ExpressibleAsUnexpectedNodes? = nil, condition: ExpressibleAsExprBuildable, unexpectedBetweenConditionAndComma: ExpressibleAsUnexpectedNodes? = nil, comma: Token? = nil, unexpectedBetweenCommaAndMessage: ExpressibleAsUnexpectedNodes? = nil, message: Token? = nil, unexpectedBetweenMessageAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    assert(poundAssert.text == #"#assert"#)
    assert(leftParen.text == #"("#)
    assert(comma == nil || comma!.text == #","#)
    assert(rightParen.text == #")"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforePoundAssert: unexpectedBeforePoundAssert?.createUnexpectedNodes(), poundAssert: poundAssert, unexpectedBetweenPoundAssertAndLeftParen: unexpectedBetweenPoundAssertAndLeftParen?.createUnexpectedNodes(), leftParen: leftParen, unexpectedBetweenLeftParenAndCondition: unexpectedBetweenLeftParenAndCondition?.createUnexpectedNodes(), condition: condition.createExprBuildable(), unexpectedBetweenConditionAndComma: unexpectedBetweenConditionAndComma?.createUnexpectedNodes(), comma: comma, unexpectedBetweenCommaAndMessage: unexpectedBetweenCommaAndMessage?.createUnexpectedNodes(), message: message, unexpectedBetweenMessageAndRightParen: unexpectedBetweenMessageAndRightParen?.createUnexpectedNodes(), rightParen: rightParen))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforePoundAssert: ExpressibleAsUnexpectedNodes? = nil, poundAssert: Token = Token.`poundAssert`, unexpectedBetweenPoundAssertAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndCondition: ExpressibleAsUnexpectedNodes? = nil, condition: ExpressibleAsExprBuildable, unexpectedBetweenConditionAndComma: ExpressibleAsUnexpectedNodes? = nil, comma: Token? = nil, unexpectedBetweenCommaAndMessage: ExpressibleAsUnexpectedNodes? = nil, message: String?, unexpectedBetweenMessageAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforePoundAssert: unexpectedBeforePoundAssert, poundAssert: poundAssert, unexpectedBetweenPoundAssertAndLeftParen: unexpectedBetweenPoundAssertAndLeftParen, leftParen: leftParen, unexpectedBetweenLeftParenAndCondition: unexpectedBetweenLeftParenAndCondition, condition: condition, unexpectedBetweenConditionAndComma: unexpectedBetweenConditionAndComma, comma: comma, unexpectedBetweenCommaAndMessage: unexpectedBetweenCommaAndMessage, message: message.map { Token.`stringLiteral`($0) }, unexpectedBetweenMessageAndRightParen: unexpectedBetweenMessageAndRightParen, rightParen: rightParen)
  }
  public init(_ constructedNode: PoundAssertStmtSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `PoundAssertStmtSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PoundAssertStmtSyntax`.
  func buildPoundAssertStmt(format: Format) -> PoundAssertStmtSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = PoundAssertStmtSyntax(buildableData.unexpectedBeforePoundAssert?.buildUnexpectedNodes(format: format), poundAssert: buildableData.poundAssert.buildToken(format: format), buildableData.unexpectedBetweenPoundAssertAndLeftParen?.buildUnexpectedNodes(format: format), leftParen: buildableData.leftParen.buildToken(format: format), buildableData.unexpectedBetweenLeftParenAndCondition?.buildUnexpectedNodes(format: format), condition: buildableData.condition.buildExpr(format: format), buildableData.unexpectedBetweenConditionAndComma?.buildUnexpectedNodes(format: format), comma: buildableData.comma?.buildToken(format: format), buildableData.unexpectedBetweenCommaAndMessage?.buildUnexpectedNodes(format: format), message: buildableData.message?.buildToken(format: format), buildableData.unexpectedBetweenMessageAndRightParen?.buildUnexpectedNodes(format: format), rightParen: buildableData.rightParen.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `StmtBuildable`.
  public func buildStmt(format: Format) -> StmtSyntax {
    let result = buildPoundAssertStmt(format: format)
    return StmtSyntax(result)
  }
  /// Conformance to `ExpressibleAsPoundAssertStmt`.
  public func createPoundAssertStmt() -> PoundAssertStmt {
    return self
  }
  /// Conformance to `ExpressibleAsStmtBuildable`.
  /// `PoundAssertStmt` may conform to `ExpressibleAsStmtBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createStmtBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createStmtBuildable() -> StmtBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `StmtBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct GenericWhereClause: SyntaxBuildable, ExpressibleAsGenericWhereClause {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeWhereKeyword: UnexpectedNodes?
    var whereKeyword: Token
    var unexpectedBetweenWhereKeywordAndRequirementList: UnexpectedNodes?
    var requirementList: GenericRequirementList
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(GenericWhereClauseSyntax)
  }
  private var data: Data
  /// Creates a `GenericWhereClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeWhereKeyword: 
  ///   - whereKeyword: 
  ///   - unexpectedBetweenWhereKeywordAndRequirementList: 
  ///   - requirementList: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeWhereKeyword: ExpressibleAsUnexpectedNodes? = nil, whereKeyword: Token = Token.`where`, unexpectedBetweenWhereKeywordAndRequirementList: ExpressibleAsUnexpectedNodes? = nil, requirementList: ExpressibleAsGenericRequirementList) {
    assert(whereKeyword.text == #"where"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeWhereKeyword: unexpectedBeforeWhereKeyword?.createUnexpectedNodes(), whereKeyword: whereKeyword, unexpectedBetweenWhereKeywordAndRequirementList: unexpectedBetweenWhereKeywordAndRequirementList?.createUnexpectedNodes(), requirementList: requirementList.createGenericRequirementList()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeWhereKeyword: ExpressibleAsUnexpectedNodes? = nil, whereKeyword: Token = Token.`where`, unexpectedBetweenWhereKeywordAndRequirementList: ExpressibleAsUnexpectedNodes? = nil, @GenericRequirementListBuilder requirementListBuilder: () -> ExpressibleAsGenericRequirementList =  {
    GenericRequirementList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeWhereKeyword: unexpectedBeforeWhereKeyword, whereKeyword: whereKeyword, unexpectedBetweenWhereKeywordAndRequirementList: unexpectedBetweenWhereKeywordAndRequirementList, requirementList: requirementListBuilder())
  }
  public init(_ constructedNode: GenericWhereClauseSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `GenericWhereClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `GenericWhereClauseSyntax`.
  func buildGenericWhereClause(format: Format) -> GenericWhereClauseSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = GenericWhereClauseSyntax(buildableData.unexpectedBeforeWhereKeyword?.buildUnexpectedNodes(format: format), whereKeyword: buildableData.whereKeyword.buildToken(format: format), buildableData.unexpectedBetweenWhereKeywordAndRequirementList?.buildUnexpectedNodes(format: format), requirementList: buildableData.requirementList.buildGenericRequirementList(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildGenericWhereClause(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsGenericWhereClause`.
  public func createGenericWhereClause() -> GenericWhereClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `GenericWhereClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct GenericRequirement: SyntaxBuildable, ExpressibleAsGenericRequirement, HasTrailingComma {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeBody: UnexpectedNodes?
    var body: SyntaxBuildable
    var unexpectedBetweenBodyAndTrailingComma: UnexpectedNodes?
    var trailingComma: Token?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(GenericRequirementSyntax)
  }
  private var data: Data
  var hasTrailingComma: Bool {
    switch data {
    case .buildable(let buildableData):
      return buildableData.trailingComma != nil
    case .constructed(let node):
      return node.trailingComma != nil
    }
  }
  /// Creates a `GenericRequirement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeBody: 
  ///   - body: 
  ///   - unexpectedBetweenBodyAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeBody: ExpressibleAsUnexpectedNodes? = nil, body: ExpressibleAsSyntaxBuildable, unexpectedBetweenBodyAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    assert(trailingComma == nil || trailingComma!.text == #","#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeBody: unexpectedBeforeBody?.createUnexpectedNodes(), body: body.createSyntaxBuildable(), unexpectedBetweenBodyAndTrailingComma: unexpectedBetweenBodyAndTrailingComma?.createUnexpectedNodes(), trailingComma: trailingComma))
  }
  public init(_ constructedNode: GenericRequirementSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `GenericRequirementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `GenericRequirementSyntax`.
  func buildGenericRequirement(format: Format) -> GenericRequirementSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = GenericRequirementSyntax(buildableData.unexpectedBeforeBody?.buildUnexpectedNodes(format: format), body: buildableData.body.buildSyntax(format: format), buildableData.unexpectedBetweenBodyAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: buildableData.trailingComma?.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildGenericRequirement(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsGenericRequirement`.
  public func createGenericRequirement() -> GenericRequirement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `GenericRequirement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingComma = withComma ? .comma : nil
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withComma = node.withTrailingComma(withComma ? .commaToken() : nil)
      var result = self
      result.data = .constructed(withComma)
      return result
    }
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct SameTypeRequirement: SyntaxBuildable, ExpressibleAsSameTypeRequirement {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeLeftTypeIdentifier: UnexpectedNodes?
    var leftTypeIdentifier: TypeBuildable
    var unexpectedBetweenLeftTypeIdentifierAndEqualityToken: UnexpectedNodes?
    var equalityToken: Token
    var unexpectedBetweenEqualityTokenAndRightTypeIdentifier: UnexpectedNodes?
    var rightTypeIdentifier: TypeBuildable
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(SameTypeRequirementSyntax)
  }
  private var data: Data
  /// Creates a `SameTypeRequirement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftTypeIdentifier: 
  ///   - leftTypeIdentifier: 
  ///   - unexpectedBetweenLeftTypeIdentifierAndEqualityToken: 
  ///   - equalityToken: 
  ///   - unexpectedBetweenEqualityTokenAndRightTypeIdentifier: 
  ///   - rightTypeIdentifier: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftTypeIdentifier: ExpressibleAsUnexpectedNodes? = nil, leftTypeIdentifier: ExpressibleAsTypeBuildable, unexpectedBetweenLeftTypeIdentifierAndEqualityToken: ExpressibleAsUnexpectedNodes? = nil, equalityToken: Token, unexpectedBetweenEqualityTokenAndRightTypeIdentifier: ExpressibleAsUnexpectedNodes? = nil, rightTypeIdentifier: ExpressibleAsTypeBuildable) {
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeLeftTypeIdentifier: unexpectedBeforeLeftTypeIdentifier?.createUnexpectedNodes(), leftTypeIdentifier: leftTypeIdentifier.createTypeBuildable(), unexpectedBetweenLeftTypeIdentifierAndEqualityToken: unexpectedBetweenLeftTypeIdentifierAndEqualityToken?.createUnexpectedNodes(), equalityToken: equalityToken, unexpectedBetweenEqualityTokenAndRightTypeIdentifier: unexpectedBetweenEqualityTokenAndRightTypeIdentifier?.createUnexpectedNodes(), rightTypeIdentifier: rightTypeIdentifier.createTypeBuildable()))
  }
  public init(_ constructedNode: SameTypeRequirementSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `SameTypeRequirementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SameTypeRequirementSyntax`.
  func buildSameTypeRequirement(format: Format) -> SameTypeRequirementSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = SameTypeRequirementSyntax(buildableData.unexpectedBeforeLeftTypeIdentifier?.buildUnexpectedNodes(format: format), leftTypeIdentifier: buildableData.leftTypeIdentifier.buildType(format: format), buildableData.unexpectedBetweenLeftTypeIdentifierAndEqualityToken?.buildUnexpectedNodes(format: format), equalityToken: buildableData.equalityToken.buildToken(format: format), buildableData.unexpectedBetweenEqualityTokenAndRightTypeIdentifier?.buildUnexpectedNodes(format: format), rightTypeIdentifier: buildableData.rightTypeIdentifier.buildType(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildSameTypeRequirement(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsSameTypeRequirement`.
  public func createSameTypeRequirement() -> SameTypeRequirement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `SameTypeRequirement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct LayoutRequirement: SyntaxBuildable, ExpressibleAsLayoutRequirement {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeTypeIdentifier: UnexpectedNodes?
    var typeIdentifier: TypeBuildable
    var unexpectedBetweenTypeIdentifierAndColon: UnexpectedNodes?
    var colon: Token
    var unexpectedBetweenColonAndLayoutConstraint: UnexpectedNodes?
    var layoutConstraint: Token
    var unexpectedBetweenLayoutConstraintAndLeftParen: UnexpectedNodes?
    var leftParen: Token?
    var unexpectedBetweenLeftParenAndSize: UnexpectedNodes?
    var size: Token?
    var unexpectedBetweenSizeAndComma: UnexpectedNodes?
    var comma: Token?
    var unexpectedBetweenCommaAndAlignment: UnexpectedNodes?
    var alignment: Token?
    var unexpectedBetweenAlignmentAndRightParen: UnexpectedNodes?
    var rightParen: Token?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(LayoutRequirementSyntax)
  }
  private var data: Data
  /// Creates a `LayoutRequirement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeTypeIdentifier: 
  ///   - typeIdentifier: 
  ///   - unexpectedBetweenTypeIdentifierAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndLayoutConstraint: 
  ///   - layoutConstraint: 
  ///   - unexpectedBetweenLayoutConstraintAndLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndSize: 
  ///   - size: 
  ///   - unexpectedBetweenSizeAndComma: 
  ///   - comma: 
  ///   - unexpectedBetweenCommaAndAlignment: 
  ///   - alignment: 
  ///   - unexpectedBetweenAlignmentAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeTypeIdentifier: ExpressibleAsUnexpectedNodes? = nil, typeIdentifier: ExpressibleAsTypeBuildable, unexpectedBetweenTypeIdentifierAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndLayoutConstraint: ExpressibleAsUnexpectedNodes? = nil, layoutConstraint: Token, unexpectedBetweenLayoutConstraintAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token? = nil, unexpectedBetweenLeftParenAndSize: ExpressibleAsUnexpectedNodes? = nil, size: Token? = nil, unexpectedBetweenSizeAndComma: ExpressibleAsUnexpectedNodes? = nil, comma: Token? = nil, unexpectedBetweenCommaAndAlignment: ExpressibleAsUnexpectedNodes? = nil, alignment: Token? = nil, unexpectedBetweenAlignmentAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token? = nil) {
    assert(colon.text == #":"#)
    assert(leftParen == nil || leftParen!.text == #"("#)
    assert(comma == nil || comma!.text == #","#)
    assert(rightParen == nil || rightParen!.text == #")"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeTypeIdentifier: unexpectedBeforeTypeIdentifier?.createUnexpectedNodes(), typeIdentifier: typeIdentifier.createTypeBuildable(), unexpectedBetweenTypeIdentifierAndColon: unexpectedBetweenTypeIdentifierAndColon?.createUnexpectedNodes(), colon: colon, unexpectedBetweenColonAndLayoutConstraint: unexpectedBetweenColonAndLayoutConstraint?.createUnexpectedNodes(), layoutConstraint: layoutConstraint, unexpectedBetweenLayoutConstraintAndLeftParen: unexpectedBetweenLayoutConstraintAndLeftParen?.createUnexpectedNodes(), leftParen: leftParen, unexpectedBetweenLeftParenAndSize: unexpectedBetweenLeftParenAndSize?.createUnexpectedNodes(), size: size, unexpectedBetweenSizeAndComma: unexpectedBetweenSizeAndComma?.createUnexpectedNodes(), comma: comma, unexpectedBetweenCommaAndAlignment: unexpectedBetweenCommaAndAlignment?.createUnexpectedNodes(), alignment: alignment, unexpectedBetweenAlignmentAndRightParen: unexpectedBetweenAlignmentAndRightParen?.createUnexpectedNodes(), rightParen: rightParen))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeTypeIdentifier: ExpressibleAsUnexpectedNodes? = nil, typeIdentifier: ExpressibleAsTypeBuildable, unexpectedBetweenTypeIdentifierAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndLayoutConstraint: ExpressibleAsUnexpectedNodes? = nil, layoutConstraint: String, unexpectedBetweenLayoutConstraintAndLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token? = nil, unexpectedBetweenLeftParenAndSize: ExpressibleAsUnexpectedNodes? = nil, size: String?, unexpectedBetweenSizeAndComma: ExpressibleAsUnexpectedNodes? = nil, comma: Token? = nil, unexpectedBetweenCommaAndAlignment: ExpressibleAsUnexpectedNodes? = nil, alignment: String?, unexpectedBetweenAlignmentAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeTypeIdentifier: unexpectedBeforeTypeIdentifier, typeIdentifier: typeIdentifier, unexpectedBetweenTypeIdentifierAndColon: unexpectedBetweenTypeIdentifierAndColon, colon: colon, unexpectedBetweenColonAndLayoutConstraint: unexpectedBetweenColonAndLayoutConstraint, layoutConstraint: Token.`identifier`(layoutConstraint), unexpectedBetweenLayoutConstraintAndLeftParen: unexpectedBetweenLayoutConstraintAndLeftParen, leftParen: leftParen, unexpectedBetweenLeftParenAndSize: unexpectedBetweenLeftParenAndSize, size: size.map { Token.`integerLiteral`($0) }, unexpectedBetweenSizeAndComma: unexpectedBetweenSizeAndComma, comma: comma, unexpectedBetweenCommaAndAlignment: unexpectedBetweenCommaAndAlignment, alignment: alignment.map { Token.`integerLiteral`($0) }, unexpectedBetweenAlignmentAndRightParen: unexpectedBetweenAlignmentAndRightParen, rightParen: rightParen)
  }
  public init(_ constructedNode: LayoutRequirementSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `LayoutRequirementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `LayoutRequirementSyntax`.
  func buildLayoutRequirement(format: Format) -> LayoutRequirementSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = LayoutRequirementSyntax(buildableData.unexpectedBeforeTypeIdentifier?.buildUnexpectedNodes(format: format), typeIdentifier: buildableData.typeIdentifier.buildType(format: format), buildableData.unexpectedBetweenTypeIdentifierAndColon?.buildUnexpectedNodes(format: format), colon: buildableData.colon.buildToken(format: format), buildableData.unexpectedBetweenColonAndLayoutConstraint?.buildUnexpectedNodes(format: format), layoutConstraint: buildableData.layoutConstraint.buildToken(format: format), buildableData.unexpectedBetweenLayoutConstraintAndLeftParen?.buildUnexpectedNodes(format: format), leftParen: buildableData.leftParen?.buildToken(format: format), buildableData.unexpectedBetweenLeftParenAndSize?.buildUnexpectedNodes(format: format), size: buildableData.size?.buildToken(format: format), buildableData.unexpectedBetweenSizeAndComma?.buildUnexpectedNodes(format: format), comma: buildableData.comma?.buildToken(format: format), buildableData.unexpectedBetweenCommaAndAlignment?.buildUnexpectedNodes(format: format), alignment: buildableData.alignment?.buildToken(format: format), buildableData.unexpectedBetweenAlignmentAndRightParen?.buildUnexpectedNodes(format: format), rightParen: buildableData.rightParen?.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildLayoutRequirement(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsLayoutRequirement`.
  public func createLayoutRequirement() -> LayoutRequirement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `LayoutRequirement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct GenericParameter: SyntaxBuildable, ExpressibleAsGenericParameter, HasTrailingComma {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeAttributes: UnexpectedNodes?
    var attributes: AttributeList?
    var unexpectedBetweenAttributesAndName: UnexpectedNodes?
    var name: Token
    var unexpectedBetweenNameAndColon: UnexpectedNodes?
    var colon: Token?
    var unexpectedBetweenColonAndInheritedType: UnexpectedNodes?
    var inheritedType: TypeBuildable?
    var unexpectedBetweenInheritedTypeAndTrailingComma: UnexpectedNodes?
    var trailingComma: Token?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(GenericParameterSyntax)
  }
  private var data: Data
  var hasTrailingComma: Bool {
    switch data {
    case .buildable(let buildableData):
      return buildableData.trailingComma != nil
    case .constructed(let node):
      return node.trailingComma != nil
    }
  }
  /// Creates a `GenericParameter` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndInheritedType: 
  ///   - inheritedType: 
  ///   - unexpectedBetweenInheritedTypeAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token? = nil, unexpectedBetweenColonAndInheritedType: ExpressibleAsUnexpectedNodes? = nil, inheritedType: ExpressibleAsTypeBuildable? = nil, unexpectedBetweenInheritedTypeAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    assert(colon == nil || colon!.text == #":"#)
    assert(trailingComma == nil || trailingComma!.text == #","#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes?.createUnexpectedNodes(), attributes: attributes?.createAttributeList(), unexpectedBetweenAttributesAndName: unexpectedBetweenAttributesAndName?.createUnexpectedNodes(), name: name, unexpectedBetweenNameAndColon: unexpectedBetweenNameAndColon?.createUnexpectedNodes(), colon: colon, unexpectedBetweenColonAndInheritedType: unexpectedBetweenColonAndInheritedType?.createUnexpectedNodes(), inheritedType: inheritedType?.createTypeBuildable(), unexpectedBetweenInheritedTypeAndTrailingComma: unexpectedBetweenInheritedTypeAndTrailingComma?.createUnexpectedNodes(), trailingComma: trailingComma))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndName: ExpressibleAsUnexpectedNodes? = nil, name: String, unexpectedBetweenNameAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token? = nil, unexpectedBetweenColonAndInheritedType: ExpressibleAsUnexpectedNodes? = nil, inheritedType: ExpressibleAsTypeBuildable? = nil, unexpectedBetweenInheritedTypeAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeAttributes: unexpectedBeforeAttributes, attributes: attributes, unexpectedBetweenAttributesAndName: unexpectedBetweenAttributesAndName, name: Token.`identifier`(name), unexpectedBetweenNameAndColon: unexpectedBetweenNameAndColon, colon: colon, unexpectedBetweenColonAndInheritedType: unexpectedBetweenColonAndInheritedType, inheritedType: inheritedType, unexpectedBetweenInheritedTypeAndTrailingComma: unexpectedBetweenInheritedTypeAndTrailingComma, trailingComma: trailingComma)
  }
  public init(_ constructedNode: GenericParameterSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `GenericParameterSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `GenericParameterSyntax`.
  func buildGenericParameter(format: Format) -> GenericParameterSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = GenericParameterSyntax(buildableData.unexpectedBeforeAttributes?.buildUnexpectedNodes(format: format), attributes: buildableData.attributes?.buildAttributeList(format: format), buildableData.unexpectedBetweenAttributesAndName?.buildUnexpectedNodes(format: format), name: buildableData.name.buildToken(format: format), buildableData.unexpectedBetweenNameAndColon?.buildUnexpectedNodes(format: format), colon: buildableData.colon?.buildToken(format: format), buildableData.unexpectedBetweenColonAndInheritedType?.buildUnexpectedNodes(format: format), inheritedType: buildableData.inheritedType?.buildType(format: format), buildableData.unexpectedBetweenInheritedTypeAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: buildableData.trailingComma?.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildGenericParameter(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsGenericParameter`.
  public func createGenericParameter() -> GenericParameter {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `GenericParameter` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingComma = withComma ? .comma : nil
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withComma = node.withTrailingComma(withComma ? .commaToken() : nil)
      var result = self
      result.data = .constructed(withComma)
      return result
    }
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct PrimaryAssociatedType: SyntaxBuildable, ExpressibleAsPrimaryAssociatedType, HasTrailingComma {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeName: UnexpectedNodes?
    var name: Token
    var unexpectedBetweenNameAndTrailingComma: UnexpectedNodes?
    var trailingComma: Token?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(PrimaryAssociatedTypeSyntax)
  }
  private var data: Data
  var hasTrailingComma: Bool {
    switch data {
    case .buildable(let buildableData):
      return buildableData.trailingComma != nil
    case .constructed(let node):
      return node.trailingComma != nil
    }
  }
  /// Creates a `PrimaryAssociatedType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    assert(trailingComma == nil || trailingComma!.text == #","#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeName: unexpectedBeforeName?.createUnexpectedNodes(), name: name, unexpectedBetweenNameAndTrailingComma: unexpectedBetweenNameAndTrailingComma?.createUnexpectedNodes(), trailingComma: trailingComma))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: String, unexpectedBetweenNameAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeName: unexpectedBeforeName, name: Token.`identifier`(name), unexpectedBetweenNameAndTrailingComma: unexpectedBetweenNameAndTrailingComma, trailingComma: trailingComma)
  }
  public init(_ constructedNode: PrimaryAssociatedTypeSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `PrimaryAssociatedTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PrimaryAssociatedTypeSyntax`.
  func buildPrimaryAssociatedType(format: Format) -> PrimaryAssociatedTypeSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = PrimaryAssociatedTypeSyntax(buildableData.unexpectedBeforeName?.buildUnexpectedNodes(format: format), name: buildableData.name.buildToken(format: format), buildableData.unexpectedBetweenNameAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: buildableData.trailingComma?.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildPrimaryAssociatedType(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsPrimaryAssociatedType`.
  public func createPrimaryAssociatedType() -> PrimaryAssociatedType {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PrimaryAssociatedType` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingComma = withComma ? .comma : nil
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withComma = node.withTrailingComma(withComma ? .commaToken() : nil)
      var result = self
      result.data = .constructed(withComma)
      return result
    }
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct GenericParameterClause: SyntaxBuildable, ExpressibleAsGenericParameterClause {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeLeftAngleBracket: UnexpectedNodes?
    var leftAngleBracket: Token
    var unexpectedBetweenLeftAngleBracketAndGenericParameterList: UnexpectedNodes?
    var genericParameterList: GenericParameterList
    var unexpectedBetweenGenericParameterListAndGenericWhereClause: UnexpectedNodes?
    var genericWhereClause: GenericWhereClause?
    var unexpectedBetweenGenericWhereClauseAndRightAngleBracket: UnexpectedNodes?
    var rightAngleBracket: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(GenericParameterClauseSyntax)
  }
  private var data: Data
  /// Creates a `GenericParameterClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftAngleBracket: 
  ///   - leftAngleBracket: 
  ///   - unexpectedBetweenLeftAngleBracketAndGenericParameterList: 
  ///   - genericParameterList: 
  ///   - unexpectedBetweenGenericParameterListAndGenericWhereClause: 
  ///   - genericWhereClause: 
  ///   - unexpectedBetweenGenericWhereClauseAndRightAngleBracket: 
  ///   - rightAngleBracket: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftAngleBracket: ExpressibleAsUnexpectedNodes? = nil, leftAngleBracket: Token = Token.`leftAngle`, unexpectedBetweenLeftAngleBracketAndGenericParameterList: ExpressibleAsUnexpectedNodes? = nil, genericParameterList: ExpressibleAsGenericParameterList, unexpectedBetweenGenericParameterListAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndRightAngleBracket: ExpressibleAsUnexpectedNodes? = nil, rightAngleBracket: Token = Token.`rightAngle`) {
    assert(leftAngleBracket.text == #"<"#)
    assert(rightAngleBracket.text == #">"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeLeftAngleBracket: unexpectedBeforeLeftAngleBracket?.createUnexpectedNodes(), leftAngleBracket: leftAngleBracket, unexpectedBetweenLeftAngleBracketAndGenericParameterList: unexpectedBetweenLeftAngleBracketAndGenericParameterList?.createUnexpectedNodes(), genericParameterList: genericParameterList.createGenericParameterList(), unexpectedBetweenGenericParameterListAndGenericWhereClause: unexpectedBetweenGenericParameterListAndGenericWhereClause?.createUnexpectedNodes(), genericWhereClause: genericWhereClause?.createGenericWhereClause(), unexpectedBetweenGenericWhereClauseAndRightAngleBracket: unexpectedBetweenGenericWhereClauseAndRightAngleBracket?.createUnexpectedNodes(), rightAngleBracket: rightAngleBracket))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftAngleBracket: ExpressibleAsUnexpectedNodes? = nil, leftAngleBracket: Token = Token.`leftAngle`, unexpectedBetweenLeftAngleBracketAndGenericParameterList: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenGenericParameterListAndGenericWhereClause: ExpressibleAsUnexpectedNodes? = nil, genericWhereClause: ExpressibleAsGenericWhereClause? = nil, unexpectedBetweenGenericWhereClauseAndRightAngleBracket: ExpressibleAsUnexpectedNodes? = nil, rightAngleBracket: Token = Token.`rightAngle`, @GenericParameterListBuilder genericParameterListBuilder: () -> ExpressibleAsGenericParameterList =  {
    GenericParameterList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftAngleBracket: unexpectedBeforeLeftAngleBracket, leftAngleBracket: leftAngleBracket, unexpectedBetweenLeftAngleBracketAndGenericParameterList: unexpectedBetweenLeftAngleBracketAndGenericParameterList, genericParameterList: genericParameterListBuilder(), unexpectedBetweenGenericParameterListAndGenericWhereClause: unexpectedBetweenGenericParameterListAndGenericWhereClause, genericWhereClause: genericWhereClause, unexpectedBetweenGenericWhereClauseAndRightAngleBracket: unexpectedBetweenGenericWhereClauseAndRightAngleBracket, rightAngleBracket: rightAngleBracket)
  }
  public init(_ constructedNode: GenericParameterClauseSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `GenericParameterClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `GenericParameterClauseSyntax`.
  func buildGenericParameterClause(format: Format) -> GenericParameterClauseSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = GenericParameterClauseSyntax(buildableData.unexpectedBeforeLeftAngleBracket?.buildUnexpectedNodes(format: format), leftAngleBracket: buildableData.leftAngleBracket.buildToken(format: format), buildableData.unexpectedBetweenLeftAngleBracketAndGenericParameterList?.buildUnexpectedNodes(format: format), genericParameterList: buildableData.genericParameterList.buildGenericParameterList(format: format), buildableData.unexpectedBetweenGenericParameterListAndGenericWhereClause?.buildUnexpectedNodes(format: format), genericWhereClause: buildableData.genericWhereClause?.buildGenericWhereClause(format: format), buildableData.unexpectedBetweenGenericWhereClauseAndRightAngleBracket?.buildUnexpectedNodes(format: format), rightAngleBracket: buildableData.rightAngleBracket.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildGenericParameterClause(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsGenericParameterClause`.
  public func createGenericParameterClause() -> GenericParameterClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `GenericParameterClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct ConformanceRequirement: SyntaxBuildable, ExpressibleAsConformanceRequirement {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeLeftTypeIdentifier: UnexpectedNodes?
    var leftTypeIdentifier: TypeBuildable
    var unexpectedBetweenLeftTypeIdentifierAndColon: UnexpectedNodes?
    var colon: Token
    var unexpectedBetweenColonAndRightTypeIdentifier: UnexpectedNodes?
    var rightTypeIdentifier: TypeBuildable
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ConformanceRequirementSyntax)
  }
  private var data: Data
  /// Creates a `ConformanceRequirement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftTypeIdentifier: 
  ///   - leftTypeIdentifier: 
  ///   - unexpectedBetweenLeftTypeIdentifierAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndRightTypeIdentifier: 
  ///   - rightTypeIdentifier: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftTypeIdentifier: ExpressibleAsUnexpectedNodes? = nil, leftTypeIdentifier: ExpressibleAsTypeBuildable, unexpectedBetweenLeftTypeIdentifierAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndRightTypeIdentifier: ExpressibleAsUnexpectedNodes? = nil, rightTypeIdentifier: ExpressibleAsTypeBuildable) {
    assert(colon.text == #":"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeLeftTypeIdentifier: unexpectedBeforeLeftTypeIdentifier?.createUnexpectedNodes(), leftTypeIdentifier: leftTypeIdentifier.createTypeBuildable(), unexpectedBetweenLeftTypeIdentifierAndColon: unexpectedBetweenLeftTypeIdentifierAndColon?.createUnexpectedNodes(), colon: colon, unexpectedBetweenColonAndRightTypeIdentifier: unexpectedBetweenColonAndRightTypeIdentifier?.createUnexpectedNodes(), rightTypeIdentifier: rightTypeIdentifier.createTypeBuildable()))
  }
  public init(_ constructedNode: ConformanceRequirementSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ConformanceRequirementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ConformanceRequirementSyntax`.
  func buildConformanceRequirement(format: Format) -> ConformanceRequirementSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ConformanceRequirementSyntax(buildableData.unexpectedBeforeLeftTypeIdentifier?.buildUnexpectedNodes(format: format), leftTypeIdentifier: buildableData.leftTypeIdentifier.buildType(format: format), buildableData.unexpectedBetweenLeftTypeIdentifierAndColon?.buildUnexpectedNodes(format: format), colon: buildableData.colon.buildToken(format: format), buildableData.unexpectedBetweenColonAndRightTypeIdentifier?.buildUnexpectedNodes(format: format), rightTypeIdentifier: buildableData.rightTypeIdentifier.buildType(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildConformanceRequirement(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsConformanceRequirement`.
  public func createConformanceRequirement() -> ConformanceRequirement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `ConformanceRequirement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct PrimaryAssociatedTypeClause: SyntaxBuildable, ExpressibleAsPrimaryAssociatedTypeClause {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeLeftAngleBracket: UnexpectedNodes?
    var leftAngleBracket: Token
    var unexpectedBetweenLeftAngleBracketAndPrimaryAssociatedTypeList: UnexpectedNodes?
    var primaryAssociatedTypeList: PrimaryAssociatedTypeList
    var unexpectedBetweenPrimaryAssociatedTypeListAndRightAngleBracket: UnexpectedNodes?
    var rightAngleBracket: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(PrimaryAssociatedTypeClauseSyntax)
  }
  private var data: Data
  /// Creates a `PrimaryAssociatedTypeClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftAngleBracket: 
  ///   - leftAngleBracket: 
  ///   - unexpectedBetweenLeftAngleBracketAndPrimaryAssociatedTypeList: 
  ///   - primaryAssociatedTypeList: 
  ///   - unexpectedBetweenPrimaryAssociatedTypeListAndRightAngleBracket: 
  ///   - rightAngleBracket: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftAngleBracket: ExpressibleAsUnexpectedNodes? = nil, leftAngleBracket: Token = Token.`leftAngle`, unexpectedBetweenLeftAngleBracketAndPrimaryAssociatedTypeList: ExpressibleAsUnexpectedNodes? = nil, primaryAssociatedTypeList: ExpressibleAsPrimaryAssociatedTypeList, unexpectedBetweenPrimaryAssociatedTypeListAndRightAngleBracket: ExpressibleAsUnexpectedNodes? = nil, rightAngleBracket: Token = Token.`rightAngle`) {
    assert(leftAngleBracket.text == #"<"#)
    assert(rightAngleBracket.text == #">"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeLeftAngleBracket: unexpectedBeforeLeftAngleBracket?.createUnexpectedNodes(), leftAngleBracket: leftAngleBracket, unexpectedBetweenLeftAngleBracketAndPrimaryAssociatedTypeList: unexpectedBetweenLeftAngleBracketAndPrimaryAssociatedTypeList?.createUnexpectedNodes(), primaryAssociatedTypeList: primaryAssociatedTypeList.createPrimaryAssociatedTypeList(), unexpectedBetweenPrimaryAssociatedTypeListAndRightAngleBracket: unexpectedBetweenPrimaryAssociatedTypeListAndRightAngleBracket?.createUnexpectedNodes(), rightAngleBracket: rightAngleBracket))
  }
  public init(_ constructedNode: PrimaryAssociatedTypeClauseSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `PrimaryAssociatedTypeClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PrimaryAssociatedTypeClauseSyntax`.
  func buildPrimaryAssociatedTypeClause(format: Format) -> PrimaryAssociatedTypeClauseSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = PrimaryAssociatedTypeClauseSyntax(buildableData.unexpectedBeforeLeftAngleBracket?.buildUnexpectedNodes(format: format), leftAngleBracket: buildableData.leftAngleBracket.buildToken(format: format), buildableData.unexpectedBetweenLeftAngleBracketAndPrimaryAssociatedTypeList?.buildUnexpectedNodes(format: format), primaryAssociatedTypeList: buildableData.primaryAssociatedTypeList.buildPrimaryAssociatedTypeList(format: format), buildableData.unexpectedBetweenPrimaryAssociatedTypeListAndRightAngleBracket?.buildUnexpectedNodes(format: format), rightAngleBracket: buildableData.rightAngleBracket.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildPrimaryAssociatedTypeClause(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsPrimaryAssociatedTypeClause`.
  public func createPrimaryAssociatedTypeClause() -> PrimaryAssociatedTypeClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PrimaryAssociatedTypeClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct SimpleTypeIdentifier: TypeBuildable, ExpressibleAsSimpleTypeIdentifier {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeName: UnexpectedNodes?
    var name: Token
    var unexpectedBetweenNameAndGenericArgumentClause: UnexpectedNodes?
    var genericArgumentClause: GenericArgumentClause?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(SimpleTypeIdentifierSyntax)
  }
  private var data: Data
  /// Creates a `SimpleTypeIdentifier` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndGenericArgumentClause: 
  ///   - genericArgumentClause: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndGenericArgumentClause: ExpressibleAsUnexpectedNodes? = nil, genericArgumentClause: ExpressibleAsGenericArgumentClause? = nil) {
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeName: unexpectedBeforeName?.createUnexpectedNodes(), name: name, unexpectedBetweenNameAndGenericArgumentClause: unexpectedBetweenNameAndGenericArgumentClause?.createUnexpectedNodes(), genericArgumentClause: genericArgumentClause?.createGenericArgumentClause()))
  }
  public init(_ constructedNode: SimpleTypeIdentifierSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `SimpleTypeIdentifierSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `SimpleTypeIdentifierSyntax`.
  func buildSimpleTypeIdentifier(format: Format) -> SimpleTypeIdentifierSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = SimpleTypeIdentifierSyntax(buildableData.unexpectedBeforeName?.buildUnexpectedNodes(format: format), name: buildableData.name.buildToken(format: format), buildableData.unexpectedBetweenNameAndGenericArgumentClause?.buildUnexpectedNodes(format: format), genericArgumentClause: buildableData.genericArgumentClause?.buildGenericArgumentClause(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format) -> TypeSyntax {
    let result = buildSimpleTypeIdentifier(format: format)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsSimpleTypeIdentifier`.
  public func createSimpleTypeIdentifier() -> SimpleTypeIdentifier {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `SimpleTypeIdentifier` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct MemberTypeIdentifier: TypeBuildable, ExpressibleAsMemberTypeIdentifier {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeBaseType: UnexpectedNodes?
    var baseType: TypeBuildable
    var unexpectedBetweenBaseTypeAndPeriod: UnexpectedNodes?
    var period: Token
    var unexpectedBetweenPeriodAndName: UnexpectedNodes?
    var name: Token
    var unexpectedBetweenNameAndGenericArgumentClause: UnexpectedNodes?
    var genericArgumentClause: GenericArgumentClause?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(MemberTypeIdentifierSyntax)
  }
  private var data: Data
  /// Creates a `MemberTypeIdentifier` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeBaseType: 
  ///   - baseType: 
  ///   - unexpectedBetweenBaseTypeAndPeriod: 
  ///   - period: 
  ///   - unexpectedBetweenPeriodAndName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndGenericArgumentClause: 
  ///   - genericArgumentClause: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeBaseType: ExpressibleAsUnexpectedNodes? = nil, baseType: ExpressibleAsTypeBuildable, unexpectedBetweenBaseTypeAndPeriod: ExpressibleAsUnexpectedNodes? = nil, period: Token, unexpectedBetweenPeriodAndName: ExpressibleAsUnexpectedNodes? = nil, name: Token, unexpectedBetweenNameAndGenericArgumentClause: ExpressibleAsUnexpectedNodes? = nil, genericArgumentClause: ExpressibleAsGenericArgumentClause? = nil) {
    assert(period.text == #"."# || period.text == #"."#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeBaseType: unexpectedBeforeBaseType?.createUnexpectedNodes(), baseType: baseType.createTypeBuildable(), unexpectedBetweenBaseTypeAndPeriod: unexpectedBetweenBaseTypeAndPeriod?.createUnexpectedNodes(), period: period, unexpectedBetweenPeriodAndName: unexpectedBetweenPeriodAndName?.createUnexpectedNodes(), name: name, unexpectedBetweenNameAndGenericArgumentClause: unexpectedBetweenNameAndGenericArgumentClause?.createUnexpectedNodes(), genericArgumentClause: genericArgumentClause?.createGenericArgumentClause()))
  }
  public init(_ constructedNode: MemberTypeIdentifierSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `MemberTypeIdentifierSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `MemberTypeIdentifierSyntax`.
  func buildMemberTypeIdentifier(format: Format) -> MemberTypeIdentifierSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = MemberTypeIdentifierSyntax(buildableData.unexpectedBeforeBaseType?.buildUnexpectedNodes(format: format), baseType: buildableData.baseType.buildType(format: format), buildableData.unexpectedBetweenBaseTypeAndPeriod?.buildUnexpectedNodes(format: format), period: buildableData.period.buildToken(format: format), buildableData.unexpectedBetweenPeriodAndName?.buildUnexpectedNodes(format: format), name: buildableData.name.buildToken(format: format), buildableData.unexpectedBetweenNameAndGenericArgumentClause?.buildUnexpectedNodes(format: format), genericArgumentClause: buildableData.genericArgumentClause?.buildGenericArgumentClause(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format) -> TypeSyntax {
    let result = buildMemberTypeIdentifier(format: format)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsMemberTypeIdentifier`.
  public func createMemberTypeIdentifier() -> MemberTypeIdentifier {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `MemberTypeIdentifier` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct ClassRestrictionType: TypeBuildable, ExpressibleAsClassRestrictionType {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeClassKeyword: UnexpectedNodes?
    var classKeyword: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ClassRestrictionTypeSyntax)
  }
  private var data: Data
  /// Creates a `ClassRestrictionType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeClassKeyword: 
  ///   - classKeyword: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeClassKeyword: ExpressibleAsUnexpectedNodes? = nil, classKeyword: Token = Token.`class`) {
    assert(classKeyword.text == #"class"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeClassKeyword: unexpectedBeforeClassKeyword?.createUnexpectedNodes(), classKeyword: classKeyword))
  }
  public init(_ constructedNode: ClassRestrictionTypeSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ClassRestrictionTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ClassRestrictionTypeSyntax`.
  func buildClassRestrictionType(format: Format) -> ClassRestrictionTypeSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ClassRestrictionTypeSyntax(buildableData.unexpectedBeforeClassKeyword?.buildUnexpectedNodes(format: format), classKeyword: buildableData.classKeyword.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format) -> TypeSyntax {
    let result = buildClassRestrictionType(format: format)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsClassRestrictionType`.
  public func createClassRestrictionType() -> ClassRestrictionType {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `ClassRestrictionType` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct ArrayType: TypeBuildable, ExpressibleAsArrayType {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeLeftSquareBracket: UnexpectedNodes?
    var leftSquareBracket: Token
    var unexpectedBetweenLeftSquareBracketAndElementType: UnexpectedNodes?
    var elementType: TypeBuildable
    var unexpectedBetweenElementTypeAndRightSquareBracket: UnexpectedNodes?
    var rightSquareBracket: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ArrayTypeSyntax)
  }
  private var data: Data
  /// Creates a `ArrayType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftSquareBracket: 
  ///   - leftSquareBracket: 
  ///   - unexpectedBetweenLeftSquareBracketAndElementType: 
  ///   - elementType: 
  ///   - unexpectedBetweenElementTypeAndRightSquareBracket: 
  ///   - rightSquareBracket: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftSquareBracket: ExpressibleAsUnexpectedNodes? = nil, leftSquareBracket: Token = Token.`leftSquareBracket`, unexpectedBetweenLeftSquareBracketAndElementType: ExpressibleAsUnexpectedNodes? = nil, elementType: ExpressibleAsTypeBuildable, unexpectedBetweenElementTypeAndRightSquareBracket: ExpressibleAsUnexpectedNodes? = nil, rightSquareBracket: Token = Token.`rightSquareBracket`) {
    assert(leftSquareBracket.text == #"["#)
    assert(rightSquareBracket.text == #"]"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeLeftSquareBracket: unexpectedBeforeLeftSquareBracket?.createUnexpectedNodes(), leftSquareBracket: leftSquareBracket, unexpectedBetweenLeftSquareBracketAndElementType: unexpectedBetweenLeftSquareBracketAndElementType?.createUnexpectedNodes(), elementType: elementType.createTypeBuildable(), unexpectedBetweenElementTypeAndRightSquareBracket: unexpectedBetweenElementTypeAndRightSquareBracket?.createUnexpectedNodes(), rightSquareBracket: rightSquareBracket))
  }
  public init(_ constructedNode: ArrayTypeSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ArrayTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ArrayTypeSyntax`.
  func buildArrayType(format: Format) -> ArrayTypeSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ArrayTypeSyntax(buildableData.unexpectedBeforeLeftSquareBracket?.buildUnexpectedNodes(format: format), leftSquareBracket: buildableData.leftSquareBracket.buildToken(format: format), buildableData.unexpectedBetweenLeftSquareBracketAndElementType?.buildUnexpectedNodes(format: format), elementType: buildableData.elementType.buildType(format: format), buildableData.unexpectedBetweenElementTypeAndRightSquareBracket?.buildUnexpectedNodes(format: format), rightSquareBracket: buildableData.rightSquareBracket.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format) -> TypeSyntax {
    let result = buildArrayType(format: format)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsArrayType`.
  public func createArrayType() -> ArrayType {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `ArrayType` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct DictionaryType: TypeBuildable, ExpressibleAsDictionaryType {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeLeftSquareBracket: UnexpectedNodes?
    var leftSquareBracket: Token
    var unexpectedBetweenLeftSquareBracketAndKeyType: UnexpectedNodes?
    var keyType: TypeBuildable
    var unexpectedBetweenKeyTypeAndColon: UnexpectedNodes?
    var colon: Token
    var unexpectedBetweenColonAndValueType: UnexpectedNodes?
    var valueType: TypeBuildable
    var unexpectedBetweenValueTypeAndRightSquareBracket: UnexpectedNodes?
    var rightSquareBracket: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(DictionaryTypeSyntax)
  }
  private var data: Data
  /// Creates a `DictionaryType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftSquareBracket: 
  ///   - leftSquareBracket: 
  ///   - unexpectedBetweenLeftSquareBracketAndKeyType: 
  ///   - keyType: 
  ///   - unexpectedBetweenKeyTypeAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndValueType: 
  ///   - valueType: 
  ///   - unexpectedBetweenValueTypeAndRightSquareBracket: 
  ///   - rightSquareBracket: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftSquareBracket: ExpressibleAsUnexpectedNodes? = nil, leftSquareBracket: Token = Token.`leftSquareBracket`, unexpectedBetweenLeftSquareBracketAndKeyType: ExpressibleAsUnexpectedNodes? = nil, keyType: ExpressibleAsTypeBuildable, unexpectedBetweenKeyTypeAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndValueType: ExpressibleAsUnexpectedNodes? = nil, valueType: ExpressibleAsTypeBuildable, unexpectedBetweenValueTypeAndRightSquareBracket: ExpressibleAsUnexpectedNodes? = nil, rightSquareBracket: Token = Token.`rightSquareBracket`) {
    assert(leftSquareBracket.text == #"["#)
    assert(colon.text == #":"#)
    assert(rightSquareBracket.text == #"]"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeLeftSquareBracket: unexpectedBeforeLeftSquareBracket?.createUnexpectedNodes(), leftSquareBracket: leftSquareBracket, unexpectedBetweenLeftSquareBracketAndKeyType: unexpectedBetweenLeftSquareBracketAndKeyType?.createUnexpectedNodes(), keyType: keyType.createTypeBuildable(), unexpectedBetweenKeyTypeAndColon: unexpectedBetweenKeyTypeAndColon?.createUnexpectedNodes(), colon: colon, unexpectedBetweenColonAndValueType: unexpectedBetweenColonAndValueType?.createUnexpectedNodes(), valueType: valueType.createTypeBuildable(), unexpectedBetweenValueTypeAndRightSquareBracket: unexpectedBetweenValueTypeAndRightSquareBracket?.createUnexpectedNodes(), rightSquareBracket: rightSquareBracket))
  }
  public init(_ constructedNode: DictionaryTypeSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `DictionaryTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `DictionaryTypeSyntax`.
  func buildDictionaryType(format: Format) -> DictionaryTypeSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = DictionaryTypeSyntax(buildableData.unexpectedBeforeLeftSquareBracket?.buildUnexpectedNodes(format: format), leftSquareBracket: buildableData.leftSquareBracket.buildToken(format: format), buildableData.unexpectedBetweenLeftSquareBracketAndKeyType?.buildUnexpectedNodes(format: format), keyType: buildableData.keyType.buildType(format: format), buildableData.unexpectedBetweenKeyTypeAndColon?.buildUnexpectedNodes(format: format), colon: buildableData.colon.buildToken(format: format), buildableData.unexpectedBetweenColonAndValueType?.buildUnexpectedNodes(format: format), valueType: buildableData.valueType.buildType(format: format), buildableData.unexpectedBetweenValueTypeAndRightSquareBracket?.buildUnexpectedNodes(format: format), rightSquareBracket: buildableData.rightSquareBracket.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format) -> TypeSyntax {
    let result = buildDictionaryType(format: format)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsDictionaryType`.
  public func createDictionaryType() -> DictionaryType {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `DictionaryType` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct MetatypeType: TypeBuildable, ExpressibleAsMetatypeType {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeBaseType: UnexpectedNodes?
    var baseType: TypeBuildable
    var unexpectedBetweenBaseTypeAndPeriod: UnexpectedNodes?
    var period: Token
    var unexpectedBetweenPeriodAndTypeOrProtocol: UnexpectedNodes?
    var typeOrProtocol: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(MetatypeTypeSyntax)
  }
  private var data: Data
  /// Creates a `MetatypeType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeBaseType: 
  ///   - baseType: 
  ///   - unexpectedBetweenBaseTypeAndPeriod: 
  ///   - period: 
  ///   - unexpectedBetweenPeriodAndTypeOrProtocol: 
  ///   - typeOrProtocol: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeBaseType: ExpressibleAsUnexpectedNodes? = nil, baseType: ExpressibleAsTypeBuildable, unexpectedBetweenBaseTypeAndPeriod: ExpressibleAsUnexpectedNodes? = nil, period: Token = Token.`period`, unexpectedBetweenPeriodAndTypeOrProtocol: ExpressibleAsUnexpectedNodes? = nil, typeOrProtocol: Token) {
    assert(period.text == #"."#)
    assert(typeOrProtocol.text == #"Type"# || typeOrProtocol.text == #"Protocol"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeBaseType: unexpectedBeforeBaseType?.createUnexpectedNodes(), baseType: baseType.createTypeBuildable(), unexpectedBetweenBaseTypeAndPeriod: unexpectedBetweenBaseTypeAndPeriod?.createUnexpectedNodes(), period: period, unexpectedBetweenPeriodAndTypeOrProtocol: unexpectedBetweenPeriodAndTypeOrProtocol?.createUnexpectedNodes(), typeOrProtocol: typeOrProtocol))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeBaseType: ExpressibleAsUnexpectedNodes? = nil, baseType: ExpressibleAsTypeBuildable, unexpectedBetweenBaseTypeAndPeriod: ExpressibleAsUnexpectedNodes? = nil, period: Token = Token.`period`, unexpectedBetweenPeriodAndTypeOrProtocol: ExpressibleAsUnexpectedNodes? = nil, typeOrProtocol: String) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeBaseType: unexpectedBeforeBaseType, baseType: baseType, unexpectedBetweenBaseTypeAndPeriod: unexpectedBetweenBaseTypeAndPeriod, period: period, unexpectedBetweenPeriodAndTypeOrProtocol: unexpectedBetweenPeriodAndTypeOrProtocol, typeOrProtocol: Token.`identifier`(typeOrProtocol))
  }
  public init(_ constructedNode: MetatypeTypeSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `MetatypeTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `MetatypeTypeSyntax`.
  func buildMetatypeType(format: Format) -> MetatypeTypeSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = MetatypeTypeSyntax(buildableData.unexpectedBeforeBaseType?.buildUnexpectedNodes(format: format), baseType: buildableData.baseType.buildType(format: format), buildableData.unexpectedBetweenBaseTypeAndPeriod?.buildUnexpectedNodes(format: format), period: buildableData.period.buildToken(format: format), buildableData.unexpectedBetweenPeriodAndTypeOrProtocol?.buildUnexpectedNodes(format: format), typeOrProtocol: buildableData.typeOrProtocol.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format) -> TypeSyntax {
    let result = buildMetatypeType(format: format)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsMetatypeType`.
  public func createMetatypeType() -> MetatypeType {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `MetatypeType` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct OptionalType: TypeBuildable, ExpressibleAsOptionalType {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeWrappedType: UnexpectedNodes?
    var wrappedType: TypeBuildable
    var unexpectedBetweenWrappedTypeAndQuestionMark: UnexpectedNodes?
    var questionMark: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(OptionalTypeSyntax)
  }
  private var data: Data
  /// Creates a `OptionalType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeWrappedType: 
  ///   - wrappedType: 
  ///   - unexpectedBetweenWrappedTypeAndQuestionMark: 
  ///   - questionMark: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeWrappedType: ExpressibleAsUnexpectedNodes? = nil, wrappedType: ExpressibleAsTypeBuildable, unexpectedBetweenWrappedTypeAndQuestionMark: ExpressibleAsUnexpectedNodes? = nil, questionMark: Token = Token.`postfixQuestionMark`) {
    assert(questionMark.text == #"?"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeWrappedType: unexpectedBeforeWrappedType?.createUnexpectedNodes(), wrappedType: wrappedType.createTypeBuildable(), unexpectedBetweenWrappedTypeAndQuestionMark: unexpectedBetweenWrappedTypeAndQuestionMark?.createUnexpectedNodes(), questionMark: questionMark))
  }
  public init(_ constructedNode: OptionalTypeSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `OptionalTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `OptionalTypeSyntax`.
  func buildOptionalType(format: Format) -> OptionalTypeSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = OptionalTypeSyntax(buildableData.unexpectedBeforeWrappedType?.buildUnexpectedNodes(format: format), wrappedType: buildableData.wrappedType.buildType(format: format), buildableData.unexpectedBetweenWrappedTypeAndQuestionMark?.buildUnexpectedNodes(format: format), questionMark: buildableData.questionMark.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format) -> TypeSyntax {
    let result = buildOptionalType(format: format)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsOptionalType`.
  public func createOptionalType() -> OptionalType {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `OptionalType` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct ConstrainedSugarType: TypeBuildable, ExpressibleAsConstrainedSugarType {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeSomeOrAnySpecifier: UnexpectedNodes?
    var someOrAnySpecifier: Token
    var unexpectedBetweenSomeOrAnySpecifierAndBaseType: UnexpectedNodes?
    var baseType: TypeBuildable
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ConstrainedSugarTypeSyntax)
  }
  private var data: Data
  /// Creates a `ConstrainedSugarType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeSomeOrAnySpecifier: 
  ///   - someOrAnySpecifier: 
  ///   - unexpectedBetweenSomeOrAnySpecifierAndBaseType: 
  ///   - baseType: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeSomeOrAnySpecifier: ExpressibleAsUnexpectedNodes? = nil, someOrAnySpecifier: Token, unexpectedBetweenSomeOrAnySpecifierAndBaseType: ExpressibleAsUnexpectedNodes? = nil, baseType: ExpressibleAsTypeBuildable) {
    assert(someOrAnySpecifier.text == #"some"# || someOrAnySpecifier.text == #"any"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeSomeOrAnySpecifier: unexpectedBeforeSomeOrAnySpecifier?.createUnexpectedNodes(), someOrAnySpecifier: someOrAnySpecifier, unexpectedBetweenSomeOrAnySpecifierAndBaseType: unexpectedBetweenSomeOrAnySpecifierAndBaseType?.createUnexpectedNodes(), baseType: baseType.createTypeBuildable()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeSomeOrAnySpecifier: ExpressibleAsUnexpectedNodes? = nil, someOrAnySpecifier: String, unexpectedBetweenSomeOrAnySpecifierAndBaseType: ExpressibleAsUnexpectedNodes? = nil, baseType: ExpressibleAsTypeBuildable) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeSomeOrAnySpecifier: unexpectedBeforeSomeOrAnySpecifier, someOrAnySpecifier: Token.`identifier`(someOrAnySpecifier), unexpectedBetweenSomeOrAnySpecifierAndBaseType: unexpectedBetweenSomeOrAnySpecifierAndBaseType, baseType: baseType)
  }
  public init(_ constructedNode: ConstrainedSugarTypeSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ConstrainedSugarTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ConstrainedSugarTypeSyntax`.
  func buildConstrainedSugarType(format: Format) -> ConstrainedSugarTypeSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ConstrainedSugarTypeSyntax(buildableData.unexpectedBeforeSomeOrAnySpecifier?.buildUnexpectedNodes(format: format), someOrAnySpecifier: buildableData.someOrAnySpecifier.buildToken(format: format), buildableData.unexpectedBetweenSomeOrAnySpecifierAndBaseType?.buildUnexpectedNodes(format: format), baseType: buildableData.baseType.buildType(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format) -> TypeSyntax {
    let result = buildConstrainedSugarType(format: format)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsConstrainedSugarType`.
  public func createConstrainedSugarType() -> ConstrainedSugarType {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `ConstrainedSugarType` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct ImplicitlyUnwrappedOptionalType: TypeBuildable, ExpressibleAsImplicitlyUnwrappedOptionalType {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeWrappedType: UnexpectedNodes?
    var wrappedType: TypeBuildable
    var unexpectedBetweenWrappedTypeAndExclamationMark: UnexpectedNodes?
    var exclamationMark: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ImplicitlyUnwrappedOptionalTypeSyntax)
  }
  private var data: Data
  /// Creates a `ImplicitlyUnwrappedOptionalType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeWrappedType: 
  ///   - wrappedType: 
  ///   - unexpectedBetweenWrappedTypeAndExclamationMark: 
  ///   - exclamationMark: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeWrappedType: ExpressibleAsUnexpectedNodes? = nil, wrappedType: ExpressibleAsTypeBuildable, unexpectedBetweenWrappedTypeAndExclamationMark: ExpressibleAsUnexpectedNodes? = nil, exclamationMark: Token = Token.`exclamationMark`) {
    assert(exclamationMark.text == #"!"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeWrappedType: unexpectedBeforeWrappedType?.createUnexpectedNodes(), wrappedType: wrappedType.createTypeBuildable(), unexpectedBetweenWrappedTypeAndExclamationMark: unexpectedBetweenWrappedTypeAndExclamationMark?.createUnexpectedNodes(), exclamationMark: exclamationMark))
  }
  public init(_ constructedNode: ImplicitlyUnwrappedOptionalTypeSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ImplicitlyUnwrappedOptionalTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ImplicitlyUnwrappedOptionalTypeSyntax`.
  func buildImplicitlyUnwrappedOptionalType(format: Format) -> ImplicitlyUnwrappedOptionalTypeSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ImplicitlyUnwrappedOptionalTypeSyntax(buildableData.unexpectedBeforeWrappedType?.buildUnexpectedNodes(format: format), wrappedType: buildableData.wrappedType.buildType(format: format), buildableData.unexpectedBetweenWrappedTypeAndExclamationMark?.buildUnexpectedNodes(format: format), exclamationMark: buildableData.exclamationMark.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format) -> TypeSyntax {
    let result = buildImplicitlyUnwrappedOptionalType(format: format)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsImplicitlyUnwrappedOptionalType`.
  public func createImplicitlyUnwrappedOptionalType() -> ImplicitlyUnwrappedOptionalType {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `ImplicitlyUnwrappedOptionalType` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct CompositionTypeElement: SyntaxBuildable, ExpressibleAsCompositionTypeElement {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeType: UnexpectedNodes?
    var type: TypeBuildable
    var unexpectedBetweenTypeAndAmpersand: UnexpectedNodes?
    var ampersand: Token?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(CompositionTypeElementSyntax)
  }
  private var data: Data
  /// Creates a `CompositionTypeElement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeType: 
  ///   - type: 
  ///   - unexpectedBetweenTypeAndAmpersand: 
  ///   - ampersand: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeType: ExpressibleAsUnexpectedNodes? = nil, type: ExpressibleAsTypeBuildable, unexpectedBetweenTypeAndAmpersand: ExpressibleAsUnexpectedNodes? = nil, ampersand: Token? = nil) {
    assert(ampersand == nil || ampersand!.text == #"&"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeType: unexpectedBeforeType?.createUnexpectedNodes(), type: type.createTypeBuildable(), unexpectedBetweenTypeAndAmpersand: unexpectedBetweenTypeAndAmpersand?.createUnexpectedNodes(), ampersand: ampersand))
  }
  public init(_ constructedNode: CompositionTypeElementSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `CompositionTypeElementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `CompositionTypeElementSyntax`.
  func buildCompositionTypeElement(format: Format) -> CompositionTypeElementSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = CompositionTypeElementSyntax(buildableData.unexpectedBeforeType?.buildUnexpectedNodes(format: format), type: buildableData.type.buildType(format: format), buildableData.unexpectedBetweenTypeAndAmpersand?.buildUnexpectedNodes(format: format), ampersand: buildableData.ampersand?.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildCompositionTypeElement(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsCompositionTypeElement`.
  public func createCompositionTypeElement() -> CompositionTypeElement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `CompositionTypeElement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct CompositionType: TypeBuildable, ExpressibleAsCompositionType {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeElements: UnexpectedNodes?
    var elements: CompositionTypeElementList
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(CompositionTypeSyntax)
  }
  private var data: Data
  /// Creates a `CompositionType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeElements: 
  ///   - elements: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeElements: ExpressibleAsUnexpectedNodes? = nil, elements: ExpressibleAsCompositionTypeElementList) {
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeElements: unexpectedBeforeElements?.createUnexpectedNodes(), elements: elements.createCompositionTypeElementList()))
  }
  public init(_ constructedNode: CompositionTypeSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `CompositionTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `CompositionTypeSyntax`.
  func buildCompositionType(format: Format) -> CompositionTypeSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = CompositionTypeSyntax(buildableData.unexpectedBeforeElements?.buildUnexpectedNodes(format: format), elements: buildableData.elements.buildCompositionTypeElementList(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format) -> TypeSyntax {
    let result = buildCompositionType(format: format)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsCompositionType`.
  public func createCompositionType() -> CompositionType {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `CompositionType` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct PackExpansionType: TypeBuildable, ExpressibleAsPackExpansionType {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforePatternType: UnexpectedNodes?
    var patternType: TypeBuildable
    var unexpectedBetweenPatternTypeAndEllipsis: UnexpectedNodes?
    var ellipsis: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(PackExpansionTypeSyntax)
  }
  private var data: Data
  /// Creates a `PackExpansionType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePatternType: 
  ///   - patternType: 
  ///   - unexpectedBetweenPatternTypeAndEllipsis: 
  ///   - ellipsis: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePatternType: ExpressibleAsUnexpectedNodes? = nil, patternType: ExpressibleAsTypeBuildable, unexpectedBetweenPatternTypeAndEllipsis: ExpressibleAsUnexpectedNodes? = nil, ellipsis: Token = Token.`ellipsis`) {
    assert(ellipsis.text == #"..."#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforePatternType: unexpectedBeforePatternType?.createUnexpectedNodes(), patternType: patternType.createTypeBuildable(), unexpectedBetweenPatternTypeAndEllipsis: unexpectedBetweenPatternTypeAndEllipsis?.createUnexpectedNodes(), ellipsis: ellipsis))
  }
  public init(_ constructedNode: PackExpansionTypeSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `PackExpansionTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `PackExpansionTypeSyntax`.
  func buildPackExpansionType(format: Format) -> PackExpansionTypeSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = PackExpansionTypeSyntax(buildableData.unexpectedBeforePatternType?.buildUnexpectedNodes(format: format), patternType: buildableData.patternType.buildType(format: format), buildableData.unexpectedBetweenPatternTypeAndEllipsis?.buildUnexpectedNodes(format: format), ellipsis: buildableData.ellipsis.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format) -> TypeSyntax {
    let result = buildPackExpansionType(format: format)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsPackExpansionType`.
  public func createPackExpansionType() -> PackExpansionType {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `PackExpansionType` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct TupleTypeElement: SyntaxBuildable, ExpressibleAsTupleTypeElement, HasTrailingComma {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeInOut: UnexpectedNodes?
    var inOut: Token?
    var unexpectedBetweenInOutAndName: UnexpectedNodes?
    var name: Token?
    var unexpectedBetweenNameAndSecondName: UnexpectedNodes?
    var secondName: Token?
    var unexpectedBetweenSecondNameAndColon: UnexpectedNodes?
    var colon: Token?
    var unexpectedBetweenColonAndType: UnexpectedNodes?
    var type: TypeBuildable
    var unexpectedBetweenTypeAndEllipsis: UnexpectedNodes?
    var ellipsis: Token?
    var unexpectedBetweenEllipsisAndInitializer: UnexpectedNodes?
    var initializer: InitializerClause?
    var unexpectedBetweenInitializerAndTrailingComma: UnexpectedNodes?
    var trailingComma: Token?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(TupleTypeElementSyntax)
  }
  private var data: Data
  var hasTrailingComma: Bool {
    switch data {
    case .buildable(let buildableData):
      return buildableData.trailingComma != nil
    case .constructed(let node):
      return node.trailingComma != nil
    }
  }
  /// Creates a `TupleTypeElement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeInOut: 
  ///   - inOut: 
  ///   - unexpectedBetweenInOutAndName: 
  ///   - name: 
  ///   - unexpectedBetweenNameAndSecondName: 
  ///   - secondName: 
  ///   - unexpectedBetweenSecondNameAndColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndType: 
  ///   - type: 
  ///   - unexpectedBetweenTypeAndEllipsis: 
  ///   - ellipsis: 
  ///   - unexpectedBetweenEllipsisAndInitializer: 
  ///   - initializer: 
  ///   - unexpectedBetweenInitializerAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeInOut: ExpressibleAsUnexpectedNodes? = nil, inOut: Token? = nil, unexpectedBetweenInOutAndName: ExpressibleAsUnexpectedNodes? = nil, name: Token? = nil, unexpectedBetweenNameAndSecondName: ExpressibleAsUnexpectedNodes? = nil, secondName: Token? = nil, unexpectedBetweenSecondNameAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token? = nil, unexpectedBetweenColonAndType: ExpressibleAsUnexpectedNodes? = nil, type: ExpressibleAsTypeBuildable, unexpectedBetweenTypeAndEllipsis: ExpressibleAsUnexpectedNodes? = nil, ellipsis: Token? = nil, unexpectedBetweenEllipsisAndInitializer: ExpressibleAsUnexpectedNodes? = nil, initializer: ExpressibleAsInitializerClause? = nil, unexpectedBetweenInitializerAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    assert(inOut == nil || inOut!.text == #"inout"#)
    assert(colon == nil || colon!.text == #":"#)
    assert(ellipsis == nil || ellipsis!.text == #"..."#)
    assert(trailingComma == nil || trailingComma!.text == #","#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeInOut: unexpectedBeforeInOut?.createUnexpectedNodes(), inOut: inOut, unexpectedBetweenInOutAndName: unexpectedBetweenInOutAndName?.createUnexpectedNodes(), name: name, unexpectedBetweenNameAndSecondName: unexpectedBetweenNameAndSecondName?.createUnexpectedNodes(), secondName: secondName, unexpectedBetweenSecondNameAndColon: unexpectedBetweenSecondNameAndColon?.createUnexpectedNodes(), colon: colon, unexpectedBetweenColonAndType: unexpectedBetweenColonAndType?.createUnexpectedNodes(), type: type.createTypeBuildable(), unexpectedBetweenTypeAndEllipsis: unexpectedBetweenTypeAndEllipsis?.createUnexpectedNodes(), ellipsis: ellipsis, unexpectedBetweenEllipsisAndInitializer: unexpectedBetweenEllipsisAndInitializer?.createUnexpectedNodes(), initializer: initializer?.createInitializerClause(), unexpectedBetweenInitializerAndTrailingComma: unexpectedBetweenInitializerAndTrailingComma?.createUnexpectedNodes(), trailingComma: trailingComma))
  }
  public init(_ constructedNode: TupleTypeElementSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `TupleTypeElementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TupleTypeElementSyntax`.
  func buildTupleTypeElement(format: Format) -> TupleTypeElementSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = TupleTypeElementSyntax(buildableData.unexpectedBeforeInOut?.buildUnexpectedNodes(format: format), inOut: buildableData.inOut?.buildToken(format: format), buildableData.unexpectedBetweenInOutAndName?.buildUnexpectedNodes(format: format), name: buildableData.name?.buildToken(format: format), buildableData.unexpectedBetweenNameAndSecondName?.buildUnexpectedNodes(format: format), secondName: buildableData.secondName?.buildToken(format: format), buildableData.unexpectedBetweenSecondNameAndColon?.buildUnexpectedNodes(format: format), colon: buildableData.colon?.buildToken(format: format), buildableData.unexpectedBetweenColonAndType?.buildUnexpectedNodes(format: format), type: buildableData.type.buildType(format: format), buildableData.unexpectedBetweenTypeAndEllipsis?.buildUnexpectedNodes(format: format), ellipsis: buildableData.ellipsis?.buildToken(format: format), buildableData.unexpectedBetweenEllipsisAndInitializer?.buildUnexpectedNodes(format: format), initializer: buildableData.initializer?.buildInitializerClause(format: format), buildableData.unexpectedBetweenInitializerAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: buildableData.trailingComma?.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildTupleTypeElement(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsTupleTypeElement`.
  public func createTupleTypeElement() -> TupleTypeElement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TupleTypeElement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingComma = withComma ? .comma : nil
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withComma = node.withTrailingComma(withComma ? .commaToken() : nil)
      var result = self
      result.data = .constructed(withComma)
      return result
    }
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct TupleType: TypeBuildable, ExpressibleAsTupleType {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeLeftParen: UnexpectedNodes?
    var leftParen: Token
    var unexpectedBetweenLeftParenAndElements: UnexpectedNodes?
    var elements: TupleTypeElementList
    var unexpectedBetweenElementsAndRightParen: UnexpectedNodes?
    var rightParen: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(TupleTypeSyntax)
  }
  private var data: Data
  /// Creates a `TupleType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndElements: 
  ///   - elements: 
  ///   - unexpectedBetweenElementsAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndElements: ExpressibleAsUnexpectedNodes? = nil, elements: ExpressibleAsTupleTypeElementList, unexpectedBetweenElementsAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    assert(leftParen.text == #"("#)
    assert(rightParen.text == #")"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeLeftParen: unexpectedBeforeLeftParen?.createUnexpectedNodes(), leftParen: leftParen, unexpectedBetweenLeftParenAndElements: unexpectedBetweenLeftParenAndElements?.createUnexpectedNodes(), elements: elements.createTupleTypeElementList(), unexpectedBetweenElementsAndRightParen: unexpectedBetweenElementsAndRightParen?.createUnexpectedNodes(), rightParen: rightParen))
  }
  public init(_ constructedNode: TupleTypeSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `TupleTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TupleTypeSyntax`.
  func buildTupleType(format: Format) -> TupleTypeSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = TupleTypeSyntax(buildableData.unexpectedBeforeLeftParen?.buildUnexpectedNodes(format: format), leftParen: buildableData.leftParen.buildToken(format: format), buildableData.unexpectedBetweenLeftParenAndElements?.buildUnexpectedNodes(format: format), elements: buildableData.elements.buildTupleTypeElementList(format: format), buildableData.unexpectedBetweenElementsAndRightParen?.buildUnexpectedNodes(format: format), rightParen: buildableData.rightParen.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format) -> TypeSyntax {
    let result = buildTupleType(format: format)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsTupleType`.
  public func createTupleType() -> TupleType {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `TupleType` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct FunctionType: TypeBuildable, ExpressibleAsFunctionType {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeLeftParen: UnexpectedNodes?
    var leftParen: Token
    var unexpectedBetweenLeftParenAndArguments: UnexpectedNodes?
    var arguments: TupleTypeElementList
    var unexpectedBetweenArgumentsAndRightParen: UnexpectedNodes?
    var rightParen: Token
    var unexpectedBetweenRightParenAndAsyncKeyword: UnexpectedNodes?
    var asyncKeyword: Token?
    var unexpectedBetweenAsyncKeywordAndThrowsOrRethrowsKeyword: UnexpectedNodes?
    var throwsOrRethrowsKeyword: Token?
    var unexpectedBetweenThrowsOrRethrowsKeywordAndArrow: UnexpectedNodes?
    var arrow: Token
    var unexpectedBetweenArrowAndReturnType: UnexpectedNodes?
    var returnType: TypeBuildable
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(FunctionTypeSyntax)
  }
  private var data: Data
  /// Creates a `FunctionType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndArguments: 
  ///   - arguments: 
  ///   - unexpectedBetweenArgumentsAndRightParen: 
  ///   - rightParen: 
  ///   - unexpectedBetweenRightParenAndAsyncKeyword: 
  ///   - asyncKeyword: 
  ///   - unexpectedBetweenAsyncKeywordAndThrowsOrRethrowsKeyword: 
  ///   - throwsOrRethrowsKeyword: 
  ///   - unexpectedBetweenThrowsOrRethrowsKeywordAndArrow: 
  ///   - arrow: 
  ///   - unexpectedBetweenArrowAndReturnType: 
  ///   - returnType: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndArguments: ExpressibleAsUnexpectedNodes? = nil, arguments: ExpressibleAsTupleTypeElementList, unexpectedBetweenArgumentsAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`, unexpectedBetweenRightParenAndAsyncKeyword: ExpressibleAsUnexpectedNodes? = nil, asyncKeyword: Token? = nil, unexpectedBetweenAsyncKeywordAndThrowsOrRethrowsKeyword: ExpressibleAsUnexpectedNodes? = nil, throwsOrRethrowsKeyword: Token? = nil, unexpectedBetweenThrowsOrRethrowsKeywordAndArrow: ExpressibleAsUnexpectedNodes? = nil, arrow: Token = Token.`arrow`, unexpectedBetweenArrowAndReturnType: ExpressibleAsUnexpectedNodes? = nil, returnType: ExpressibleAsTypeBuildable) {
    assert(leftParen.text == #"("#)
    assert(rightParen.text == #")"#)
    assert(asyncKeyword == nil || asyncKeyword!.text == #"async"#)
    assert(throwsOrRethrowsKeyword == nil || throwsOrRethrowsKeyword!.text == #"throws"# || throwsOrRethrowsKeyword!.text == #"rethrows"# || throwsOrRethrowsKeyword!.text == #"throw"#)
    assert(arrow.text == #"->"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeLeftParen: unexpectedBeforeLeftParen?.createUnexpectedNodes(), leftParen: leftParen, unexpectedBetweenLeftParenAndArguments: unexpectedBetweenLeftParenAndArguments?.createUnexpectedNodes(), arguments: arguments.createTupleTypeElementList(), unexpectedBetweenArgumentsAndRightParen: unexpectedBetweenArgumentsAndRightParen?.createUnexpectedNodes(), rightParen: rightParen, unexpectedBetweenRightParenAndAsyncKeyword: unexpectedBetweenRightParenAndAsyncKeyword?.createUnexpectedNodes(), asyncKeyword: asyncKeyword, unexpectedBetweenAsyncKeywordAndThrowsOrRethrowsKeyword: unexpectedBetweenAsyncKeywordAndThrowsOrRethrowsKeyword?.createUnexpectedNodes(), throwsOrRethrowsKeyword: throwsOrRethrowsKeyword, unexpectedBetweenThrowsOrRethrowsKeywordAndArrow: unexpectedBetweenThrowsOrRethrowsKeywordAndArrow?.createUnexpectedNodes(), arrow: arrow, unexpectedBetweenArrowAndReturnType: unexpectedBetweenArrowAndReturnType?.createUnexpectedNodes(), returnType: returnType.createTypeBuildable()))
  }
  public init(_ constructedNode: FunctionTypeSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `FunctionTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `FunctionTypeSyntax`.
  func buildFunctionType(format: Format) -> FunctionTypeSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = FunctionTypeSyntax(buildableData.unexpectedBeforeLeftParen?.buildUnexpectedNodes(format: format), leftParen: buildableData.leftParen.buildToken(format: format), buildableData.unexpectedBetweenLeftParenAndArguments?.buildUnexpectedNodes(format: format), arguments: buildableData.arguments.buildTupleTypeElementList(format: format), buildableData.unexpectedBetweenArgumentsAndRightParen?.buildUnexpectedNodes(format: format), rightParen: buildableData.rightParen.buildToken(format: format), buildableData.unexpectedBetweenRightParenAndAsyncKeyword?.buildUnexpectedNodes(format: format), asyncKeyword: buildableData.asyncKeyword?.buildToken(format: format), buildableData.unexpectedBetweenAsyncKeywordAndThrowsOrRethrowsKeyword?.buildUnexpectedNodes(format: format), throwsOrRethrowsKeyword: buildableData.throwsOrRethrowsKeyword?.buildToken(format: format), buildableData.unexpectedBetweenThrowsOrRethrowsKeywordAndArrow?.buildUnexpectedNodes(format: format), arrow: buildableData.arrow.buildToken(format: format), buildableData.unexpectedBetweenArrowAndReturnType?.buildUnexpectedNodes(format: format), returnType: buildableData.returnType.buildType(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format) -> TypeSyntax {
    let result = buildFunctionType(format: format)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsFunctionType`.
  public func createFunctionType() -> FunctionType {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `FunctionType` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct AttributedType: TypeBuildable, ExpressibleAsAttributedType {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeSpecifier: UnexpectedNodes?
    var specifier: Token?
    var unexpectedBetweenSpecifierAndAttributes: UnexpectedNodes?
    var attributes: AttributeList?
    var unexpectedBetweenAttributesAndBaseType: UnexpectedNodes?
    var baseType: TypeBuildable
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(AttributedTypeSyntax)
  }
  private var data: Data
  /// Creates a `AttributedType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeSpecifier: 
  ///   - specifier: 
  ///   - unexpectedBetweenSpecifierAndAttributes: 
  ///   - attributes: 
  ///   - unexpectedBetweenAttributesAndBaseType: 
  ///   - baseType: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeSpecifier: ExpressibleAsUnexpectedNodes? = nil, specifier: Token? = nil, unexpectedBetweenSpecifierAndAttributes: ExpressibleAsUnexpectedNodes? = nil, attributes: ExpressibleAsAttributeList? = nil, unexpectedBetweenAttributesAndBaseType: ExpressibleAsUnexpectedNodes? = nil, baseType: ExpressibleAsTypeBuildable) {
    assert(specifier == nil || specifier!.text == #"inout"# || specifier!.text == #"__shared"# || specifier!.text == #"__owned"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeSpecifier: unexpectedBeforeSpecifier?.createUnexpectedNodes(), specifier: specifier, unexpectedBetweenSpecifierAndAttributes: unexpectedBetweenSpecifierAndAttributes?.createUnexpectedNodes(), attributes: attributes?.createAttributeList(), unexpectedBetweenAttributesAndBaseType: unexpectedBetweenAttributesAndBaseType?.createUnexpectedNodes(), baseType: baseType.createTypeBuildable()))
  }
  public init(_ constructedNode: AttributedTypeSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `AttributedTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AttributedTypeSyntax`.
  func buildAttributedType(format: Format) -> AttributedTypeSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = AttributedTypeSyntax(buildableData.unexpectedBeforeSpecifier?.buildUnexpectedNodes(format: format), specifier: buildableData.specifier?.buildToken(format: format), buildableData.unexpectedBetweenSpecifierAndAttributes?.buildUnexpectedNodes(format: format), attributes: buildableData.attributes?.buildAttributeList(format: format), buildableData.unexpectedBetweenAttributesAndBaseType?.buildUnexpectedNodes(format: format), baseType: buildableData.baseType.buildType(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format) -> TypeSyntax {
    let result = buildAttributedType(format: format)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsAttributedType`.
  public func createAttributedType() -> AttributedType {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `AttributedType` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct GenericArgument: SyntaxBuildable, ExpressibleAsGenericArgument, HasTrailingComma {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeArgumentType: UnexpectedNodes?
    var argumentType: TypeBuildable
    var unexpectedBetweenArgumentTypeAndTrailingComma: UnexpectedNodes?
    var trailingComma: Token?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(GenericArgumentSyntax)
  }
  private var data: Data
  var hasTrailingComma: Bool {
    switch data {
    case .buildable(let buildableData):
      return buildableData.trailingComma != nil
    case .constructed(let node):
      return node.trailingComma != nil
    }
  }
  /// Creates a `GenericArgument` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeArgumentType: 
  ///   - argumentType: 
  ///   - unexpectedBetweenArgumentTypeAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeArgumentType: ExpressibleAsUnexpectedNodes? = nil, argumentType: ExpressibleAsTypeBuildable, unexpectedBetweenArgumentTypeAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    assert(trailingComma == nil || trailingComma!.text == #","#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeArgumentType: unexpectedBeforeArgumentType?.createUnexpectedNodes(), argumentType: argumentType.createTypeBuildable(), unexpectedBetweenArgumentTypeAndTrailingComma: unexpectedBetweenArgumentTypeAndTrailingComma?.createUnexpectedNodes(), trailingComma: trailingComma))
  }
  public init(_ constructedNode: GenericArgumentSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `GenericArgumentSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `GenericArgumentSyntax`.
  func buildGenericArgument(format: Format) -> GenericArgumentSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = GenericArgumentSyntax(buildableData.unexpectedBeforeArgumentType?.buildUnexpectedNodes(format: format), argumentType: buildableData.argumentType.buildType(format: format), buildableData.unexpectedBetweenArgumentTypeAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: buildableData.trailingComma?.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildGenericArgument(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsGenericArgument`.
  public func createGenericArgument() -> GenericArgument {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `GenericArgument` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingComma = withComma ? .comma : nil
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withComma = node.withTrailingComma(withComma ? .commaToken() : nil)
      var result = self
      result.data = .constructed(withComma)
      return result
    }
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct GenericArgumentClause: SyntaxBuildable, ExpressibleAsGenericArgumentClause {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeLeftAngleBracket: UnexpectedNodes?
    var leftAngleBracket: Token
    var unexpectedBetweenLeftAngleBracketAndArguments: UnexpectedNodes?
    var arguments: GenericArgumentList
    var unexpectedBetweenArgumentsAndRightAngleBracket: UnexpectedNodes?
    var rightAngleBracket: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(GenericArgumentClauseSyntax)
  }
  private var data: Data
  /// Creates a `GenericArgumentClause` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftAngleBracket: 
  ///   - leftAngleBracket: 
  ///   - unexpectedBetweenLeftAngleBracketAndArguments: 
  ///   - arguments: 
  ///   - unexpectedBetweenArgumentsAndRightAngleBracket: 
  ///   - rightAngleBracket: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftAngleBracket: ExpressibleAsUnexpectedNodes? = nil, leftAngleBracket: Token = Token.`leftAngle`, unexpectedBetweenLeftAngleBracketAndArguments: ExpressibleAsUnexpectedNodes? = nil, arguments: ExpressibleAsGenericArgumentList, unexpectedBetweenArgumentsAndRightAngleBracket: ExpressibleAsUnexpectedNodes? = nil, rightAngleBracket: Token = Token.`rightAngle`) {
    assert(leftAngleBracket.text == #"<"#)
    assert(rightAngleBracket.text == #">"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeLeftAngleBracket: unexpectedBeforeLeftAngleBracket?.createUnexpectedNodes(), leftAngleBracket: leftAngleBracket, unexpectedBetweenLeftAngleBracketAndArguments: unexpectedBetweenLeftAngleBracketAndArguments?.createUnexpectedNodes(), arguments: arguments.createGenericArgumentList(), unexpectedBetweenArgumentsAndRightAngleBracket: unexpectedBetweenArgumentsAndRightAngleBracket?.createUnexpectedNodes(), rightAngleBracket: rightAngleBracket))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftAngleBracket: ExpressibleAsUnexpectedNodes? = nil, leftAngleBracket: Token = Token.`leftAngle`, unexpectedBetweenLeftAngleBracketAndArguments: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenArgumentsAndRightAngleBracket: ExpressibleAsUnexpectedNodes? = nil, rightAngleBracket: Token = Token.`rightAngle`, @GenericArgumentListBuilder argumentsBuilder: () -> ExpressibleAsGenericArgumentList =  {
    GenericArgumentList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftAngleBracket: unexpectedBeforeLeftAngleBracket, leftAngleBracket: leftAngleBracket, unexpectedBetweenLeftAngleBracketAndArguments: unexpectedBetweenLeftAngleBracketAndArguments, arguments: argumentsBuilder(), unexpectedBetweenArgumentsAndRightAngleBracket: unexpectedBetweenArgumentsAndRightAngleBracket, rightAngleBracket: rightAngleBracket)
  }
  public init(_ constructedNode: GenericArgumentClauseSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `GenericArgumentClauseSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `GenericArgumentClauseSyntax`.
  func buildGenericArgumentClause(format: Format) -> GenericArgumentClauseSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = GenericArgumentClauseSyntax(buildableData.unexpectedBeforeLeftAngleBracket?.buildUnexpectedNodes(format: format), leftAngleBracket: buildableData.leftAngleBracket.buildToken(format: format), buildableData.unexpectedBetweenLeftAngleBracketAndArguments?.buildUnexpectedNodes(format: format), arguments: buildableData.arguments.buildGenericArgumentList(format: format), buildableData.unexpectedBetweenArgumentsAndRightAngleBracket?.buildUnexpectedNodes(format: format), rightAngleBracket: buildableData.rightAngleBracket.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildGenericArgumentClause(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsGenericArgumentClause`.
  public func createGenericArgumentClause() -> GenericArgumentClause {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `GenericArgumentClause` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct NamedOpaqueReturnType: TypeBuildable, ExpressibleAsNamedOpaqueReturnType {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeGenericParameters: UnexpectedNodes?
    var genericParameters: GenericParameterClause
    var unexpectedBetweenGenericParametersAndBaseType: UnexpectedNodes?
    var baseType: TypeBuildable
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(NamedOpaqueReturnTypeSyntax)
  }
  private var data: Data
  /// Creates a `NamedOpaqueReturnType` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeGenericParameters: 
  ///   - genericParameters: 
  ///   - unexpectedBetweenGenericParametersAndBaseType: 
  ///   - baseType: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeGenericParameters: ExpressibleAsUnexpectedNodes? = nil, genericParameters: ExpressibleAsGenericParameterClause, unexpectedBetweenGenericParametersAndBaseType: ExpressibleAsUnexpectedNodes? = nil, baseType: ExpressibleAsTypeBuildable) {
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeGenericParameters: unexpectedBeforeGenericParameters?.createUnexpectedNodes(), genericParameters: genericParameters.createGenericParameterClause(), unexpectedBetweenGenericParametersAndBaseType: unexpectedBetweenGenericParametersAndBaseType?.createUnexpectedNodes(), baseType: baseType.createTypeBuildable()))
  }
  public init(_ constructedNode: NamedOpaqueReturnTypeSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `NamedOpaqueReturnTypeSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `NamedOpaqueReturnTypeSyntax`.
  func buildNamedOpaqueReturnType(format: Format) -> NamedOpaqueReturnTypeSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = NamedOpaqueReturnTypeSyntax(buildableData.unexpectedBeforeGenericParameters?.buildUnexpectedNodes(format: format), genericParameters: buildableData.genericParameters.buildGenericParameterClause(format: format), buildableData.unexpectedBetweenGenericParametersAndBaseType?.buildUnexpectedNodes(format: format), baseType: buildableData.baseType.buildType(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `TypeBuildable`.
  public func buildType(format: Format) -> TypeSyntax {
    let result = buildNamedOpaqueReturnType(format: format)
    return TypeSyntax(result)
  }
  /// Conformance to `ExpressibleAsNamedOpaqueReturnType`.
  public func createNamedOpaqueReturnType() -> NamedOpaqueReturnType {
    return self
  }
  /// Conformance to `ExpressibleAsTypeBuildable`.
  /// `NamedOpaqueReturnType` may conform to `ExpressibleAsTypeBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createTypeBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createTypeBuildable() -> TypeBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct TypeAnnotation: SyntaxBuildable, ExpressibleAsTypeAnnotation {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeColon: UnexpectedNodes?
    var colon: Token
    var unexpectedBetweenColonAndType: UnexpectedNodes?
    var type: TypeBuildable
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(TypeAnnotationSyntax)
  }
  private var data: Data
  /// Creates a `TypeAnnotation` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeColon: 
  ///   - colon: 
  ///   - unexpectedBetweenColonAndType: 
  ///   - type: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndType: ExpressibleAsUnexpectedNodes? = nil, type: ExpressibleAsTypeBuildable) {
    assert(colon.text == #":"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeColon: unexpectedBeforeColon?.createUnexpectedNodes(), colon: colon, unexpectedBetweenColonAndType: unexpectedBetweenColonAndType?.createUnexpectedNodes(), type: type.createTypeBuildable()))
  }
  public init(_ constructedNode: TypeAnnotationSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `TypeAnnotationSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TypeAnnotationSyntax`.
  func buildTypeAnnotation(format: Format) -> TypeAnnotationSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = TypeAnnotationSyntax(buildableData.unexpectedBeforeColon?.buildUnexpectedNodes(format: format), colon: buildableData.colon.buildToken(format: format), buildableData.unexpectedBetweenColonAndType?.buildUnexpectedNodes(format: format), type: buildableData.type.buildType(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildTypeAnnotation(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsTypeAnnotation`.
  public func createTypeAnnotation() -> TypeAnnotation {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TypeAnnotation` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct EnumCasePattern: PatternBuildable, ExpressibleAsEnumCasePattern {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeType: UnexpectedNodes?
    var type: TypeBuildable?
    var unexpectedBetweenTypeAndPeriod: UnexpectedNodes?
    var period: Token
    var unexpectedBetweenPeriodAndCaseName: UnexpectedNodes?
    var caseName: Token
    var unexpectedBetweenCaseNameAndAssociatedTuple: UnexpectedNodes?
    var associatedTuple: TuplePattern?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(EnumCasePatternSyntax)
  }
  private var data: Data
  /// Creates a `EnumCasePattern` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeType: 
  ///   - type: 
  ///   - unexpectedBetweenTypeAndPeriod: 
  ///   - period: 
  ///   - unexpectedBetweenPeriodAndCaseName: 
  ///   - caseName: 
  ///   - unexpectedBetweenCaseNameAndAssociatedTuple: 
  ///   - associatedTuple: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeType: ExpressibleAsUnexpectedNodes? = nil, type: ExpressibleAsTypeBuildable? = nil, unexpectedBetweenTypeAndPeriod: ExpressibleAsUnexpectedNodes? = nil, period: Token = Token.`period`, unexpectedBetweenPeriodAndCaseName: ExpressibleAsUnexpectedNodes? = nil, caseName: Token, unexpectedBetweenCaseNameAndAssociatedTuple: ExpressibleAsUnexpectedNodes? = nil, associatedTuple: ExpressibleAsTuplePattern? = nil) {
    assert(period.text == #"."#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeType: unexpectedBeforeType?.createUnexpectedNodes(), type: type?.createTypeBuildable(), unexpectedBetweenTypeAndPeriod: unexpectedBetweenTypeAndPeriod?.createUnexpectedNodes(), period: period, unexpectedBetweenPeriodAndCaseName: unexpectedBetweenPeriodAndCaseName?.createUnexpectedNodes(), caseName: caseName, unexpectedBetweenCaseNameAndAssociatedTuple: unexpectedBetweenCaseNameAndAssociatedTuple?.createUnexpectedNodes(), associatedTuple: associatedTuple?.createTuplePattern()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeType: ExpressibleAsUnexpectedNodes? = nil, type: ExpressibleAsTypeBuildable? = nil, unexpectedBetweenTypeAndPeriod: ExpressibleAsUnexpectedNodes? = nil, period: Token = Token.`period`, unexpectedBetweenPeriodAndCaseName: ExpressibleAsUnexpectedNodes? = nil, caseName: String, unexpectedBetweenCaseNameAndAssociatedTuple: ExpressibleAsUnexpectedNodes? = nil, associatedTuple: ExpressibleAsTuplePattern? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeType: unexpectedBeforeType, type: type, unexpectedBetweenTypeAndPeriod: unexpectedBetweenTypeAndPeriod, period: period, unexpectedBetweenPeriodAndCaseName: unexpectedBetweenPeriodAndCaseName, caseName: Token.`identifier`(caseName), unexpectedBetweenCaseNameAndAssociatedTuple: unexpectedBetweenCaseNameAndAssociatedTuple, associatedTuple: associatedTuple)
  }
  public init(_ constructedNode: EnumCasePatternSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `EnumCasePatternSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `EnumCasePatternSyntax`.
  func buildEnumCasePattern(format: Format) -> EnumCasePatternSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = EnumCasePatternSyntax(buildableData.unexpectedBeforeType?.buildUnexpectedNodes(format: format), type: buildableData.type?.buildType(format: format), buildableData.unexpectedBetweenTypeAndPeriod?.buildUnexpectedNodes(format: format), period: buildableData.period.buildToken(format: format), buildableData.unexpectedBetweenPeriodAndCaseName?.buildUnexpectedNodes(format: format), caseName: buildableData.caseName.buildToken(format: format), buildableData.unexpectedBetweenCaseNameAndAssociatedTuple?.buildUnexpectedNodes(format: format), associatedTuple: buildableData.associatedTuple?.buildTuplePattern(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `PatternBuildable`.
  public func buildPattern(format: Format) -> PatternSyntax {
    let result = buildEnumCasePattern(format: format)
    return PatternSyntax(result)
  }
  /// Conformance to `ExpressibleAsEnumCasePattern`.
  public func createEnumCasePattern() -> EnumCasePattern {
    return self
  }
  /// Conformance to `ExpressibleAsPatternBuildable`.
  /// `EnumCasePattern` may conform to `ExpressibleAsPatternBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createPatternBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createPatternBuildable() -> PatternBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PatternBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct IsTypePattern: PatternBuildable, ExpressibleAsIsTypePattern {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeIsKeyword: UnexpectedNodes?
    var isKeyword: Token
    var unexpectedBetweenIsKeywordAndType: UnexpectedNodes?
    var type: TypeBuildable
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(IsTypePatternSyntax)
  }
  private var data: Data
  /// Creates a `IsTypePattern` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeIsKeyword: 
  ///   - isKeyword: 
  ///   - unexpectedBetweenIsKeywordAndType: 
  ///   - type: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeIsKeyword: ExpressibleAsUnexpectedNodes? = nil, isKeyword: Token = Token.`is`, unexpectedBetweenIsKeywordAndType: ExpressibleAsUnexpectedNodes? = nil, type: ExpressibleAsTypeBuildable) {
    assert(isKeyword.text == #"is"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeIsKeyword: unexpectedBeforeIsKeyword?.createUnexpectedNodes(), isKeyword: isKeyword, unexpectedBetweenIsKeywordAndType: unexpectedBetweenIsKeywordAndType?.createUnexpectedNodes(), type: type.createTypeBuildable()))
  }
  public init(_ constructedNode: IsTypePatternSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `IsTypePatternSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `IsTypePatternSyntax`.
  func buildIsTypePattern(format: Format) -> IsTypePatternSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = IsTypePatternSyntax(buildableData.unexpectedBeforeIsKeyword?.buildUnexpectedNodes(format: format), isKeyword: buildableData.isKeyword.buildToken(format: format), buildableData.unexpectedBetweenIsKeywordAndType?.buildUnexpectedNodes(format: format), type: buildableData.type.buildType(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `PatternBuildable`.
  public func buildPattern(format: Format) -> PatternSyntax {
    let result = buildIsTypePattern(format: format)
    return PatternSyntax(result)
  }
  /// Conformance to `ExpressibleAsIsTypePattern`.
  public func createIsTypePattern() -> IsTypePattern {
    return self
  }
  /// Conformance to `ExpressibleAsPatternBuildable`.
  /// `IsTypePattern` may conform to `ExpressibleAsPatternBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createPatternBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createPatternBuildable() -> PatternBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PatternBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct OptionalPattern: PatternBuildable, ExpressibleAsOptionalPattern {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeSubPattern: UnexpectedNodes?
    var subPattern: PatternBuildable
    var unexpectedBetweenSubPatternAndQuestionMark: UnexpectedNodes?
    var questionMark: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(OptionalPatternSyntax)
  }
  private var data: Data
  /// Creates a `OptionalPattern` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeSubPattern: 
  ///   - subPattern: 
  ///   - unexpectedBetweenSubPatternAndQuestionMark: 
  ///   - questionMark: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeSubPattern: ExpressibleAsUnexpectedNodes? = nil, subPattern: ExpressibleAsPatternBuildable, unexpectedBetweenSubPatternAndQuestionMark: ExpressibleAsUnexpectedNodes? = nil, questionMark: Token = Token.`postfixQuestionMark`) {
    assert(questionMark.text == #"?"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeSubPattern: unexpectedBeforeSubPattern?.createUnexpectedNodes(), subPattern: subPattern.createPatternBuildable(), unexpectedBetweenSubPatternAndQuestionMark: unexpectedBetweenSubPatternAndQuestionMark?.createUnexpectedNodes(), questionMark: questionMark))
  }
  public init(_ constructedNode: OptionalPatternSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `OptionalPatternSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `OptionalPatternSyntax`.
  func buildOptionalPattern(format: Format) -> OptionalPatternSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = OptionalPatternSyntax(buildableData.unexpectedBeforeSubPattern?.buildUnexpectedNodes(format: format), subPattern: buildableData.subPattern.buildPattern(format: format), buildableData.unexpectedBetweenSubPatternAndQuestionMark?.buildUnexpectedNodes(format: format), questionMark: buildableData.questionMark.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `PatternBuildable`.
  public func buildPattern(format: Format) -> PatternSyntax {
    let result = buildOptionalPattern(format: format)
    return PatternSyntax(result)
  }
  /// Conformance to `ExpressibleAsOptionalPattern`.
  public func createOptionalPattern() -> OptionalPattern {
    return self
  }
  /// Conformance to `ExpressibleAsPatternBuildable`.
  /// `OptionalPattern` may conform to `ExpressibleAsPatternBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createPatternBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createPatternBuildable() -> PatternBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PatternBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct IdentifierPattern: PatternBuildable, ExpressibleAsIdentifierPattern {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeIdentifier: UnexpectedNodes?
    var identifier: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(IdentifierPatternSyntax)
  }
  private var data: Data
  /// Creates a `IdentifierPattern` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeIdentifier: 
  ///   - identifier: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeIdentifier: ExpressibleAsUnexpectedNodes? = nil, identifier: Token) {
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeIdentifier: unexpectedBeforeIdentifier?.createUnexpectedNodes(), identifier: identifier))
  }
  public init(_ constructedNode: IdentifierPatternSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `IdentifierPatternSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `IdentifierPatternSyntax`.
  func buildIdentifierPattern(format: Format) -> IdentifierPatternSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = IdentifierPatternSyntax(buildableData.unexpectedBeforeIdentifier?.buildUnexpectedNodes(format: format), identifier: buildableData.identifier.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `PatternBuildable`.
  public func buildPattern(format: Format) -> PatternSyntax {
    let result = buildIdentifierPattern(format: format)
    return PatternSyntax(result)
  }
  /// Conformance to `ExpressibleAsIdentifierPattern`.
  public func createIdentifierPattern() -> IdentifierPattern {
    return self
  }
  /// Conformance to `ExpressibleAsPatternBuildable`.
  /// `IdentifierPattern` may conform to `ExpressibleAsPatternBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createPatternBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createPatternBuildable() -> PatternBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PatternBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct AsTypePattern: PatternBuildable, ExpressibleAsAsTypePattern {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforePattern: UnexpectedNodes?
    var pattern: PatternBuildable
    var unexpectedBetweenPatternAndAsKeyword: UnexpectedNodes?
    var asKeyword: Token
    var unexpectedBetweenAsKeywordAndType: UnexpectedNodes?
    var type: TypeBuildable
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(AsTypePatternSyntax)
  }
  private var data: Data
  /// Creates a `AsTypePattern` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePattern: 
  ///   - pattern: 
  ///   - unexpectedBetweenPatternAndAsKeyword: 
  ///   - asKeyword: 
  ///   - unexpectedBetweenAsKeywordAndType: 
  ///   - type: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePattern: ExpressibleAsUnexpectedNodes? = nil, pattern: ExpressibleAsPatternBuildable, unexpectedBetweenPatternAndAsKeyword: ExpressibleAsUnexpectedNodes? = nil, asKeyword: Token = Token.`as`, unexpectedBetweenAsKeywordAndType: ExpressibleAsUnexpectedNodes? = nil, type: ExpressibleAsTypeBuildable) {
    assert(asKeyword.text == #"as"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforePattern: unexpectedBeforePattern?.createUnexpectedNodes(), pattern: pattern.createPatternBuildable(), unexpectedBetweenPatternAndAsKeyword: unexpectedBetweenPatternAndAsKeyword?.createUnexpectedNodes(), asKeyword: asKeyword, unexpectedBetweenAsKeywordAndType: unexpectedBetweenAsKeywordAndType?.createUnexpectedNodes(), type: type.createTypeBuildable()))
  }
  public init(_ constructedNode: AsTypePatternSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `AsTypePatternSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AsTypePatternSyntax`.
  func buildAsTypePattern(format: Format) -> AsTypePatternSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = AsTypePatternSyntax(buildableData.unexpectedBeforePattern?.buildUnexpectedNodes(format: format), pattern: buildableData.pattern.buildPattern(format: format), buildableData.unexpectedBetweenPatternAndAsKeyword?.buildUnexpectedNodes(format: format), asKeyword: buildableData.asKeyword.buildToken(format: format), buildableData.unexpectedBetweenAsKeywordAndType?.buildUnexpectedNodes(format: format), type: buildableData.type.buildType(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `PatternBuildable`.
  public func buildPattern(format: Format) -> PatternSyntax {
    let result = buildAsTypePattern(format: format)
    return PatternSyntax(result)
  }
  /// Conformance to `ExpressibleAsAsTypePattern`.
  public func createAsTypePattern() -> AsTypePattern {
    return self
  }
  /// Conformance to `ExpressibleAsPatternBuildable`.
  /// `AsTypePattern` may conform to `ExpressibleAsPatternBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createPatternBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createPatternBuildable() -> PatternBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PatternBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct TuplePattern: PatternBuildable, ExpressibleAsTuplePattern {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeLeftParen: UnexpectedNodes?
    var leftParen: Token
    var unexpectedBetweenLeftParenAndElements: UnexpectedNodes?
    var elements: TuplePatternElementList
    var unexpectedBetweenElementsAndRightParen: UnexpectedNodes?
    var rightParen: Token
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(TuplePatternSyntax)
  }
  private var data: Data
  /// Creates a `TuplePattern` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLeftParen: 
  ///   - leftParen: 
  ///   - unexpectedBetweenLeftParenAndElements: 
  ///   - elements: 
  ///   - unexpectedBetweenElementsAndRightParen: 
  ///   - rightParen: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndElements: ExpressibleAsUnexpectedNodes? = nil, elements: ExpressibleAsTuplePatternElementList, unexpectedBetweenElementsAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`) {
    assert(leftParen.text == #"("#)
    assert(rightParen.text == #")"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeLeftParen: unexpectedBeforeLeftParen?.createUnexpectedNodes(), leftParen: leftParen, unexpectedBetweenLeftParenAndElements: unexpectedBetweenLeftParenAndElements?.createUnexpectedNodes(), elements: elements.createTuplePatternElementList(), unexpectedBetweenElementsAndRightParen: unexpectedBetweenElementsAndRightParen?.createUnexpectedNodes(), rightParen: rightParen))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLeftParen: ExpressibleAsUnexpectedNodes? = nil, leftParen: Token = Token.`leftParen`, unexpectedBetweenLeftParenAndElements: ExpressibleAsUnexpectedNodes? = nil, unexpectedBetweenElementsAndRightParen: ExpressibleAsUnexpectedNodes? = nil, rightParen: Token = Token.`rightParen`, @TuplePatternElementListBuilder elementsBuilder: () -> ExpressibleAsTuplePatternElementList =  {
    TuplePatternElementList([])
  }) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLeftParen: unexpectedBeforeLeftParen, leftParen: leftParen, unexpectedBetweenLeftParenAndElements: unexpectedBetweenLeftParenAndElements, elements: elementsBuilder(), unexpectedBetweenElementsAndRightParen: unexpectedBetweenElementsAndRightParen, rightParen: rightParen)
  }
  public init(_ constructedNode: TuplePatternSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `TuplePatternSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TuplePatternSyntax`.
  func buildTuplePattern(format: Format) -> TuplePatternSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = TuplePatternSyntax(buildableData.unexpectedBeforeLeftParen?.buildUnexpectedNodes(format: format), leftParen: buildableData.leftParen.buildToken(format: format), buildableData.unexpectedBetweenLeftParenAndElements?.buildUnexpectedNodes(format: format), elements: buildableData.elements.buildTuplePatternElementList(format: format), buildableData.unexpectedBetweenElementsAndRightParen?.buildUnexpectedNodes(format: format), rightParen: buildableData.rightParen.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `PatternBuildable`.
  public func buildPattern(format: Format) -> PatternSyntax {
    let result = buildTuplePattern(format: format)
    return PatternSyntax(result)
  }
  /// Conformance to `ExpressibleAsTuplePattern`.
  public func createTuplePattern() -> TuplePattern {
    return self
  }
  /// Conformance to `ExpressibleAsPatternBuildable`.
  /// `TuplePattern` may conform to `ExpressibleAsPatternBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createPatternBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createPatternBuildable() -> PatternBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PatternBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct WildcardPattern: PatternBuildable, ExpressibleAsWildcardPattern {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeWildcard: UnexpectedNodes?
    var wildcard: Token
    var unexpectedBetweenWildcardAndTypeAnnotation: UnexpectedNodes?
    var typeAnnotation: TypeAnnotation?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(WildcardPatternSyntax)
  }
  private var data: Data
  /// Creates a `WildcardPattern` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeWildcard: 
  ///   - wildcard: 
  ///   - unexpectedBetweenWildcardAndTypeAnnotation: 
  ///   - typeAnnotation: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeWildcard: ExpressibleAsUnexpectedNodes? = nil, wildcard: Token = Token.`wildcard`, unexpectedBetweenWildcardAndTypeAnnotation: ExpressibleAsUnexpectedNodes? = nil, typeAnnotation: ExpressibleAsTypeAnnotation? = nil) {
    assert(wildcard.text == #"_"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeWildcard: unexpectedBeforeWildcard?.createUnexpectedNodes(), wildcard: wildcard, unexpectedBetweenWildcardAndTypeAnnotation: unexpectedBetweenWildcardAndTypeAnnotation?.createUnexpectedNodes(), typeAnnotation: typeAnnotation?.createTypeAnnotation()))
  }
  public init(_ constructedNode: WildcardPatternSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `WildcardPatternSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `WildcardPatternSyntax`.
  func buildWildcardPattern(format: Format) -> WildcardPatternSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = WildcardPatternSyntax(buildableData.unexpectedBeforeWildcard?.buildUnexpectedNodes(format: format), wildcard: buildableData.wildcard.buildToken(format: format), buildableData.unexpectedBetweenWildcardAndTypeAnnotation?.buildUnexpectedNodes(format: format), typeAnnotation: buildableData.typeAnnotation?.buildTypeAnnotation(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `PatternBuildable`.
  public func buildPattern(format: Format) -> PatternSyntax {
    let result = buildWildcardPattern(format: format)
    return PatternSyntax(result)
  }
  /// Conformance to `ExpressibleAsWildcardPattern`.
  public func createWildcardPattern() -> WildcardPattern {
    return self
  }
  /// Conformance to `ExpressibleAsPatternBuildable`.
  /// `WildcardPattern` may conform to `ExpressibleAsPatternBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createPatternBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createPatternBuildable() -> PatternBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PatternBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct TuplePatternElement: SyntaxBuildable, ExpressibleAsTuplePatternElement, HasTrailingComma {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeLabelName: UnexpectedNodes?
    var labelName: Token?
    var unexpectedBetweenLabelNameAndLabelColon: UnexpectedNodes?
    var labelColon: Token?
    var unexpectedBetweenLabelColonAndPattern: UnexpectedNodes?
    var pattern: PatternBuildable
    var unexpectedBetweenPatternAndTrailingComma: UnexpectedNodes?
    var trailingComma: Token?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(TuplePatternElementSyntax)
  }
  private var data: Data
  var hasTrailingComma: Bool {
    switch data {
    case .buildable(let buildableData):
      return buildableData.trailingComma != nil
    case .constructed(let node):
      return node.trailingComma != nil
    }
  }
  /// Creates a `TuplePatternElement` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLabelName: 
  ///   - labelName: 
  ///   - unexpectedBetweenLabelNameAndLabelColon: 
  ///   - labelColon: 
  ///   - unexpectedBetweenLabelColonAndPattern: 
  ///   - pattern: 
  ///   - unexpectedBetweenPatternAndTrailingComma: 
  ///   - trailingComma: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLabelName: ExpressibleAsUnexpectedNodes? = nil, labelName: Token? = nil, unexpectedBetweenLabelNameAndLabelColon: ExpressibleAsUnexpectedNodes? = nil, labelColon: Token? = nil, unexpectedBetweenLabelColonAndPattern: ExpressibleAsUnexpectedNodes? = nil, pattern: ExpressibleAsPatternBuildable, unexpectedBetweenPatternAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    assert(labelColon == nil || labelColon!.text == #":"#)
    assert(trailingComma == nil || trailingComma!.text == #","#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeLabelName: unexpectedBeforeLabelName?.createUnexpectedNodes(), labelName: labelName, unexpectedBetweenLabelNameAndLabelColon: unexpectedBetweenLabelNameAndLabelColon?.createUnexpectedNodes(), labelColon: labelColon, unexpectedBetweenLabelColonAndPattern: unexpectedBetweenLabelColonAndPattern?.createUnexpectedNodes(), pattern: pattern.createPatternBuildable(), unexpectedBetweenPatternAndTrailingComma: unexpectedBetweenPatternAndTrailingComma?.createUnexpectedNodes(), trailingComma: trailingComma))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLabelName: ExpressibleAsUnexpectedNodes? = nil, labelName: String?, unexpectedBetweenLabelNameAndLabelColon: ExpressibleAsUnexpectedNodes? = nil, labelColon: Token? = nil, unexpectedBetweenLabelColonAndPattern: ExpressibleAsUnexpectedNodes? = nil, pattern: ExpressibleAsPatternBuildable, unexpectedBetweenPatternAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLabelName: unexpectedBeforeLabelName, labelName: labelName.map { Token.`identifier`($0) }, unexpectedBetweenLabelNameAndLabelColon: unexpectedBetweenLabelNameAndLabelColon, labelColon: labelColon, unexpectedBetweenLabelColonAndPattern: unexpectedBetweenLabelColonAndPattern, pattern: pattern, unexpectedBetweenPatternAndTrailingComma: unexpectedBetweenPatternAndTrailingComma, trailingComma: trailingComma)
  }
  public init(_ constructedNode: TuplePatternElementSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `TuplePatternElementSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `TuplePatternElementSyntax`.
  func buildTuplePatternElement(format: Format) -> TuplePatternElementSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = TuplePatternElementSyntax(buildableData.unexpectedBeforeLabelName?.buildUnexpectedNodes(format: format), labelName: buildableData.labelName?.buildToken(format: format), buildableData.unexpectedBetweenLabelNameAndLabelColon?.buildUnexpectedNodes(format: format), labelColon: buildableData.labelColon?.buildToken(format: format), buildableData.unexpectedBetweenLabelColonAndPattern?.buildUnexpectedNodes(format: format), pattern: buildableData.pattern.buildPattern(format: format), buildableData.unexpectedBetweenPatternAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: buildableData.trailingComma?.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildTuplePatternElement(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsTuplePatternElement`.
  public func createTuplePatternElement() -> TuplePatternElement {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `TuplePatternElement` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  /// Conformance to `HasTrailingComma`.
  public func withTrailingComma(_ withComma: Bool) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingComma = withComma ? .comma : nil
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withComma = node.withTrailingComma(withComma ? .commaToken() : nil)
      var result = self
      result.data = .constructed(withComma)
      return result
    }
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct ExpressionPattern: PatternBuildable, ExpressibleAsExpressionPattern {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeExpression: UnexpectedNodes?
    var expression: ExprBuildable
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ExpressionPatternSyntax)
  }
  private var data: Data
  /// Creates a `ExpressionPattern` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeExpression: 
  ///   - expression: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeExpression: ExpressibleAsUnexpectedNodes? = nil, expression: ExpressibleAsExprBuildable) {
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeExpression: unexpectedBeforeExpression?.createUnexpectedNodes(), expression: expression.createExprBuildable()))
  }
  public init(_ constructedNode: ExpressionPatternSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ExpressionPatternSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ExpressionPatternSyntax`.
  func buildExpressionPattern(format: Format) -> ExpressionPatternSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ExpressionPatternSyntax(buildableData.unexpectedBeforeExpression?.buildUnexpectedNodes(format: format), expression: buildableData.expression.buildExpr(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `PatternBuildable`.
  public func buildPattern(format: Format) -> PatternSyntax {
    let result = buildExpressionPattern(format: format)
    return PatternSyntax(result)
  }
  /// Conformance to `ExpressibleAsExpressionPattern`.
  public func createExpressionPattern() -> ExpressionPattern {
    return self
  }
  /// Conformance to `ExpressibleAsPatternBuildable`.
  /// `ExpressionPattern` may conform to `ExpressibleAsPatternBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createPatternBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createPatternBuildable() -> PatternBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PatternBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
public struct ValueBindingPattern: PatternBuildable, ExpressibleAsValueBindingPattern {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeLetOrVarKeyword: UnexpectedNodes?
    var letOrVarKeyword: Token
    var unexpectedBetweenLetOrVarKeywordAndValuePattern: UnexpectedNodes?
    var valuePattern: PatternBuildable
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(ValueBindingPatternSyntax)
  }
  private var data: Data
  /// Creates a `ValueBindingPattern` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLetOrVarKeyword: 
  ///   - letOrVarKeyword: 
  ///   - unexpectedBetweenLetOrVarKeywordAndValuePattern: 
  ///   - valuePattern: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLetOrVarKeyword: ExpressibleAsUnexpectedNodes? = nil, letOrVarKeyword: Token, unexpectedBetweenLetOrVarKeywordAndValuePattern: ExpressibleAsUnexpectedNodes? = nil, valuePattern: ExpressibleAsPatternBuildable) {
    assert(letOrVarKeyword.text == #"let"# || letOrVarKeyword.text == #"var"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeLetOrVarKeyword: unexpectedBeforeLetOrVarKeyword?.createUnexpectedNodes(), letOrVarKeyword: letOrVarKeyword, unexpectedBetweenLetOrVarKeywordAndValuePattern: unexpectedBetweenLetOrVarKeywordAndValuePattern?.createUnexpectedNodes(), valuePattern: valuePattern.createPatternBuildable()))
  }
  public init(_ constructedNode: ValueBindingPatternSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `ValueBindingPatternSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `ValueBindingPatternSyntax`.
  func buildValueBindingPattern(format: Format) -> ValueBindingPatternSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = ValueBindingPatternSyntax(buildableData.unexpectedBeforeLetOrVarKeyword?.buildUnexpectedNodes(format: format), letOrVarKeyword: buildableData.letOrVarKeyword.buildToken(format: format), buildableData.unexpectedBetweenLetOrVarKeywordAndValuePattern?.buildUnexpectedNodes(format: format), valuePattern: buildableData.valuePattern.buildPattern(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `PatternBuildable`.
  public func buildPattern(format: Format) -> PatternSyntax {
    let result = buildValueBindingPattern(format: format)
    return PatternSyntax(result)
  }
  /// Conformance to `ExpressibleAsValueBindingPattern`.
  public func createValueBindingPattern() -> ValueBindingPattern {
    return self
  }
  /// Conformance to `ExpressibleAsPatternBuildable`.
  /// `ValueBindingPattern` may conform to `ExpressibleAsPatternBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createPatternBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createPatternBuildable() -> PatternBuildable {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `PatternBuildable` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
/// A single argument to an `@available` argument like `*`, `iOS 10.1`,or `message: "This has been deprecated"`.
public struct AvailabilityArgument: SyntaxBuildable, ExpressibleAsAvailabilityArgument {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeEntry: UnexpectedNodes?
    var entry: SyntaxBuildable
    var unexpectedBetweenEntryAndTrailingComma: UnexpectedNodes?
    var trailingComma: Token?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(AvailabilityArgumentSyntax)
  }
  private var data: Data
  /// Creates a `AvailabilityArgument` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeEntry: 
  ///   - entry: The actual argument
  ///   - unexpectedBetweenEntryAndTrailingComma: 
  ///   - trailingComma: A trailing comma if the argument is followed by anotherargument
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeEntry: ExpressibleAsUnexpectedNodes? = nil, entry: ExpressibleAsSyntaxBuildable, unexpectedBetweenEntryAndTrailingComma: ExpressibleAsUnexpectedNodes? = nil, trailingComma: Token? = nil) {
    assert(trailingComma == nil || trailingComma!.text == #","#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeEntry: unexpectedBeforeEntry?.createUnexpectedNodes(), entry: entry.createSyntaxBuildable(), unexpectedBetweenEntryAndTrailingComma: unexpectedBetweenEntryAndTrailingComma?.createUnexpectedNodes(), trailingComma: trailingComma))
  }
  public init(_ constructedNode: AvailabilityArgumentSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `AvailabilityArgumentSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AvailabilityArgumentSyntax`.
  func buildAvailabilityArgument(format: Format) -> AvailabilityArgumentSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = AvailabilityArgumentSyntax(buildableData.unexpectedBeforeEntry?.buildUnexpectedNodes(format: format), entry: buildableData.entry.buildSyntax(format: format), buildableData.unexpectedBetweenEntryAndTrailingComma?.buildUnexpectedNodes(format: format), trailingComma: buildableData.trailingComma?.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildAvailabilityArgument(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsAvailabilityArgument`.
  public func createAvailabilityArgument() -> AvailabilityArgument {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `AvailabilityArgument` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
/// A argument to an `@available` attribute that consists of a label anda value, e.g. `message: "This has been deprecated"`.
public struct AvailabilityLabeledArgument: SyntaxBuildable, ExpressibleAsAvailabilityLabeledArgument {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeLabel: UnexpectedNodes?
    var label: Token
    var unexpectedBetweenLabelAndColon: UnexpectedNodes?
    var colon: Token
    var unexpectedBetweenColonAndValue: UnexpectedNodes?
    var value: SyntaxBuildable
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(AvailabilityLabeledArgumentSyntax)
  }
  private var data: Data
  /// Creates a `AvailabilityLabeledArgument` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeLabel: 
  ///   - label: The label of the argument
  ///   - unexpectedBetweenLabelAndColon: 
  ///   - colon: The colon separating label and value
  ///   - unexpectedBetweenColonAndValue: 
  ///   - value: The value of this labeled argument
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeLabel: ExpressibleAsUnexpectedNodes? = nil, label: Token, unexpectedBetweenLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndValue: ExpressibleAsUnexpectedNodes? = nil, value: ExpressibleAsSyntaxBuildable) {
    assert(colon.text == #":"#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeLabel: unexpectedBeforeLabel?.createUnexpectedNodes(), label: label, unexpectedBetweenLabelAndColon: unexpectedBetweenLabelAndColon?.createUnexpectedNodes(), colon: colon, unexpectedBetweenColonAndValue: unexpectedBetweenColonAndValue?.createUnexpectedNodes(), value: value.createSyntaxBuildable()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeLabel: ExpressibleAsUnexpectedNodes? = nil, label: String, unexpectedBetweenLabelAndColon: ExpressibleAsUnexpectedNodes? = nil, colon: Token = Token.`colon`, unexpectedBetweenColonAndValue: ExpressibleAsUnexpectedNodes? = nil, value: ExpressibleAsSyntaxBuildable) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeLabel: unexpectedBeforeLabel, label: Token.`identifier`(label), unexpectedBetweenLabelAndColon: unexpectedBetweenLabelAndColon, colon: colon, unexpectedBetweenColonAndValue: unexpectedBetweenColonAndValue, value: value)
  }
  public init(_ constructedNode: AvailabilityLabeledArgumentSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `AvailabilityLabeledArgumentSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AvailabilityLabeledArgumentSyntax`.
  func buildAvailabilityLabeledArgument(format: Format) -> AvailabilityLabeledArgumentSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = AvailabilityLabeledArgumentSyntax(buildableData.unexpectedBeforeLabel?.buildUnexpectedNodes(format: format), label: buildableData.label.buildToken(format: format), buildableData.unexpectedBetweenLabelAndColon?.buildUnexpectedNodes(format: format), colon: buildableData.colon.buildToken(format: format), buildableData.unexpectedBetweenColonAndValue?.buildUnexpectedNodes(format: format), value: buildableData.value.buildSyntax(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildAvailabilityLabeledArgument(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsAvailabilityLabeledArgument`.
  public func createAvailabilityLabeledArgument() -> AvailabilityLabeledArgument {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `AvailabilityLabeledArgument` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
/// An argument to `@available` that restricts the availability on acertain platform to a version, e.g. `iOS 10` or `swift 3.4`.
public struct AvailabilityVersionRestriction: SyntaxBuildable, ExpressibleAsAvailabilityVersionRestriction {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforePlatform: UnexpectedNodes?
    var platform: Token
    var unexpectedBetweenPlatformAndVersion: UnexpectedNodes?
    var version: VersionTuple?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(AvailabilityVersionRestrictionSyntax)
  }
  private var data: Data
  /// Creates a `AvailabilityVersionRestriction` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforePlatform: 
  ///   - platform: The name of the OS on which the availability should berestricted or 'swift' if the availability should berestricted based on a Swift version.
  ///   - unexpectedBetweenPlatformAndVersion: 
  ///   - version: 
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforePlatform: ExpressibleAsUnexpectedNodes? = nil, platform: Token, unexpectedBetweenPlatformAndVersion: ExpressibleAsUnexpectedNodes? = nil, version: ExpressibleAsVersionTuple? = nil) {
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforePlatform: unexpectedBeforePlatform?.createUnexpectedNodes(), platform: platform, unexpectedBetweenPlatformAndVersion: unexpectedBetweenPlatformAndVersion?.createUnexpectedNodes(), version: version?.createVersionTuple()))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforePlatform: ExpressibleAsUnexpectedNodes? = nil, platform: String, unexpectedBetweenPlatformAndVersion: ExpressibleAsUnexpectedNodes? = nil, version: ExpressibleAsVersionTuple? = nil) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforePlatform: unexpectedBeforePlatform, platform: Token.`identifier`(platform), unexpectedBetweenPlatformAndVersion: unexpectedBetweenPlatformAndVersion, version: version)
  }
  public init(_ constructedNode: AvailabilityVersionRestrictionSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `AvailabilityVersionRestrictionSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `AvailabilityVersionRestrictionSyntax`.
  func buildAvailabilityVersionRestriction(format: Format) -> AvailabilityVersionRestrictionSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = AvailabilityVersionRestrictionSyntax(buildableData.unexpectedBeforePlatform?.buildUnexpectedNodes(format: format), platform: buildableData.platform.buildToken(format: format), buildableData.unexpectedBetweenPlatformAndVersion?.buildUnexpectedNodes(format: format), version: buildableData.version?.buildVersionTuple(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildAvailabilityVersionRestriction(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsAvailabilityVersionRestriction`.
  public func createAvailabilityVersionRestriction() -> AvailabilityVersionRestriction {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `AvailabilityVersionRestriction` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
/// A version number of the form major.minor.patch in which the minorand patch part may be omitted.
public struct VersionTuple: SyntaxBuildable, ExpressibleAsVersionTuple {
  struct BuildableData {
    /// The leading trivia attached to this syntax node once built.
    var leadingTrivia: Trivia
    /// The trailing trivia attached to this syntax node once built.
    var trailingTrivia: Trivia
    var unexpectedBeforeMajorMinor: UnexpectedNodes?
    var majorMinor: SyntaxBuildable
    var unexpectedBetweenMajorMinorAndPatchPeriod: UnexpectedNodes?
    var patchPeriod: Token?
    var unexpectedBetweenPatchPeriodAndPatchVersion: UnexpectedNodes?
    var patchVersion: Token?
  }
  enum Data {
    case buildable(BuildableData)
    case constructed(VersionTupleSyntax)
  }
  private var data: Data
  /// Creates a `VersionTuple` using the provided parameters.
  /// - Parameters:
  ///   - unexpectedBeforeMajorMinor: 
  ///   - majorMinor: In case the version consists only of the major version, aninteger literal that specifies the major version. In casethe version consists of major and minor version number, afloating literal in which the decimal part is interpretedas the minor version.
  ///   - unexpectedBetweenMajorMinorAndPatchPeriod: 
  ///   - patchPeriod: If the version contains a patch number, the periodseparating the minor from the patch number.
  ///   - unexpectedBetweenPatchPeriodAndPatchVersion: 
  ///   - patchVersion: The patch version if specified.
  public init (leadingTrivia: Trivia = [], trailingTrivia: Trivia = [], unexpectedBeforeMajorMinor: ExpressibleAsUnexpectedNodes? = nil, majorMinor: ExpressibleAsSyntaxBuildable, unexpectedBetweenMajorMinorAndPatchPeriod: ExpressibleAsUnexpectedNodes? = nil, patchPeriod: Token? = nil, unexpectedBetweenPatchPeriodAndPatchVersion: ExpressibleAsUnexpectedNodes? = nil, patchVersion: Token? = nil) {
    assert(patchPeriod == nil || patchPeriod!.text == #"."#)
    self.data = .buildable(BuildableData(leadingTrivia: leadingTrivia, trailingTrivia: trailingTrivia, unexpectedBeforeMajorMinor: unexpectedBeforeMajorMinor?.createUnexpectedNodes(), majorMinor: majorMinor.createSyntaxBuildable(), unexpectedBetweenMajorMinorAndPatchPeriod: unexpectedBetweenMajorMinorAndPatchPeriod?.createUnexpectedNodes(), patchPeriod: patchPeriod, unexpectedBetweenPatchPeriodAndPatchVersion: unexpectedBetweenPatchPeriodAndPatchVersion?.createUnexpectedNodes(), patchVersion: patchVersion))
  }
  /// A convenience initializer that allows:
  ///  - Initializing syntax collections using result builders
  ///  - Initializing tokens without default text using strings
  public init (leadingTrivia: Trivia = [], unexpectedBeforeMajorMinor: ExpressibleAsUnexpectedNodes? = nil, majorMinor: ExpressibleAsSyntaxBuildable, unexpectedBetweenMajorMinorAndPatchPeriod: ExpressibleAsUnexpectedNodes? = nil, patchPeriod: Token? = nil, unexpectedBetweenPatchPeriodAndPatchVersion: ExpressibleAsUnexpectedNodes? = nil, patchVersion: String?) {
    self.init(leadingTrivia: leadingTrivia, unexpectedBeforeMajorMinor: unexpectedBeforeMajorMinor, majorMinor: majorMinor, unexpectedBetweenMajorMinorAndPatchPeriod: unexpectedBetweenMajorMinorAndPatchPeriod, patchPeriod: patchPeriod, unexpectedBetweenPatchPeriodAndPatchVersion: unexpectedBetweenPatchPeriodAndPatchVersion, patchVersion: patchVersion.map { Token.`integerLiteral`($0) })
  }
  public init(_ constructedNode: VersionTupleSyntax) {
    self.data = .constructed(constructedNode)
  }
  /// Builds a `VersionTupleSyntax`.
  /// - Parameter format: The `Format` to use.
  /// - Parameter leadingTrivia: Additional leading trivia to attach, typically used for indentation.
  /// - Returns: The built `VersionTupleSyntax`.
  func buildVersionTuple(format: Format) -> VersionTupleSyntax {
    switch data {
    case .buildable(let buildableData): 
      var result = VersionTupleSyntax(buildableData.unexpectedBeforeMajorMinor?.buildUnexpectedNodes(format: format), majorMinor: buildableData.majorMinor.buildSyntax(format: format), buildableData.unexpectedBetweenMajorMinorAndPatchPeriod?.buildUnexpectedNodes(format: format), patchPeriod: buildableData.patchPeriod?.buildToken(format: format), buildableData.unexpectedBetweenPatchPeriodAndPatchVersion?.buildUnexpectedNodes(format: format), patchVersion: buildableData.patchVersion?.buildToken(format: format))
      if !buildableData.leadingTrivia.isEmpty {
        let trivia = (buildableData.leadingTrivia + (result.leadingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withLeadingTrivia(trivia)
      }
      if !buildableData.trailingTrivia.isEmpty {
        let trivia = (buildableData.trailingTrivia + (result.trailingTrivia ?? [])).indented(indentation: format.indentTrivia)
        result = result.withTrailingTrivia(trivia)
      }
      return format.format(syntax: result)
    case .constructed(let node): 
      return Indenter.indent(node, indentation: format.indentTrivia)
    }
  }
  /// Conformance to `SyntaxBuildable`.
  public func buildSyntax(format: Format) -> Syntax {
    let result = buildVersionTuple(format: format)
    return Syntax(result)
  }
  /// Conformance to `ExpressibleAsVersionTuple`.
  public func createVersionTuple() -> VersionTuple {
    return self
  }
  /// Conformance to `ExpressibleAsSyntaxBuildable`.
  /// `VersionTuple` may conform to `ExpressibleAsSyntaxBuildable` via different `ExpressibleAs*` paths.
  /// Thus, there are multiple default implementations of `createSyntaxBuildable`, some of which perform conversions
  /// through `ExpressibleAs*` protocols. To resolve the ambiguity, provie a fixed implementation that doesn't perform any conversions.
  public func createSyntaxBuildable() -> SyntaxBuildable {
    return self
  }
  public func withLeadingTrivia(_ leadingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.leadingTrivia = leadingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withLeadingTrivia(leadingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
  public func withTrailingTrivia(_ trailingTrivia: Trivia) -> Self {
    switch data {
    case .buildable(var buildableData):
      buildableData.trailingTrivia = trailingTrivia
      var result = self
      result.data = .buildable(buildableData)
      return result
    case .constructed(let node):
      let withNewTrivia = node.withTrailingTrivia(trailingTrivia)
      var result = self
      result.data = .constructed(withNewTrivia)
      return result
    }
  }
}
