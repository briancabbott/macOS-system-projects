
//// Automatically Generated by generate-swiftsyntaxbuilder
//// Do Not Edit Directly!
//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2022 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

import SwiftSyntax
public protocol ExpressibleAsDeclBuildable: ExpressibleAsCodeBlockItem, ExpressibleAsMemberDeclListItem {
  func createDeclBuildable() -> DeclBuildable
}
public extension ExpressibleAsDeclBuildable {
  /// Conformance to ExpressibleAsCodeBlockItem
  func createCodeBlockItem() -> CodeBlockItem {
    return CodeBlockItem(item: self)
  }
  /// Conformance to ExpressibleAsMemberDeclListItem
  func createMemberDeclListItem() -> MemberDeclListItem {
    return MemberDeclListItem(decl: self)
  }
}
public protocol ExpressibleAsExprBuildable: ExpressibleAsExprList, ExpressibleAsCodeBlockItem, ExpressibleAsInitializerClause {
  func createExprBuildable() -> ExprBuildable
}
public extension ExpressibleAsExprBuildable {
  /// Conformance to `ExpressibleAsExprList`
  func createExprList() -> ExprList {
    return ExprList([self])
  }
  /// Conformance to ExpressibleAsCodeBlockItem
  func createCodeBlockItem() -> CodeBlockItem {
    return CodeBlockItem(item: self)
  }
  /// Conformance to ExpressibleAsInitializerClause
  func createInitializerClause() -> InitializerClause {
    return InitializerClause(value: self)
  }
}
public protocol ExpressibleAsPatternBuildable {
  func createPatternBuildable() -> PatternBuildable
}
public protocol ExpressibleAsStmtBuildable: ExpressibleAsCodeBlockItem {
  func createStmtBuildable() -> StmtBuildable
}
public extension ExpressibleAsStmtBuildable {
  /// Conformance to ExpressibleAsCodeBlockItem
  func createCodeBlockItem() -> CodeBlockItem {
    return CodeBlockItem(item: self)
  }
}
public protocol ExpressibleAsSyntaxBuildable: ExpressibleAsUnexpectedNodes, ExpressibleAsStringLiteralSegments, ExpressibleAsPrecedenceGroupAttributeList, ExpressibleAsAttributeList, ExpressibleAsSpecializeAttributeSpecList, ExpressibleAsSwitchCaseList {
  func createSyntaxBuildable() -> SyntaxBuildable
}
public extension ExpressibleAsSyntaxBuildable {
  /// Conformance to `ExpressibleAsUnexpectedNodes`
  func createUnexpectedNodes() -> UnexpectedNodes {
    return UnexpectedNodes([self])
  }
  /// Conformance to `ExpressibleAsStringLiteralSegments`
  func createStringLiteralSegments() -> StringLiteralSegments {
    return StringLiteralSegments([self])
  }
  /// Conformance to `ExpressibleAsPrecedenceGroupAttributeList`
  func createPrecedenceGroupAttributeList() -> PrecedenceGroupAttributeList {
    return PrecedenceGroupAttributeList([self])
  }
  /// Conformance to `ExpressibleAsAttributeList`
  func createAttributeList() -> AttributeList {
    return AttributeList([self])
  }
  /// Conformance to `ExpressibleAsSpecializeAttributeSpecList`
  func createSpecializeAttributeSpecList() -> SpecializeAttributeSpecList {
    return SpecializeAttributeSpecList([self])
  }
  /// Conformance to `ExpressibleAsSwitchCaseList`
  func createSwitchCaseList() -> SwitchCaseList {
    return SwitchCaseList([self])
  }
}
public protocol ExpressibleAsTypeBuildable: ExpressibleAsReturnClause, ExpressibleAsTypeInitializerClause, ExpressibleAsTypeAnnotation {
  func createTypeBuildable() -> TypeBuildable
}
public extension ExpressibleAsTypeBuildable {
  /// Conformance to ExpressibleAsReturnClause
  func createReturnClause() -> ReturnClause {
    return ReturnClause(returnType: self)
  }
  /// Conformance to ExpressibleAsTypeInitializerClause
  func createTypeInitializerClause() -> TypeInitializerClause {
    return TypeInitializerClause(value: self)
  }
  /// Conformance to ExpressibleAsTypeAnnotation
  func createTypeAnnotation() -> TypeAnnotation {
    return TypeAnnotation(type: self)
  }
}
public protocol ExpressibleAsCodeBlockItem: ExpressibleAsCodeBlockItemList {
  func createCodeBlockItem() -> CodeBlockItem
}
public extension ExpressibleAsCodeBlockItem {
  /// Conformance to `ExpressibleAsCodeBlockItemList`
  func createCodeBlockItemList() -> CodeBlockItemList {
    return CodeBlockItemList([self])
  }
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createCodeBlockItem()
  }
}
public protocol ExpressibleAsCodeBlockItemList: ExpressibleAsCodeBlock {
  func createCodeBlockItemList() -> CodeBlockItemList
}
public extension ExpressibleAsCodeBlockItemList {
  /// Conformance to ExpressibleAsCodeBlock
  func createCodeBlock() -> CodeBlock {
    return CodeBlock(statements: self)
  }
}
public protocol ExpressibleAsCodeBlock: ExpressibleAsSyntaxBuildable {
  func createCodeBlock() -> CodeBlock
}
public extension ExpressibleAsCodeBlock {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createCodeBlock()
  }
}
public protocol ExpressibleAsUnexpectedNodes {
  func createUnexpectedNodes() -> UnexpectedNodes
}
public protocol ExpressibleAsInOutExpr: ExpressibleAsExprBuildable {
  func createInOutExpr() -> InOutExpr
}
public extension ExpressibleAsInOutExpr {
  func createExprBuildable() -> ExprBuildable {
    return createInOutExpr()
  }
}
public protocol ExpressibleAsPoundColumnExpr: ExpressibleAsExprBuildable {
  func createPoundColumnExpr() -> PoundColumnExpr
}
public extension ExpressibleAsPoundColumnExpr {
  func createExprBuildable() -> ExprBuildable {
    return createPoundColumnExpr()
  }
}
public protocol ExpressibleAsTupleExprElementList {
  func createTupleExprElementList() -> TupleExprElementList
}
public protocol ExpressibleAsArrayElementList: ExpressibleAsArrayExpr {
  func createArrayElementList() -> ArrayElementList
}
public extension ExpressibleAsArrayElementList {
  /// Conformance to ExpressibleAsArrayExpr
  func createArrayExpr() -> ArrayExpr {
    return ArrayExpr(elements: self)
  }
}
public protocol ExpressibleAsDictionaryElementList {
  func createDictionaryElementList() -> DictionaryElementList
}
public protocol ExpressibleAsStringLiteralSegments {
  func createStringLiteralSegments() -> StringLiteralSegments
}
public protocol ExpressibleAsTryExpr: ExpressibleAsExprBuildable {
  func createTryExpr() -> TryExpr
}
public extension ExpressibleAsTryExpr {
  func createExprBuildable() -> ExprBuildable {
    return createTryExpr()
  }
}
public protocol ExpressibleAsAwaitExpr: ExpressibleAsExprBuildable {
  func createAwaitExpr() -> AwaitExpr
}
public extension ExpressibleAsAwaitExpr {
  func createExprBuildable() -> ExprBuildable {
    return createAwaitExpr()
  }
}
public protocol ExpressibleAsMoveExpr: ExpressibleAsExprBuildable {
  func createMoveExpr() -> MoveExpr
}
public extension ExpressibleAsMoveExpr {
  func createExprBuildable() -> ExprBuildable {
    return createMoveExpr()
  }
}
public protocol ExpressibleAsDeclNameArgument: ExpressibleAsDeclNameArgumentList, ExpressibleAsSyntaxBuildable {
  func createDeclNameArgument() -> DeclNameArgument
}
public extension ExpressibleAsDeclNameArgument {
  /// Conformance to `ExpressibleAsDeclNameArgumentList`
  func createDeclNameArgumentList() -> DeclNameArgumentList {
    return DeclNameArgumentList([self])
  }
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createDeclNameArgument()
  }
}
public protocol ExpressibleAsDeclNameArgumentList {
  func createDeclNameArgumentList() -> DeclNameArgumentList
}
public protocol ExpressibleAsDeclNameArguments: ExpressibleAsSyntaxBuildable {
  func createDeclNameArguments() -> DeclNameArguments
}
public extension ExpressibleAsDeclNameArguments {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createDeclNameArguments()
  }
}
public protocol ExpressibleAsIdentifierExpr: ExpressibleAsExprBuildable {
  func createIdentifierExpr() -> IdentifierExpr
}
public extension ExpressibleAsIdentifierExpr {
  func createExprBuildable() -> ExprBuildable {
    return createIdentifierExpr()
  }
}
public protocol ExpressibleAsSuperRefExpr: ExpressibleAsExprBuildable {
  func createSuperRefExpr() -> SuperRefExpr
}
public extension ExpressibleAsSuperRefExpr {
  func createExprBuildable() -> ExprBuildable {
    return createSuperRefExpr()
  }
}
public protocol ExpressibleAsNilLiteralExpr: ExpressibleAsExprBuildable {
  func createNilLiteralExpr() -> NilLiteralExpr
}
public extension ExpressibleAsNilLiteralExpr {
  func createExprBuildable() -> ExprBuildable {
    return createNilLiteralExpr()
  }
}
public protocol ExpressibleAsDiscardAssignmentExpr: ExpressibleAsExprBuildable {
  func createDiscardAssignmentExpr() -> DiscardAssignmentExpr
}
public extension ExpressibleAsDiscardAssignmentExpr {
  func createExprBuildable() -> ExprBuildable {
    return createDiscardAssignmentExpr()
  }
}
public protocol ExpressibleAsAssignmentExpr: ExpressibleAsExprBuildable {
  func createAssignmentExpr() -> AssignmentExpr
}
public extension ExpressibleAsAssignmentExpr {
  func createExprBuildable() -> ExprBuildable {
    return createAssignmentExpr()
  }
}
public protocol ExpressibleAsSequenceExpr: ExpressibleAsTupleExprElement, ExpressibleAsExprBuildable {
  func createSequenceExpr() -> SequenceExpr
}
public extension ExpressibleAsSequenceExpr {
  /// Conformance to ExpressibleAsCodeBlockItem
  func createCodeBlockItem() -> CodeBlockItem {
    return CodeBlockItem(item: self)
  }
  /// Conformance to ExpressibleAsTupleExprElement
  func createTupleExprElement() -> TupleExprElement {
    return TupleExprElement(expression: self)
  }
  func createExprBuildable() -> ExprBuildable {
    return createSequenceExpr()
  }
}
public protocol ExpressibleAsExprList: ExpressibleAsConditionElement {
  func createExprList() -> ExprList
}
public extension ExpressibleAsExprList {
  /// Conformance to ExpressibleAsConditionElement
  func createConditionElement() -> ConditionElement {
    return ConditionElement(condition: self)
  }
}
public protocol ExpressibleAsPoundLineExpr: ExpressibleAsExprBuildable {
  func createPoundLineExpr() -> PoundLineExpr
}
public extension ExpressibleAsPoundLineExpr {
  func createExprBuildable() -> ExprBuildable {
    return createPoundLineExpr()
  }
}
public protocol ExpressibleAsPoundFileExpr: ExpressibleAsExprBuildable {
  func createPoundFileExpr() -> PoundFileExpr
}
public extension ExpressibleAsPoundFileExpr {
  func createExprBuildable() -> ExprBuildable {
    return createPoundFileExpr()
  }
}
public protocol ExpressibleAsPoundFileIDExpr: ExpressibleAsExprBuildable {
  func createPoundFileIDExpr() -> PoundFileIDExpr
}
public extension ExpressibleAsPoundFileIDExpr {
  func createExprBuildable() -> ExprBuildable {
    return createPoundFileIDExpr()
  }
}
public protocol ExpressibleAsPoundFilePathExpr: ExpressibleAsExprBuildable {
  func createPoundFilePathExpr() -> PoundFilePathExpr
}
public extension ExpressibleAsPoundFilePathExpr {
  func createExprBuildable() -> ExprBuildable {
    return createPoundFilePathExpr()
  }
}
public protocol ExpressibleAsPoundFunctionExpr: ExpressibleAsExprBuildable {
  func createPoundFunctionExpr() -> PoundFunctionExpr
}
public extension ExpressibleAsPoundFunctionExpr {
  func createExprBuildable() -> ExprBuildable {
    return createPoundFunctionExpr()
  }
}
public protocol ExpressibleAsPoundDsohandleExpr: ExpressibleAsExprBuildable {
  func createPoundDsohandleExpr() -> PoundDsohandleExpr
}
public extension ExpressibleAsPoundDsohandleExpr {
  func createExprBuildable() -> ExprBuildable {
    return createPoundDsohandleExpr()
  }
}
public protocol ExpressibleAsSymbolicReferenceExpr: ExpressibleAsExprBuildable {
  func createSymbolicReferenceExpr() -> SymbolicReferenceExpr
}
public extension ExpressibleAsSymbolicReferenceExpr {
  func createExprBuildable() -> ExprBuildable {
    return createSymbolicReferenceExpr()
  }
}
public protocol ExpressibleAsPrefixOperatorExpr: ExpressibleAsExprBuildable {
  func createPrefixOperatorExpr() -> PrefixOperatorExpr
}
public extension ExpressibleAsPrefixOperatorExpr {
  func createExprBuildable() -> ExprBuildable {
    return createPrefixOperatorExpr()
  }
}
public protocol ExpressibleAsBinaryOperatorExpr: ExpressibleAsExprBuildable {
  func createBinaryOperatorExpr() -> BinaryOperatorExpr
}
public extension ExpressibleAsBinaryOperatorExpr {
  func createExprBuildable() -> ExprBuildable {
    return createBinaryOperatorExpr()
  }
}
public protocol ExpressibleAsArrowExpr: ExpressibleAsExprBuildable {
  func createArrowExpr() -> ArrowExpr
}
public extension ExpressibleAsArrowExpr {
  func createExprBuildable() -> ExprBuildable {
    return createArrowExpr()
  }
}
public protocol ExpressibleAsInfixOperatorExpr: ExpressibleAsExprBuildable {
  func createInfixOperatorExpr() -> InfixOperatorExpr
}
public extension ExpressibleAsInfixOperatorExpr {
  func createExprBuildable() -> ExprBuildable {
    return createInfixOperatorExpr()
  }
}
public protocol ExpressibleAsFloatLiteralExpr: ExpressibleAsExprBuildable {
  func createFloatLiteralExpr() -> FloatLiteralExpr
}
public extension ExpressibleAsFloatLiteralExpr {
  func createExprBuildable() -> ExprBuildable {
    return createFloatLiteralExpr()
  }
}
public protocol ExpressibleAsTupleExpr: ExpressibleAsExprBuildable {
  func createTupleExpr() -> TupleExpr
}
public extension ExpressibleAsTupleExpr {
  func createExprBuildable() -> ExprBuildable {
    return createTupleExpr()
  }
}
public protocol ExpressibleAsArrayExpr: ExpressibleAsExprBuildable {
  func createArrayExpr() -> ArrayExpr
}
public extension ExpressibleAsArrayExpr {
  func createExprBuildable() -> ExprBuildable {
    return createArrayExpr()
  }
}
public protocol ExpressibleAsDictionaryExpr: ExpressibleAsExprBuildable {
  func createDictionaryExpr() -> DictionaryExpr
}
public extension ExpressibleAsDictionaryExpr {
  func createExprBuildable() -> ExprBuildable {
    return createDictionaryExpr()
  }
}
public protocol ExpressibleAsTupleExprElement: ExpressibleAsTupleExprElementList, ExpressibleAsSyntaxBuildable {
  func createTupleExprElement() -> TupleExprElement
}
public extension ExpressibleAsTupleExprElement {
  /// Conformance to `ExpressibleAsTupleExprElementList`
  func createTupleExprElementList() -> TupleExprElementList {
    return TupleExprElementList([self])
  }
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createTupleExprElement()
  }
}
public protocol ExpressibleAsArrayElement: ExpressibleAsArrayElementList {
  func createArrayElement() -> ArrayElement
}
public extension ExpressibleAsArrayElement {
  /// Conformance to `ExpressibleAsArrayElementList`
  func createArrayElementList() -> ArrayElementList {
    return ArrayElementList([self])
  }
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createArrayElement()
  }
}
public protocol ExpressibleAsDictionaryElement: ExpressibleAsDictionaryElementList, ExpressibleAsSyntaxBuildable {
  func createDictionaryElement() -> DictionaryElement
}
public extension ExpressibleAsDictionaryElement {
  /// Conformance to `ExpressibleAsDictionaryElementList`
  func createDictionaryElementList() -> DictionaryElementList {
    return DictionaryElementList([self])
  }
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createDictionaryElement()
  }
}
public protocol ExpressibleAsIntegerLiteralExpr: ExpressibleAsExprBuildable {
  func createIntegerLiteralExpr() -> IntegerLiteralExpr
}
public extension ExpressibleAsIntegerLiteralExpr {
  func createExprBuildable() -> ExprBuildable {
    return createIntegerLiteralExpr()
  }
}
public protocol ExpressibleAsBooleanLiteralExpr: ExpressibleAsExprBuildable {
  func createBooleanLiteralExpr() -> BooleanLiteralExpr
}
public extension ExpressibleAsBooleanLiteralExpr {
  func createExprBuildable() -> ExprBuildable {
    return createBooleanLiteralExpr()
  }
}
public protocol ExpressibleAsUnresolvedTernaryExpr: ExpressibleAsExprBuildable {
  func createUnresolvedTernaryExpr() -> UnresolvedTernaryExpr
}
public extension ExpressibleAsUnresolvedTernaryExpr {
  func createExprBuildable() -> ExprBuildable {
    return createUnresolvedTernaryExpr()
  }
}
public protocol ExpressibleAsTernaryExpr: ExpressibleAsExprBuildable {
  func createTernaryExpr() -> TernaryExpr
}
public extension ExpressibleAsTernaryExpr {
  func createExprBuildable() -> ExprBuildable {
    return createTernaryExpr()
  }
}
public protocol ExpressibleAsMemberAccessExpr: ExpressibleAsExprBuildable {
  func createMemberAccessExpr() -> MemberAccessExpr
}
public extension ExpressibleAsMemberAccessExpr {
  func createExprBuildable() -> ExprBuildable {
    return createMemberAccessExpr()
  }
}
public protocol ExpressibleAsUnresolvedIsExpr: ExpressibleAsExprBuildable {
  func createUnresolvedIsExpr() -> UnresolvedIsExpr
}
public extension ExpressibleAsUnresolvedIsExpr {
  func createExprBuildable() -> ExprBuildable {
    return createUnresolvedIsExpr()
  }
}
public protocol ExpressibleAsIsExpr: ExpressibleAsExprBuildable {
  func createIsExpr() -> IsExpr
}
public extension ExpressibleAsIsExpr {
  func createExprBuildable() -> ExprBuildable {
    return createIsExpr()
  }
}
public protocol ExpressibleAsUnresolvedAsExpr: ExpressibleAsExprBuildable {
  func createUnresolvedAsExpr() -> UnresolvedAsExpr
}
public extension ExpressibleAsUnresolvedAsExpr {
  func createExprBuildable() -> ExprBuildable {
    return createUnresolvedAsExpr()
  }
}
public protocol ExpressibleAsAsExpr: ExpressibleAsExprBuildable {
  func createAsExpr() -> AsExpr
}
public extension ExpressibleAsAsExpr {
  func createExprBuildable() -> ExprBuildable {
    return createAsExpr()
  }
}
public protocol ExpressibleAsTypeExpr: ExpressibleAsExprBuildable {
  func createTypeExpr() -> TypeExpr
}
public extension ExpressibleAsTypeExpr {
  func createExprBuildable() -> ExprBuildable {
    return createTypeExpr()
  }
}
public protocol ExpressibleAsClosureCaptureItem: ExpressibleAsClosureCaptureItemList, ExpressibleAsSyntaxBuildable {
  func createClosureCaptureItem() -> ClosureCaptureItem
}
public extension ExpressibleAsClosureCaptureItem {
  /// Conformance to `ExpressibleAsClosureCaptureItemList`
  func createClosureCaptureItemList() -> ClosureCaptureItemList {
    return ClosureCaptureItemList([self])
  }
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createClosureCaptureItem()
  }
}
public protocol ExpressibleAsClosureCaptureItemList {
  func createClosureCaptureItemList() -> ClosureCaptureItemList
}
public protocol ExpressibleAsClosureCaptureSignature: ExpressibleAsSyntaxBuildable {
  func createClosureCaptureSignature() -> ClosureCaptureSignature
}
public extension ExpressibleAsClosureCaptureSignature {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createClosureCaptureSignature()
  }
}
public protocol ExpressibleAsClosureParam: ExpressibleAsClosureParamList, ExpressibleAsSyntaxBuildable {
  func createClosureParam() -> ClosureParam
}
public extension ExpressibleAsClosureParam {
  /// Conformance to `ExpressibleAsClosureParamList`
  func createClosureParamList() -> ClosureParamList {
    return ClosureParamList([self])
  }
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createClosureParam()
  }
}
public protocol ExpressibleAsClosureParamList {
  func createClosureParamList() -> ClosureParamList
}
public protocol ExpressibleAsClosureSignature: ExpressibleAsSyntaxBuildable {
  func createClosureSignature() -> ClosureSignature
}
public extension ExpressibleAsClosureSignature {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createClosureSignature()
  }
}
public protocol ExpressibleAsClosureExpr: ExpressibleAsExprBuildable {
  func createClosureExpr() -> ClosureExpr
}
public extension ExpressibleAsClosureExpr {
  func createExprBuildable() -> ExprBuildable {
    return createClosureExpr()
  }
}
public protocol ExpressibleAsUnresolvedPatternExpr: ExpressibleAsExprBuildable {
  func createUnresolvedPatternExpr() -> UnresolvedPatternExpr
}
public extension ExpressibleAsUnresolvedPatternExpr {
  func createExprBuildable() -> ExprBuildable {
    return createUnresolvedPatternExpr()
  }
}
public protocol ExpressibleAsMultipleTrailingClosureElement: ExpressibleAsMultipleTrailingClosureElementList, ExpressibleAsSyntaxBuildable {
  func createMultipleTrailingClosureElement() -> MultipleTrailingClosureElement
}
public extension ExpressibleAsMultipleTrailingClosureElement {
  /// Conformance to `ExpressibleAsMultipleTrailingClosureElementList`
  func createMultipleTrailingClosureElementList() -> MultipleTrailingClosureElementList {
    return MultipleTrailingClosureElementList([self])
  }
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createMultipleTrailingClosureElement()
  }
}
public protocol ExpressibleAsMultipleTrailingClosureElementList {
  func createMultipleTrailingClosureElementList() -> MultipleTrailingClosureElementList
}
public protocol ExpressibleAsFunctionCallExpr: ExpressibleAsExprBuildable {
  func createFunctionCallExpr() -> FunctionCallExpr
}
public extension ExpressibleAsFunctionCallExpr {
  func createExprBuildable() -> ExprBuildable {
    return createFunctionCallExpr()
  }
}
public protocol ExpressibleAsSubscriptExpr: ExpressibleAsExprBuildable {
  func createSubscriptExpr() -> SubscriptExpr
}
public extension ExpressibleAsSubscriptExpr {
  func createExprBuildable() -> ExprBuildable {
    return createSubscriptExpr()
  }
}
public protocol ExpressibleAsOptionalChainingExpr: ExpressibleAsExprBuildable {
  func createOptionalChainingExpr() -> OptionalChainingExpr
}
public extension ExpressibleAsOptionalChainingExpr {
  func createExprBuildable() -> ExprBuildable {
    return createOptionalChainingExpr()
  }
}
public protocol ExpressibleAsForcedValueExpr: ExpressibleAsExprBuildable {
  func createForcedValueExpr() -> ForcedValueExpr
}
public extension ExpressibleAsForcedValueExpr {
  func createExprBuildable() -> ExprBuildable {
    return createForcedValueExpr()
  }
}
public protocol ExpressibleAsPostfixUnaryExpr: ExpressibleAsExprBuildable {
  func createPostfixUnaryExpr() -> PostfixUnaryExpr
}
public extension ExpressibleAsPostfixUnaryExpr {
  func createExprBuildable() -> ExprBuildable {
    return createPostfixUnaryExpr()
  }
}
public protocol ExpressibleAsSpecializeExpr: ExpressibleAsExprBuildable {
  func createSpecializeExpr() -> SpecializeExpr
}
public extension ExpressibleAsSpecializeExpr {
  func createExprBuildable() -> ExprBuildable {
    return createSpecializeExpr()
  }
}
public protocol ExpressibleAsStringSegment: ExpressibleAsSyntaxBuildable {
  func createStringSegment() -> StringSegment
}
public extension ExpressibleAsStringSegment {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createStringSegment()
  }
}
public protocol ExpressibleAsExpressionSegment: ExpressibleAsSyntaxBuildable {
  func createExpressionSegment() -> ExpressionSegment
}
public extension ExpressibleAsExpressionSegment {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createExpressionSegment()
  }
}
public protocol ExpressibleAsStringLiteralExpr: ExpressibleAsExprBuildable {
  func createStringLiteralExpr() -> StringLiteralExpr
}
public extension ExpressibleAsStringLiteralExpr {
  func createExprBuildable() -> ExprBuildable {
    return createStringLiteralExpr()
  }
}
public protocol ExpressibleAsRegexLiteralExpr: ExpressibleAsExprBuildable {
  func createRegexLiteralExpr() -> RegexLiteralExpr
}
public extension ExpressibleAsRegexLiteralExpr {
  func createExprBuildable() -> ExprBuildable {
    return createRegexLiteralExpr()
  }
}
public protocol ExpressibleAsKeyPathExpr: ExpressibleAsExprBuildable {
  func createKeyPathExpr() -> KeyPathExpr
}
public extension ExpressibleAsKeyPathExpr {
  func createExprBuildable() -> ExprBuildable {
    return createKeyPathExpr()
  }
}
public protocol ExpressibleAsKeyPathComponentList {
  func createKeyPathComponentList() -> KeyPathComponentList
}
public protocol ExpressibleAsKeyPathComponent: ExpressibleAsKeyPathComponentList, ExpressibleAsSyntaxBuildable {
  func createKeyPathComponent() -> KeyPathComponent
}
public extension ExpressibleAsKeyPathComponent {
  /// Conformance to `ExpressibleAsKeyPathComponentList`
  func createKeyPathComponentList() -> KeyPathComponentList {
    return KeyPathComponentList([self])
  }
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createKeyPathComponent()
  }
}
public protocol ExpressibleAsKeyPathPropertyComponent: ExpressibleAsSyntaxBuildable {
  func createKeyPathPropertyComponent() -> KeyPathPropertyComponent
}
public extension ExpressibleAsKeyPathPropertyComponent {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createKeyPathPropertyComponent()
  }
}
public protocol ExpressibleAsKeyPathSubscriptComponent: ExpressibleAsSyntaxBuildable {
  func createKeyPathSubscriptComponent() -> KeyPathSubscriptComponent
}
public extension ExpressibleAsKeyPathSubscriptComponent {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createKeyPathSubscriptComponent()
  }
}
public protocol ExpressibleAsKeyPathOptionalComponent: ExpressibleAsSyntaxBuildable {
  func createKeyPathOptionalComponent() -> KeyPathOptionalComponent
}
public extension ExpressibleAsKeyPathOptionalComponent {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createKeyPathOptionalComponent()
  }
}
public protocol ExpressibleAsOldKeyPathExpr: ExpressibleAsExprBuildable {
  func createOldKeyPathExpr() -> OldKeyPathExpr
}
public extension ExpressibleAsOldKeyPathExpr {
  func createExprBuildable() -> ExprBuildable {
    return createOldKeyPathExpr()
  }
}
public protocol ExpressibleAsKeyPathBaseExpr: ExpressibleAsExprBuildable {
  func createKeyPathBaseExpr() -> KeyPathBaseExpr
}
public extension ExpressibleAsKeyPathBaseExpr {
  func createExprBuildable() -> ExprBuildable {
    return createKeyPathBaseExpr()
  }
}
public protocol ExpressibleAsObjcNamePiece: ExpressibleAsObjcName, ExpressibleAsSyntaxBuildable {
  func createObjcNamePiece() -> ObjcNamePiece
}
public extension ExpressibleAsObjcNamePiece {
  /// Conformance to `ExpressibleAsObjcName`
  func createObjcName() -> ObjcName {
    return ObjcName([self])
  }
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createObjcNamePiece()
  }
}
public protocol ExpressibleAsObjcName {
  func createObjcName() -> ObjcName
}
public protocol ExpressibleAsObjcKeyPathExpr: ExpressibleAsExprBuildable {
  func createObjcKeyPathExpr() -> ObjcKeyPathExpr
}
public extension ExpressibleAsObjcKeyPathExpr {
  func createExprBuildable() -> ExprBuildable {
    return createObjcKeyPathExpr()
  }
}
public protocol ExpressibleAsObjcSelectorExpr: ExpressibleAsExprBuildable {
  func createObjcSelectorExpr() -> ObjcSelectorExpr
}
public extension ExpressibleAsObjcSelectorExpr {
  func createExprBuildable() -> ExprBuildable {
    return createObjcSelectorExpr()
  }
}
public protocol ExpressibleAsPostfixIfConfigExpr: ExpressibleAsExprBuildable {
  func createPostfixIfConfigExpr() -> PostfixIfConfigExpr
}
public extension ExpressibleAsPostfixIfConfigExpr {
  func createExprBuildable() -> ExprBuildable {
    return createPostfixIfConfigExpr()
  }
}
public protocol ExpressibleAsEditorPlaceholderExpr: ExpressibleAsExprBuildable {
  func createEditorPlaceholderExpr() -> EditorPlaceholderExpr
}
public extension ExpressibleAsEditorPlaceholderExpr {
  func createExprBuildable() -> ExprBuildable {
    return createEditorPlaceholderExpr()
  }
}
public protocol ExpressibleAsObjectLiteralExpr: ExpressibleAsExprBuildable {
  func createObjectLiteralExpr() -> ObjectLiteralExpr
}
public extension ExpressibleAsObjectLiteralExpr {
  func createExprBuildable() -> ExprBuildable {
    return createObjectLiteralExpr()
  }
}
public protocol ExpressibleAsYieldExprList {
  func createYieldExprList() -> YieldExprList
}
public protocol ExpressibleAsYieldExprListElement: ExpressibleAsYieldExprList, ExpressibleAsSyntaxBuildable {
  func createYieldExprListElement() -> YieldExprListElement
}
public extension ExpressibleAsYieldExprListElement {
  /// Conformance to `ExpressibleAsYieldExprList`
  func createYieldExprList() -> YieldExprList {
    return YieldExprList([self])
  }
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createYieldExprListElement()
  }
}
public protocol ExpressibleAsTypeInitializerClause: ExpressibleAsSyntaxBuildable {
  func createTypeInitializerClause() -> TypeInitializerClause
}
public extension ExpressibleAsTypeInitializerClause {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createTypeInitializerClause()
  }
}
public protocol ExpressibleAsTypealiasDecl: ExpressibleAsDeclBuildable {
  func createTypealiasDecl() -> TypealiasDecl
}
public extension ExpressibleAsTypealiasDecl {
  func createDeclBuildable() -> DeclBuildable {
    return createTypealiasDecl()
  }
}
public protocol ExpressibleAsAssociatedtypeDecl: ExpressibleAsDeclBuildable {
  func createAssociatedtypeDecl() -> AssociatedtypeDecl
}
public extension ExpressibleAsAssociatedtypeDecl {
  func createDeclBuildable() -> DeclBuildable {
    return createAssociatedtypeDecl()
  }
}
public protocol ExpressibleAsFunctionParameterList {
  func createFunctionParameterList() -> FunctionParameterList
}
public protocol ExpressibleAsParameterClause: ExpressibleAsSyntaxBuildable {
  func createParameterClause() -> ParameterClause
}
public extension ExpressibleAsParameterClause {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createParameterClause()
  }
}
public protocol ExpressibleAsReturnClause: ExpressibleAsSyntaxBuildable {
  func createReturnClause() -> ReturnClause
}
public extension ExpressibleAsReturnClause {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createReturnClause()
  }
}
public protocol ExpressibleAsFunctionSignature: ExpressibleAsSyntaxBuildable {
  func createFunctionSignature() -> FunctionSignature
}
public extension ExpressibleAsFunctionSignature {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createFunctionSignature()
  }
}
public protocol ExpressibleAsIfConfigClause: ExpressibleAsIfConfigClauseList, ExpressibleAsSyntaxBuildable {
  func createIfConfigClause() -> IfConfigClause
}
public extension ExpressibleAsIfConfigClause {
  /// Conformance to `ExpressibleAsIfConfigClauseList`
  func createIfConfigClauseList() -> IfConfigClauseList {
    return IfConfigClauseList([self])
  }
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createIfConfigClause()
  }
}
public protocol ExpressibleAsIfConfigClauseList {
  func createIfConfigClauseList() -> IfConfigClauseList
}
public protocol ExpressibleAsIfConfigDecl: ExpressibleAsDeclBuildable {
  func createIfConfigDecl() -> IfConfigDecl
}
public extension ExpressibleAsIfConfigDecl {
  func createDeclBuildable() -> DeclBuildable {
    return createIfConfigDecl()
  }
}
public protocol ExpressibleAsPoundErrorDecl: ExpressibleAsDeclBuildable {
  func createPoundErrorDecl() -> PoundErrorDecl
}
public extension ExpressibleAsPoundErrorDecl {
  func createDeclBuildable() -> DeclBuildable {
    return createPoundErrorDecl()
  }
}
public protocol ExpressibleAsPoundWarningDecl: ExpressibleAsDeclBuildable {
  func createPoundWarningDecl() -> PoundWarningDecl
}
public extension ExpressibleAsPoundWarningDecl {
  func createDeclBuildable() -> DeclBuildable {
    return createPoundWarningDecl()
  }
}
public protocol ExpressibleAsPoundSourceLocation: ExpressibleAsDeclBuildable {
  func createPoundSourceLocation() -> PoundSourceLocation
}
public extension ExpressibleAsPoundSourceLocation {
  func createDeclBuildable() -> DeclBuildable {
    return createPoundSourceLocation()
  }
}
public protocol ExpressibleAsPoundSourceLocationArgs: ExpressibleAsSyntaxBuildable {
  func createPoundSourceLocationArgs() -> PoundSourceLocationArgs
}
public extension ExpressibleAsPoundSourceLocationArgs {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createPoundSourceLocationArgs()
  }
}
public protocol ExpressibleAsDeclModifierDetail: ExpressibleAsSyntaxBuildable {
  func createDeclModifierDetail() -> DeclModifierDetail
}
public extension ExpressibleAsDeclModifierDetail {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createDeclModifierDetail()
  }
}
public protocol ExpressibleAsDeclModifier: ExpressibleAsModifierList, ExpressibleAsSyntaxBuildable {
  func createDeclModifier() -> DeclModifier
}
public extension ExpressibleAsDeclModifier {
  /// Conformance to `ExpressibleAsModifierList`
  func createModifierList() -> ModifierList {
    return ModifierList([self])
  }
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createDeclModifier()
  }
}
public protocol ExpressibleAsInheritedType: ExpressibleAsInheritedTypeList, ExpressibleAsSyntaxBuildable {
  func createInheritedType() -> InheritedType
}
public extension ExpressibleAsInheritedType {
  /// Conformance to `ExpressibleAsInheritedTypeList`
  func createInheritedTypeList() -> InheritedTypeList {
    return InheritedTypeList([self])
  }
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createInheritedType()
  }
}
public protocol ExpressibleAsInheritedTypeList {
  func createInheritedTypeList() -> InheritedTypeList
}
public protocol ExpressibleAsTypeInheritanceClause: ExpressibleAsSyntaxBuildable {
  func createTypeInheritanceClause() -> TypeInheritanceClause
}
public extension ExpressibleAsTypeInheritanceClause {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createTypeInheritanceClause()
  }
}
public protocol ExpressibleAsClassDecl: ExpressibleAsDeclBuildable {
  func createClassDecl() -> ClassDecl
}
public extension ExpressibleAsClassDecl {
  func createDeclBuildable() -> DeclBuildable {
    return createClassDecl()
  }
}
public protocol ExpressibleAsActorDecl: ExpressibleAsDeclBuildable {
  func createActorDecl() -> ActorDecl
}
public extension ExpressibleAsActorDecl {
  func createDeclBuildable() -> DeclBuildable {
    return createActorDecl()
  }
}
public protocol ExpressibleAsStructDecl: ExpressibleAsDeclBuildable {
  func createStructDecl() -> StructDecl
}
public extension ExpressibleAsStructDecl {
  func createDeclBuildable() -> DeclBuildable {
    return createStructDecl()
  }
}
public protocol ExpressibleAsProtocolDecl: ExpressibleAsDeclBuildable {
  func createProtocolDecl() -> ProtocolDecl
}
public extension ExpressibleAsProtocolDecl {
  func createDeclBuildable() -> DeclBuildable {
    return createProtocolDecl()
  }
}
public protocol ExpressibleAsExtensionDecl: ExpressibleAsDeclBuildable {
  func createExtensionDecl() -> ExtensionDecl
}
public extension ExpressibleAsExtensionDecl {
  func createDeclBuildable() -> DeclBuildable {
    return createExtensionDecl()
  }
}
public protocol ExpressibleAsMemberDeclBlock: ExpressibleAsSyntaxBuildable {
  func createMemberDeclBlock() -> MemberDeclBlock
}
public extension ExpressibleAsMemberDeclBlock {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createMemberDeclBlock()
  }
}
public protocol ExpressibleAsMemberDeclList: ExpressibleAsMemberDeclBlock {
  func createMemberDeclList() -> MemberDeclList
}
public extension ExpressibleAsMemberDeclList {
  /// Conformance to ExpressibleAsMemberDeclBlock
  func createMemberDeclBlock() -> MemberDeclBlock {
    return MemberDeclBlock(members: self)
  }
}
public protocol ExpressibleAsMemberDeclListItem: ExpressibleAsMemberDeclList {
  func createMemberDeclListItem() -> MemberDeclListItem
}
public extension ExpressibleAsMemberDeclListItem {
  /// Conformance to `ExpressibleAsMemberDeclList`
  func createMemberDeclList() -> MemberDeclList {
    return MemberDeclList([self])
  }
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createMemberDeclListItem()
  }
}
public protocol ExpressibleAsSourceFile: ExpressibleAsSyntaxBuildable {
  func createSourceFile() -> SourceFile
}
public extension ExpressibleAsSourceFile {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createSourceFile()
  }
}
public protocol ExpressibleAsInitializerClause: ExpressibleAsSyntaxBuildable {
  func createInitializerClause() -> InitializerClause
}
public extension ExpressibleAsInitializerClause {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createInitializerClause()
  }
}
public protocol ExpressibleAsFunctionParameter: ExpressibleAsFunctionParameterList, ExpressibleAsSyntaxBuildable {
  func createFunctionParameter() -> FunctionParameter
}
public extension ExpressibleAsFunctionParameter {
  /// Conformance to `ExpressibleAsFunctionParameterList`
  func createFunctionParameterList() -> FunctionParameterList {
    return FunctionParameterList([self])
  }
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createFunctionParameter()
  }
}
public protocol ExpressibleAsModifierList {
  func createModifierList() -> ModifierList
}
public protocol ExpressibleAsFunctionDecl: ExpressibleAsDeclBuildable {
  func createFunctionDecl() -> FunctionDecl
}
public extension ExpressibleAsFunctionDecl {
  func createDeclBuildable() -> DeclBuildable {
    return createFunctionDecl()
  }
}
public protocol ExpressibleAsInitializerDecl: ExpressibleAsDeclBuildable {
  func createInitializerDecl() -> InitializerDecl
}
public extension ExpressibleAsInitializerDecl {
  func createDeclBuildable() -> DeclBuildable {
    return createInitializerDecl()
  }
}
public protocol ExpressibleAsDeinitializerDecl: ExpressibleAsDeclBuildable {
  func createDeinitializerDecl() -> DeinitializerDecl
}
public extension ExpressibleAsDeinitializerDecl {
  func createDeclBuildable() -> DeclBuildable {
    return createDeinitializerDecl()
  }
}
public protocol ExpressibleAsSubscriptDecl: ExpressibleAsDeclBuildable {
  func createSubscriptDecl() -> SubscriptDecl
}
public extension ExpressibleAsSubscriptDecl {
  func createDeclBuildable() -> DeclBuildable {
    return createSubscriptDecl()
  }
}
public protocol ExpressibleAsAccessLevelModifier: ExpressibleAsSyntaxBuildable {
  func createAccessLevelModifier() -> AccessLevelModifier
}
public extension ExpressibleAsAccessLevelModifier {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createAccessLevelModifier()
  }
}
public protocol ExpressibleAsAccessPathComponent: ExpressibleAsAccessPath, ExpressibleAsSyntaxBuildable {
  func createAccessPathComponent() -> AccessPathComponent
}
public extension ExpressibleAsAccessPathComponent {
  /// Conformance to `ExpressibleAsAccessPath`
  func createAccessPath() -> AccessPath {
    return AccessPath([self])
  }
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createAccessPathComponent()
  }
}
public protocol ExpressibleAsAccessPath {
  func createAccessPath() -> AccessPath
}
public protocol ExpressibleAsImportDecl: ExpressibleAsDeclBuildable {
  func createImportDecl() -> ImportDecl
}
public extension ExpressibleAsImportDecl {
  func createDeclBuildable() -> DeclBuildable {
    return createImportDecl()
  }
}
public protocol ExpressibleAsAccessorParameter: ExpressibleAsSyntaxBuildable {
  func createAccessorParameter() -> AccessorParameter
}
public extension ExpressibleAsAccessorParameter {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createAccessorParameter()
  }
}
public protocol ExpressibleAsAccessorDecl: ExpressibleAsAccessorList, ExpressibleAsDeclBuildable {
  func createAccessorDecl() -> AccessorDecl
}
public extension ExpressibleAsAccessorDecl {
  /// Conformance to `ExpressibleAsAccessorList`
  func createAccessorList() -> AccessorList {
    return AccessorList([self])
  }
  func createDeclBuildable() -> DeclBuildable {
    return createAccessorDecl()
  }
}
public protocol ExpressibleAsAccessorList: ExpressibleAsAccessorBlock {
  func createAccessorList() -> AccessorList
}
public extension ExpressibleAsAccessorList {
  /// Conformance to ExpressibleAsAccessorBlock
  func createAccessorBlock() -> AccessorBlock {
    return AccessorBlock(accessors: self)
  }
}
public protocol ExpressibleAsAccessorBlock: ExpressibleAsSyntaxBuildable {
  func createAccessorBlock() -> AccessorBlock
}
public extension ExpressibleAsAccessorBlock {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createAccessorBlock()
  }
}
public protocol ExpressibleAsPatternBinding: ExpressibleAsPatternBindingList, ExpressibleAsSyntaxBuildable {
  func createPatternBinding() -> PatternBinding
}
public extension ExpressibleAsPatternBinding {
  /// Conformance to `ExpressibleAsPatternBindingList`
  func createPatternBindingList() -> PatternBindingList {
    return PatternBindingList([self])
  }
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createPatternBinding()
  }
}
public protocol ExpressibleAsPatternBindingList {
  func createPatternBindingList() -> PatternBindingList
}
public protocol ExpressibleAsVariableDecl: ExpressibleAsDeclBuildable {
  func createVariableDecl() -> VariableDecl
}
public extension ExpressibleAsVariableDecl {
  func createDeclBuildable() -> DeclBuildable {
    return createVariableDecl()
  }
}
public protocol ExpressibleAsEnumCaseElement: ExpressibleAsEnumCaseElementList, ExpressibleAsSyntaxBuildable {
  func createEnumCaseElement() -> EnumCaseElement
}
public extension ExpressibleAsEnumCaseElement {
  /// Conformance to `ExpressibleAsEnumCaseElementList`
  func createEnumCaseElementList() -> EnumCaseElementList {
    return EnumCaseElementList([self])
  }
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createEnumCaseElement()
  }
}
public protocol ExpressibleAsEnumCaseElementList {
  func createEnumCaseElementList() -> EnumCaseElementList
}
public protocol ExpressibleAsEnumCaseDecl: ExpressibleAsDeclBuildable {
  func createEnumCaseDecl() -> EnumCaseDecl
}
public extension ExpressibleAsEnumCaseDecl {
  func createDeclBuildable() -> DeclBuildable {
    return createEnumCaseDecl()
  }
}
public protocol ExpressibleAsEnumDecl: ExpressibleAsDeclBuildable {
  func createEnumDecl() -> EnumDecl
}
public extension ExpressibleAsEnumDecl {
  func createDeclBuildable() -> DeclBuildable {
    return createEnumDecl()
  }
}
public protocol ExpressibleAsOperatorDecl: ExpressibleAsDeclBuildable {
  func createOperatorDecl() -> OperatorDecl
}
public extension ExpressibleAsOperatorDecl {
  func createDeclBuildable() -> DeclBuildable {
    return createOperatorDecl()
  }
}
public protocol ExpressibleAsDesignatedTypeList {
  func createDesignatedTypeList() -> DesignatedTypeList
}
public protocol ExpressibleAsDesignatedTypeElement: ExpressibleAsDesignatedTypeList, ExpressibleAsSyntaxBuildable {
  func createDesignatedTypeElement() -> DesignatedTypeElement
}
public extension ExpressibleAsDesignatedTypeElement {
  /// Conformance to `ExpressibleAsDesignatedTypeList`
  func createDesignatedTypeList() -> DesignatedTypeList {
    return DesignatedTypeList([self])
  }
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createDesignatedTypeElement()
  }
}
public protocol ExpressibleAsOperatorPrecedenceAndTypes: ExpressibleAsSyntaxBuildable {
  func createOperatorPrecedenceAndTypes() -> OperatorPrecedenceAndTypes
}
public extension ExpressibleAsOperatorPrecedenceAndTypes {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createOperatorPrecedenceAndTypes()
  }
}
public protocol ExpressibleAsPrecedenceGroupDecl: ExpressibleAsDeclBuildable {
  func createPrecedenceGroupDecl() -> PrecedenceGroupDecl
}
public extension ExpressibleAsPrecedenceGroupDecl {
  func createDeclBuildable() -> DeclBuildable {
    return createPrecedenceGroupDecl()
  }
}
public protocol ExpressibleAsPrecedenceGroupAttributeList {
  func createPrecedenceGroupAttributeList() -> PrecedenceGroupAttributeList
}
public protocol ExpressibleAsPrecedenceGroupRelation: ExpressibleAsSyntaxBuildable {
  func createPrecedenceGroupRelation() -> PrecedenceGroupRelation
}
public extension ExpressibleAsPrecedenceGroupRelation {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createPrecedenceGroupRelation()
  }
}
public protocol ExpressibleAsPrecedenceGroupNameList {
  func createPrecedenceGroupNameList() -> PrecedenceGroupNameList
}
public protocol ExpressibleAsPrecedenceGroupNameElement: ExpressibleAsPrecedenceGroupNameList, ExpressibleAsSyntaxBuildable {
  func createPrecedenceGroupNameElement() -> PrecedenceGroupNameElement
}
public extension ExpressibleAsPrecedenceGroupNameElement {
  /// Conformance to `ExpressibleAsPrecedenceGroupNameList`
  func createPrecedenceGroupNameList() -> PrecedenceGroupNameList {
    return PrecedenceGroupNameList([self])
  }
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createPrecedenceGroupNameElement()
  }
}
public protocol ExpressibleAsPrecedenceGroupAssignment: ExpressibleAsSyntaxBuildable {
  func createPrecedenceGroupAssignment() -> PrecedenceGroupAssignment
}
public extension ExpressibleAsPrecedenceGroupAssignment {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createPrecedenceGroupAssignment()
  }
}
public protocol ExpressibleAsPrecedenceGroupAssociativity: ExpressibleAsSyntaxBuildable {
  func createPrecedenceGroupAssociativity() -> PrecedenceGroupAssociativity
}
public extension ExpressibleAsPrecedenceGroupAssociativity {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createPrecedenceGroupAssociativity()
  }
}
public protocol ExpressibleAsTokenList {
  func createTokenList() -> TokenList
}
public protocol ExpressibleAsNonEmptyTokenList {
  func createNonEmptyTokenList() -> NonEmptyTokenList
}
public protocol ExpressibleAsCustomAttribute: ExpressibleAsSyntaxBuildable {
  func createCustomAttribute() -> CustomAttribute
}
public extension ExpressibleAsCustomAttribute {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createCustomAttribute()
  }
}
public protocol ExpressibleAsAttribute: ExpressibleAsSyntaxBuildable {
  func createAttribute() -> Attribute
}
public extension ExpressibleAsAttribute {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createAttribute()
  }
}
public protocol ExpressibleAsAttributeList {
  func createAttributeList() -> AttributeList
}
public protocol ExpressibleAsSpecializeAttributeSpecList {
  func createSpecializeAttributeSpecList() -> SpecializeAttributeSpecList
}
public protocol ExpressibleAsAvailabilityEntry: ExpressibleAsSyntaxBuildable {
  func createAvailabilityEntry() -> AvailabilityEntry
}
public extension ExpressibleAsAvailabilityEntry {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createAvailabilityEntry()
  }
}
public protocol ExpressibleAsLabeledSpecializeEntry: ExpressibleAsSyntaxBuildable {
  func createLabeledSpecializeEntry() -> LabeledSpecializeEntry
}
public extension ExpressibleAsLabeledSpecializeEntry {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createLabeledSpecializeEntry()
  }
}
public protocol ExpressibleAsTargetFunctionEntry: ExpressibleAsSyntaxBuildable {
  func createTargetFunctionEntry() -> TargetFunctionEntry
}
public extension ExpressibleAsTargetFunctionEntry {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createTargetFunctionEntry()
  }
}
public protocol ExpressibleAsNamedAttributeStringArgument: ExpressibleAsSyntaxBuildable {
  func createNamedAttributeStringArgument() -> NamedAttributeStringArgument
}
public extension ExpressibleAsNamedAttributeStringArgument {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createNamedAttributeStringArgument()
  }
}
public protocol ExpressibleAsDeclName: ExpressibleAsSyntaxBuildable {
  func createDeclName() -> DeclName
}
public extension ExpressibleAsDeclName {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createDeclName()
  }
}
public protocol ExpressibleAsImplementsAttributeArguments: ExpressibleAsSyntaxBuildable {
  func createImplementsAttributeArguments() -> ImplementsAttributeArguments
}
public extension ExpressibleAsImplementsAttributeArguments {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createImplementsAttributeArguments()
  }
}
public protocol ExpressibleAsObjCSelectorPiece: ExpressibleAsObjCSelector, ExpressibleAsSyntaxBuildable {
  func createObjCSelectorPiece() -> ObjCSelectorPiece
}
public extension ExpressibleAsObjCSelectorPiece {
  /// Conformance to `ExpressibleAsObjCSelector`
  func createObjCSelector() -> ObjCSelector {
    return ObjCSelector([self])
  }
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createObjCSelectorPiece()
  }
}
public protocol ExpressibleAsObjCSelector {
  func createObjCSelector() -> ObjCSelector
}
public protocol ExpressibleAsDifferentiableAttributeArguments: ExpressibleAsSyntaxBuildable {
  func createDifferentiableAttributeArguments() -> DifferentiableAttributeArguments
}
public extension ExpressibleAsDifferentiableAttributeArguments {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createDifferentiableAttributeArguments()
  }
}
public protocol ExpressibleAsDifferentiabilityParamsClause: ExpressibleAsSyntaxBuildable {
  func createDifferentiabilityParamsClause() -> DifferentiabilityParamsClause
}
public extension ExpressibleAsDifferentiabilityParamsClause {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createDifferentiabilityParamsClause()
  }
}
public protocol ExpressibleAsDifferentiabilityParams: ExpressibleAsSyntaxBuildable {
  func createDifferentiabilityParams() -> DifferentiabilityParams
}
public extension ExpressibleAsDifferentiabilityParams {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createDifferentiabilityParams()
  }
}
public protocol ExpressibleAsDifferentiabilityParamList {
  func createDifferentiabilityParamList() -> DifferentiabilityParamList
}
public protocol ExpressibleAsDifferentiabilityParam: ExpressibleAsDifferentiabilityParamList, ExpressibleAsSyntaxBuildable {
  func createDifferentiabilityParam() -> DifferentiabilityParam
}
public extension ExpressibleAsDifferentiabilityParam {
  /// Conformance to `ExpressibleAsDifferentiabilityParamList`
  func createDifferentiabilityParamList() -> DifferentiabilityParamList {
    return DifferentiabilityParamList([self])
  }
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createDifferentiabilityParam()
  }
}
public protocol ExpressibleAsDerivativeRegistrationAttributeArguments: ExpressibleAsSyntaxBuildable {
  func createDerivativeRegistrationAttributeArguments() -> DerivativeRegistrationAttributeArguments
}
public extension ExpressibleAsDerivativeRegistrationAttributeArguments {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createDerivativeRegistrationAttributeArguments()
  }
}
public protocol ExpressibleAsQualifiedDeclName: ExpressibleAsSyntaxBuildable {
  func createQualifiedDeclName() -> QualifiedDeclName
}
public extension ExpressibleAsQualifiedDeclName {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createQualifiedDeclName()
  }
}
public protocol ExpressibleAsFunctionDeclName: ExpressibleAsSyntaxBuildable {
  func createFunctionDeclName() -> FunctionDeclName
}
public extension ExpressibleAsFunctionDeclName {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createFunctionDeclName()
  }
}
public protocol ExpressibleAsBackDeployAttributeSpecList: ExpressibleAsSyntaxBuildable {
  func createBackDeployAttributeSpecList() -> BackDeployAttributeSpecList
}
public extension ExpressibleAsBackDeployAttributeSpecList {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createBackDeployAttributeSpecList()
  }
}
public protocol ExpressibleAsBackDeployVersionList {
  func createBackDeployVersionList() -> BackDeployVersionList
}
public protocol ExpressibleAsBackDeployVersionArgument: ExpressibleAsBackDeployVersionList, ExpressibleAsSyntaxBuildable {
  func createBackDeployVersionArgument() -> BackDeployVersionArgument
}
public extension ExpressibleAsBackDeployVersionArgument {
  /// Conformance to `ExpressibleAsBackDeployVersionList`
  func createBackDeployVersionList() -> BackDeployVersionList {
    return BackDeployVersionList([self])
  }
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createBackDeployVersionArgument()
  }
}
public protocol ExpressibleAsOpaqueReturnTypeOfAttributeArguments: ExpressibleAsSyntaxBuildable {
  func createOpaqueReturnTypeOfAttributeArguments() -> OpaqueReturnTypeOfAttributeArguments
}
public extension ExpressibleAsOpaqueReturnTypeOfAttributeArguments {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createOpaqueReturnTypeOfAttributeArguments()
  }
}
public protocol ExpressibleAsConventionAttributeArguments: ExpressibleAsSyntaxBuildable {
  func createConventionAttributeArguments() -> ConventionAttributeArguments
}
public extension ExpressibleAsConventionAttributeArguments {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createConventionAttributeArguments()
  }
}
public protocol ExpressibleAsConventionWitnessMethodAttributeArguments: ExpressibleAsSyntaxBuildable {
  func createConventionWitnessMethodAttributeArguments() -> ConventionWitnessMethodAttributeArguments
}
public extension ExpressibleAsConventionWitnessMethodAttributeArguments {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createConventionWitnessMethodAttributeArguments()
  }
}
public protocol ExpressibleAsLabeledStmt: ExpressibleAsStmtBuildable {
  func createLabeledStmt() -> LabeledStmt
}
public extension ExpressibleAsLabeledStmt {
  func createStmtBuildable() -> StmtBuildable {
    return createLabeledStmt()
  }
}
public protocol ExpressibleAsContinueStmt: ExpressibleAsStmtBuildable {
  func createContinueStmt() -> ContinueStmt
}
public extension ExpressibleAsContinueStmt {
  func createStmtBuildable() -> StmtBuildable {
    return createContinueStmt()
  }
}
public protocol ExpressibleAsWhileStmt: ExpressibleAsStmtBuildable {
  func createWhileStmt() -> WhileStmt
}
public extension ExpressibleAsWhileStmt {
  func createStmtBuildable() -> StmtBuildable {
    return createWhileStmt()
  }
}
public protocol ExpressibleAsDeferStmt: ExpressibleAsStmtBuildable {
  func createDeferStmt() -> DeferStmt
}
public extension ExpressibleAsDeferStmt {
  func createStmtBuildable() -> StmtBuildable {
    return createDeferStmt()
  }
}
public protocol ExpressibleAsExpressionStmt: ExpressibleAsStmtBuildable {
  func createExpressionStmt() -> ExpressionStmt
}
public extension ExpressibleAsExpressionStmt {
  func createStmtBuildable() -> StmtBuildable {
    return createExpressionStmt()
  }
}
public protocol ExpressibleAsSwitchCaseList {
  func createSwitchCaseList() -> SwitchCaseList
}
public protocol ExpressibleAsRepeatWhileStmt: ExpressibleAsStmtBuildable {
  func createRepeatWhileStmt() -> RepeatWhileStmt
}
public extension ExpressibleAsRepeatWhileStmt {
  func createStmtBuildable() -> StmtBuildable {
    return createRepeatWhileStmt()
  }
}
public protocol ExpressibleAsGuardStmt: ExpressibleAsStmtBuildable {
  func createGuardStmt() -> GuardStmt
}
public extension ExpressibleAsGuardStmt {
  func createStmtBuildable() -> StmtBuildable {
    return createGuardStmt()
  }
}
public protocol ExpressibleAsWhereClause: ExpressibleAsSyntaxBuildable {
  func createWhereClause() -> WhereClause
}
public extension ExpressibleAsWhereClause {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createWhereClause()
  }
}
public protocol ExpressibleAsForInStmt: ExpressibleAsStmtBuildable {
  func createForInStmt() -> ForInStmt
}
public extension ExpressibleAsForInStmt {
  func createStmtBuildable() -> StmtBuildable {
    return createForInStmt()
  }
}
public protocol ExpressibleAsSwitchStmt: ExpressibleAsStmtBuildable {
  func createSwitchStmt() -> SwitchStmt
}
public extension ExpressibleAsSwitchStmt {
  func createStmtBuildable() -> StmtBuildable {
    return createSwitchStmt()
  }
}
public protocol ExpressibleAsCatchClauseList {
  func createCatchClauseList() -> CatchClauseList
}
public protocol ExpressibleAsDoStmt: ExpressibleAsStmtBuildable {
  func createDoStmt() -> DoStmt
}
public extension ExpressibleAsDoStmt {
  func createStmtBuildable() -> StmtBuildable {
    return createDoStmt()
  }
}
public protocol ExpressibleAsReturnStmt: ExpressibleAsStmtBuildable {
  func createReturnStmt() -> ReturnStmt
}
public extension ExpressibleAsReturnStmt {
  func createStmtBuildable() -> StmtBuildable {
    return createReturnStmt()
  }
}
public protocol ExpressibleAsYieldStmt: ExpressibleAsStmtBuildable {
  func createYieldStmt() -> YieldStmt
}
public extension ExpressibleAsYieldStmt {
  func createStmtBuildable() -> StmtBuildable {
    return createYieldStmt()
  }
}
public protocol ExpressibleAsYieldList: ExpressibleAsSyntaxBuildable {
  func createYieldList() -> YieldList
}
public extension ExpressibleAsYieldList {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createYieldList()
  }
}
public protocol ExpressibleAsFallthroughStmt: ExpressibleAsStmtBuildable {
  func createFallthroughStmt() -> FallthroughStmt
}
public extension ExpressibleAsFallthroughStmt {
  func createStmtBuildable() -> StmtBuildable {
    return createFallthroughStmt()
  }
}
public protocol ExpressibleAsBreakStmt: ExpressibleAsStmtBuildable {
  func createBreakStmt() -> BreakStmt
}
public extension ExpressibleAsBreakStmt {
  func createStmtBuildable() -> StmtBuildable {
    return createBreakStmt()
  }
}
public protocol ExpressibleAsCaseItemList {
  func createCaseItemList() -> CaseItemList
}
public protocol ExpressibleAsCatchItemList {
  func createCatchItemList() -> CatchItemList
}
public protocol ExpressibleAsConditionElement: ExpressibleAsConditionElementList, ExpressibleAsSyntaxBuildable {
  func createConditionElement() -> ConditionElement
}
public extension ExpressibleAsConditionElement {
  /// Conformance to `ExpressibleAsConditionElementList`
  func createConditionElementList() -> ConditionElementList {
    return ConditionElementList([self])
  }
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createConditionElement()
  }
}
public protocol ExpressibleAsAvailabilityCondition: ExpressibleAsSyntaxBuildable {
  func createAvailabilityCondition() -> AvailabilityCondition
}
public extension ExpressibleAsAvailabilityCondition {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createAvailabilityCondition()
  }
}
public protocol ExpressibleAsMatchingPatternCondition: ExpressibleAsConditionElement {
  func createMatchingPatternCondition() -> MatchingPatternCondition
}
public extension ExpressibleAsMatchingPatternCondition {
  /// Conformance to ExpressibleAsConditionElement
  func createConditionElement() -> ConditionElement {
    return ConditionElement(condition: self)
  }
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createMatchingPatternCondition()
  }
}
public protocol ExpressibleAsOptionalBindingCondition: ExpressibleAsConditionElement {
  func createOptionalBindingCondition() -> OptionalBindingCondition
}
public extension ExpressibleAsOptionalBindingCondition {
  /// Conformance to ExpressibleAsConditionElement
  func createConditionElement() -> ConditionElement {
    return ConditionElement(condition: self)
  }
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createOptionalBindingCondition()
  }
}
public protocol ExpressibleAsUnavailabilityCondition: ExpressibleAsSyntaxBuildable {
  func createUnavailabilityCondition() -> UnavailabilityCondition
}
public extension ExpressibleAsUnavailabilityCondition {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createUnavailabilityCondition()
  }
}
public protocol ExpressibleAsHasSymbolCondition: ExpressibleAsSyntaxBuildable {
  func createHasSymbolCondition() -> HasSymbolCondition
}
public extension ExpressibleAsHasSymbolCondition {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createHasSymbolCondition()
  }
}
public protocol ExpressibleAsConditionElementList {
  func createConditionElementList() -> ConditionElementList
}
public protocol ExpressibleAsDeclarationStmt: ExpressibleAsStmtBuildable {
  func createDeclarationStmt() -> DeclarationStmt
}
public extension ExpressibleAsDeclarationStmt {
  func createStmtBuildable() -> StmtBuildable {
    return createDeclarationStmt()
  }
}
public protocol ExpressibleAsThrowStmt: ExpressibleAsStmtBuildable {
  func createThrowStmt() -> ThrowStmt
}
public extension ExpressibleAsThrowStmt {
  func createStmtBuildable() -> StmtBuildable {
    return createThrowStmt()
  }
}
public protocol ExpressibleAsIfStmt: ExpressibleAsStmtBuildable {
  func createIfStmt() -> IfStmt
}
public extension ExpressibleAsIfStmt {
  func createStmtBuildable() -> StmtBuildable {
    return createIfStmt()
  }
}
public protocol ExpressibleAsElseIfContinuation: ExpressibleAsSyntaxBuildable {
  func createElseIfContinuation() -> ElseIfContinuation
}
public extension ExpressibleAsElseIfContinuation {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createElseIfContinuation()
  }
}
public protocol ExpressibleAsElseBlock: ExpressibleAsSyntaxBuildable {
  func createElseBlock() -> ElseBlock
}
public extension ExpressibleAsElseBlock {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createElseBlock()
  }
}
public protocol ExpressibleAsSwitchCase: ExpressibleAsSyntaxBuildable {
  func createSwitchCase() -> SwitchCase
}
public extension ExpressibleAsSwitchCase {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createSwitchCase()
  }
}
public protocol ExpressibleAsSwitchDefaultLabel: ExpressibleAsSyntaxBuildable {
  func createSwitchDefaultLabel() -> SwitchDefaultLabel
}
public extension ExpressibleAsSwitchDefaultLabel {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createSwitchDefaultLabel()
  }
}
public protocol ExpressibleAsCaseItem: ExpressibleAsCaseItemList, ExpressibleAsSyntaxBuildable {
  func createCaseItem() -> CaseItem
}
public extension ExpressibleAsCaseItem {
  /// Conformance to `ExpressibleAsCaseItemList`
  func createCaseItemList() -> CaseItemList {
    return CaseItemList([self])
  }
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createCaseItem()
  }
}
public protocol ExpressibleAsCatchItem: ExpressibleAsCatchItemList, ExpressibleAsSyntaxBuildable {
  func createCatchItem() -> CatchItem
}
public extension ExpressibleAsCatchItem {
  /// Conformance to `ExpressibleAsCatchItemList`
  func createCatchItemList() -> CatchItemList {
    return CatchItemList([self])
  }
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createCatchItem()
  }
}
public protocol ExpressibleAsSwitchCaseLabel: ExpressibleAsSyntaxBuildable {
  func createSwitchCaseLabel() -> SwitchCaseLabel
}
public extension ExpressibleAsSwitchCaseLabel {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createSwitchCaseLabel()
  }
}
public protocol ExpressibleAsCatchClause: ExpressibleAsCatchClauseList, ExpressibleAsSyntaxBuildable {
  func createCatchClause() -> CatchClause
}
public extension ExpressibleAsCatchClause {
  /// Conformance to `ExpressibleAsCatchClauseList`
  func createCatchClauseList() -> CatchClauseList {
    return CatchClauseList([self])
  }
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createCatchClause()
  }
}
public protocol ExpressibleAsPoundAssertStmt: ExpressibleAsStmtBuildable {
  func createPoundAssertStmt() -> PoundAssertStmt
}
public extension ExpressibleAsPoundAssertStmt {
  func createStmtBuildable() -> StmtBuildable {
    return createPoundAssertStmt()
  }
}
public protocol ExpressibleAsGenericWhereClause: ExpressibleAsSyntaxBuildable {
  func createGenericWhereClause() -> GenericWhereClause
}
public extension ExpressibleAsGenericWhereClause {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createGenericWhereClause()
  }
}
public protocol ExpressibleAsGenericRequirementList {
  func createGenericRequirementList() -> GenericRequirementList
}
public protocol ExpressibleAsGenericRequirement: ExpressibleAsGenericRequirementList, ExpressibleAsSyntaxBuildable {
  func createGenericRequirement() -> GenericRequirement
}
public extension ExpressibleAsGenericRequirement {
  /// Conformance to `ExpressibleAsGenericRequirementList`
  func createGenericRequirementList() -> GenericRequirementList {
    return GenericRequirementList([self])
  }
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createGenericRequirement()
  }
}
public protocol ExpressibleAsSameTypeRequirement: ExpressibleAsSyntaxBuildable {
  func createSameTypeRequirement() -> SameTypeRequirement
}
public extension ExpressibleAsSameTypeRequirement {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createSameTypeRequirement()
  }
}
public protocol ExpressibleAsLayoutRequirement: ExpressibleAsSyntaxBuildable {
  func createLayoutRequirement() -> LayoutRequirement
}
public extension ExpressibleAsLayoutRequirement {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createLayoutRequirement()
  }
}
public protocol ExpressibleAsGenericParameterList {
  func createGenericParameterList() -> GenericParameterList
}
public protocol ExpressibleAsGenericParameter: ExpressibleAsGenericParameterList, ExpressibleAsSyntaxBuildable {
  func createGenericParameter() -> GenericParameter
}
public extension ExpressibleAsGenericParameter {
  /// Conformance to `ExpressibleAsGenericParameterList`
  func createGenericParameterList() -> GenericParameterList {
    return GenericParameterList([self])
  }
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createGenericParameter()
  }
}
public protocol ExpressibleAsPrimaryAssociatedTypeList {
  func createPrimaryAssociatedTypeList() -> PrimaryAssociatedTypeList
}
public protocol ExpressibleAsPrimaryAssociatedType: ExpressibleAsPrimaryAssociatedTypeList, ExpressibleAsSyntaxBuildable {
  func createPrimaryAssociatedType() -> PrimaryAssociatedType
}
public extension ExpressibleAsPrimaryAssociatedType {
  /// Conformance to `ExpressibleAsPrimaryAssociatedTypeList`
  func createPrimaryAssociatedTypeList() -> PrimaryAssociatedTypeList {
    return PrimaryAssociatedTypeList([self])
  }
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createPrimaryAssociatedType()
  }
}
public protocol ExpressibleAsGenericParameterClause: ExpressibleAsSyntaxBuildable {
  func createGenericParameterClause() -> GenericParameterClause
}
public extension ExpressibleAsGenericParameterClause {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createGenericParameterClause()
  }
}
public protocol ExpressibleAsConformanceRequirement: ExpressibleAsSyntaxBuildable {
  func createConformanceRequirement() -> ConformanceRequirement
}
public extension ExpressibleAsConformanceRequirement {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createConformanceRequirement()
  }
}
public protocol ExpressibleAsPrimaryAssociatedTypeClause: ExpressibleAsSyntaxBuildable {
  func createPrimaryAssociatedTypeClause() -> PrimaryAssociatedTypeClause
}
public extension ExpressibleAsPrimaryAssociatedTypeClause {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createPrimaryAssociatedTypeClause()
  }
}
public protocol ExpressibleAsSimpleTypeIdentifier: ExpressibleAsTypeExpr, ExpressibleAsTypeBuildable {
  func createSimpleTypeIdentifier() -> SimpleTypeIdentifier
}
public extension ExpressibleAsSimpleTypeIdentifier {
  /// Conformance to ExpressibleAsTypeExpr
  func createTypeExpr() -> TypeExpr {
    return TypeExpr(type: self)
  }
  func createTypeBuildable() -> TypeBuildable {
    return createSimpleTypeIdentifier()
  }
}
public protocol ExpressibleAsMemberTypeIdentifier: ExpressibleAsTypeBuildable {
  func createMemberTypeIdentifier() -> MemberTypeIdentifier
}
public extension ExpressibleAsMemberTypeIdentifier {
  func createTypeBuildable() -> TypeBuildable {
    return createMemberTypeIdentifier()
  }
}
public protocol ExpressibleAsClassRestrictionType: ExpressibleAsTypeBuildable {
  func createClassRestrictionType() -> ClassRestrictionType
}
public extension ExpressibleAsClassRestrictionType {
  func createTypeBuildable() -> TypeBuildable {
    return createClassRestrictionType()
  }
}
public protocol ExpressibleAsArrayType: ExpressibleAsTypeBuildable {
  func createArrayType() -> ArrayType
}
public extension ExpressibleAsArrayType {
  func createTypeBuildable() -> TypeBuildable {
    return createArrayType()
  }
}
public protocol ExpressibleAsDictionaryType: ExpressibleAsTypeBuildable {
  func createDictionaryType() -> DictionaryType
}
public extension ExpressibleAsDictionaryType {
  func createTypeBuildable() -> TypeBuildable {
    return createDictionaryType()
  }
}
public protocol ExpressibleAsMetatypeType: ExpressibleAsTypeBuildable {
  func createMetatypeType() -> MetatypeType
}
public extension ExpressibleAsMetatypeType {
  func createTypeBuildable() -> TypeBuildable {
    return createMetatypeType()
  }
}
public protocol ExpressibleAsOptionalType: ExpressibleAsTypeBuildable {
  func createOptionalType() -> OptionalType
}
public extension ExpressibleAsOptionalType {
  func createTypeBuildable() -> TypeBuildable {
    return createOptionalType()
  }
}
public protocol ExpressibleAsConstrainedSugarType: ExpressibleAsTypeBuildable {
  func createConstrainedSugarType() -> ConstrainedSugarType
}
public extension ExpressibleAsConstrainedSugarType {
  func createTypeBuildable() -> TypeBuildable {
    return createConstrainedSugarType()
  }
}
public protocol ExpressibleAsImplicitlyUnwrappedOptionalType: ExpressibleAsTypeBuildable {
  func createImplicitlyUnwrappedOptionalType() -> ImplicitlyUnwrappedOptionalType
}
public extension ExpressibleAsImplicitlyUnwrappedOptionalType {
  func createTypeBuildable() -> TypeBuildable {
    return createImplicitlyUnwrappedOptionalType()
  }
}
public protocol ExpressibleAsCompositionTypeElement: ExpressibleAsCompositionTypeElementList, ExpressibleAsSyntaxBuildable {
  func createCompositionTypeElement() -> CompositionTypeElement
}
public extension ExpressibleAsCompositionTypeElement {
  /// Conformance to `ExpressibleAsCompositionTypeElementList`
  func createCompositionTypeElementList() -> CompositionTypeElementList {
    return CompositionTypeElementList([self])
  }
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createCompositionTypeElement()
  }
}
public protocol ExpressibleAsCompositionTypeElementList {
  func createCompositionTypeElementList() -> CompositionTypeElementList
}
public protocol ExpressibleAsCompositionType: ExpressibleAsTypeBuildable {
  func createCompositionType() -> CompositionType
}
public extension ExpressibleAsCompositionType {
  func createTypeBuildable() -> TypeBuildable {
    return createCompositionType()
  }
}
public protocol ExpressibleAsPackExpansionType: ExpressibleAsTypeBuildable {
  func createPackExpansionType() -> PackExpansionType
}
public extension ExpressibleAsPackExpansionType {
  func createTypeBuildable() -> TypeBuildable {
    return createPackExpansionType()
  }
}
public protocol ExpressibleAsTupleTypeElement: ExpressibleAsTupleTypeElementList, ExpressibleAsSyntaxBuildable {
  func createTupleTypeElement() -> TupleTypeElement
}
public extension ExpressibleAsTupleTypeElement {
  /// Conformance to `ExpressibleAsTupleTypeElementList`
  func createTupleTypeElementList() -> TupleTypeElementList {
    return TupleTypeElementList([self])
  }
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createTupleTypeElement()
  }
}
public protocol ExpressibleAsTupleTypeElementList {
  func createTupleTypeElementList() -> TupleTypeElementList
}
public protocol ExpressibleAsTupleType: ExpressibleAsTypeBuildable {
  func createTupleType() -> TupleType
}
public extension ExpressibleAsTupleType {
  func createTypeBuildable() -> TypeBuildable {
    return createTupleType()
  }
}
public protocol ExpressibleAsFunctionType: ExpressibleAsTypeBuildable {
  func createFunctionType() -> FunctionType
}
public extension ExpressibleAsFunctionType {
  func createTypeBuildable() -> TypeBuildable {
    return createFunctionType()
  }
}
public protocol ExpressibleAsAttributedType: ExpressibleAsTypeBuildable {
  func createAttributedType() -> AttributedType
}
public extension ExpressibleAsAttributedType {
  func createTypeBuildable() -> TypeBuildable {
    return createAttributedType()
  }
}
public protocol ExpressibleAsGenericArgumentList {
  func createGenericArgumentList() -> GenericArgumentList
}
public protocol ExpressibleAsGenericArgument: ExpressibleAsGenericArgumentList, ExpressibleAsSyntaxBuildable {
  func createGenericArgument() -> GenericArgument
}
public extension ExpressibleAsGenericArgument {
  /// Conformance to `ExpressibleAsGenericArgumentList`
  func createGenericArgumentList() -> GenericArgumentList {
    return GenericArgumentList([self])
  }
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createGenericArgument()
  }
}
public protocol ExpressibleAsGenericArgumentClause: ExpressibleAsSyntaxBuildable {
  func createGenericArgumentClause() -> GenericArgumentClause
}
public extension ExpressibleAsGenericArgumentClause {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createGenericArgumentClause()
  }
}
public protocol ExpressibleAsNamedOpaqueReturnType: ExpressibleAsTypeBuildable {
  func createNamedOpaqueReturnType() -> NamedOpaqueReturnType
}
public extension ExpressibleAsNamedOpaqueReturnType {
  func createTypeBuildable() -> TypeBuildable {
    return createNamedOpaqueReturnType()
  }
}
public protocol ExpressibleAsTypeAnnotation: ExpressibleAsSyntaxBuildable {
  func createTypeAnnotation() -> TypeAnnotation
}
public extension ExpressibleAsTypeAnnotation {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createTypeAnnotation()
  }
}
public protocol ExpressibleAsEnumCasePattern: ExpressibleAsPatternBuildable {
  func createEnumCasePattern() -> EnumCasePattern
}
public extension ExpressibleAsEnumCasePattern {
  func createPatternBuildable() -> PatternBuildable {
    return createEnumCasePattern()
  }
}
public protocol ExpressibleAsIsTypePattern: ExpressibleAsPatternBuildable {
  func createIsTypePattern() -> IsTypePattern
}
public extension ExpressibleAsIsTypePattern {
  func createPatternBuildable() -> PatternBuildable {
    return createIsTypePattern()
  }
}
public protocol ExpressibleAsOptionalPattern: ExpressibleAsPatternBuildable {
  func createOptionalPattern() -> OptionalPattern
}
public extension ExpressibleAsOptionalPattern {
  func createPatternBuildable() -> PatternBuildable {
    return createOptionalPattern()
  }
}
public protocol ExpressibleAsIdentifierPattern: ExpressibleAsPatternBuildable {
  func createIdentifierPattern() -> IdentifierPattern
}
public extension ExpressibleAsIdentifierPattern {
  func createPatternBuildable() -> PatternBuildable {
    return createIdentifierPattern()
  }
}
public protocol ExpressibleAsAsTypePattern: ExpressibleAsPatternBuildable {
  func createAsTypePattern() -> AsTypePattern
}
public extension ExpressibleAsAsTypePattern {
  func createPatternBuildable() -> PatternBuildable {
    return createAsTypePattern()
  }
}
public protocol ExpressibleAsTuplePattern: ExpressibleAsPatternBuildable {
  func createTuplePattern() -> TuplePattern
}
public extension ExpressibleAsTuplePattern {
  func createPatternBuildable() -> PatternBuildable {
    return createTuplePattern()
  }
}
public protocol ExpressibleAsWildcardPattern: ExpressibleAsPatternBuildable {
  func createWildcardPattern() -> WildcardPattern
}
public extension ExpressibleAsWildcardPattern {
  func createPatternBuildable() -> PatternBuildable {
    return createWildcardPattern()
  }
}
public protocol ExpressibleAsTuplePatternElement: ExpressibleAsTuplePatternElementList, ExpressibleAsSyntaxBuildable {
  func createTuplePatternElement() -> TuplePatternElement
}
public extension ExpressibleAsTuplePatternElement {
  /// Conformance to `ExpressibleAsTuplePatternElementList`
  func createTuplePatternElementList() -> TuplePatternElementList {
    return TuplePatternElementList([self])
  }
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createTuplePatternElement()
  }
}
public protocol ExpressibleAsExpressionPattern: ExpressibleAsPatternBuildable {
  func createExpressionPattern() -> ExpressionPattern
}
public extension ExpressibleAsExpressionPattern {
  func createPatternBuildable() -> PatternBuildable {
    return createExpressionPattern()
  }
}
public protocol ExpressibleAsTuplePatternElementList {
  func createTuplePatternElementList() -> TuplePatternElementList
}
public protocol ExpressibleAsValueBindingPattern: ExpressibleAsPatternBuildable {
  func createValueBindingPattern() -> ValueBindingPattern
}
public extension ExpressibleAsValueBindingPattern {
  func createPatternBuildable() -> PatternBuildable {
    return createValueBindingPattern()
  }
}
public protocol ExpressibleAsAvailabilitySpecList {
  func createAvailabilitySpecList() -> AvailabilitySpecList
}
public protocol ExpressibleAsAvailabilityArgument: ExpressibleAsAvailabilitySpecList, ExpressibleAsSyntaxBuildable {
  func createAvailabilityArgument() -> AvailabilityArgument
}
public extension ExpressibleAsAvailabilityArgument {
  /// Conformance to `ExpressibleAsAvailabilitySpecList`
  func createAvailabilitySpecList() -> AvailabilitySpecList {
    return AvailabilitySpecList([self])
  }
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createAvailabilityArgument()
  }
}
public protocol ExpressibleAsAvailabilityLabeledArgument: ExpressibleAsSyntaxBuildable {
  func createAvailabilityLabeledArgument() -> AvailabilityLabeledArgument
}
public extension ExpressibleAsAvailabilityLabeledArgument {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createAvailabilityLabeledArgument()
  }
}
public protocol ExpressibleAsAvailabilityVersionRestriction: ExpressibleAsSyntaxBuildable {
  func createAvailabilityVersionRestriction() -> AvailabilityVersionRestriction
}
public extension ExpressibleAsAvailabilityVersionRestriction {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createAvailabilityVersionRestriction()
  }
}
public protocol ExpressibleAsVersionTuple: ExpressibleAsSyntaxBuildable {
  func createVersionTuple() -> VersionTuple
}
public extension ExpressibleAsVersionTuple {
  func createSyntaxBuildable() -> SyntaxBuildable {
    return createVersionTuple()
  }
}
