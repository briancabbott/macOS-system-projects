
/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// class java.lang.Class ///

open class JavaClass: JavaObject, /* interface java.io.Serializable */ UnavailableProtocol {

    public convenience init?( casting object: JavaObject, _ file: StaticString = #file, _ line: Int = #line ) {
        self.init( javaObject: nil )
        object.withJavaObject {
            self.javaObject = $0
        }
    }

    private static var JavaClassJNIClass: jclass?

    /// private static final int java.lang.Class.ANNOTATION

    /// private static final int java.lang.Class.ENUM

    /// private static final int java.lang.Class.SYNTHETIC

    /// private static java.security.ProtectionDomain java.lang.Class.allPermDomain

    /// private static boolean java.lang.Class.initted

    /// private static sun.reflect.ReflectionFactory java.lang.Class.reflectionFactory

    /// private static final java.io.ObjectStreamField[] java.lang.Class.serialPersistentFields

    /// private static final long java.lang.Class.serialVersionUID

    /// private static boolean java.lang.Class.useCaches

    /// private transient volatile java.lang.Class$AnnotationData java.lang.Class.annotationData

    /// private transient volatile sun.reflect.annotation.AnnotationType java.lang.Class.annotationType

    /// private transient volatile java.lang.reflect.Constructor java.lang.Class.cachedConstructor

    /// private transient volatile int java.lang.Class.classRedefinedCount

    /// transient java.lang.ClassValue$ClassValueMap java.lang.Class.classValueMap

    // Skipping field: true false false false false false 

    /// private transient volatile java.util.Map java.lang.Class.enumConstantDirectory

    /// private transient volatile java.lang.Object[] java.lang.Class.enumConstants

    /// private transient volatile sun.reflect.generics.repository.ClassRepository java.lang.Class.genericInfo

    /// private transient java.lang.String java.lang.Class.name

    /// private transient volatile java.lang.Class java.lang.Class.newInstanceCallerCache

    /// private transient volatile java.lang.ref.SoftReference java.lang.Class.reflectionData

    /// private java.lang.Class(java.lang.ClassLoader)

    /// static java.lang.reflect.Field[] java.lang.Class.access$100(java.lang.Class,boolean)

    // Skipping method: true false false false false 

    /// static java.lang.reflect.Field java.lang.Class.access$200(java.lang.reflect.Field[],java.lang.String)

    // Skipping method: true false false false false 

    /// static boolean java.lang.Class.access$300(java.lang.Object[],java.lang.Object[])

    // Skipping method: true false false false false 

    /// static boolean java.lang.Class.access$402(boolean)

    // Skipping method: true false false false false 

    /// static boolean java.lang.Class.access$502(boolean)

    // Skipping method: true false false false false 

    /// private static void java.lang.Class.addAll(java.util.Collection,java.lang.reflect.Field[])

    /// private static java.lang.String java.lang.Class.argumentTypesToString(java.lang.Class[])

    /// private static boolean java.lang.Class.arrayContentsEq(java.lang.Object[],java.lang.Object[])

    /// private static void java.lang.Class.checkInitted()

    /// private static java.lang.reflect.Constructor[] java.lang.Class.copyConstructors(java.lang.reflect.Constructor[])

    /// private static java.lang.reflect.Field[] java.lang.Class.copyFields(java.lang.reflect.Field[])

    /// private static java.lang.reflect.Method[] java.lang.Class.copyMethods(java.lang.reflect.Method[])

    /// private static native boolean java.lang.Class.desiredAssertionStatus0(java.lang.Class)

    /// public static java.lang.Class java.lang.Class.forName(java.lang.String) throws java.lang.ClassNotFoundException

    private static var forName_MethodID_1: jmethodID?

    open class func forName( arg0: String? ) throws /* java.lang.ClassNotFoundException */ -> JavaClass! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/lang/Class", classCache: &JavaClassJNIClass, methodName: "forName", methodSig: "(Ljava/lang/String;)Ljava/lang/Class;", methodCache: &forName_MethodID_1, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw /* class java.lang.ClassNotFoundException */ UnavailableObject( javaObject: throwable )
        }
        return __return != nil ? JavaClass( javaObject: __return ) : nil
    }

    open class func forName( _ _arg0: String? ) throws /* java.lang.ClassNotFoundException */ -> JavaClass! {
        return try forName( arg0: _arg0 )
    }

    /// public static java.lang.Class java.lang.Class.forName(java.lang.String,boolean,java.lang.ClassLoader) throws java.lang.ClassNotFoundException

    private static var forName_MethodID_2: jmethodID?

    open class func forName( arg0: String?, arg1: Bool, arg2: /* class java.lang.ClassLoader */ UnavailableObject? ) throws /* java.lang.ClassNotFoundException */ -> JavaClass! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: arg0, locals: &__locals )
        __args[1] = jvalue( z: jboolean(arg1 ? JNI_TRUE : JNI_FALSE) )
        __args[2] = JNIType.toJava( value: arg2, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/lang/Class", classCache: &JavaClassJNIClass, methodName: "forName", methodSig: "(Ljava/lang/String;ZLjava/lang/ClassLoader;)Ljava/lang/Class;", methodCache: &forName_MethodID_2, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw /* class java.lang.ClassNotFoundException */ UnavailableObject( javaObject: throwable )
        }
        return __return != nil ? JavaClass( javaObject: __return ) : nil
    }

    open class func forName( _ _arg0: String?, _ _arg1: Bool, _ _arg2: /* class java.lang.ClassLoader */ UnavailableObject? ) throws /* java.lang.ClassNotFoundException */ -> JavaClass! {
        return try forName( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// private static native java.lang.Class java.lang.Class.forName0(java.lang.String,boolean,java.lang.ClassLoader,java.lang.Class) throws java.lang.ClassNotFoundException

    /// static byte[] java.lang.Class.getExecutableTypeAnnotationBytes(java.lang.reflect.Executable)

    // Skipping method: true false false false false 

    /// static native java.lang.Class java.lang.Class.getPrimitiveClass(java.lang.String)

    // Skipping method: true false false false false 

    /// private static sun.reflect.ReflectionFactory java.lang.Class.getReflectionFactory()

    /// private static boolean java.lang.Class.isAsciiDigit(char)

    /// private static native void java.lang.Class.registerNatives()

    /// private static java.lang.reflect.Field java.lang.Class.searchFields(java.lang.reflect.Field[],java.lang.String)

    /// private static java.lang.reflect.Method java.lang.Class.searchMethods(java.lang.reflect.Method[],java.lang.String,java.lang.Class[])

    /// private static java.lang.Class java.lang.Class.toClass(java.lang.reflect.Type)

    /// private java.lang.Class$AnnotationData java.lang.Class.annotationData()

    /// public java.lang.Class java.lang.Class.asSubclass(java.lang.Class)

    private static var asSubclass_MethodID_3: jmethodID?

    open func asSubclass( arg0: JavaClass? ) -> JavaClass! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "asSubclass", methodSig: "(Ljava/lang/Class;)Ljava/lang/Class;", methodCache: &JavaClass.asSubclass_MethodID_3, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? JavaClass( javaObject: __return ) : nil
    }

    open func asSubclass( _ _arg0: JavaClass? ) -> JavaClass! {
        return asSubclass( arg0: _arg0 )
    }

    /// private java.lang.String java.lang.Class.cannotCastMsg(java.lang.Object)

    /// boolean java.lang.Class.casAnnotationType(sun.reflect.annotation.AnnotationType,sun.reflect.annotation.AnnotationType)

    // Skipping method: true false false false false 

    /// public java.lang.Object java.lang.Class.cast(java.lang.Object)

    private static var cast_MethodID_4: jmethodID?

    open func cast( arg0: JavaObject? ) -> JavaObject! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "cast", methodSig: "(Ljava/lang/Object;)Ljava/lang/Object;", methodCache: &JavaClass.cast_MethodID_4, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? JavaObject( javaObject: __return ) : nil
    }

    open func cast( _ _arg0: JavaObject? ) -> JavaObject! {
        return cast( arg0: _arg0 )
    }

    /// private void java.lang.Class.checkMemberAccess(int,java.lang.Class,boolean)

    /// private void java.lang.Class.checkPackageAccess(java.lang.ClassLoader,boolean)

    /// private java.lang.Class$AnnotationData java.lang.Class.createAnnotationData(int)

    /// public boolean java.lang.Class.desiredAssertionStatus()

    private static var desiredAssertionStatus_MethodID_5: jmethodID?

    open func desiredAssertionStatus() -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "desiredAssertionStatus", methodSig: "()Z", methodCache: &JavaClass.desiredAssertionStatus_MethodID_5, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }


    /// java.util.Map java.lang.Class.enumConstantDirectory()

    // Skipping method: true false false false false 

    /// public java.lang.reflect.AnnotatedType[] java.lang.Class.getAnnotatedInterfaces()

    private static var getAnnotatedInterfaces_MethodID_6: jmethodID?

    open func getAnnotatedInterfaces() -> [/* interface java.lang.reflect.AnnotatedType */ UnavailableProtocol]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getAnnotatedInterfaces", methodSig: "()[Ljava/lang/reflect/AnnotatedType;", methodCache: &JavaClass.getAnnotatedInterfaces_MethodID_6, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [/* interface java.lang.reflect.AnnotatedType */ UnavailableProtocolForward].self, from: __return )
    }


    /// public java.lang.reflect.AnnotatedType java.lang.Class.getAnnotatedSuperclass()

    private static var getAnnotatedSuperclass_MethodID_7: jmethodID?

    open func getAnnotatedSuperclass() -> /* interface java.lang.reflect.AnnotatedType */ UnavailableProtocol! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getAnnotatedSuperclass", methodSig: "()Ljava/lang/reflect/AnnotatedType;", methodCache: &JavaClass.getAnnotatedSuperclass_MethodID_7, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? /* interface java.lang.reflect.AnnotatedType */ UnavailableProtocolForward( javaObject: __return ) : nil
    }


    /// public java.lang.annotation.Annotation java.lang.Class.getAnnotation(java.lang.Class)

    private static var getAnnotation_MethodID_8: jmethodID?

    open func getAnnotation( arg0: JavaClass? ) -> /* interface java.lang.annotation.Annotation */ UnavailableProtocol! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getAnnotation", methodSig: "(Ljava/lang/Class;)Ljava/lang/annotation/Annotation;", methodCache: &JavaClass.getAnnotation_MethodID_8, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? /* interface java.lang.annotation.Annotation */ UnavailableProtocolForward( javaObject: __return ) : nil
    }

    open func getAnnotation( _ _arg0: JavaClass? ) -> /* interface java.lang.annotation.Annotation */ UnavailableProtocol! {
        return getAnnotation( arg0: _arg0 )
    }

    /// sun.reflect.annotation.AnnotationType java.lang.Class.getAnnotationType()

    // Skipping method: true false false false false 

    /// public java.lang.annotation.Annotation[] java.lang.Class.getAnnotations()

    private static var getAnnotations_MethodID_9: jmethodID?

    open func getAnnotations() -> [/* interface java.lang.annotation.Annotation */ UnavailableProtocol]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getAnnotations", methodSig: "()[Ljava/lang/annotation/Annotation;", methodCache: &JavaClass.getAnnotations_MethodID_9, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [/* interface java.lang.annotation.Annotation */ UnavailableProtocolForward].self, from: __return )
    }


    /// public java.lang.annotation.Annotation[] java.lang.Class.getAnnotationsByType(java.lang.Class)

    private static var getAnnotationsByType_MethodID_10: jmethodID?

    open func getAnnotationsByType( arg0: JavaClass? ) -> [/* interface java.lang.annotation.Annotation */ UnavailableProtocol]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getAnnotationsByType", methodSig: "(Ljava/lang/Class;)[Ljava/lang/annotation/Annotation;", methodCache: &JavaClass.getAnnotationsByType_MethodID_10, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [/* interface java.lang.annotation.Annotation */ UnavailableProtocolForward].self, from: __return )
    }

    open func getAnnotationsByType( _ _arg0: JavaClass? ) -> [/* interface java.lang.annotation.Annotation */ UnavailableProtocol]! {
        return getAnnotationsByType( arg0: _arg0 )
    }

    /// public java.lang.String java.lang.Class.getCanonicalName()

    private static var getCanonicalName_MethodID_11: jmethodID?

    open func getCanonicalName() -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getCanonicalName", methodSig: "()Ljava/lang/String;", methodCache: &JavaClass.getCanonicalName_MethodID_11, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? String( javaObject: __return ) : nil
    }


    /// public java.lang.ClassLoader java.lang.Class.getClassLoader()

    private static var getClassLoader_MethodID_12: jmethodID?

    open func getClassLoader() -> /* class java.lang.ClassLoader */ UnavailableObject! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getClassLoader", methodSig: "()Ljava/lang/ClassLoader;", methodCache: &JavaClass.getClassLoader_MethodID_12, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? /* class java.lang.ClassLoader */ UnavailableObject( javaObject: __return ) : nil
    }


    /// java.lang.ClassLoader java.lang.Class.getClassLoader0()

    // Skipping method: true false false false false 

    /// public java.lang.Class[] java.lang.Class.getClasses()

    private static var getClasses_MethodID_13: jmethodID?

    open func getClasses() -> [JavaClass]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getClasses", methodSig: "()[Ljava/lang/Class;", methodCache: &JavaClass.getClasses_MethodID_13, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [JavaClass].self, from: __return )
    }


    /// public native java.lang.Class java.lang.Class.getComponentType()

    private static var getComponentType_MethodID_14: jmethodID?

    open func getComponentType() -> JavaClass! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getComponentType", methodSig: "()Ljava/lang/Class;", methodCache: &JavaClass.getComponentType_MethodID_14, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? JavaClass( javaObject: __return ) : nil
    }


    /// native sun.reflect.ConstantPool java.lang.Class.getConstantPool()

    // Skipping method: true false false false false 

    /// public java.lang.reflect.Constructor java.lang.Class.getConstructor(java.lang.Class[]) throws java.lang.NoSuchMethodException,java.lang.SecurityException

    private static var getConstructor_MethodID_15: jmethodID?

    open func getConstructor( arg0: [JavaClass]? ) throws /* java.lang.NoSuchMethodException, java.lang.SecurityException */ -> /* class java.lang.reflect.Constructor */ UnavailableObject! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getConstructor", methodSig: "([Ljava/lang/Class;)Ljava/lang/reflect/Constructor;", methodCache: &JavaClass.getConstructor_MethodID_15, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw /* class java.lang.NoSuchMethodException */ UnavailableObject( javaObject: throwable )
        }
        return __return != nil ? /* class java.lang.reflect.Constructor */ UnavailableObject( javaObject: __return ) : nil
    }

    open func getConstructor( _ _arg0: [JavaClass]? ) throws /* java.lang.NoSuchMethodException, java.lang.SecurityException */ -> /* class java.lang.reflect.Constructor */ UnavailableObject! {
        return try getConstructor( arg0: _arg0 )
    }

    /// private java.lang.reflect.Constructor java.lang.Class.getConstructor0(java.lang.Class[],int) throws java.lang.NoSuchMethodException

    /// public java.lang.reflect.Constructor[] java.lang.Class.getConstructors() throws java.lang.SecurityException

    private static var getConstructors_MethodID_16: jmethodID?

    open func getConstructors() throws /* java.lang.SecurityException */ -> [/* class java.lang.reflect.Constructor */ UnavailableObject]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getConstructors", methodSig: "()[Ljava/lang/reflect/Constructor;", methodCache: &JavaClass.getConstructors_MethodID_16, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw /* class java.lang.SecurityException */ UnavailableObject( javaObject: throwable )
        }
        return JNIType.toSwift( type: [/* class java.lang.reflect.Constructor */ UnavailableObject].self, from: __return )
    }


    /// public java.lang.annotation.Annotation java.lang.Class.getDeclaredAnnotation(java.lang.Class)

    private static var getDeclaredAnnotation_MethodID_17: jmethodID?

    open func getDeclaredAnnotation( arg0: JavaClass? ) -> /* interface java.lang.annotation.Annotation */ UnavailableProtocol! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getDeclaredAnnotation", methodSig: "(Ljava/lang/Class;)Ljava/lang/annotation/Annotation;", methodCache: &JavaClass.getDeclaredAnnotation_MethodID_17, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? /* interface java.lang.annotation.Annotation */ UnavailableProtocolForward( javaObject: __return ) : nil
    }

    open func getDeclaredAnnotation( _ _arg0: JavaClass? ) -> /* interface java.lang.annotation.Annotation */ UnavailableProtocol! {
        return getDeclaredAnnotation( arg0: _arg0 )
    }

    /// java.util.Map java.lang.Class.getDeclaredAnnotationMap()

    // Skipping method: true false false false false 

    /// public java.lang.annotation.Annotation[] java.lang.Class.getDeclaredAnnotations()

    private static var getDeclaredAnnotations_MethodID_18: jmethodID?

    open func getDeclaredAnnotations() -> [/* interface java.lang.annotation.Annotation */ UnavailableProtocol]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getDeclaredAnnotations", methodSig: "()[Ljava/lang/annotation/Annotation;", methodCache: &JavaClass.getDeclaredAnnotations_MethodID_18, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [/* interface java.lang.annotation.Annotation */ UnavailableProtocolForward].self, from: __return )
    }


    /// public java.lang.annotation.Annotation[] java.lang.Class.getDeclaredAnnotationsByType(java.lang.Class)

    private static var getDeclaredAnnotationsByType_MethodID_19: jmethodID?

    open func getDeclaredAnnotationsByType( arg0: JavaClass? ) -> [/* interface java.lang.annotation.Annotation */ UnavailableProtocol]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getDeclaredAnnotationsByType", methodSig: "(Ljava/lang/Class;)[Ljava/lang/annotation/Annotation;", methodCache: &JavaClass.getDeclaredAnnotationsByType_MethodID_19, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [/* interface java.lang.annotation.Annotation */ UnavailableProtocolForward].self, from: __return )
    }

    open func getDeclaredAnnotationsByType( _ _arg0: JavaClass? ) -> [/* interface java.lang.annotation.Annotation */ UnavailableProtocol]! {
        return getDeclaredAnnotationsByType( arg0: _arg0 )
    }

    /// public java.lang.Class[] java.lang.Class.getDeclaredClasses() throws java.lang.SecurityException

    private static var getDeclaredClasses_MethodID_20: jmethodID?

    open func getDeclaredClasses() throws /* java.lang.SecurityException */ -> [JavaClass]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getDeclaredClasses", methodSig: "()[Ljava/lang/Class;", methodCache: &JavaClass.getDeclaredClasses_MethodID_20, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw /* class java.lang.SecurityException */ UnavailableObject( javaObject: throwable )
        }
        return JNIType.toSwift( type: [JavaClass].self, from: __return )
    }


    /// private native java.lang.Class[] java.lang.Class.getDeclaredClasses0()

    /// public java.lang.reflect.Constructor java.lang.Class.getDeclaredConstructor(java.lang.Class[]) throws java.lang.NoSuchMethodException,java.lang.SecurityException

    private static var getDeclaredConstructor_MethodID_21: jmethodID?

    open func getDeclaredConstructor( arg0: [JavaClass]? ) throws /* java.lang.NoSuchMethodException, java.lang.SecurityException */ -> /* class java.lang.reflect.Constructor */ UnavailableObject! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getDeclaredConstructor", methodSig: "([Ljava/lang/Class;)Ljava/lang/reflect/Constructor;", methodCache: &JavaClass.getDeclaredConstructor_MethodID_21, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw /* class java.lang.NoSuchMethodException */ UnavailableObject( javaObject: throwable )
        }
        return __return != nil ? /* class java.lang.reflect.Constructor */ UnavailableObject( javaObject: __return ) : nil
    }

    open func getDeclaredConstructor( _ _arg0: [JavaClass]? ) throws /* java.lang.NoSuchMethodException, java.lang.SecurityException */ -> /* class java.lang.reflect.Constructor */ UnavailableObject! {
        return try getDeclaredConstructor( arg0: _arg0 )
    }

    /// public java.lang.reflect.Constructor[] java.lang.Class.getDeclaredConstructors() throws java.lang.SecurityException

    private static var getDeclaredConstructors_MethodID_22: jmethodID?

    open func getDeclaredConstructors() throws /* java.lang.SecurityException */ -> [/* class java.lang.reflect.Constructor */ UnavailableObject]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getDeclaredConstructors", methodSig: "()[Ljava/lang/reflect/Constructor;", methodCache: &JavaClass.getDeclaredConstructors_MethodID_22, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw /* class java.lang.SecurityException */ UnavailableObject( javaObject: throwable )
        }
        return JNIType.toSwift( type: [/* class java.lang.reflect.Constructor */ UnavailableObject].self, from: __return )
    }


    /// private native java.lang.reflect.Constructor[] java.lang.Class.getDeclaredConstructors0(boolean)

    /// public java.lang.reflect.Field java.lang.Class.getDeclaredField(java.lang.String) throws java.lang.NoSuchFieldException,java.lang.SecurityException

    private static var getDeclaredField_MethodID_23: jmethodID?

    open func getDeclaredField( arg0: String? ) throws /* java.lang.NoSuchFieldException, java.lang.SecurityException */ -> /* class java.lang.reflect.Field */ UnavailableObject! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getDeclaredField", methodSig: "(Ljava/lang/String;)Ljava/lang/reflect/Field;", methodCache: &JavaClass.getDeclaredField_MethodID_23, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw /* class java.lang.NoSuchFieldException */ UnavailableObject( javaObject: throwable )
        }
        return __return != nil ? /* class java.lang.reflect.Field */ UnavailableObject( javaObject: __return ) : nil
    }

    open func getDeclaredField( _ _arg0: String? ) throws /* java.lang.NoSuchFieldException, java.lang.SecurityException */ -> /* class java.lang.reflect.Field */ UnavailableObject! {
        return try getDeclaredField( arg0: _arg0 )
    }

    /// public java.lang.reflect.Field[] java.lang.Class.getDeclaredFields() throws java.lang.SecurityException

    private static var getDeclaredFields_MethodID_24: jmethodID?

    open func getDeclaredFields() throws /* java.lang.SecurityException */ -> [/* class java.lang.reflect.Field */ UnavailableObject]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getDeclaredFields", methodSig: "()[Ljava/lang/reflect/Field;", methodCache: &JavaClass.getDeclaredFields_MethodID_24, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw /* class java.lang.SecurityException */ UnavailableObject( javaObject: throwable )
        }
        return JNIType.toSwift( type: [/* class java.lang.reflect.Field */ UnavailableObject].self, from: __return )
    }


    /// private native java.lang.reflect.Field[] java.lang.Class.getDeclaredFields0(boolean)

    /// public java.lang.reflect.Method java.lang.Class.getDeclaredMethod(java.lang.String,java.lang.Class[]) throws java.lang.NoSuchMethodException,java.lang.SecurityException

    private static var getDeclaredMethod_MethodID_25: jmethodID?

    open func getDeclaredMethod( arg0: String?, arg1: [JavaClass]? ) throws /* java.lang.NoSuchMethodException, java.lang.SecurityException */ -> /* class java.lang.reflect.Method */ UnavailableObject! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: arg0, locals: &__locals )
        __args[1] = JNIType.toJava( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getDeclaredMethod", methodSig: "(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;", methodCache: &JavaClass.getDeclaredMethod_MethodID_25, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw /* class java.lang.NoSuchMethodException */ UnavailableObject( javaObject: throwable )
        }
        return __return != nil ? /* class java.lang.reflect.Method */ UnavailableObject( javaObject: __return ) : nil
    }

    open func getDeclaredMethod( _ _arg0: String?, _ _arg1: [JavaClass]? ) throws /* java.lang.NoSuchMethodException, java.lang.SecurityException */ -> /* class java.lang.reflect.Method */ UnavailableObject! {
        return try getDeclaredMethod( arg0: _arg0, arg1: _arg1 )
    }

    /// public java.lang.reflect.Method[] java.lang.Class.getDeclaredMethods() throws java.lang.SecurityException

    private static var getDeclaredMethods_MethodID_26: jmethodID?

    open func getDeclaredMethods() throws /* java.lang.SecurityException */ -> [/* class java.lang.reflect.Method */ UnavailableObject]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getDeclaredMethods", methodSig: "()[Ljava/lang/reflect/Method;", methodCache: &JavaClass.getDeclaredMethods_MethodID_26, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw /* class java.lang.SecurityException */ UnavailableObject( javaObject: throwable )
        }
        return JNIType.toSwift( type: [/* class java.lang.reflect.Method */ UnavailableObject].self, from: __return )
    }


    /// private native java.lang.reflect.Method[] java.lang.Class.getDeclaredMethods0(boolean)

    /// public java.lang.Class java.lang.Class.getDeclaringClass() throws java.lang.SecurityException

    private static var getDeclaringClass_MethodID_27: jmethodID?

    open func getDeclaringClass() throws /* java.lang.SecurityException */ -> JavaClass! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getDeclaringClass", methodSig: "()Ljava/lang/Class;", methodCache: &JavaClass.getDeclaringClass_MethodID_27, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw /* class java.lang.SecurityException */ UnavailableObject( javaObject: throwable )
        }
        return __return != nil ? JavaClass( javaObject: __return ) : nil
    }


    /// private native java.lang.Class java.lang.Class.getDeclaringClass0()

    /// public java.lang.Class java.lang.Class.getEnclosingClass() throws java.lang.SecurityException

    private static var getEnclosingClass_MethodID_28: jmethodID?

    open func getEnclosingClass() throws /* java.lang.SecurityException */ -> JavaClass! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getEnclosingClass", methodSig: "()Ljava/lang/Class;", methodCache: &JavaClass.getEnclosingClass_MethodID_28, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw /* class java.lang.SecurityException */ UnavailableObject( javaObject: throwable )
        }
        return __return != nil ? JavaClass( javaObject: __return ) : nil
    }


    /// public java.lang.reflect.Constructor java.lang.Class.getEnclosingConstructor() throws java.lang.SecurityException

    private static var getEnclosingConstructor_MethodID_29: jmethodID?

    open func getEnclosingConstructor() throws /* java.lang.SecurityException */ -> /* class java.lang.reflect.Constructor */ UnavailableObject! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getEnclosingConstructor", methodSig: "()Ljava/lang/reflect/Constructor;", methodCache: &JavaClass.getEnclosingConstructor_MethodID_29, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw /* class java.lang.SecurityException */ UnavailableObject( javaObject: throwable )
        }
        return __return != nil ? /* class java.lang.reflect.Constructor */ UnavailableObject( javaObject: __return ) : nil
    }


    /// public java.lang.reflect.Method java.lang.Class.getEnclosingMethod() throws java.lang.SecurityException

    private static var getEnclosingMethod_MethodID_30: jmethodID?

    open func getEnclosingMethod() throws /* java.lang.SecurityException */ -> /* class java.lang.reflect.Method */ UnavailableObject! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getEnclosingMethod", methodSig: "()Ljava/lang/reflect/Method;", methodCache: &JavaClass.getEnclosingMethod_MethodID_30, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw /* class java.lang.SecurityException */ UnavailableObject( javaObject: throwable )
        }
        return __return != nil ? /* class java.lang.reflect.Method */ UnavailableObject( javaObject: __return ) : nil
    }


    /// private native java.lang.Object[] java.lang.Class.getEnclosingMethod0()

    /// private java.lang.Class$EnclosingMethodInfo java.lang.Class.getEnclosingMethodInfo()

    /// public java.lang.Object[] java.lang.Class.getEnumConstants()

    private static var getEnumConstants_MethodID_31: jmethodID?

    open func getEnumConstants() -> [JavaObject]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getEnumConstants", methodSig: "()[Ljava/lang/Object;", methodCache: &JavaClass.getEnumConstants_MethodID_31, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [JavaObject].self, from: __return )
    }


    /// java.lang.Object[] java.lang.Class.getEnumConstantsShared()

    // Skipping method: true false false false false 

    /// private sun.reflect.generics.factory.GenericsFactory java.lang.Class.getFactory()

    /// public java.lang.reflect.Field java.lang.Class.getField(java.lang.String) throws java.lang.NoSuchFieldException,java.lang.SecurityException

    private static var getField_MethodID_32: jmethodID?

    open func getField( arg0: String? ) throws /* java.lang.NoSuchFieldException, java.lang.SecurityException */ -> /* class java.lang.reflect.Field */ UnavailableObject! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getField", methodSig: "(Ljava/lang/String;)Ljava/lang/reflect/Field;", methodCache: &JavaClass.getField_MethodID_32, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw /* class java.lang.NoSuchFieldException */ UnavailableObject( javaObject: throwable )
        }
        return __return != nil ? /* class java.lang.reflect.Field */ UnavailableObject( javaObject: __return ) : nil
    }

    open func getField( _ _arg0: String? ) throws /* java.lang.NoSuchFieldException, java.lang.SecurityException */ -> /* class java.lang.reflect.Field */ UnavailableObject! {
        return try getField( arg0: _arg0 )
    }

    /// private java.lang.reflect.Field java.lang.Class.getField0(java.lang.String) throws java.lang.NoSuchFieldException

    /// public java.lang.reflect.Field[] java.lang.Class.getFields() throws java.lang.SecurityException

    private static var getFields_MethodID_33: jmethodID?

    open func getFields() throws /* java.lang.SecurityException */ -> [/* class java.lang.reflect.Field */ UnavailableObject]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getFields", methodSig: "()[Ljava/lang/reflect/Field;", methodCache: &JavaClass.getFields_MethodID_33, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw /* class java.lang.SecurityException */ UnavailableObject( javaObject: throwable )
        }
        return JNIType.toSwift( type: [/* class java.lang.reflect.Field */ UnavailableObject].self, from: __return )
    }


    /// private sun.reflect.generics.repository.ClassRepository java.lang.Class.getGenericInfo()

    /// public java.lang.reflect.Type[] java.lang.Class.getGenericInterfaces()

    private static var getGenericInterfaces_MethodID_34: jmethodID?

    open func getGenericInterfaces() -> [/* interface java.lang.reflect.Type */ UnavailableProtocol]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getGenericInterfaces", methodSig: "()[Ljava/lang/reflect/Type;", methodCache: &JavaClass.getGenericInterfaces_MethodID_34, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [/* interface java.lang.reflect.Type */ UnavailableProtocolForward].self, from: __return )
    }


    /// private native java.lang.String java.lang.Class.getGenericSignature0()

    /// public java.lang.reflect.Type java.lang.Class.getGenericSuperclass()

    private static var getGenericSuperclass_MethodID_35: jmethodID?

    open func getGenericSuperclass() -> /* interface java.lang.reflect.Type */ UnavailableProtocol! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getGenericSuperclass", methodSig: "()Ljava/lang/reflect/Type;", methodCache: &JavaClass.getGenericSuperclass_MethodID_35, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? /* interface java.lang.reflect.Type */ UnavailableProtocolForward( javaObject: __return ) : nil
    }


    /// public java.lang.Class[] java.lang.Class.getInterfaces()

    private static var getInterfaces_MethodID_36: jmethodID?

    open func getInterfaces() -> [JavaClass]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getInterfaces", methodSig: "()[Ljava/lang/Class;", methodCache: &JavaClass.getInterfaces_MethodID_36, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [JavaClass].self, from: __return )
    }


    /// private native java.lang.Class[] java.lang.Class.getInterfaces0()

    /// public java.lang.reflect.Method java.lang.Class.getMethod(java.lang.String,java.lang.Class[]) throws java.lang.NoSuchMethodException,java.lang.SecurityException

    private static var getMethod_MethodID_37: jmethodID?

    open func getMethod( arg0: String?, arg1: [JavaClass]? ) throws /* java.lang.NoSuchMethodException, java.lang.SecurityException */ -> /* class java.lang.reflect.Method */ UnavailableObject! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: arg0, locals: &__locals )
        __args[1] = JNIType.toJava( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getMethod", methodSig: "(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;", methodCache: &JavaClass.getMethod_MethodID_37, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw /* class java.lang.NoSuchMethodException */ UnavailableObject( javaObject: throwable )
        }
        return __return != nil ? /* class java.lang.reflect.Method */ UnavailableObject( javaObject: __return ) : nil
    }

    open func getMethod( _ _arg0: String?, _ _arg1: [JavaClass]? ) throws /* java.lang.NoSuchMethodException, java.lang.SecurityException */ -> /* class java.lang.reflect.Method */ UnavailableObject! {
        return try getMethod( arg0: _arg0, arg1: _arg1 )
    }

    /// private java.lang.reflect.Method java.lang.Class.getMethod0(java.lang.String,java.lang.Class[],boolean)

    /// public java.lang.reflect.Method[] java.lang.Class.getMethods() throws java.lang.SecurityException

    private static var getMethods_MethodID_38: jmethodID?

    open func getMethods() throws /* java.lang.SecurityException */ -> [/* class java.lang.reflect.Method */ UnavailableObject]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getMethods", methodSig: "()[Ljava/lang/reflect/Method;", methodCache: &JavaClass.getMethods_MethodID_38, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw /* class java.lang.SecurityException */ UnavailableObject( javaObject: throwable )
        }
        return JNIType.toSwift( type: [/* class java.lang.reflect.Method */ UnavailableObject].self, from: __return )
    }


    /// public native int java.lang.Class.getModifiers()

    private static var getModifiers_MethodID_39: jmethodID?

    open func getModifiers() -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getModifiers", methodSig: "()I", methodCache: &JavaClass.getModifiers_MethodID_39, args: &__args, locals: &__locals )
        return Int(__return)
    }


    /// public java.lang.String java.lang.Class.getName()

    private static var getName_MethodID_40: jmethodID?

    open func getName() -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getName", methodSig: "()Ljava/lang/String;", methodCache: &JavaClass.getName_MethodID_40, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? String( javaObject: __return ) : nil
    }


    /// private native java.lang.String java.lang.Class.getName0()

    /// public java.lang.Package java.lang.Class.getPackage()

    private static var getPackage_MethodID_41: jmethodID?

    open func getPackage() -> /* class java.lang.Package */ UnavailableObject! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getPackage", methodSig: "()Ljava/lang/Package;", methodCache: &JavaClass.getPackage_MethodID_41, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? /* class java.lang.Package */ UnavailableObject( javaObject: __return ) : nil
    }


    /// public java.security.ProtectionDomain java.lang.Class.getProtectionDomain()

    private static var getProtectionDomain_MethodID_42: jmethodID?

    open func getProtectionDomain() -> /* class java.security.ProtectionDomain */ UnavailableObject! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getProtectionDomain", methodSig: "()Ljava/security/ProtectionDomain;", methodCache: &JavaClass.getProtectionDomain_MethodID_42, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? /* class java.security.ProtectionDomain */ UnavailableObject( javaObject: __return ) : nil
    }


    /// private native java.security.ProtectionDomain java.lang.Class.getProtectionDomain0()

    /// native byte[] java.lang.Class.getRawAnnotations()

    // Skipping method: true false false false false 

    /// native byte[] java.lang.Class.getRawTypeAnnotations()

    // Skipping method: true false false false false 

    /// public java.net.URL java.lang.Class.getResource(java.lang.String)

    private static var getResource_MethodID_43: jmethodID?

    open func getResource( arg0: String? ) -> /* class java.net.URL */ UnavailableObject! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getResource", methodSig: "(Ljava/lang/String;)Ljava/net/URL;", methodCache: &JavaClass.getResource_MethodID_43, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? /* class java.net.URL */ UnavailableObject( javaObject: __return ) : nil
    }

    open func getResource( _ _arg0: String? ) -> /* class java.net.URL */ UnavailableObject! {
        return getResource( arg0: _arg0 )
    }

    /// public java.io.InputStream java.lang.Class.getResourceAsStream(java.lang.String)

    private static var getResourceAsStream_MethodID_44: jmethodID?

    open func getResourceAsStream( arg0: String? ) -> /* class java.io.InputStream */ UnavailableObject! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getResourceAsStream", methodSig: "(Ljava/lang/String;)Ljava/io/InputStream;", methodCache: &JavaClass.getResourceAsStream_MethodID_44, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? /* class java.io.InputStream */ UnavailableObject( javaObject: __return ) : nil
    }

    open func getResourceAsStream( _ _arg0: String? ) -> /* class java.io.InputStream */ UnavailableObject! {
        return getResourceAsStream( arg0: _arg0 )
    }

    /// public native java.lang.Object[] java.lang.Class.getSigners()

    private static var getSigners_MethodID_45: jmethodID?

    open func getSigners() -> [JavaObject]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getSigners", methodSig: "()[Ljava/lang/Object;", methodCache: &JavaClass.getSigners_MethodID_45, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [JavaObject].self, from: __return )
    }


    /// private java.lang.String java.lang.Class.getSimpleBinaryName()

    /// public java.lang.String java.lang.Class.getSimpleName()

    private static var getSimpleName_MethodID_46: jmethodID?

    open func getSimpleName() -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getSimpleName", methodSig: "()Ljava/lang/String;", methodCache: &JavaClass.getSimpleName_MethodID_46, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? String( javaObject: __return ) : nil
    }


    /// public native java.lang.Class java.lang.Class.getSuperclass()

    private static var getSuperclass_MethodID_47: jmethodID?

    open func getSuperclass() -> JavaClass! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getSuperclass", methodSig: "()Ljava/lang/Class;", methodCache: &JavaClass.getSuperclass_MethodID_47, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? JavaClass( javaObject: __return ) : nil
    }


    /// public java.lang.String java.lang.Class.getTypeName()

    private static var getTypeName_MethodID_48: jmethodID?

    open func getTypeName() -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getTypeName", methodSig: "()Ljava/lang/String;", methodCache: &JavaClass.getTypeName_MethodID_48, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? String( javaObject: __return ) : nil
    }


    /// public java.lang.reflect.TypeVariable[] java.lang.Class.getTypeParameters()

    private static var getTypeParameters_MethodID_49: jmethodID?

    open func getTypeParameters() -> [/* interface java.lang.reflect.TypeVariable */ UnavailableProtocol]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getTypeParameters", methodSig: "()[Ljava/lang/reflect/TypeVariable;", methodCache: &JavaClass.getTypeParameters_MethodID_49, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [/* interface java.lang.reflect.TypeVariable */ UnavailableProtocolForward].self, from: __return )
    }


    /// public boolean java.lang.Class.isAnnotation()

    private static var isAnnotation_MethodID_50: jmethodID?

    open func isAnnotation() -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isAnnotation", methodSig: "()Z", methodCache: &JavaClass.isAnnotation_MethodID_50, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }


    /// public boolean java.lang.Class.isAnnotationPresent(java.lang.Class)

    private static var isAnnotationPresent_MethodID_51: jmethodID?

    open func isAnnotationPresent( arg0: JavaClass? ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isAnnotationPresent", methodSig: "(Ljava/lang/Class;)Z", methodCache: &JavaClass.isAnnotationPresent_MethodID_51, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open func isAnnotationPresent( _ _arg0: JavaClass? ) -> Bool {
        return isAnnotationPresent( arg0: _arg0 )
    }

    /// public boolean java.lang.Class.isAnonymousClass()

    private static var isAnonymousClass_MethodID_52: jmethodID?

    open func isAnonymousClass() -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isAnonymousClass", methodSig: "()Z", methodCache: &JavaClass.isAnonymousClass_MethodID_52, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }


    /// public native boolean java.lang.Class.isArray()

    private static var isArray_MethodID_53: jmethodID?

    open func isArray() -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isArray", methodSig: "()Z", methodCache: &JavaClass.isArray_MethodID_53, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }


    /// public native boolean java.lang.Class.isAssignableFrom(java.lang.Class)

    private static var isAssignableFrom_MethodID_54: jmethodID?

    open func isAssignableFrom( arg0: JavaClass? ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isAssignableFrom", methodSig: "(Ljava/lang/Class;)Z", methodCache: &JavaClass.isAssignableFrom_MethodID_54, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open func isAssignableFrom( _ _arg0: JavaClass? ) -> Bool {
        return isAssignableFrom( arg0: _arg0 )
    }

    /// public boolean java.lang.Class.isEnum()

    private static var isEnum_MethodID_55: jmethodID?

    open func isEnum() -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isEnum", methodSig: "()Z", methodCache: &JavaClass.isEnum_MethodID_55, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }


    /// public native boolean java.lang.Class.isInstance(java.lang.Object)

    private static var isInstance_MethodID_56: jmethodID?

    open func isInstance( arg0: JavaObject? ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isInstance", methodSig: "(Ljava/lang/Object;)Z", methodCache: &JavaClass.isInstance_MethodID_56, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open func isInstance( _ _arg0: JavaObject? ) -> Bool {
        return isInstance( arg0: _arg0 )
    }

    /// public native boolean java.lang.Class.isInterface()

    private static var isInterface_MethodID_57: jmethodID?

    open func isInterface() -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isInterface", methodSig: "()Z", methodCache: &JavaClass.isInterface_MethodID_57, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }


    /// public boolean java.lang.Class.isLocalClass()

    private static var isLocalClass_MethodID_58: jmethodID?

    open func isLocalClass() -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isLocalClass", methodSig: "()Z", methodCache: &JavaClass.isLocalClass_MethodID_58, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }


    /// private boolean java.lang.Class.isLocalOrAnonymousClass()

    /// public boolean java.lang.Class.isMemberClass()

    private static var isMemberClass_MethodID_59: jmethodID?

    open func isMemberClass() -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isMemberClass", methodSig: "()Z", methodCache: &JavaClass.isMemberClass_MethodID_59, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }


    /// public native boolean java.lang.Class.isPrimitive()

    private static var isPrimitive_MethodID_60: jmethodID?

    open func isPrimitive() -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isPrimitive", methodSig: "()Z", methodCache: &JavaClass.isPrimitive_MethodID_60, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }


    /// public boolean java.lang.Class.isSynthetic()

    private static var isSynthetic_MethodID_61: jmethodID?

    open func isSynthetic() -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isSynthetic", methodSig: "()Z", methodCache: &JavaClass.isSynthetic_MethodID_61, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }


    /// public java.lang.Object java.lang.Class.newInstance() throws java.lang.InstantiationException,java.lang.IllegalAccessException

    private static var newInstance_MethodID_62: jmethodID?

    open func newInstance() throws /* java.lang.InstantiationException, java.lang.IllegalAccessException */ -> JavaObject! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "newInstance", methodSig: "()Ljava/lang/Object;", methodCache: &JavaClass.newInstance_MethodID_62, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw /* class java.lang.InstantiationException */ UnavailableObject( javaObject: throwable )
        }
        return __return != nil ? JavaObject( javaObject: __return ) : nil
    }


    /// private java.lang.Class$ReflectionData java.lang.Class.newReflectionData(java.lang.ref.SoftReference,int)

    /// private java.lang.reflect.Constructor[] java.lang.Class.privateGetDeclaredConstructors(boolean)

    /// private java.lang.reflect.Field[] java.lang.Class.privateGetDeclaredFields(boolean)

    /// private java.lang.reflect.Method[] java.lang.Class.privateGetDeclaredMethods(boolean)

    /// private java.lang.reflect.Method java.lang.Class.privateGetMethodRecursive(java.lang.String,java.lang.Class[],boolean,java.lang.Class$MethodArray)

    /// private java.lang.reflect.Field[] java.lang.Class.privateGetPublicFields(java.util.Set)

    /// private java.lang.reflect.Method[] java.lang.Class.privateGetPublicMethods()

    /// private java.lang.Class$ReflectionData java.lang.Class.reflectionData()

    /// private java.lang.String java.lang.Class.resolveName(java.lang.String)

    /// native void java.lang.Class.setSigners(java.lang.Object[])

    // Skipping method: true false false false false 

    /// public java.lang.String java.lang.Class.toGenericString()

    private static var toGenericString_MethodID_63: jmethodID?

    open func toGenericString() -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "toGenericString", methodSig: "()Ljava/lang/String;", methodCache: &JavaClass.toGenericString_MethodID_63, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? String( javaObject: __return ) : nil
    }


    /// public java.lang.String java.lang.Class.toString()

    // Skipping method: false true false false false 

}

