
import java_swift
import java_lang

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// class java.util.regex.Pattern ///

open class Pattern: java_swift.JavaObject, /* interface java.io.Serializable */ UnavailableProtocol {

    public convenience init?( casting object: java_swift.JavaObject, _ file: StaticString = #file, _ line: Int = #line ) {
        self.init( javaObject: nil )
        object.withJavaObject {
            self.javaObject = $0
        }
    }

    private static var PatternJNIClass: jclass?

    /// static final boolean java.util.regex.Pattern.$assertionsDisabled

    // Skipping field: true false false false false false 

    /// public static final int java.util.regex.Pattern.CANON_EQ

    private static var CANON_EQ_FieldID: jfieldID?

    public static var CANON_EQ: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "CANON_EQ", fieldType: "I", fieldCache: &CANON_EQ_FieldID, className: "java/util/regex/Pattern", classCache: &PatternJNIClass )
            return Int(__value)
        }
    }

    /// public static final int java.util.regex.Pattern.CASE_INSENSITIVE

    private static var CASE_INSENSITIVE_FieldID: jfieldID?

    public static var CASE_INSENSITIVE: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "CASE_INSENSITIVE", fieldType: "I", fieldCache: &CASE_INSENSITIVE_FieldID, className: "java/util/regex/Pattern", classCache: &PatternJNIClass )
            return Int(__value)
        }
    }

    /// public static final int java.util.regex.Pattern.COMMENTS

    private static var COMMENTS_FieldID: jfieldID?

    public static var COMMENTS: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "COMMENTS", fieldType: "I", fieldCache: &COMMENTS_FieldID, className: "java/util/regex/Pattern", classCache: &PatternJNIClass )
            return Int(__value)
        }
    }

    /// public static final int java.util.regex.Pattern.DOTALL

    private static var DOTALL_FieldID: jfieldID?

    public static var DOTALL: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "DOTALL", fieldType: "I", fieldCache: &DOTALL_FieldID, className: "java/util/regex/Pattern", classCache: &PatternJNIClass )
            return Int(__value)
        }
    }

    /// static final int java.util.regex.Pattern.GREEDY

    // Skipping field: true false false false false false 

    /// static final int java.util.regex.Pattern.INDEPENDENT

    // Skipping field: true false false false false false 

    /// static final int java.util.regex.Pattern.LAZY

    // Skipping field: true false false false false false 

    /// public static final int java.util.regex.Pattern.LITERAL

    private static var LITERAL_FieldID: jfieldID?

    public static var LITERAL: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "LITERAL", fieldType: "I", fieldCache: &LITERAL_FieldID, className: "java/util/regex/Pattern", classCache: &PatternJNIClass )
            return Int(__value)
        }
    }

    /// static final int java.util.regex.Pattern.MAX_REPS

    // Skipping field: true false false false false false 

    /// public static final int java.util.regex.Pattern.MULTILINE

    private static var MULTILINE_FieldID: jfieldID?

    public static var MULTILINE: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "MULTILINE", fieldType: "I", fieldCache: &MULTILINE_FieldID, className: "java/util/regex/Pattern", classCache: &PatternJNIClass )
            return Int(__value)
        }
    }

    /// static final int java.util.regex.Pattern.POSSESSIVE

    // Skipping field: true false false false false false 

    /// public static final int java.util.regex.Pattern.UNICODE_CASE

    private static var UNICODE_CASE_FieldID: jfieldID?

    public static var UNICODE_CASE: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "UNICODE_CASE", fieldType: "I", fieldCache: &UNICODE_CASE_FieldID, className: "java/util/regex/Pattern", classCache: &PatternJNIClass )
            return Int(__value)
        }
    }

    /// public static final int java.util.regex.Pattern.UNICODE_CHARACTER_CLASS

    private static var UNICODE_CHARACTER_CLASS_FieldID: jfieldID?

    public static var UNICODE_CHARACTER_CLASS: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "UNICODE_CHARACTER_CLASS", fieldType: "I", fieldCache: &UNICODE_CHARACTER_CLASS_FieldID, className: "java/util/regex/Pattern", classCache: &PatternJNIClass )
            return Int(__value)
        }
    }

    /// public static final int java.util.regex.Pattern.UNIX_LINES

    private static var UNIX_LINES_FieldID: jfieldID?

    public static var UNIX_LINES: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "UNIX_LINES", fieldType: "I", fieldCache: &UNIX_LINES_FieldID, className: "java/util/regex/Pattern", classCache: &PatternJNIClass )
            return Int(__value)
        }
    }

    /// static java.util.regex.Pattern$Node java.util.regex.Pattern.accept

    // Skipping field: true false false false false false 

    /// static java.util.regex.Pattern$Node java.util.regex.Pattern.lastAccept

    // Skipping field: true false false false false false 

    /// static java.util.regex.Pattern$Node java.util.regex.Pattern.lookbehindEnd

    // Skipping field: true false false false false false 

    /// private static final long java.util.regex.Pattern.serialVersionUID

    /// transient int[] java.util.regex.Pattern.buffer

    // Skipping field: true false false false false false 

    /// transient int java.util.regex.Pattern.capturingGroupCount

    // Skipping field: true false false false false false 

    /// private transient volatile boolean java.util.regex.Pattern.compiled

    /// private transient int java.util.regex.Pattern.cursor

    /// private int java.util.regex.Pattern.flags

    /// transient java.util.regex.Pattern$GroupHead[] java.util.regex.Pattern.groupNodes

    // Skipping field: true false false false false false 

    /// private transient boolean java.util.regex.Pattern.hasSupplementary

    /// transient int java.util.regex.Pattern.localCount

    // Skipping field: true false false false false false 

    /// transient java.util.regex.Pattern$Node java.util.regex.Pattern.matchRoot

    // Skipping field: true false false false false false 

    /// transient volatile java.util.Map java.util.regex.Pattern.namedGroups

    // Skipping field: true false false false false false 

    /// private transient java.lang.String java.util.regex.Pattern.normalizedPattern

    /// private java.lang.String java.util.regex.Pattern.pattern

    /// private transient int java.util.regex.Pattern.patternLength

    /// transient java.util.regex.Pattern$Node java.util.regex.Pattern.root

    // Skipping field: true false false false false false 

    /// private transient int[] java.util.regex.Pattern.temp

    /// private java.util.regex.Pattern(java.lang.String,int)

    /// static boolean java.util.regex.Pattern.access$200(int,int,int)

    // Skipping method: true false false false false 

    /// static int java.util.regex.Pattern.access$300(java.lang.CharSequence,int,int)

    // Skipping method: true false false false false 

    /// static boolean java.util.regex.Pattern.access$400(java.util.regex.Matcher,int,java.lang.CharSequence)

    // Skipping method: true false false false false 

    /// static java.util.regex.Pattern$CharProperty java.util.regex.Pattern.access$600(int,int)

    // Skipping method: true false false false false 

    /// public static java.util.regex.Pattern java.util.regex.Pattern.compile(java.lang.String)

    private static var compile_MethodID_1: jmethodID?

    open class func compile( regex: String? ) -> Pattern! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: regex, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/regex/Pattern", classCache: &PatternJNIClass, methodName: "compile", methodSig: "(Ljava/lang/String;)Ljava/util/regex/Pattern;", methodCache: &compile_MethodID_1, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? Pattern( javaObject: __return ) : nil
    }

    open class func compile( _ _regex: String? ) -> Pattern! {
        return compile( regex: _regex )
    }

    /// public static java.util.regex.Pattern java.util.regex.Pattern.compile(java.lang.String,int)

    private static var compile_MethodID_2: jmethodID?

    open class func compile( regex: String?, flags: Int ) -> Pattern! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: regex, locals: &__locals )
        __args[1] = jvalue( i: jint(flags) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/regex/Pattern", classCache: &PatternJNIClass, methodName: "compile", methodSig: "(Ljava/lang/String;I)Ljava/util/regex/Pattern;", methodCache: &compile_MethodID_2, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? Pattern( javaObject: __return ) : nil
    }

    open class func compile( _ _regex: String?, _ _flags: Int ) -> Pattern! {
        return compile( regex: _regex, flags: _flags )
    }

    /// private static final int java.util.regex.Pattern.countChars(java.lang.CharSequence,int,int)

    /// private static final int java.util.regex.Pattern.countCodePoints(java.lang.CharSequence)

    /// private static boolean java.util.regex.Pattern.hasBaseCharacter(java.util.regex.Matcher,int,java.lang.CharSequence)

    /// private static boolean java.util.regex.Pattern.inRange(int,int,int)

    /// private static java.util.regex.Pattern$CharProperty java.util.regex.Pattern.intersection(java.util.regex.Pattern$CharProperty,java.util.regex.Pattern$CharProperty)

    /// private static final boolean java.util.regex.Pattern.isSupplementary(int)

    /// public static boolean java.util.regex.Pattern.matches(java.lang.String,java.lang.CharSequence)

    private static var matches_MethodID_3: jmethodID?

    open class func matches( regex: String?, input: java_lang.CharSequence? ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: regex, locals: &__locals )
        __args[1] = JNIType.toJava( value: input, locals: &__locals )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/util/regex/Pattern", classCache: &PatternJNIClass, methodName: "matches", methodSig: "(Ljava/lang/String;Ljava/lang/CharSequence;)Z", methodCache: &matches_MethodID_3, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open class func matches( _ _regex: String?, _ _input: java_lang.CharSequence? ) -> Bool {
        return matches( regex: _regex, input: _input )
    }

    /// private static void java.util.regex.Pattern.printObjectTree(java.util.regex.Pattern$Node)

    /// public static java.lang.String java.util.regex.Pattern.quote(java.lang.String)

    private static var quote_MethodID_4: jmethodID?

    open class func quote( s: String? ) -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: s, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/regex/Pattern", classCache: &PatternJNIClass, methodName: "quote", methodSig: "(Ljava/lang/String;)Ljava/lang/String;", methodCache: &quote_MethodID_4, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? String( javaObject: __return ) : nil
    }

    open class func quote( _ _s: String? ) -> String! {
        return quote( s: _s )
    }

    /// private static java.util.regex.Pattern$CharProperty java.util.regex.Pattern.rangeFor(int,int)

    /// private static java.util.regex.Pattern$CharProperty java.util.regex.Pattern.setDifference(java.util.regex.Pattern$CharProperty,java.util.regex.Pattern$CharProperty)

    /// private static java.util.regex.Pattern$CharProperty java.util.regex.Pattern.union(java.util.regex.Pattern$CharProperty,java.util.regex.Pattern$CharProperty)

    /// private void java.util.regex.Pattern.RemoveQEQuoting()

    /// private void java.util.regex.Pattern.accept(int,java.lang.String)

    /// private void java.util.regex.Pattern.addFlag()

    /// private void java.util.regex.Pattern.append(int,int)

    /// public java.util.function.Predicate java.util.regex.Pattern.asPredicate()

    private static var asPredicate_MethodID_5: jmethodID?

    open func asPredicate() -> Predicate! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "asPredicate", methodSig: "()Ljava/util/function/Predicate;", methodCache: &Pattern.asPredicate_MethodID_5, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? PredicateForward( javaObject: __return ) : nil
    }


    /// private java.util.regex.Pattern$Node java.util.regex.Pattern.atom()

    /// private java.util.regex.Pattern$CharProperty java.util.regex.Pattern.bitsOrSingle(java.util.regex.Pattern$BitClass,int)

    /// private int java.util.regex.Pattern.c()

    /// private java.util.regex.Pattern$CharProperty java.util.regex.Pattern.caseInsensitiveRangeFor(int,int)

    /// private java.util.regex.Pattern$CharProperty java.util.regex.Pattern.charPropertyNodeFor(java.lang.String)

    /// private java.util.regex.Pattern$CharProperty java.util.regex.Pattern.clazz(boolean)

    /// private java.util.regex.Pattern$Node java.util.regex.Pattern.closure(java.util.regex.Pattern$Node)

    /// private void java.util.regex.Pattern.compile()

    /// private java.lang.String java.util.regex.Pattern.composeOneStep(java.lang.String)

    /// private java.util.regex.Pattern$Node java.util.regex.Pattern.createGroup(boolean)

    /// private int java.util.regex.Pattern.cursor()

    /// private java.util.regex.PatternSyntaxException java.util.regex.Pattern.error(java.lang.String)

    /// private int java.util.regex.Pattern.escape(boolean,boolean,boolean)

    /// private java.util.regex.Pattern$Node java.util.regex.Pattern.expr(java.util.regex.Pattern$Node)

    /// private java.util.regex.Pattern$CharProperty java.util.regex.Pattern.family(boolean,boolean)

    /// private boolean java.util.regex.Pattern.findSupplementary(int,int)

    /// public int java.util.regex.Pattern.flags()

    private static var flags_MethodID_6: jmethodID?

    open func flags() -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "flags", methodSig: "()I", methodCache: &Pattern.flags_MethodID_6, args: &__args, locals: &__locals )
        return Int(__return)
    }


    /// private int java.util.regex.Pattern.getClass(int)

    /// private java.util.regex.Pattern$Node java.util.regex.Pattern.group0()

    /// private java.lang.String java.util.regex.Pattern.groupname(int)

    /// private boolean java.util.regex.Pattern.has(int)

    /// private boolean java.util.regex.Pattern.isLineSeparator(int)

    /// private boolean java.util.regex.Pattern.lambda$asPredicate$0(java.lang.String)

    /// private void java.util.regex.Pattern.mark(int)

    /// public java.util.regex.Matcher java.util.regex.Pattern.matcher(java.lang.CharSequence)

    private static var matcher_MethodID_7: jmethodID?

    open func matcher( input: java_lang.CharSequence? ) -> Matcher! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: input, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "matcher", methodSig: "(Ljava/lang/CharSequence;)Ljava/util/regex/Matcher;", methodCache: &Pattern.matcher_MethodID_7, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? Matcher( javaObject: __return ) : nil
    }

    open func matcher( _ _input: java_lang.CharSequence? ) -> Matcher! {
        return matcher( input: _input )
    }

    /// java.util.Map java.util.regex.Pattern.namedGroups()

    // Skipping method: true false false false false 

    /// private java.util.regex.Pattern$CharProperty java.util.regex.Pattern.newSingle(int)

    /// private java.util.regex.Pattern$Node java.util.regex.Pattern.newSlice(int[],int,boolean)

    /// private int java.util.regex.Pattern.next()

    /// private int java.util.regex.Pattern.nextEscaped()

    /// private void java.util.regex.Pattern.normalize()

    /// private int java.util.regex.Pattern.normalizeCharClass(java.lang.StringBuilder,int)

    /// private int java.util.regex.Pattern.o()

    /// private int java.util.regex.Pattern.parsePastLine()

    /// private int java.util.regex.Pattern.parsePastWhitespace(int)

    /// public java.lang.String java.util.regex.Pattern.pattern()

    private static var pattern_MethodID_8: jmethodID?

    open func pattern() -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "pattern", methodSig: "()Ljava/lang/String;", methodCache: &Pattern.pattern_MethodID_8, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? String( javaObject: __return ) : nil
    }


    /// private int java.util.regex.Pattern.peek()

    /// private int java.util.regex.Pattern.peekPastLine()

    /// private int java.util.regex.Pattern.peekPastWhitespace(int)

    /// private java.lang.String java.util.regex.Pattern.produceEquivalentAlternation(java.lang.String)

    /// private java.lang.String[] java.util.regex.Pattern.producePermutations(java.lang.String)

    /// private java.util.regex.Pattern$CharProperty java.util.regex.Pattern.range(java.util.regex.Pattern$BitClass)

    /// private int java.util.regex.Pattern.read()

    /// private int java.util.regex.Pattern.readEscaped()

    /// private void java.util.regex.Pattern.readObject(java.io.ObjectInputStream) throws java.io.IOException,java.lang.ClassNotFoundException

    /// private java.util.regex.Pattern$Node java.util.regex.Pattern.ref(int)

    /// private java.util.regex.Pattern$Node java.util.regex.Pattern.sequence(java.util.regex.Pattern$Node)

    /// private void java.util.regex.Pattern.setcursor(int)

    /// private int java.util.regex.Pattern.skip()

    /// public java.lang.String[] java.util.regex.Pattern.split(java.lang.CharSequence)

    private static var split_MethodID_9: jmethodID?

    open func split( input: java_lang.CharSequence? ) -> [String]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: input, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "split", methodSig: "(Ljava/lang/CharSequence;)[Ljava/lang/String;", methodCache: &Pattern.split_MethodID_9, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [String].self, from: __return )
    }

    open func split( _ _input: java_lang.CharSequence? ) -> [String]! {
        return split( input: _input )
    }

    /// public java.lang.String[] java.util.regex.Pattern.split(java.lang.CharSequence,int)

    private static var split_MethodID_10: jmethodID?

    open func split( input: java_lang.CharSequence?, limit: Int ) -> [String]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: input, locals: &__locals )
        __args[1] = jvalue( i: jint(limit) )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "split", methodSig: "(Ljava/lang/CharSequence;I)[Ljava/lang/String;", methodCache: &Pattern.split_MethodID_10, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [String].self, from: __return )
    }

    open func split( _ _input: java_lang.CharSequence?, _ _limit: Int ) -> [String]! {
        return split( input: _input, limit: _limit )
    }

    /// public java.util.stream.Stream java.util.regex.Pattern.splitAsStream(java.lang.CharSequence)

    private static var splitAsStream_MethodID_11: jmethodID?

    open func splitAsStream( input: java_lang.CharSequence? ) -> Stream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: input, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "splitAsStream", methodSig: "(Ljava/lang/CharSequence;)Ljava/util/stream/Stream;", methodCache: &Pattern.splitAsStream_MethodID_11, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? StreamForward( javaObject: __return ) : nil
    }

    open func splitAsStream( _ _input: java_lang.CharSequence? ) -> Stream! {
        return splitAsStream( input: _input )
    }

    /// private void java.util.regex.Pattern.subFlag()

    /// public java.lang.String java.util.regex.Pattern.toString()

    // Skipping method: false true false false false 

    /// private int java.util.regex.Pattern.u()

    /// private java.util.regex.Pattern$CharProperty java.util.regex.Pattern.unicodeBlockPropertyFor(java.lang.String)

    /// private java.util.regex.Pattern$CharProperty java.util.regex.Pattern.unicodeScriptPropertyFor(java.lang.String)

    /// private void java.util.regex.Pattern.unread()

    /// private int java.util.regex.Pattern.uxxxx()

    /// private int java.util.regex.Pattern.x()

}

