
import java_swift

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// interface java.util.stream.Stream ///

public protocol Stream: BaseStream {

    /// public static java.util.stream.Stream$Builder java.util.stream.Stream.builder()

    // Skipping method: false false true false false 

    /// public static java.util.stream.Stream java.util.stream.Stream.concat(java.util.stream.Stream,java.util.stream.Stream)

    //    class func concat( a: Stream?, b: Stream? ) -> Stream!

    /// public static java.util.stream.Stream java.util.stream.Stream.empty()

    //    class func empty() -> Stream!

    /// public static java.util.stream.Stream java.util.stream.Stream.generate(java.util.function.Supplier)

    //    class func generate( s: Supplier? ) -> Stream!

    /// public static java.util.stream.Stream java.util.stream.Stream.iterate(java.lang.Object,java.util.function.UnaryOperator)

    //    class func iterate( seed: java_swift.JavaObject?, f: UnaryOperator? ) -> Stream!

    /// public static java.util.stream.Stream java.util.stream.Stream.of(java.lang.Object[])

    //    class func of( values: [JavaObject]? ) -> Stream!

    /// public static java.util.stream.Stream java.util.stream.Stream.of(java.lang.Object)

    //    class func of( t: java_swift.JavaObject? ) -> Stream!

    /// public abstract boolean java.util.stream.Stream.allMatch(java.util.function.Predicate)

    func allMatch( predicate: Predicate? ) -> Bool

    /// public abstract boolean java.util.stream.Stream.anyMatch(java.util.function.Predicate)

    func anyMatch( predicate: Predicate? ) -> Bool

    /// public abstract java.lang.Object java.util.stream.Stream.collect(java.util.stream.Collector)

    func collect( collector: Collector? ) -> java_swift.JavaObject!

    /// public abstract java.lang.Object java.util.stream.Stream.collect(java.util.function.Supplier,java.util.function.BiConsumer,java.util.function.BiConsumer)

    func collect( supplier: Supplier?, accumulator: BiConsumer?, combiner: BiConsumer? ) -> java_swift.JavaObject!

    /// public abstract long java.util.stream.Stream.count()

    func count() -> Int64

    /// public abstract java.util.stream.Stream java.util.stream.Stream.distinct()

    func distinct() -> Stream!

    /// public abstract java.util.stream.Stream java.util.stream.Stream.filter(java.util.function.Predicate)

    func filter( predicate: Predicate? ) -> Stream!

    /// public abstract java.util.Optional java.util.stream.Stream.findAny()

    func findAny() -> Optional!

    /// public abstract java.util.Optional java.util.stream.Stream.findFirst()

    func findFirst() -> Optional!

    /// public abstract java.util.stream.Stream java.util.stream.Stream.flatMap(java.util.function.Function)

    func flatMap( mapper: Function? ) -> Stream!

    /// public abstract java.util.stream.DoubleStream java.util.stream.Stream.flatMapToDouble(java.util.function.Function)

    func flatMapToDouble( mapper: Function? ) -> DoubleStream!

    /// public abstract java.util.stream.IntStream java.util.stream.Stream.flatMapToInt(java.util.function.Function)

    func flatMapToInt( mapper: Function? ) -> IntStream!

    /// public abstract java.util.stream.LongStream java.util.stream.Stream.flatMapToLong(java.util.function.Function)

    func flatMapToLong( mapper: Function? ) -> LongStream!

    /// public abstract void java.util.stream.Stream.forEach(java.util.function.Consumer)

    func forEach( action: Consumer? )

    /// public abstract void java.util.stream.Stream.forEachOrdered(java.util.function.Consumer)

    func forEachOrdered( action: Consumer? )

    /// public abstract java.util.stream.Stream java.util.stream.Stream.limit(long)

    func limit( maxSize: Int64 ) -> Stream!

    /// public abstract java.util.stream.Stream java.util.stream.Stream.map(java.util.function.Function)

    func map( mapper: Function? ) -> Stream!

    /// public abstract java.util.stream.DoubleStream java.util.stream.Stream.mapToDouble(java.util.function.ToDoubleFunction)

    func mapToDouble( mapper: ToDoubleFunction? ) -> DoubleStream!

    /// public abstract java.util.stream.IntStream java.util.stream.Stream.mapToInt(java.util.function.ToIntFunction)

    func mapToInt( mapper: ToIntFunction? ) -> IntStream!

    /// public abstract java.util.stream.LongStream java.util.stream.Stream.mapToLong(java.util.function.ToLongFunction)

    func mapToLong( mapper: ToLongFunction? ) -> LongStream!

    /// public abstract java.util.Optional java.util.stream.Stream.max(java.util.Comparator)

    func max( comparator: JavaComparator? ) -> Optional!

    /// public abstract java.util.Optional java.util.stream.Stream.min(java.util.Comparator)

    func min( comparator: JavaComparator? ) -> Optional!

    /// public abstract boolean java.util.stream.Stream.noneMatch(java.util.function.Predicate)

    func noneMatch( predicate: Predicate? ) -> Bool

    /// public abstract java.util.stream.Stream java.util.stream.Stream.peek(java.util.function.Consumer)

    func peek( action: Consumer? ) -> Stream!

    /// public abstract java.util.Optional java.util.stream.Stream.reduce(java.util.function.BinaryOperator)

    func reduce( accumulator: BinaryOperator? ) -> Optional!

    /// public abstract java.lang.Object java.util.stream.Stream.reduce(java.lang.Object,java.util.function.BiFunction,java.util.function.BinaryOperator)

    func reduce( identity: java_swift.JavaObject?, accumulator: BiFunction?, combiner: BinaryOperator? ) -> java_swift.JavaObject!

    /// public abstract java.lang.Object java.util.stream.Stream.reduce(java.lang.Object,java.util.function.BinaryOperator)

    func reduce( identity: java_swift.JavaObject?, accumulator: BinaryOperator? ) -> java_swift.JavaObject!

    /// public abstract java.util.stream.Stream java.util.stream.Stream.skip(long)

    func skip( n: Int64 ) -> Stream!

    /// public abstract java.util.stream.Stream java.util.stream.Stream.sorted(java.util.Comparator)

    func sorted( comparator: JavaComparator? ) -> Stream!

    /// public abstract java.util.stream.Stream java.util.stream.Stream.sorted()

    func sorted() -> Stream!

    /// public abstract java.lang.Object[] java.util.stream.Stream.toArray(java.util.function.IntFunction)

    func toArray( generator: IntFunction? ) -> [JavaObject]!

    /// public abstract java.lang.Object[] java.util.stream.Stream.toArray()

    func toArray() -> [JavaObject]!

}


open class StreamForward: BaseStreamForward, Stream {

    private static var StreamJNIClass: jclass?

    /// public static java.util.stream.Stream$Builder java.util.stream.Stream.builder()

    // Skipping method: false false true false false 

    /// public static java.util.stream.Stream java.util.stream.Stream.concat(java.util.stream.Stream,java.util.stream.Stream)

    private static var concat_MethodID_39: jmethodID?

    open class func concat( a: Stream?, b: Stream? ) -> Stream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = JNIType.toJava( value: b, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Stream", classCache: &StreamJNIClass, methodName: "concat", methodSig: "(Ljava/util/stream/Stream;Ljava/util/stream/Stream;)Ljava/util/stream/Stream;", methodCache: &concat_MethodID_39, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? StreamForward( javaObject: __return ) : nil
    }

    open class func concat( _ _a: Stream?, _ _b: Stream? ) -> Stream! {
        return concat( a: _a, b: _b )
    }

    /// public static java.util.stream.Stream java.util.stream.Stream.empty()

    private static var empty_MethodID_40: jmethodID?

    open class func empty() -> Stream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Stream", classCache: &StreamJNIClass, methodName: "empty", methodSig: "()Ljava/util/stream/Stream;", methodCache: &empty_MethodID_40, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? StreamForward( javaObject: __return ) : nil
    }


    /// public static java.util.stream.Stream java.util.stream.Stream.generate(java.util.function.Supplier)

    private static var generate_MethodID_41: jmethodID?

    open class func generate( s: Supplier? ) -> Stream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: s, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Stream", classCache: &StreamJNIClass, methodName: "generate", methodSig: "(Ljava/util/function/Supplier;)Ljava/util/stream/Stream;", methodCache: &generate_MethodID_41, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? StreamForward( javaObject: __return ) : nil
    }

    open class func generate( _ _s: Supplier? ) -> Stream! {
        return generate( s: _s )
    }

    /// public static java.util.stream.Stream java.util.stream.Stream.iterate(java.lang.Object,java.util.function.UnaryOperator)

    private static var iterate_MethodID_42: jmethodID?

    open class func iterate( seed: java_swift.JavaObject?, f: UnaryOperator? ) -> Stream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: seed, locals: &__locals )
        __args[1] = JNIType.toJava( value: f, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Stream", classCache: &StreamJNIClass, methodName: "iterate", methodSig: "(Ljava/lang/Object;Ljava/util/function/UnaryOperator;)Ljava/util/stream/Stream;", methodCache: &iterate_MethodID_42, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? StreamForward( javaObject: __return ) : nil
    }

    open class func iterate( _ _seed: java_swift.JavaObject?, _ _f: UnaryOperator? ) -> Stream! {
        return iterate( seed: _seed, f: _f )
    }

    /// public static java.util.stream.Stream java.util.stream.Stream.of(java.lang.Object[])

    private static var of_MethodID_43: jmethodID?

    open class func of( values: [JavaObject]? ) -> Stream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: values, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Stream", classCache: &StreamJNIClass, methodName: "of", methodSig: "([Ljava/lang/Object;)Ljava/util/stream/Stream;", methodCache: &of_MethodID_43, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? StreamForward( javaObject: __return ) : nil
    }

    open class func of( _ _values: [JavaObject]? ) -> Stream! {
        return of( values: _values )
    }

    /// public static java.util.stream.Stream java.util.stream.Stream.of(java.lang.Object)

    private static var of_MethodID_44: jmethodID?

    open class func of( t: java_swift.JavaObject? ) -> Stream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: t, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Stream", classCache: &StreamJNIClass, methodName: "of", methodSig: "(Ljava/lang/Object;)Ljava/util/stream/Stream;", methodCache: &of_MethodID_44, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? StreamForward( javaObject: __return ) : nil
    }

    open class func of( _ _t: java_swift.JavaObject? ) -> Stream! {
        return of( t: _t )
    }

    /// public abstract boolean java.util.stream.Stream.allMatch(java.util.function.Predicate)

    private static var allMatch_MethodID_45: jmethodID?

    open func allMatch( predicate: Predicate? ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: predicate, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "allMatch", methodSig: "(Ljava/util/function/Predicate;)Z", methodCache: &StreamForward.allMatch_MethodID_45, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open func allMatch( _ _predicate: Predicate? ) -> Bool {
        return allMatch( predicate: _predicate )
    }

    /// public abstract boolean java.util.stream.Stream.anyMatch(java.util.function.Predicate)

    private static var anyMatch_MethodID_46: jmethodID?

    open func anyMatch( predicate: Predicate? ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: predicate, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "anyMatch", methodSig: "(Ljava/util/function/Predicate;)Z", methodCache: &StreamForward.anyMatch_MethodID_46, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open func anyMatch( _ _predicate: Predicate? ) -> Bool {
        return anyMatch( predicate: _predicate )
    }

    /// public abstract void java.util.stream.BaseStream.close()

    private static var close_MethodID_47: jmethodID?

    override open func close() {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "close", methodSig: "()V", methodCache: &StreamForward.close_MethodID_47, args: &__args, locals: &__locals )
    }


    /// public abstract java.lang.Object java.util.stream.Stream.collect(java.util.stream.Collector)

    private static var collect_MethodID_48: jmethodID?

    open func collect( collector: Collector? ) -> java_swift.JavaObject! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: collector, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "collect", methodSig: "(Ljava/util/stream/Collector;)Ljava/lang/Object;", methodCache: &StreamForward.collect_MethodID_48, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? java_swift.JavaObject( javaObject: __return ) : nil
    }

    open func collect( _ _collector: Collector? ) -> java_swift.JavaObject! {
        return collect( collector: _collector )
    }

    /// public abstract java.lang.Object java.util.stream.Stream.collect(java.util.function.Supplier,java.util.function.BiConsumer,java.util.function.BiConsumer)

    private static var collect_MethodID_49: jmethodID?

    open func collect( supplier: Supplier?, accumulator: BiConsumer?, combiner: BiConsumer? ) -> java_swift.JavaObject! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: supplier, locals: &__locals )
        __args[1] = JNIType.toJava( value: accumulator, locals: &__locals )
        __args[2] = JNIType.toJava( value: combiner, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "collect", methodSig: "(Ljava/util/function/Supplier;Ljava/util/function/BiConsumer;Ljava/util/function/BiConsumer;)Ljava/lang/Object;", methodCache: &StreamForward.collect_MethodID_49, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? java_swift.JavaObject( javaObject: __return ) : nil
    }

    open func collect( _ _supplier: Supplier?, _ _accumulator: BiConsumer?, _ _combiner: BiConsumer? ) -> java_swift.JavaObject! {
        return collect( supplier: _supplier, accumulator: _accumulator, combiner: _combiner )
    }

    /// public abstract long java.util.stream.Stream.count()

    private static var count_MethodID_50: jmethodID?

    open func count() -> Int64 {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "count", methodSig: "()J", methodCache: &StreamForward.count_MethodID_50, args: &__args, locals: &__locals )
        return __return
    }


    /// public abstract java.util.stream.Stream java.util.stream.Stream.distinct()

    private static var distinct_MethodID_51: jmethodID?

    open func distinct() -> Stream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "distinct", methodSig: "()Ljava/util/stream/Stream;", methodCache: &StreamForward.distinct_MethodID_51, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? StreamForward( javaObject: __return ) : nil
    }


    /// public abstract java.util.stream.Stream java.util.stream.Stream.filter(java.util.function.Predicate)

    private static var filter_MethodID_52: jmethodID?

    open func filter( predicate: Predicate? ) -> Stream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: predicate, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "filter", methodSig: "(Ljava/util/function/Predicate;)Ljava/util/stream/Stream;", methodCache: &StreamForward.filter_MethodID_52, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? StreamForward( javaObject: __return ) : nil
    }

    open func filter( _ _predicate: Predicate? ) -> Stream! {
        return filter( predicate: _predicate )
    }

    /// public abstract java.util.Optional java.util.stream.Stream.findAny()

    private static var findAny_MethodID_53: jmethodID?

    open func findAny() -> Optional! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "findAny", methodSig: "()Ljava/util/Optional;", methodCache: &StreamForward.findAny_MethodID_53, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? Optional( javaObject: __return ) : nil
    }


    /// public abstract java.util.Optional java.util.stream.Stream.findFirst()

    private static var findFirst_MethodID_54: jmethodID?

    open func findFirst() -> Optional! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "findFirst", methodSig: "()Ljava/util/Optional;", methodCache: &StreamForward.findFirst_MethodID_54, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? Optional( javaObject: __return ) : nil
    }


    /// public abstract java.util.stream.Stream java.util.stream.Stream.flatMap(java.util.function.Function)

    private static var flatMap_MethodID_55: jmethodID?

    open func flatMap( mapper: Function? ) -> Stream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: mapper, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "flatMap", methodSig: "(Ljava/util/function/Function;)Ljava/util/stream/Stream;", methodCache: &StreamForward.flatMap_MethodID_55, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? StreamForward( javaObject: __return ) : nil
    }

    open func flatMap( _ _mapper: Function? ) -> Stream! {
        return flatMap( mapper: _mapper )
    }

    /// public abstract java.util.stream.DoubleStream java.util.stream.Stream.flatMapToDouble(java.util.function.Function)

    private static var flatMapToDouble_MethodID_56: jmethodID?

    open func flatMapToDouble( mapper: Function? ) -> DoubleStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: mapper, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "flatMapToDouble", methodSig: "(Ljava/util/function/Function;)Ljava/util/stream/DoubleStream;", methodCache: &StreamForward.flatMapToDouble_MethodID_56, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? DoubleStreamForward( javaObject: __return ) : nil
    }

    open func flatMapToDouble( _ _mapper: Function? ) -> DoubleStream! {
        return flatMapToDouble( mapper: _mapper )
    }

    /// public abstract java.util.stream.IntStream java.util.stream.Stream.flatMapToInt(java.util.function.Function)

    private static var flatMapToInt_MethodID_57: jmethodID?

    open func flatMapToInt( mapper: Function? ) -> IntStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: mapper, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "flatMapToInt", methodSig: "(Ljava/util/function/Function;)Ljava/util/stream/IntStream;", methodCache: &StreamForward.flatMapToInt_MethodID_57, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? IntStreamForward( javaObject: __return ) : nil
    }

    open func flatMapToInt( _ _mapper: Function? ) -> IntStream! {
        return flatMapToInt( mapper: _mapper )
    }

    /// public abstract java.util.stream.LongStream java.util.stream.Stream.flatMapToLong(java.util.function.Function)

    private static var flatMapToLong_MethodID_58: jmethodID?

    open func flatMapToLong( mapper: Function? ) -> LongStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: mapper, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "flatMapToLong", methodSig: "(Ljava/util/function/Function;)Ljava/util/stream/LongStream;", methodCache: &StreamForward.flatMapToLong_MethodID_58, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? LongStreamForward( javaObject: __return ) : nil
    }

    open func flatMapToLong( _ _mapper: Function? ) -> LongStream! {
        return flatMapToLong( mapper: _mapper )
    }

    /// public abstract void java.util.stream.Stream.forEach(java.util.function.Consumer)

    private static var forEach_MethodID_59: jmethodID?

    open func forEach( action: Consumer? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: action, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "forEach", methodSig: "(Ljava/util/function/Consumer;)V", methodCache: &StreamForward.forEach_MethodID_59, args: &__args, locals: &__locals )
    }

    open func forEach( _ _action: Consumer? ) {
        forEach( action: _action )
    }

    /// public abstract void java.util.stream.Stream.forEachOrdered(java.util.function.Consumer)

    private static var forEachOrdered_MethodID_60: jmethodID?

    open func forEachOrdered( action: Consumer? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: action, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "forEachOrdered", methodSig: "(Ljava/util/function/Consumer;)V", methodCache: &StreamForward.forEachOrdered_MethodID_60, args: &__args, locals: &__locals )
    }

    open func forEachOrdered( _ _action: Consumer? ) {
        forEachOrdered( action: _action )
    }

    /// public abstract boolean java.util.stream.BaseStream.isParallel()

    private static var isParallel_MethodID_61: jmethodID?

    override open func isParallel() -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isParallel", methodSig: "()Z", methodCache: &StreamForward.isParallel_MethodID_61, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }


    /// public abstract java.util.Iterator java.util.stream.BaseStream.iterator()

    private static var iterator_MethodID_62: jmethodID?

    override open func iterator() -> Iterator! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "iterator", methodSig: "()Ljava/util/Iterator;", methodCache: &StreamForward.iterator_MethodID_62, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? IteratorForward( javaObject: __return ) : nil
    }


    /// public abstract java.util.stream.Stream java.util.stream.Stream.limit(long)

    private static var limit_MethodID_63: jmethodID?

    open func limit( maxSize: Int64 ) -> Stream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( j: maxSize )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "limit", methodSig: "(J)Ljava/util/stream/Stream;", methodCache: &StreamForward.limit_MethodID_63, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? StreamForward( javaObject: __return ) : nil
    }

    open func limit( _ _maxSize: Int64 ) -> Stream! {
        return limit( maxSize: _maxSize )
    }

    /// public abstract java.util.stream.Stream java.util.stream.Stream.map(java.util.function.Function)

    private static var map_MethodID_64: jmethodID?

    open func map( mapper: Function? ) -> Stream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: mapper, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "map", methodSig: "(Ljava/util/function/Function;)Ljava/util/stream/Stream;", methodCache: &StreamForward.map_MethodID_64, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? StreamForward( javaObject: __return ) : nil
    }

    open func map( _ _mapper: Function? ) -> Stream! {
        return map( mapper: _mapper )
    }

    /// public abstract java.util.stream.DoubleStream java.util.stream.Stream.mapToDouble(java.util.function.ToDoubleFunction)

    private static var mapToDouble_MethodID_65: jmethodID?

    open func mapToDouble( mapper: ToDoubleFunction? ) -> DoubleStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: mapper, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "mapToDouble", methodSig: "(Ljava/util/function/ToDoubleFunction;)Ljava/util/stream/DoubleStream;", methodCache: &StreamForward.mapToDouble_MethodID_65, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? DoubleStreamForward( javaObject: __return ) : nil
    }

    open func mapToDouble( _ _mapper: ToDoubleFunction? ) -> DoubleStream! {
        return mapToDouble( mapper: _mapper )
    }

    /// public abstract java.util.stream.IntStream java.util.stream.Stream.mapToInt(java.util.function.ToIntFunction)

    private static var mapToInt_MethodID_66: jmethodID?

    open func mapToInt( mapper: ToIntFunction? ) -> IntStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: mapper, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "mapToInt", methodSig: "(Ljava/util/function/ToIntFunction;)Ljava/util/stream/IntStream;", methodCache: &StreamForward.mapToInt_MethodID_66, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? IntStreamForward( javaObject: __return ) : nil
    }

    open func mapToInt( _ _mapper: ToIntFunction? ) -> IntStream! {
        return mapToInt( mapper: _mapper )
    }

    /// public abstract java.util.stream.LongStream java.util.stream.Stream.mapToLong(java.util.function.ToLongFunction)

    private static var mapToLong_MethodID_67: jmethodID?

    open func mapToLong( mapper: ToLongFunction? ) -> LongStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: mapper, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "mapToLong", methodSig: "(Ljava/util/function/ToLongFunction;)Ljava/util/stream/LongStream;", methodCache: &StreamForward.mapToLong_MethodID_67, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? LongStreamForward( javaObject: __return ) : nil
    }

    open func mapToLong( _ _mapper: ToLongFunction? ) -> LongStream! {
        return mapToLong( mapper: _mapper )
    }

    /// public abstract java.util.Optional java.util.stream.Stream.max(java.util.Comparator)

    private static var max_MethodID_68: jmethodID?

    open func max( comparator: JavaComparator? ) -> Optional! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: comparator, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "max", methodSig: "(Ljava/util/Comparator;)Ljava/util/Optional;", methodCache: &StreamForward.max_MethodID_68, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? Optional( javaObject: __return ) : nil
    }

    open func max( _ _comparator: JavaComparator? ) -> Optional! {
        return max( comparator: _comparator )
    }

    /// public abstract java.util.Optional java.util.stream.Stream.min(java.util.Comparator)

    private static var min_MethodID_69: jmethodID?

    open func min( comparator: JavaComparator? ) -> Optional! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: comparator, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "min", methodSig: "(Ljava/util/Comparator;)Ljava/util/Optional;", methodCache: &StreamForward.min_MethodID_69, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? Optional( javaObject: __return ) : nil
    }

    open func min( _ _comparator: JavaComparator? ) -> Optional! {
        return min( comparator: _comparator )
    }

    /// public abstract boolean java.util.stream.Stream.noneMatch(java.util.function.Predicate)

    private static var noneMatch_MethodID_70: jmethodID?

    open func noneMatch( predicate: Predicate? ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: predicate, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "noneMatch", methodSig: "(Ljava/util/function/Predicate;)Z", methodCache: &StreamForward.noneMatch_MethodID_70, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open func noneMatch( _ _predicate: Predicate? ) -> Bool {
        return noneMatch( predicate: _predicate )
    }

    /// public abstract java.util.stream.BaseStream java.util.stream.BaseStream.onClose(java.lang.Runnable)

    private static var onClose_MethodID_71: jmethodID?

    override open func onClose( closeHandler: java_swift.Runnable? ) -> BaseStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: closeHandler, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "onClose", methodSig: "(Ljava/lang/Runnable;)Ljava/util/stream/BaseStream;", methodCache: &StreamForward.onClose_MethodID_71, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? BaseStreamForward( javaObject: __return ) : nil
    }

    override open func onClose( _ _closeHandler: java_swift.Runnable? ) -> BaseStream! {
        return onClose( closeHandler: _closeHandler )
    }

    /// public abstract java.util.stream.BaseStream java.util.stream.BaseStream.parallel()

    private static var parallel_MethodID_72: jmethodID?

    override open func parallel() -> BaseStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "parallel", methodSig: "()Ljava/util/stream/BaseStream;", methodCache: &StreamForward.parallel_MethodID_72, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? BaseStreamForward( javaObject: __return ) : nil
    }


    /// public abstract java.util.stream.Stream java.util.stream.Stream.peek(java.util.function.Consumer)

    private static var peek_MethodID_73: jmethodID?

    open func peek( action: Consumer? ) -> Stream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: action, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "peek", methodSig: "(Ljava/util/function/Consumer;)Ljava/util/stream/Stream;", methodCache: &StreamForward.peek_MethodID_73, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? StreamForward( javaObject: __return ) : nil
    }

    open func peek( _ _action: Consumer? ) -> Stream! {
        return peek( action: _action )
    }

    /// public abstract java.util.Optional java.util.stream.Stream.reduce(java.util.function.BinaryOperator)

    private static var reduce_MethodID_74: jmethodID?

    open func reduce( accumulator: BinaryOperator? ) -> Optional! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: accumulator, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "reduce", methodSig: "(Ljava/util/function/BinaryOperator;)Ljava/util/Optional;", methodCache: &StreamForward.reduce_MethodID_74, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? Optional( javaObject: __return ) : nil
    }

    open func reduce( _ _accumulator: BinaryOperator? ) -> Optional! {
        return reduce( accumulator: _accumulator )
    }

    /// public abstract java.lang.Object java.util.stream.Stream.reduce(java.lang.Object,java.util.function.BiFunction,java.util.function.BinaryOperator)

    private static var reduce_MethodID_75: jmethodID?

    open func reduce( identity: java_swift.JavaObject?, accumulator: BiFunction?, combiner: BinaryOperator? ) -> java_swift.JavaObject! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: identity, locals: &__locals )
        __args[1] = JNIType.toJava( value: accumulator, locals: &__locals )
        __args[2] = JNIType.toJava( value: combiner, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "reduce", methodSig: "(Ljava/lang/Object;Ljava/util/function/BiFunction;Ljava/util/function/BinaryOperator;)Ljava/lang/Object;", methodCache: &StreamForward.reduce_MethodID_75, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? java_swift.JavaObject( javaObject: __return ) : nil
    }

    open func reduce( _ _identity: java_swift.JavaObject?, _ _accumulator: BiFunction?, _ _combiner: BinaryOperator? ) -> java_swift.JavaObject! {
        return reduce( identity: _identity, accumulator: _accumulator, combiner: _combiner )
    }

    /// public abstract java.lang.Object java.util.stream.Stream.reduce(java.lang.Object,java.util.function.BinaryOperator)

    private static var reduce_MethodID_76: jmethodID?

    open func reduce( identity: java_swift.JavaObject?, accumulator: BinaryOperator? ) -> java_swift.JavaObject! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: identity, locals: &__locals )
        __args[1] = JNIType.toJava( value: accumulator, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "reduce", methodSig: "(Ljava/lang/Object;Ljava/util/function/BinaryOperator;)Ljava/lang/Object;", methodCache: &StreamForward.reduce_MethodID_76, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? java_swift.JavaObject( javaObject: __return ) : nil
    }

    open func reduce( _ _identity: java_swift.JavaObject?, _ _accumulator: BinaryOperator? ) -> java_swift.JavaObject! {
        return reduce( identity: _identity, accumulator: _accumulator )
    }

    /// public abstract java.util.stream.BaseStream java.util.stream.BaseStream.sequential()

    private static var sequential_MethodID_77: jmethodID?

    override open func sequential() -> BaseStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "sequential", methodSig: "()Ljava/util/stream/BaseStream;", methodCache: &StreamForward.sequential_MethodID_77, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? BaseStreamForward( javaObject: __return ) : nil
    }


    /// public abstract java.util.stream.Stream java.util.stream.Stream.skip(long)

    private static var skip_MethodID_78: jmethodID?

    open func skip( n: Int64 ) -> Stream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( j: n )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "skip", methodSig: "(J)Ljava/util/stream/Stream;", methodCache: &StreamForward.skip_MethodID_78, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? StreamForward( javaObject: __return ) : nil
    }

    open func skip( _ _n: Int64 ) -> Stream! {
        return skip( n: _n )
    }

    /// public abstract java.util.stream.Stream java.util.stream.Stream.sorted(java.util.Comparator)

    private static var sorted_MethodID_79: jmethodID?

    open func sorted( comparator: JavaComparator? ) -> Stream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: comparator, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "sorted", methodSig: "(Ljava/util/Comparator;)Ljava/util/stream/Stream;", methodCache: &StreamForward.sorted_MethodID_79, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? StreamForward( javaObject: __return ) : nil
    }

    open func sorted( _ _comparator: JavaComparator? ) -> Stream! {
        return sorted( comparator: _comparator )
    }

    /// public abstract java.util.stream.Stream java.util.stream.Stream.sorted()

    private static var sorted_MethodID_80: jmethodID?

    open func sorted() -> Stream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "sorted", methodSig: "()Ljava/util/stream/Stream;", methodCache: &StreamForward.sorted_MethodID_80, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? StreamForward( javaObject: __return ) : nil
    }


    /// public abstract java.util.Spliterator java.util.stream.BaseStream.spliterator()

    private static var spliterator_MethodID_81: jmethodID?

    override open func spliterator() -> Spliterator! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "spliterator", methodSig: "()Ljava/util/Spliterator;", methodCache: &StreamForward.spliterator_MethodID_81, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? SpliteratorForward( javaObject: __return ) : nil
    }


    /// public abstract java.lang.Object[] java.util.stream.Stream.toArray(java.util.function.IntFunction)

    private static var toArray_MethodID_82: jmethodID?

    open func toArray( generator: IntFunction? ) -> [JavaObject]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: generator, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "toArray", methodSig: "(Ljava/util/function/IntFunction;)[Ljava/lang/Object;", methodCache: &StreamForward.toArray_MethodID_82, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [JavaObject].self, from: __return )
    }

    open func toArray( _ _generator: IntFunction? ) -> [JavaObject]! {
        return toArray( generator: _generator )
    }

    /// public abstract java.lang.Object[] java.util.stream.Stream.toArray()

    private static var toArray_MethodID_83: jmethodID?

    open func toArray() -> [JavaObject]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "toArray", methodSig: "()[Ljava/lang/Object;", methodCache: &StreamForward.toArray_MethodID_83, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [JavaObject].self, from: __return )
    }


    /// public abstract java.util.stream.BaseStream java.util.stream.BaseStream.unordered()

    private static var unordered_MethodID_84: jmethodID?

    override open func unordered() -> BaseStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "unordered", methodSig: "()Ljava/util/stream/BaseStream;", methodCache: &StreamForward.unordered_MethodID_84, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? BaseStreamForward( javaObject: __return ) : nil
    }


}

