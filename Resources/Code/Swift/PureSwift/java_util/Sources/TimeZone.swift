
import java_swift
import java_lang

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// class java.util.TimeZone ///

open class TimeZone: java_swift.JavaObject, /* interface java.io.Serializable */ UnavailableProtocol, java_lang.Cloneable {

    public convenience init?( casting object: java_swift.JavaObject, _ file: StaticString = #file, _ line: Int = #line ) {
        self.init( javaObject: nil )
        if !object.validDownCast( toJavaClass: "java.util.TimeZone", file, line ) {
            return nil
        }
        object.withJavaObject {
            self.javaObject = $0
        }
    }

    private static var TimeZoneJNIClass: jclass?

    /// static final boolean java.util.TimeZone.$assertionsDisabled

    // Skipping field: true false false false false false 

    /// static final java.lang.String java.util.TimeZone.GMT_ID

    // Skipping field: true false false false false false 

    /// private static final int java.util.TimeZone.GMT_ID_LENGTH

    /// public static final int java.util.TimeZone.LONG

    private static var LONG_FieldID: jfieldID?

    public static var LONG: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "LONG", fieldType: "I", fieldCache: &LONG_FieldID, className: "java/util/TimeZone", classCache: &TimeZoneJNIClass )
            return Int(__value)
        }
    }

    /// static final java.util.TimeZone java.util.TimeZone.NO_TIMEZONE

    // Skipping field: true false false false false false 

    /// private static final int java.util.TimeZone.ONE_DAY

    /// private static final int java.util.TimeZone.ONE_HOUR

    /// private static final int java.util.TimeZone.ONE_MINUTE

    /// public static final int java.util.TimeZone.SHORT

    private static var SHORT_FieldID: jfieldID?

    public static var SHORT: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "SHORT", fieldType: "I", fieldCache: &SHORT_FieldID, className: "java/util/TimeZone", classCache: &TimeZoneJNIClass )
            return Int(__value)
        }
    }

    /// private static volatile java.util.TimeZone java.util.TimeZone.defaultTimeZone

    /// private static volatile java.util.TimeZone java.util.TimeZone.mainAppContextDefault

    /// static final long java.util.TimeZone.serialVersionUID

    // Skipping field: true true false false false false 

    /// private java.lang.String java.util.TimeZone.ID

    /// public java.util.TimeZone()

    private static var new_MethodID_1: jmethodID?

    public convenience init() {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __object = JNIMethod.NewObject( className: "java/util/TimeZone", classCache: &TimeZone.TimeZoneJNIClass, methodSig: "()V", methodCache: &TimeZone.new_MethodID_1, args: &__args, locals: &__locals )
        self.init( javaObject: __object )
        JNI.DeleteLocalRef( __object )
    }

    /// public static synchronized java.lang.String[] java.util.TimeZone.getAvailableIDs(int)

    private static var getAvailableIDs_MethodID_2: jmethodID?

    open class func getAvailableIDs( arg0: Int ) -> [String]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(arg0) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/TimeZone", classCache: &TimeZoneJNIClass, methodName: "getAvailableIDs", methodSig: "(I)[Ljava/lang/String;", methodCache: &getAvailableIDs_MethodID_2, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [String].self, from: __return )
    }

    open class func getAvailableIDs( _ _arg0: Int ) -> [String]! {
        return getAvailableIDs( arg0: _arg0 )
    }

    /// public static synchronized java.lang.String[] java.util.TimeZone.getAvailableIDs()

    private static var getAvailableIDs_MethodID_3: jmethodID?

    open class func getAvailableIDs() -> [String]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/TimeZone", classCache: &TimeZoneJNIClass, methodName: "getAvailableIDs", methodSig: "()[Ljava/lang/String;", methodCache: &getAvailableIDs_MethodID_3, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [String].self, from: __return )
    }


    /// public static java.util.TimeZone java.util.TimeZone.getDefault()

    private static var getDefault_MethodID_4: jmethodID?

    open class func getDefault() -> TimeZone! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/TimeZone", classCache: &TimeZoneJNIClass, methodName: "getDefault", methodSig: "()Ljava/util/TimeZone;", methodCache: &getDefault_MethodID_4, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? TimeZone( javaObject: __return ) : nil
    }


    /// static java.util.TimeZone java.util.TimeZone.getDefaultRef()

    // Skipping method: true false false false false 

    /// private static java.lang.String[] java.util.TimeZone.getDisplayNames(java.lang.String,java.util.Locale)

    /// private static native java.lang.String java.util.TimeZone.getSystemGMTOffsetID()

    /// private static native java.lang.String java.util.TimeZone.getSystemTimeZoneID(java.lang.String)

    /// public static synchronized java.util.TimeZone java.util.TimeZone.getTimeZone(java.lang.String)

    private static var getTimeZone_MethodID_5: jmethodID?

    open class func getTimeZone( arg0: String? ) -> TimeZone! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/TimeZone", classCache: &TimeZoneJNIClass, methodName: "getTimeZone", methodSig: "(Ljava/lang/String;)Ljava/util/TimeZone;", methodCache: &getTimeZone_MethodID_5, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? TimeZone( javaObject: __return ) : nil
    }

    open class func getTimeZone( _ _arg0: String? ) -> TimeZone! {
        return getTimeZone( arg0: _arg0 )
    }

    /// private static java.util.TimeZone java.util.TimeZone.getTimeZone(java.lang.String,boolean)

    /// public static java.util.TimeZone java.util.TimeZone.getTimeZone(java.time.ZoneId)

    private static var getTimeZone_MethodID_6: jmethodID?

    open class func getTimeZone( arg0: /* class java.time.ZoneId */ UnavailableObject? ) -> TimeZone! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/TimeZone", classCache: &TimeZoneJNIClass, methodName: "getTimeZone", methodSig: "(Ljava/time/ZoneId;)Ljava/util/TimeZone;", methodCache: &getTimeZone_MethodID_6, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? TimeZone( javaObject: __return ) : nil
    }

    open class func getTimeZone( _ _arg0: /* class java.time.ZoneId */ UnavailableObject? ) -> TimeZone! {
        return getTimeZone( arg0: _arg0 )
    }

    /// private static final java.util.TimeZone java.util.TimeZone.parseCustomTimeZone(java.lang.String)

    /// public static void java.util.TimeZone.setDefault(java.util.TimeZone)

    private static var setDefault_MethodID_7: jmethodID?

    open class func setDefault( arg0: TimeZone? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: arg0, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/TimeZone", classCache: &TimeZoneJNIClass, methodName: "setDefault", methodSig: "(Ljava/util/TimeZone;)V", methodCache: &setDefault_MethodID_7, args: &__args, locals: &__locals )
    }

    open class func setDefault( _ _arg0: TimeZone? ) {
        setDefault( arg0: _arg0 )
    }

    /// private static synchronized java.util.TimeZone java.util.TimeZone.setDefaultZone()

    /// public java.lang.Object java.util.TimeZone.clone()

    private static var clone_MethodID_8: jmethodID?

    override open func clone() -> java_swift.JavaObject! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "clone", methodSig: "()Ljava/lang/Object;", methodCache: &TimeZone.clone_MethodID_8, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? java_swift.JavaObject( javaObject: __return ) : nil
    }


    /// public int java.util.TimeZone.getDSTSavings()

    private static var getDSTSavings_MethodID_9: jmethodID?

    open func getDSTSavings() -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getDSTSavings", methodSig: "()I", methodCache: &TimeZone.getDSTSavings_MethodID_9, args: &__args, locals: &__locals )
        return Int(__return)
    }


    /// public final java.lang.String java.util.TimeZone.getDisplayName(boolean,int)

    private static var getDisplayName_MethodID_10: jmethodID?

    open func getDisplayName( arg0: Bool, arg1: Int ) -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = jvalue( z: jboolean(arg0 ? JNI_TRUE : JNI_FALSE) )
        __args[1] = jvalue( i: jint(arg1) )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getDisplayName", methodSig: "(ZI)Ljava/lang/String;", methodCache: &TimeZone.getDisplayName_MethodID_10, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? String( javaObject: __return ) : nil
    }

    open func getDisplayName( _ _arg0: Bool, _ _arg1: Int ) -> String! {
        return getDisplayName( arg0: _arg0, arg1: _arg1 )
    }

    /// public java.lang.String java.util.TimeZone.getDisplayName(boolean,int,java.util.Locale)

    private static var getDisplayName_MethodID_11: jmethodID?

    open func getDisplayName( arg0: Bool, arg1: Int, arg2: JavaLocale? ) -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = jvalue( z: jboolean(arg0 ? JNI_TRUE : JNI_FALSE) )
        __args[1] = jvalue( i: jint(arg1) )
        __args[2] = JNIType.toJava( value: arg2, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getDisplayName", methodSig: "(ZILjava/util/Locale;)Ljava/lang/String;", methodCache: &TimeZone.getDisplayName_MethodID_11, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? String( javaObject: __return ) : nil
    }

    open func getDisplayName( _ _arg0: Bool, _ _arg1: Int, _ _arg2: JavaLocale? ) -> String! {
        return getDisplayName( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public final java.lang.String java.util.TimeZone.getDisplayName(java.util.Locale)

    private static var getDisplayName_MethodID_12: jmethodID?

    open func getDisplayName( arg0: JavaLocale? ) -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getDisplayName", methodSig: "(Ljava/util/Locale;)Ljava/lang/String;", methodCache: &TimeZone.getDisplayName_MethodID_12, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? String( javaObject: __return ) : nil
    }

    open func getDisplayName( _ _arg0: JavaLocale? ) -> String! {
        return getDisplayName( arg0: _arg0 )
    }

    /// public final java.lang.String java.util.TimeZone.getDisplayName()

    private static var getDisplayName_MethodID_13: jmethodID?

    open func getDisplayName() -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getDisplayName", methodSig: "()Ljava/lang/String;", methodCache: &TimeZone.getDisplayName_MethodID_13, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? String( javaObject: __return ) : nil
    }


    /// public java.lang.String java.util.TimeZone.getID()

    private static var getID_MethodID_14: jmethodID?

    open func getID() -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getID", methodSig: "()Ljava/lang/String;", methodCache: &TimeZone.getID_MethodID_14, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? String( javaObject: __return ) : nil
    }


    /// public abstract int java.util.TimeZone.getOffset(int,int,int,int,int,int)

    private static var getOffset_MethodID_15: jmethodID?

    open func getOffset( arg0: Int, arg1: Int, arg2: Int, arg3: Int, arg4: Int, arg5: Int ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 6 )
        __args[0] = jvalue( i: jint(arg0) )
        __args[1] = jvalue( i: jint(arg1) )
        __args[2] = jvalue( i: jint(arg2) )
        __args[3] = jvalue( i: jint(arg3) )
        __args[4] = jvalue( i: jint(arg4) )
        __args[5] = jvalue( i: jint(arg5) )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getOffset", methodSig: "(IIIIII)I", methodCache: &TimeZone.getOffset_MethodID_15, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open func getOffset( _ _arg0: Int, _ _arg1: Int, _ _arg2: Int, _ _arg3: Int, _ _arg4: Int, _ _arg5: Int ) -> Int {
        return getOffset( arg0: _arg0, arg1: _arg1, arg2: _arg2, arg3: _arg3, arg4: _arg4, arg5: _arg5 )
    }

    /// public int java.util.TimeZone.getOffset(long)

    private static var getOffset_MethodID_16: jmethodID?

    open func getOffset( arg0: Int64 ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( j: arg0 )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getOffset", methodSig: "(J)I", methodCache: &TimeZone.getOffset_MethodID_16, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open func getOffset( _ _arg0: Int64 ) -> Int {
        return getOffset( arg0: _arg0 )
    }

    /// int java.util.TimeZone.getOffsets(long,int[])

    // Skipping method: true false false false false 

    /// public abstract int java.util.TimeZone.getRawOffset()

    private static var getRawOffset_MethodID_17: jmethodID?

    open func getRawOffset() -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getRawOffset", methodSig: "()I", methodCache: &TimeZone.getRawOffset_MethodID_17, args: &__args, locals: &__locals )
        return Int(__return)
    }


    /// public boolean java.util.TimeZone.hasSameRules(java.util.TimeZone)

    private static var hasSameRules_MethodID_18: jmethodID?

    open func hasSameRules( arg0: TimeZone? ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "hasSameRules", methodSig: "(Ljava/util/TimeZone;)Z", methodCache: &TimeZone.hasSameRules_MethodID_18, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open func hasSameRules( _ _arg0: TimeZone? ) -> Bool {
        return hasSameRules( arg0: _arg0 )
    }

    /// public abstract boolean java.util.TimeZone.inDaylightTime(java.util.Date)

    private static var inDaylightTime_MethodID_19: jmethodID?

    open func inDaylightTime( arg0: Date? ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "inDaylightTime", methodSig: "(Ljava/util/Date;)Z", methodCache: &TimeZone.inDaylightTime_MethodID_19, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open func inDaylightTime( _ _arg0: Date? ) -> Bool {
        return inDaylightTime( arg0: _arg0 )
    }

    /// public boolean java.util.TimeZone.observesDaylightTime()

    private static var observesDaylightTime_MethodID_20: jmethodID?

    open func observesDaylightTime() -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "observesDaylightTime", methodSig: "()Z", methodCache: &TimeZone.observesDaylightTime_MethodID_20, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }


    /// public void java.util.TimeZone.setID(java.lang.String)

    private static var setID_MethodID_21: jmethodID?

    open func setID( arg0: String? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setID", methodSig: "(Ljava/lang/String;)V", methodCache: &TimeZone.setID_MethodID_21, args: &__args, locals: &__locals )
    }

    open func setID( _ _arg0: String? ) {
        setID( arg0: _arg0 )
    }

    /// public abstract void java.util.TimeZone.setRawOffset(int)

    private static var setRawOffset_MethodID_22: jmethodID?

    open func setRawOffset( arg0: Int ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(arg0) )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setRawOffset", methodSig: "(I)V", methodCache: &TimeZone.setRawOffset_MethodID_22, args: &__args, locals: &__locals )
    }

    open func setRawOffset( _ _arg0: Int ) {
        setRawOffset( arg0: _arg0 )
    }

    /// public java.time.ZoneId java.util.TimeZone.toZoneId()

    private static var toZoneId_MethodID_23: jmethodID?

    open func toZoneId() -> /* class java.time.ZoneId */ UnavailableObject! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "toZoneId", methodSig: "()Ljava/time/ZoneId;", methodCache: &TimeZone.toZoneId_MethodID_23, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? /* class java.time.ZoneId */ UnavailableObject( javaObject: __return ) : nil
    }


    /// public abstract boolean java.util.TimeZone.useDaylightTime()

    private static var useDaylightTime_MethodID_24: jmethodID?

    open func useDaylightTime() -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "useDaylightTime", methodSig: "()Z", methodCache: &TimeZone.useDaylightTime_MethodID_24, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }


}

