
import java_swift

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// interface java.util.stream.IntStream ///

public protocol IntStream: BaseStream {

    /// public static java.util.stream.IntStream$Builder java.util.stream.IntStream.builder()

    // Skipping method: false false true false false 

    /// public static java.util.stream.IntStream java.util.stream.IntStream.concat(java.util.stream.IntStream,java.util.stream.IntStream)

    //    class func concat( a: IntStream?, b: IntStream? ) -> IntStream!

    /// public static java.util.stream.IntStream java.util.stream.IntStream.empty()

    //    class func empty() -> IntStream!

    /// public static java.util.stream.IntStream java.util.stream.IntStream.generate(java.util.function.IntSupplier)

    //    class func generate( s: IntSupplier? ) -> IntStream!

    /// public static java.util.stream.IntStream java.util.stream.IntStream.iterate(int,java.util.function.IntUnaryOperator)

    //    class func iterate( seed: Int, f: IntUnaryOperator? ) -> IntStream!

    /// public static java.util.stream.IntStream java.util.stream.IntStream.of(int)

    //    class func of( t: Int ) -> IntStream!

    /// public static java.util.stream.IntStream java.util.stream.IntStream.of(int[])

    //    class func of( values: [Int32]? ) -> IntStream!

    /// public static java.util.stream.IntStream java.util.stream.IntStream.range(int,int)

    //    class func range( startInclusive: Int, endExclusive: Int ) -> IntStream!

    /// public static java.util.stream.IntStream java.util.stream.IntStream.rangeClosed(int,int)

    //    class func rangeClosed( startInclusive: Int, endInclusive: Int ) -> IntStream!

    /// public abstract boolean java.util.stream.IntStream.allMatch(java.util.function.IntPredicate)

    func allMatch( predicate: IntPredicate? ) -> Bool

    /// public abstract boolean java.util.stream.IntStream.anyMatch(java.util.function.IntPredicate)

    func anyMatch( predicate: IntPredicate? ) -> Bool

    /// public abstract java.util.stream.DoubleStream java.util.stream.IntStream.asDoubleStream()

    func asDoubleStream() -> DoubleStream!

    /// public abstract java.util.stream.LongStream java.util.stream.IntStream.asLongStream()

    func asLongStream() -> LongStream!

    /// public abstract java.util.OptionalDouble java.util.stream.IntStream.average()

    func average() -> OptionalDouble!

    /// public abstract java.util.stream.Stream java.util.stream.IntStream.boxed()

    func boxed() -> Stream!

    /// public abstract java.lang.Object java.util.stream.IntStream.collect(java.util.function.Supplier,java.util.function.ObjIntConsumer,java.util.function.BiConsumer)

    func collect( supplier: Supplier?, accumulator: ObjIntConsumer?, combiner: BiConsumer? ) -> java_swift.JavaObject!

    /// public abstract long java.util.stream.IntStream.count()

    func count() -> Int64

    /// public abstract java.util.stream.IntStream java.util.stream.IntStream.distinct()

    func distinct() -> IntStream!

    /// public abstract java.util.stream.IntStream java.util.stream.IntStream.filter(java.util.function.IntPredicate)

    func filter( predicate: IntPredicate? ) -> IntStream!

    /// public abstract java.util.OptionalInt java.util.stream.IntStream.findAny()

    func findAny() -> OptionalInt!

    /// public abstract java.util.OptionalInt java.util.stream.IntStream.findFirst()

    func findFirst() -> OptionalInt!

    /// public abstract java.util.stream.IntStream java.util.stream.IntStream.flatMap(java.util.function.IntFunction)

    func flatMap( mapper: IntFunction? ) -> IntStream!

    /// public abstract void java.util.stream.IntStream.forEach(java.util.function.IntConsumer)

    func forEach( action: IntConsumer? )

    /// public abstract void java.util.stream.IntStream.forEachOrdered(java.util.function.IntConsumer)

    func forEachOrdered( action: IntConsumer? )

    /// public default java.util.Iterator java.util.stream.IntStream.iterator()

    func iterator() -> Iterator!

    /// public abstract java.util.PrimitiveIterator$OfInt java.util.stream.IntStream.iterator()

    // Skipping method: false false true false false 

    /// public abstract java.util.stream.IntStream java.util.stream.IntStream.limit(long)

    func limit( maxSize: Int64 ) -> IntStream!

    /// public abstract java.util.stream.IntStream java.util.stream.IntStream.map(java.util.function.IntUnaryOperator)

    func map( mapper: IntUnaryOperator? ) -> IntStream!

    /// public abstract java.util.stream.DoubleStream java.util.stream.IntStream.mapToDouble(java.util.function.IntToDoubleFunction)

    func mapToDouble( mapper: IntToDoubleFunction? ) -> DoubleStream!

    /// public abstract java.util.stream.LongStream java.util.stream.IntStream.mapToLong(java.util.function.IntToLongFunction)

    func mapToLong( mapper: IntToLongFunction? ) -> LongStream!

    /// public abstract java.util.stream.Stream java.util.stream.IntStream.mapToObj(java.util.function.IntFunction)

    func mapToObj( mapper: IntFunction? ) -> Stream!

    /// public abstract java.util.OptionalInt java.util.stream.IntStream.max()

    func max() -> OptionalInt!

    /// public abstract java.util.OptionalInt java.util.stream.IntStream.min()

    func min() -> OptionalInt!

    /// public abstract boolean java.util.stream.IntStream.noneMatch(java.util.function.IntPredicate)

    func noneMatch( predicate: IntPredicate? ) -> Bool

    /// public default java.util.stream.BaseStream java.util.stream.IntStream.parallel()

    func parallel() -> BaseStream!

    /// public abstract java.util.stream.IntStream java.util.stream.IntStream.parallel()

    /// public abstract java.util.stream.IntStream java.util.stream.IntStream.peek(java.util.function.IntConsumer)

    func peek( action: IntConsumer? ) -> IntStream!

    /// public abstract int java.util.stream.IntStream.reduce(int,java.util.function.IntBinaryOperator)

    func reduce( identity: Int, op: IntBinaryOperator? ) -> Int

    /// public abstract java.util.OptionalInt java.util.stream.IntStream.reduce(java.util.function.IntBinaryOperator)

    func reduce( op: IntBinaryOperator? ) -> OptionalInt!

    /// public abstract java.util.stream.IntStream java.util.stream.IntStream.sequential()

    func sequential() -> IntStream!

    /// public default java.util.stream.BaseStream java.util.stream.IntStream.sequential()

    /// public abstract java.util.stream.IntStream java.util.stream.IntStream.skip(long)

    func skip( n: Int64 ) -> IntStream!

    /// public abstract java.util.stream.IntStream java.util.stream.IntStream.sorted()

    func sorted() -> IntStream!

    /// public default java.util.Spliterator java.util.stream.IntStream.spliterator()

    func spliterator() -> Spliterator!

    /// public abstract java.util.Spliterator$OfInt java.util.stream.IntStream.spliterator()

    // Skipping method: false false true false false 

    /// public abstract int java.util.stream.IntStream.sum()

    func sum() -> Int

    /// public abstract java.util.IntSummaryStatistics java.util.stream.IntStream.summaryStatistics()

    func summaryStatistics() -> IntSummaryStatistics!

    /// public abstract int[] java.util.stream.IntStream.toArray()

    func toArray() -> [Int32]!

}


open class IntStreamForward: BaseStreamForward, IntStream {

    private static var IntStreamJNIClass: jclass?

    /// public static java.util.stream.IntStream$Builder java.util.stream.IntStream.builder()

    // Skipping method: false false true false false 

    /// public static java.util.stream.IntStream java.util.stream.IntStream.concat(java.util.stream.IntStream,java.util.stream.IntStream)

    private static var concat_MethodID_44: jmethodID?

    open class func concat( a: IntStream?, b: IntStream? ) -> IntStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = JNIType.toJava( value: b, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/IntStream", classCache: &IntStreamJNIClass, methodName: "concat", methodSig: "(Ljava/util/stream/IntStream;Ljava/util/stream/IntStream;)Ljava/util/stream/IntStream;", methodCache: &concat_MethodID_44, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? IntStreamForward( javaObject: __return ) : nil
    }

    open class func concat( _ _a: IntStream?, _ _b: IntStream? ) -> IntStream! {
        return concat( a: _a, b: _b )
    }

    /// public static java.util.stream.IntStream java.util.stream.IntStream.empty()

    private static var empty_MethodID_45: jmethodID?

    open class func empty() -> IntStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/IntStream", classCache: &IntStreamJNIClass, methodName: "empty", methodSig: "()Ljava/util/stream/IntStream;", methodCache: &empty_MethodID_45, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? IntStreamForward( javaObject: __return ) : nil
    }


    /// public static java.util.stream.IntStream java.util.stream.IntStream.generate(java.util.function.IntSupplier)

    private static var generate_MethodID_46: jmethodID?

    open class func generate( s: IntSupplier? ) -> IntStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: s, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/IntStream", classCache: &IntStreamJNIClass, methodName: "generate", methodSig: "(Ljava/util/function/IntSupplier;)Ljava/util/stream/IntStream;", methodCache: &generate_MethodID_46, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? IntStreamForward( javaObject: __return ) : nil
    }

    open class func generate( _ _s: IntSupplier? ) -> IntStream! {
        return generate( s: _s )
    }

    /// public static java.util.stream.IntStream java.util.stream.IntStream.iterate(int,java.util.function.IntUnaryOperator)

    private static var iterate_MethodID_47: jmethodID?

    open class func iterate( seed: Int, f: IntUnaryOperator? ) -> IntStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = jvalue( i: jint(seed) )
        __args[1] = JNIType.toJava( value: f, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/IntStream", classCache: &IntStreamJNIClass, methodName: "iterate", methodSig: "(ILjava/util/function/IntUnaryOperator;)Ljava/util/stream/IntStream;", methodCache: &iterate_MethodID_47, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? IntStreamForward( javaObject: __return ) : nil
    }

    open class func iterate( _ _seed: Int, _ _f: IntUnaryOperator? ) -> IntStream! {
        return iterate( seed: _seed, f: _f )
    }

    /// public static java.util.stream.IntStream java.util.stream.IntStream.of(int)

    private static var of_MethodID_48: jmethodID?

    open class func of( t: Int ) -> IntStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(t) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/IntStream", classCache: &IntStreamJNIClass, methodName: "of", methodSig: "(I)Ljava/util/stream/IntStream;", methodCache: &of_MethodID_48, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? IntStreamForward( javaObject: __return ) : nil
    }

    open class func of( _ _t: Int ) -> IntStream! {
        return of( t: _t )
    }

    /// public static java.util.stream.IntStream java.util.stream.IntStream.of(int[])

    private static var of_MethodID_49: jmethodID?

    open class func of( values: [Int32]? ) -> IntStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: values, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/IntStream", classCache: &IntStreamJNIClass, methodName: "of", methodSig: "([I)Ljava/util/stream/IntStream;", methodCache: &of_MethodID_49, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? IntStreamForward( javaObject: __return ) : nil
    }

    open class func of( _ _values: [Int32]? ) -> IntStream! {
        return of( values: _values )
    }

    /// public static java.util.stream.IntStream java.util.stream.IntStream.range(int,int)

    private static var range_MethodID_50: jmethodID?

    open class func range( startInclusive: Int, endExclusive: Int ) -> IntStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = jvalue( i: jint(startInclusive) )
        __args[1] = jvalue( i: jint(endExclusive) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/IntStream", classCache: &IntStreamJNIClass, methodName: "range", methodSig: "(II)Ljava/util/stream/IntStream;", methodCache: &range_MethodID_50, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? IntStreamForward( javaObject: __return ) : nil
    }

    open class func range( _ _startInclusive: Int, _ _endExclusive: Int ) -> IntStream! {
        return range( startInclusive: _startInclusive, endExclusive: _endExclusive )
    }

    /// public static java.util.stream.IntStream java.util.stream.IntStream.rangeClosed(int,int)

    private static var rangeClosed_MethodID_51: jmethodID?

    open class func rangeClosed( startInclusive: Int, endInclusive: Int ) -> IntStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = jvalue( i: jint(startInclusive) )
        __args[1] = jvalue( i: jint(endInclusive) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/IntStream", classCache: &IntStreamJNIClass, methodName: "rangeClosed", methodSig: "(II)Ljava/util/stream/IntStream;", methodCache: &rangeClosed_MethodID_51, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? IntStreamForward( javaObject: __return ) : nil
    }

    open class func rangeClosed( _ _startInclusive: Int, _ _endInclusive: Int ) -> IntStream! {
        return rangeClosed( startInclusive: _startInclusive, endInclusive: _endInclusive )
    }

    /// public abstract boolean java.util.stream.IntStream.allMatch(java.util.function.IntPredicate)

    private static var allMatch_MethodID_52: jmethodID?

    open func allMatch( predicate: IntPredicate? ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: predicate, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "allMatch", methodSig: "(Ljava/util/function/IntPredicate;)Z", methodCache: &IntStreamForward.allMatch_MethodID_52, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open func allMatch( _ _predicate: IntPredicate? ) -> Bool {
        return allMatch( predicate: _predicate )
    }

    /// public abstract boolean java.util.stream.IntStream.anyMatch(java.util.function.IntPredicate)

    private static var anyMatch_MethodID_53: jmethodID?

    open func anyMatch( predicate: IntPredicate? ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: predicate, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "anyMatch", methodSig: "(Ljava/util/function/IntPredicate;)Z", methodCache: &IntStreamForward.anyMatch_MethodID_53, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open func anyMatch( _ _predicate: IntPredicate? ) -> Bool {
        return anyMatch( predicate: _predicate )
    }

    /// public abstract java.util.stream.DoubleStream java.util.stream.IntStream.asDoubleStream()

    private static var asDoubleStream_MethodID_54: jmethodID?

    open func asDoubleStream() -> DoubleStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "asDoubleStream", methodSig: "()Ljava/util/stream/DoubleStream;", methodCache: &IntStreamForward.asDoubleStream_MethodID_54, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? DoubleStreamForward( javaObject: __return ) : nil
    }


    /// public abstract java.util.stream.LongStream java.util.stream.IntStream.asLongStream()

    private static var asLongStream_MethodID_55: jmethodID?

    open func asLongStream() -> LongStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "asLongStream", methodSig: "()Ljava/util/stream/LongStream;", methodCache: &IntStreamForward.asLongStream_MethodID_55, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? LongStreamForward( javaObject: __return ) : nil
    }


    /// public abstract java.util.OptionalDouble java.util.stream.IntStream.average()

    private static var average_MethodID_56: jmethodID?

    open func average() -> OptionalDouble! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "average", methodSig: "()Ljava/util/OptionalDouble;", methodCache: &IntStreamForward.average_MethodID_56, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? OptionalDouble( javaObject: __return ) : nil
    }


    /// public abstract java.util.stream.Stream java.util.stream.IntStream.boxed()

    private static var boxed_MethodID_57: jmethodID?

    open func boxed() -> Stream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "boxed", methodSig: "()Ljava/util/stream/Stream;", methodCache: &IntStreamForward.boxed_MethodID_57, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? StreamForward( javaObject: __return ) : nil
    }


    /// public abstract void java.util.stream.BaseStream.close()

    private static var close_MethodID_58: jmethodID?

    override open func close() {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "close", methodSig: "()V", methodCache: &IntStreamForward.close_MethodID_58, args: &__args, locals: &__locals )
    }


    /// public abstract java.lang.Object java.util.stream.IntStream.collect(java.util.function.Supplier,java.util.function.ObjIntConsumer,java.util.function.BiConsumer)

    private static var collect_MethodID_59: jmethodID?

    open func collect( supplier: Supplier?, accumulator: ObjIntConsumer?, combiner: BiConsumer? ) -> java_swift.JavaObject! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: supplier, locals: &__locals )
        __args[1] = JNIType.toJava( value: accumulator, locals: &__locals )
        __args[2] = JNIType.toJava( value: combiner, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "collect", methodSig: "(Ljava/util/function/Supplier;Ljava/util/function/ObjIntConsumer;Ljava/util/function/BiConsumer;)Ljava/lang/Object;", methodCache: &IntStreamForward.collect_MethodID_59, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? java_swift.JavaObject( javaObject: __return ) : nil
    }

    open func collect( _ _supplier: Supplier?, _ _accumulator: ObjIntConsumer?, _ _combiner: BiConsumer? ) -> java_swift.JavaObject! {
        return collect( supplier: _supplier, accumulator: _accumulator, combiner: _combiner )
    }

    /// public abstract long java.util.stream.IntStream.count()

    private static var count_MethodID_60: jmethodID?

    open func count() -> Int64 {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "count", methodSig: "()J", methodCache: &IntStreamForward.count_MethodID_60, args: &__args, locals: &__locals )
        return __return
    }


    /// public abstract java.util.stream.IntStream java.util.stream.IntStream.distinct()

    private static var distinct_MethodID_61: jmethodID?

    open func distinct() -> IntStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "distinct", methodSig: "()Ljava/util/stream/IntStream;", methodCache: &IntStreamForward.distinct_MethodID_61, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? IntStreamForward( javaObject: __return ) : nil
    }


    /// public abstract java.util.stream.IntStream java.util.stream.IntStream.filter(java.util.function.IntPredicate)

    private static var filter_MethodID_62: jmethodID?

    open func filter( predicate: IntPredicate? ) -> IntStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: predicate, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "filter", methodSig: "(Ljava/util/function/IntPredicate;)Ljava/util/stream/IntStream;", methodCache: &IntStreamForward.filter_MethodID_62, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? IntStreamForward( javaObject: __return ) : nil
    }

    open func filter( _ _predicate: IntPredicate? ) -> IntStream! {
        return filter( predicate: _predicate )
    }

    /// public abstract java.util.OptionalInt java.util.stream.IntStream.findAny()

    private static var findAny_MethodID_63: jmethodID?

    open func findAny() -> OptionalInt! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "findAny", methodSig: "()Ljava/util/OptionalInt;", methodCache: &IntStreamForward.findAny_MethodID_63, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? OptionalInt( javaObject: __return ) : nil
    }


    /// public abstract java.util.OptionalInt java.util.stream.IntStream.findFirst()

    private static var findFirst_MethodID_64: jmethodID?

    open func findFirst() -> OptionalInt! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "findFirst", methodSig: "()Ljava/util/OptionalInt;", methodCache: &IntStreamForward.findFirst_MethodID_64, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? OptionalInt( javaObject: __return ) : nil
    }


    /// public abstract java.util.stream.IntStream java.util.stream.IntStream.flatMap(java.util.function.IntFunction)

    private static var flatMap_MethodID_65: jmethodID?

    open func flatMap( mapper: IntFunction? ) -> IntStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: mapper, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "flatMap", methodSig: "(Ljava/util/function/IntFunction;)Ljava/util/stream/IntStream;", methodCache: &IntStreamForward.flatMap_MethodID_65, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? IntStreamForward( javaObject: __return ) : nil
    }

    open func flatMap( _ _mapper: IntFunction? ) -> IntStream! {
        return flatMap( mapper: _mapper )
    }

    /// public abstract void java.util.stream.IntStream.forEach(java.util.function.IntConsumer)

    private static var forEach_MethodID_66: jmethodID?

    open func forEach( action: IntConsumer? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: action, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "forEach", methodSig: "(Ljava/util/function/IntConsumer;)V", methodCache: &IntStreamForward.forEach_MethodID_66, args: &__args, locals: &__locals )
    }

    open func forEach( _ _action: IntConsumer? ) {
        forEach( action: _action )
    }

    /// public abstract void java.util.stream.IntStream.forEachOrdered(java.util.function.IntConsumer)

    private static var forEachOrdered_MethodID_67: jmethodID?

    open func forEachOrdered( action: IntConsumer? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: action, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "forEachOrdered", methodSig: "(Ljava/util/function/IntConsumer;)V", methodCache: &IntStreamForward.forEachOrdered_MethodID_67, args: &__args, locals: &__locals )
    }

    open func forEachOrdered( _ _action: IntConsumer? ) {
        forEachOrdered( action: _action )
    }

    /// public abstract boolean java.util.stream.BaseStream.isParallel()

    private static var isParallel_MethodID_68: jmethodID?

    override open func isParallel() -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isParallel", methodSig: "()Z", methodCache: &IntStreamForward.isParallel_MethodID_68, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }


    /// public default java.util.Iterator java.util.stream.IntStream.iterator()

    private static var iterator_MethodID_69: jmethodID?

    override open func iterator() -> Iterator! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "iterator", methodSig: "()Ljava/util/Iterator;", methodCache: &IntStreamForward.iterator_MethodID_69, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? IteratorForward( javaObject: __return ) : nil
    }


    /// public abstract java.util.PrimitiveIterator$OfInt java.util.stream.IntStream.iterator()

    // Skipping method: false false true false false 

    /// public abstract java.util.stream.IntStream java.util.stream.IntStream.limit(long)

    private static var limit_MethodID_70: jmethodID?

    open func limit( maxSize: Int64 ) -> IntStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( j: maxSize )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "limit", methodSig: "(J)Ljava/util/stream/IntStream;", methodCache: &IntStreamForward.limit_MethodID_70, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? IntStreamForward( javaObject: __return ) : nil
    }

    open func limit( _ _maxSize: Int64 ) -> IntStream! {
        return limit( maxSize: _maxSize )
    }

    /// public abstract java.util.stream.IntStream java.util.stream.IntStream.map(java.util.function.IntUnaryOperator)

    private static var map_MethodID_71: jmethodID?

    open func map( mapper: IntUnaryOperator? ) -> IntStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: mapper, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "map", methodSig: "(Ljava/util/function/IntUnaryOperator;)Ljava/util/stream/IntStream;", methodCache: &IntStreamForward.map_MethodID_71, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? IntStreamForward( javaObject: __return ) : nil
    }

    open func map( _ _mapper: IntUnaryOperator? ) -> IntStream! {
        return map( mapper: _mapper )
    }

    /// public abstract java.util.stream.DoubleStream java.util.stream.IntStream.mapToDouble(java.util.function.IntToDoubleFunction)

    private static var mapToDouble_MethodID_72: jmethodID?

    open func mapToDouble( mapper: IntToDoubleFunction? ) -> DoubleStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: mapper, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "mapToDouble", methodSig: "(Ljava/util/function/IntToDoubleFunction;)Ljava/util/stream/DoubleStream;", methodCache: &IntStreamForward.mapToDouble_MethodID_72, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? DoubleStreamForward( javaObject: __return ) : nil
    }

    open func mapToDouble( _ _mapper: IntToDoubleFunction? ) -> DoubleStream! {
        return mapToDouble( mapper: _mapper )
    }

    /// public abstract java.util.stream.LongStream java.util.stream.IntStream.mapToLong(java.util.function.IntToLongFunction)

    private static var mapToLong_MethodID_73: jmethodID?

    open func mapToLong( mapper: IntToLongFunction? ) -> LongStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: mapper, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "mapToLong", methodSig: "(Ljava/util/function/IntToLongFunction;)Ljava/util/stream/LongStream;", methodCache: &IntStreamForward.mapToLong_MethodID_73, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? LongStreamForward( javaObject: __return ) : nil
    }

    open func mapToLong( _ _mapper: IntToLongFunction? ) -> LongStream! {
        return mapToLong( mapper: _mapper )
    }

    /// public abstract java.util.stream.Stream java.util.stream.IntStream.mapToObj(java.util.function.IntFunction)

    private static var mapToObj_MethodID_74: jmethodID?

    open func mapToObj( mapper: IntFunction? ) -> Stream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: mapper, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "mapToObj", methodSig: "(Ljava/util/function/IntFunction;)Ljava/util/stream/Stream;", methodCache: &IntStreamForward.mapToObj_MethodID_74, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? StreamForward( javaObject: __return ) : nil
    }

    open func mapToObj( _ _mapper: IntFunction? ) -> Stream! {
        return mapToObj( mapper: _mapper )
    }

    /// public abstract java.util.OptionalInt java.util.stream.IntStream.max()

    private static var max_MethodID_75: jmethodID?

    open func max() -> OptionalInt! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "max", methodSig: "()Ljava/util/OptionalInt;", methodCache: &IntStreamForward.max_MethodID_75, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? OptionalInt( javaObject: __return ) : nil
    }


    /// public abstract java.util.OptionalInt java.util.stream.IntStream.min()

    private static var min_MethodID_76: jmethodID?

    open func min() -> OptionalInt! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "min", methodSig: "()Ljava/util/OptionalInt;", methodCache: &IntStreamForward.min_MethodID_76, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? OptionalInt( javaObject: __return ) : nil
    }


    /// public abstract boolean java.util.stream.IntStream.noneMatch(java.util.function.IntPredicate)

    private static var noneMatch_MethodID_77: jmethodID?

    open func noneMatch( predicate: IntPredicate? ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: predicate, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "noneMatch", methodSig: "(Ljava/util/function/IntPredicate;)Z", methodCache: &IntStreamForward.noneMatch_MethodID_77, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open func noneMatch( _ _predicate: IntPredicate? ) -> Bool {
        return noneMatch( predicate: _predicate )
    }

    /// public abstract java.util.stream.BaseStream java.util.stream.BaseStream.onClose(java.lang.Runnable)

    private static var onClose_MethodID_78: jmethodID?

    override open func onClose( closeHandler: java_swift.Runnable? ) -> BaseStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: closeHandler, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "onClose", methodSig: "(Ljava/lang/Runnable;)Ljava/util/stream/BaseStream;", methodCache: &IntStreamForward.onClose_MethodID_78, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? BaseStreamForward( javaObject: __return ) : nil
    }

    override open func onClose( _ _closeHandler: java_swift.Runnable? ) -> BaseStream! {
        return onClose( closeHandler: _closeHandler )
    }

    /// public default java.util.stream.BaseStream java.util.stream.IntStream.parallel()

    private static var parallel_MethodID_79: jmethodID?

    override open func parallel() -> BaseStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "parallel", methodSig: "()Ljava/util/stream/BaseStream;", methodCache: &IntStreamForward.parallel_MethodID_79, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? BaseStreamForward( javaObject: __return ) : nil
    }


    /// public abstract java.util.stream.IntStream java.util.stream.IntStream.parallel()

    /// public abstract java.util.stream.IntStream java.util.stream.IntStream.peek(java.util.function.IntConsumer)

    private static var peek_MethodID_80: jmethodID?

    open func peek( action: IntConsumer? ) -> IntStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: action, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "peek", methodSig: "(Ljava/util/function/IntConsumer;)Ljava/util/stream/IntStream;", methodCache: &IntStreamForward.peek_MethodID_80, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? IntStreamForward( javaObject: __return ) : nil
    }

    open func peek( _ _action: IntConsumer? ) -> IntStream! {
        return peek( action: _action )
    }

    /// public abstract int java.util.stream.IntStream.reduce(int,java.util.function.IntBinaryOperator)

    private static var reduce_MethodID_81: jmethodID?

    open func reduce( identity: Int, op: IntBinaryOperator? ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = jvalue( i: jint(identity) )
        __args[1] = JNIType.toJava( value: op, locals: &__locals )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "reduce", methodSig: "(ILjava/util/function/IntBinaryOperator;)I", methodCache: &IntStreamForward.reduce_MethodID_81, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open func reduce( _ _identity: Int, _ _op: IntBinaryOperator? ) -> Int {
        return reduce( identity: _identity, op: _op )
    }

    /// public abstract java.util.OptionalInt java.util.stream.IntStream.reduce(java.util.function.IntBinaryOperator)

    private static var reduce_MethodID_82: jmethodID?

    open func reduce( op: IntBinaryOperator? ) -> OptionalInt! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: op, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "reduce", methodSig: "(Ljava/util/function/IntBinaryOperator;)Ljava/util/OptionalInt;", methodCache: &IntStreamForward.reduce_MethodID_82, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? OptionalInt( javaObject: __return ) : nil
    }

    open func reduce( _ _op: IntBinaryOperator? ) -> OptionalInt! {
        return reduce( op: _op )
    }

    /// public abstract java.util.stream.IntStream java.util.stream.IntStream.sequential()

    private static var sequential_MethodID_83: jmethodID?

    open func sequential() -> IntStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "sequential", methodSig: "()Ljava/util/stream/IntStream;", methodCache: &IntStreamForward.sequential_MethodID_83, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? IntStreamForward( javaObject: __return ) : nil
    }


    /// public default java.util.stream.BaseStream java.util.stream.IntStream.sequential()

    /// public abstract java.util.stream.IntStream java.util.stream.IntStream.skip(long)

    private static var skip_MethodID_84: jmethodID?

    open func skip( n: Int64 ) -> IntStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( j: n )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "skip", methodSig: "(J)Ljava/util/stream/IntStream;", methodCache: &IntStreamForward.skip_MethodID_84, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? IntStreamForward( javaObject: __return ) : nil
    }

    open func skip( _ _n: Int64 ) -> IntStream! {
        return skip( n: _n )
    }

    /// public abstract java.util.stream.IntStream java.util.stream.IntStream.sorted()

    private static var sorted_MethodID_85: jmethodID?

    open func sorted() -> IntStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "sorted", methodSig: "()Ljava/util/stream/IntStream;", methodCache: &IntStreamForward.sorted_MethodID_85, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? IntStreamForward( javaObject: __return ) : nil
    }


    /// public default java.util.Spliterator java.util.stream.IntStream.spliterator()

    private static var spliterator_MethodID_86: jmethodID?

    override open func spliterator() -> Spliterator! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "spliterator", methodSig: "()Ljava/util/Spliterator;", methodCache: &IntStreamForward.spliterator_MethodID_86, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? SpliteratorForward( javaObject: __return ) : nil
    }


    /// public abstract java.util.Spliterator$OfInt java.util.stream.IntStream.spliterator()

    // Skipping method: false false true false false 

    /// public abstract int java.util.stream.IntStream.sum()

    private static var sum_MethodID_87: jmethodID?

    open func sum() -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "sum", methodSig: "()I", methodCache: &IntStreamForward.sum_MethodID_87, args: &__args, locals: &__locals )
        return Int(__return)
    }


    /// public abstract java.util.IntSummaryStatistics java.util.stream.IntStream.summaryStatistics()

    private static var summaryStatistics_MethodID_88: jmethodID?

    open func summaryStatistics() -> IntSummaryStatistics! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "summaryStatistics", methodSig: "()Ljava/util/IntSummaryStatistics;", methodCache: &IntStreamForward.summaryStatistics_MethodID_88, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? IntSummaryStatistics( javaObject: __return ) : nil
    }


    /// public abstract int[] java.util.stream.IntStream.toArray()

    private static var toArray_MethodID_89: jmethodID?

    open func toArray() -> [Int32]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "toArray", methodSig: "()[I", methodCache: &IntStreamForward.toArray_MethodID_89, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [Int32].self, from: __return )
    }


    /// public abstract java.util.stream.BaseStream java.util.stream.BaseStream.unordered()

    private static var unordered_MethodID_90: jmethodID?

    override open func unordered() -> BaseStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "unordered", methodSig: "()Ljava/util/stream/BaseStream;", methodCache: &IntStreamForward.unordered_MethodID_90, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? BaseStreamForward( javaObject: __return ) : nil
    }


}

