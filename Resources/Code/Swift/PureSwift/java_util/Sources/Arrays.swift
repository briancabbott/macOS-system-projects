
import java_swift
import java_lang

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// class java.util.Arrays ///

open class Arrays: java_swift.JavaObject {

    public convenience init?( casting object: java_swift.JavaObject, _ file: StaticString = #file, _ line: Int = #line ) {
        self.init( javaObject: nil )
        object.withJavaObject {
            self.javaObject = $0
        }
    }

    private static var ArraysJNIClass: jclass?

    /// static final boolean java.util.Arrays.$assertionsDisabled

    // Skipping field: true false false false false false 

    /// private static final int java.util.Arrays.INSERTIONSORT_THRESHOLD

    /// private static final int java.util.Arrays.MIN_ARRAY_SORT_GRAN

    /// private java.util.Arrays()

    /// public static java.util.List java.util.Arrays.asList(java.lang.Object[])

    private static var asList_MethodID_1: jmethodID?

    open class func asList( a: [JavaObject]? ) -> List! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "asList", methodSig: "([Ljava/lang/Object;)Ljava/util/List;", methodCache: &asList_MethodID_1, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? ListForward( javaObject: __return ) : nil
    }

    open class func asList( _ _a: [JavaObject]? ) -> List! {
        return asList( a: _a )
    }

    /// public static int java.util.Arrays.binarySearch(double[],double)

    private static var binarySearch_MethodID_2: jmethodID?

    open class func binarySearch( a: [Double]?, key: Double ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( d: key )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "binarySearch", methodSig: "([DD)I", methodCache: &binarySearch_MethodID_2, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func binarySearch( _ _a: [Double]?, _ _key: Double ) -> Int {
        return binarySearch( a: _a, key: _key )
    }

    /// public static int java.util.Arrays.binarySearch(double[],int,int,double)

    private static var binarySearch_MethodID_3: jmethodID?

    open class func binarySearch( a: [Double]?, fromIndex: Int, toIndex: Int, key: Double ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        __args[3] = jvalue( d: key )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "binarySearch", methodSig: "([DIID)I", methodCache: &binarySearch_MethodID_3, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func binarySearch( _ _a: [Double]?, _ _fromIndex: Int, _ _toIndex: Int, _ _key: Double ) -> Int {
        return binarySearch( a: _a, fromIndex: _fromIndex, toIndex: _toIndex, key: _key )
    }

    /// public static int java.util.Arrays.binarySearch(float[],float)

    private static var binarySearch_MethodID_4: jmethodID?

    open class func binarySearch( a: [Float]?, key: Float ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( f: key )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "binarySearch", methodSig: "([FF)I", methodCache: &binarySearch_MethodID_4, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func binarySearch( _ _a: [Float]?, _ _key: Float ) -> Int {
        return binarySearch( a: _a, key: _key )
    }

    /// public static int java.util.Arrays.binarySearch(float[],int,int,float)

    private static var binarySearch_MethodID_5: jmethodID?

    open class func binarySearch( a: [Float]?, fromIndex: Int, toIndex: Int, key: Float ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        __args[3] = jvalue( f: key )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "binarySearch", methodSig: "([FIIF)I", methodCache: &binarySearch_MethodID_5, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func binarySearch( _ _a: [Float]?, _ _fromIndex: Int, _ _toIndex: Int, _ _key: Float ) -> Int {
        return binarySearch( a: _a, fromIndex: _fromIndex, toIndex: _toIndex, key: _key )
    }

    /// public static int java.util.Arrays.binarySearch(short[],int,int,short)

    private static var binarySearch_MethodID_6: jmethodID?

    open class func binarySearch( a: [Int16]?, fromIndex: Int, toIndex: Int, key: Int16 ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        __args[3] = jvalue( s: key )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "binarySearch", methodSig: "([SIIS)I", methodCache: &binarySearch_MethodID_6, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func binarySearch( _ _a: [Int16]?, _ _fromIndex: Int, _ _toIndex: Int, _ _key: Int16 ) -> Int {
        return binarySearch( a: _a, fromIndex: _fromIndex, toIndex: _toIndex, key: _key )
    }

    /// public static int java.util.Arrays.binarySearch(short[],short)

    private static var binarySearch_MethodID_7: jmethodID?

    open class func binarySearch( a: [Int16]?, key: Int16 ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( s: key )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "binarySearch", methodSig: "([SS)I", methodCache: &binarySearch_MethodID_7, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func binarySearch( _ _a: [Int16]?, _ _key: Int16 ) -> Int {
        return binarySearch( a: _a, key: _key )
    }

    /// public static int java.util.Arrays.binarySearch(int[],int)

    private static var binarySearch_MethodID_8: jmethodID?

    open class func binarySearch( a: [Int32]?, key: Int ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( i: jint(key) )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "binarySearch", methodSig: "([II)I", methodCache: &binarySearch_MethodID_8, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func binarySearch( _ _a: [Int32]?, _ _key: Int ) -> Int {
        return binarySearch( a: _a, key: _key )
    }

    /// public static int java.util.Arrays.binarySearch(int[],int,int,int)

    private static var binarySearch_MethodID_9: jmethodID?

    open class func binarySearch( a: [Int32]?, fromIndex: Int, toIndex: Int, key: Int ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        __args[3] = jvalue( i: jint(key) )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "binarySearch", methodSig: "([IIII)I", methodCache: &binarySearch_MethodID_9, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func binarySearch( _ _a: [Int32]?, _ _fromIndex: Int, _ _toIndex: Int, _ _key: Int ) -> Int {
        return binarySearch( a: _a, fromIndex: _fromIndex, toIndex: _toIndex, key: _key )
    }

    /// public static int java.util.Arrays.binarySearch(long[],int,int,long)

    private static var binarySearch_MethodID_10: jmethodID?

    open class func binarySearch( a: [Int64]?, fromIndex: Int, toIndex: Int, key: Int64 ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        __args[3] = jvalue( j: key )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "binarySearch", methodSig: "([JIIJ)I", methodCache: &binarySearch_MethodID_10, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func binarySearch( _ _a: [Int64]?, _ _fromIndex: Int, _ _toIndex: Int, _ _key: Int64 ) -> Int {
        return binarySearch( a: _a, fromIndex: _fromIndex, toIndex: _toIndex, key: _key )
    }

    /// public static int java.util.Arrays.binarySearch(long[],long)

    private static var binarySearch_MethodID_11: jmethodID?

    open class func binarySearch( a: [Int64]?, key: Int64 ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( j: key )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "binarySearch", methodSig: "([JJ)I", methodCache: &binarySearch_MethodID_11, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func binarySearch( _ _a: [Int64]?, _ _key: Int64 ) -> Int {
        return binarySearch( a: _a, key: _key )
    }

    /// public static int java.util.Arrays.binarySearch(byte[],int,int,byte)

    private static var binarySearch_MethodID_12: jmethodID?

    open class func binarySearch( a: [Int8]?, fromIndex: Int, toIndex: Int, key: Int8 ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        __args[3] = jvalue( b: key )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "binarySearch", methodSig: "([BIIB)I", methodCache: &binarySearch_MethodID_12, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func binarySearch( _ _a: [Int8]?, _ _fromIndex: Int, _ _toIndex: Int, _ _key: Int8 ) -> Int {
        return binarySearch( a: _a, fromIndex: _fromIndex, toIndex: _toIndex, key: _key )
    }

    /// public static int java.util.Arrays.binarySearch(byte[],byte)

    private static var binarySearch_MethodID_13: jmethodID?

    open class func binarySearch( a: [Int8]?, key: Int8 ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( b: key )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "binarySearch", methodSig: "([BB)I", methodCache: &binarySearch_MethodID_13, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func binarySearch( _ _a: [Int8]?, _ _key: Int8 ) -> Int {
        return binarySearch( a: _a, key: _key )
    }

    /// public static int java.util.Arrays.binarySearch(java.lang.Object[],int,int,java.lang.Object)

    private static var binarySearch_MethodID_14: jmethodID?

    open class func binarySearch( a: [JavaObject]?, fromIndex: Int, toIndex: Int, key: java_swift.JavaObject? ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        __args[3] = JNIType.toJava( value: key, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "binarySearch", methodSig: "([Ljava/lang/Object;IILjava/lang/Object;)I", methodCache: &binarySearch_MethodID_14, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func binarySearch( _ _a: [JavaObject]?, _ _fromIndex: Int, _ _toIndex: Int, _ _key: java_swift.JavaObject? ) -> Int {
        return binarySearch( a: _a, fromIndex: _fromIndex, toIndex: _toIndex, key: _key )
    }

    /// public static int java.util.Arrays.binarySearch(java.lang.Object[],int,int,java.lang.Object,java.util.Comparator)

    private static var binarySearch_MethodID_15: jmethodID?

    open class func binarySearch( a: [JavaObject]?, fromIndex: Int, toIndex: Int, key: java_swift.JavaObject?, c: JavaComparator? ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 5 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        __args[3] = JNIType.toJava( value: key, locals: &__locals )
        __args[4] = JNIType.toJava( value: c, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "binarySearch", methodSig: "([Ljava/lang/Object;IILjava/lang/Object;Ljava/util/Comparator;)I", methodCache: &binarySearch_MethodID_15, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func binarySearch( _ _a: [JavaObject]?, _ _fromIndex: Int, _ _toIndex: Int, _ _key: java_swift.JavaObject?, _ _c: JavaComparator? ) -> Int {
        return binarySearch( a: _a, fromIndex: _fromIndex, toIndex: _toIndex, key: _key, c: _c )
    }

    /// public static int java.util.Arrays.binarySearch(java.lang.Object[],java.lang.Object)

    private static var binarySearch_MethodID_16: jmethodID?

    open class func binarySearch( a: [JavaObject]?, key: java_swift.JavaObject? ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = JNIType.toJava( value: key, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "binarySearch", methodSig: "([Ljava/lang/Object;Ljava/lang/Object;)I", methodCache: &binarySearch_MethodID_16, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func binarySearch( _ _a: [JavaObject]?, _ _key: java_swift.JavaObject? ) -> Int {
        return binarySearch( a: _a, key: _key )
    }

    /// public static int java.util.Arrays.binarySearch(java.lang.Object[],java.lang.Object,java.util.Comparator)

    private static var binarySearch_MethodID_17: jmethodID?

    open class func binarySearch( a: [JavaObject]?, key: java_swift.JavaObject?, c: JavaComparator? ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = JNIType.toJava( value: key, locals: &__locals )
        __args[2] = JNIType.toJava( value: c, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "binarySearch", methodSig: "([Ljava/lang/Object;Ljava/lang/Object;Ljava/util/Comparator;)I", methodCache: &binarySearch_MethodID_17, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func binarySearch( _ _a: [JavaObject]?, _ _key: java_swift.JavaObject?, _ _c: JavaComparator? ) -> Int {
        return binarySearch( a: _a, key: _key, c: _c )
    }

    /// public static int java.util.Arrays.binarySearch(char[],int,int,char)

    private static var binarySearch_MethodID_18: jmethodID?

    open class func binarySearch( a: [UInt16]?, fromIndex: Int, toIndex: Int, key: UInt16 ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        __args[3] = jvalue( c: key )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "binarySearch", methodSig: "([CIIC)I", methodCache: &binarySearch_MethodID_18, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func binarySearch( _ _a: [UInt16]?, _ _fromIndex: Int, _ _toIndex: Int, _ _key: UInt16 ) -> Int {
        return binarySearch( a: _a, fromIndex: _fromIndex, toIndex: _toIndex, key: _key )
    }

    /// public static int java.util.Arrays.binarySearch(char[],char)

    private static var binarySearch_MethodID_19: jmethodID?

    open class func binarySearch( a: [UInt16]?, key: UInt16 ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( c: key )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "binarySearch", methodSig: "([CC)I", methodCache: &binarySearch_MethodID_19, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func binarySearch( _ _a: [UInt16]?, _ _key: UInt16 ) -> Int {
        return binarySearch( a: _a, key: _key )
    }

    /// private static int java.util.Arrays.binarySearch0(double[],int,int,double)

    /// private static int java.util.Arrays.binarySearch0(float[],int,int,float)

    /// private static int java.util.Arrays.binarySearch0(short[],int,int,short)

    /// private static int java.util.Arrays.binarySearch0(int[],int,int,int)

    /// private static int java.util.Arrays.binarySearch0(long[],int,int,long)

    /// private static int java.util.Arrays.binarySearch0(byte[],int,int,byte)

    /// private static int java.util.Arrays.binarySearch0(java.lang.Object[],int,int,java.lang.Object)

    /// private static int java.util.Arrays.binarySearch0(java.lang.Object[],int,int,java.lang.Object,java.util.Comparator)

    /// private static int java.util.Arrays.binarySearch0(char[],int,int,char)

    /// public static boolean[] java.util.Arrays.copyOf(boolean[],int)

    private static var copyOf_MethodID_20: jmethodID?

    open class func copyOf( original: [Bool]?, newLength: Int ) -> [Bool]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: original, locals: &__locals )
        __args[1] = jvalue( i: jint(newLength) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOf", methodSig: "([ZI)[Z", methodCache: &copyOf_MethodID_20, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [Bool].self, from: __return )
    }

    open class func copyOf( _ _original: [Bool]?, _ _newLength: Int ) -> [Bool]! {
        return copyOf( original: _original, newLength: _newLength )
    }

    /// public static double[] java.util.Arrays.copyOf(double[],int)

    private static var copyOf_MethodID_21: jmethodID?

    open class func copyOf( original: [Double]?, newLength: Int ) -> [Double]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: original, locals: &__locals )
        __args[1] = jvalue( i: jint(newLength) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOf", methodSig: "([DI)[D", methodCache: &copyOf_MethodID_21, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [Double].self, from: __return )
    }

    open class func copyOf( _ _original: [Double]?, _ _newLength: Int ) -> [Double]! {
        return copyOf( original: _original, newLength: _newLength )
    }

    /// public static float[] java.util.Arrays.copyOf(float[],int)

    private static var copyOf_MethodID_22: jmethodID?

    open class func copyOf( original: [Float]?, newLength: Int ) -> [Float]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: original, locals: &__locals )
        __args[1] = jvalue( i: jint(newLength) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOf", methodSig: "([FI)[F", methodCache: &copyOf_MethodID_22, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [Float].self, from: __return )
    }

    open class func copyOf( _ _original: [Float]?, _ _newLength: Int ) -> [Float]! {
        return copyOf( original: _original, newLength: _newLength )
    }

    /// public static short[] java.util.Arrays.copyOf(short[],int)

    private static var copyOf_MethodID_23: jmethodID?

    open class func copyOf( original: [Int16]?, newLength: Int ) -> [Int16]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: original, locals: &__locals )
        __args[1] = jvalue( i: jint(newLength) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOf", methodSig: "([SI)[S", methodCache: &copyOf_MethodID_23, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [Int16].self, from: __return )
    }

    open class func copyOf( _ _original: [Int16]?, _ _newLength: Int ) -> [Int16]! {
        return copyOf( original: _original, newLength: _newLength )
    }

    /// public static int[] java.util.Arrays.copyOf(int[],int)

    private static var copyOf_MethodID_24: jmethodID?

    open class func copyOf( original: [Int32]?, newLength: Int ) -> [Int32]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: original, locals: &__locals )
        __args[1] = jvalue( i: jint(newLength) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOf", methodSig: "([II)[I", methodCache: &copyOf_MethodID_24, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [Int32].self, from: __return )
    }

    open class func copyOf( _ _original: [Int32]?, _ _newLength: Int ) -> [Int32]! {
        return copyOf( original: _original, newLength: _newLength )
    }

    /// public static long[] java.util.Arrays.copyOf(long[],int)

    private static var copyOf_MethodID_25: jmethodID?

    open class func copyOf( original: [Int64]?, newLength: Int ) -> [Int64]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: original, locals: &__locals )
        __args[1] = jvalue( i: jint(newLength) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOf", methodSig: "([JI)[J", methodCache: &copyOf_MethodID_25, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [Int64].self, from: __return )
    }

    open class func copyOf( _ _original: [Int64]?, _ _newLength: Int ) -> [Int64]! {
        return copyOf( original: _original, newLength: _newLength )
    }

    /// public static byte[] java.util.Arrays.copyOf(byte[],int)

    private static var copyOf_MethodID_26: jmethodID?

    open class func copyOf( original: [Int8]?, newLength: Int ) -> [Int8]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: original, locals: &__locals )
        __args[1] = jvalue( i: jint(newLength) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOf", methodSig: "([BI)[B", methodCache: &copyOf_MethodID_26, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [Int8].self, from: __return )
    }

    open class func copyOf( _ _original: [Int8]?, _ _newLength: Int ) -> [Int8]! {
        return copyOf( original: _original, newLength: _newLength )
    }

    /// public static java.lang.Object[] java.util.Arrays.copyOf(java.lang.Object[],int)

    private static var copyOf_MethodID_27: jmethodID?

    open class func copyOf( original: [JavaObject]?, newLength: Int ) -> [JavaObject]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: original, locals: &__locals )
        __args[1] = jvalue( i: jint(newLength) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOf", methodSig: "([Ljava/lang/Object;I)[Ljava/lang/Object;", methodCache: &copyOf_MethodID_27, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [JavaObject].self, from: __return )
    }

    open class func copyOf( _ _original: [JavaObject]?, _ _newLength: Int ) -> [JavaObject]! {
        return copyOf( original: _original, newLength: _newLength )
    }

    /// public static java.lang.Object[] java.util.Arrays.copyOf(java.lang.Object[],int,java.lang.Class)

    private static var copyOf_MethodID_28: jmethodID?

    open class func copyOf( original: [JavaObject]?, newLength: Int, newType: java_swift.JavaClass? ) -> [JavaObject]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: original, locals: &__locals )
        __args[1] = jvalue( i: jint(newLength) )
        __args[2] = JNIType.toJava( value: newType, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOf", methodSig: "([Ljava/lang/Object;ILjava/lang/Class;)[Ljava/lang/Object;", methodCache: &copyOf_MethodID_28, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [JavaObject].self, from: __return )
    }

    open class func copyOf( _ _original: [JavaObject]?, _ _newLength: Int, _ _newType: java_swift.JavaClass? ) -> [JavaObject]! {
        return copyOf( original: _original, newLength: _newLength, newType: _newType )
    }

    /// public static char[] java.util.Arrays.copyOf(char[],int)

    private static var copyOf_MethodID_29: jmethodID?

    open class func copyOf( original: [UInt16]?, newLength: Int ) -> [UInt16]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: original, locals: &__locals )
        __args[1] = jvalue( i: jint(newLength) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOf", methodSig: "([CI)[C", methodCache: &copyOf_MethodID_29, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [UInt16].self, from: __return )
    }

    open class func copyOf( _ _original: [UInt16]?, _ _newLength: Int ) -> [UInt16]! {
        return copyOf( original: _original, newLength: _newLength )
    }

    /// public static boolean[] java.util.Arrays.copyOfRange(boolean[],int,int)

    private static var copyOfRange_MethodID_30: jmethodID?

    open class func copyOfRange( original: [Bool]?, from: Int, to: Int ) -> [Bool]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: original, locals: &__locals )
        __args[1] = jvalue( i: jint(from) )
        __args[2] = jvalue( i: jint(to) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOfRange", methodSig: "([ZII)[Z", methodCache: &copyOfRange_MethodID_30, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [Bool].self, from: __return )
    }

    open class func copyOfRange( _ _original: [Bool]?, _ _from: Int, _ _to: Int ) -> [Bool]! {
        return copyOfRange( original: _original, from: _from, to: _to )
    }

    /// public static double[] java.util.Arrays.copyOfRange(double[],int,int)

    private static var copyOfRange_MethodID_31: jmethodID?

    open class func copyOfRange( original: [Double]?, from: Int, to: Int ) -> [Double]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: original, locals: &__locals )
        __args[1] = jvalue( i: jint(from) )
        __args[2] = jvalue( i: jint(to) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOfRange", methodSig: "([DII)[D", methodCache: &copyOfRange_MethodID_31, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [Double].self, from: __return )
    }

    open class func copyOfRange( _ _original: [Double]?, _ _from: Int, _ _to: Int ) -> [Double]! {
        return copyOfRange( original: _original, from: _from, to: _to )
    }

    /// public static float[] java.util.Arrays.copyOfRange(float[],int,int)

    private static var copyOfRange_MethodID_32: jmethodID?

    open class func copyOfRange( original: [Float]?, from: Int, to: Int ) -> [Float]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: original, locals: &__locals )
        __args[1] = jvalue( i: jint(from) )
        __args[2] = jvalue( i: jint(to) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOfRange", methodSig: "([FII)[F", methodCache: &copyOfRange_MethodID_32, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [Float].self, from: __return )
    }

    open class func copyOfRange( _ _original: [Float]?, _ _from: Int, _ _to: Int ) -> [Float]! {
        return copyOfRange( original: _original, from: _from, to: _to )
    }

    /// public static short[] java.util.Arrays.copyOfRange(short[],int,int)

    private static var copyOfRange_MethodID_33: jmethodID?

    open class func copyOfRange( original: [Int16]?, from: Int, to: Int ) -> [Int16]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: original, locals: &__locals )
        __args[1] = jvalue( i: jint(from) )
        __args[2] = jvalue( i: jint(to) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOfRange", methodSig: "([SII)[S", methodCache: &copyOfRange_MethodID_33, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [Int16].self, from: __return )
    }

    open class func copyOfRange( _ _original: [Int16]?, _ _from: Int, _ _to: Int ) -> [Int16]! {
        return copyOfRange( original: _original, from: _from, to: _to )
    }

    /// public static int[] java.util.Arrays.copyOfRange(int[],int,int)

    private static var copyOfRange_MethodID_34: jmethodID?

    open class func copyOfRange( original: [Int32]?, from: Int, to: Int ) -> [Int32]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: original, locals: &__locals )
        __args[1] = jvalue( i: jint(from) )
        __args[2] = jvalue( i: jint(to) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOfRange", methodSig: "([III)[I", methodCache: &copyOfRange_MethodID_34, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [Int32].self, from: __return )
    }

    open class func copyOfRange( _ _original: [Int32]?, _ _from: Int, _ _to: Int ) -> [Int32]! {
        return copyOfRange( original: _original, from: _from, to: _to )
    }

    /// public static long[] java.util.Arrays.copyOfRange(long[],int,int)

    private static var copyOfRange_MethodID_35: jmethodID?

    open class func copyOfRange( original: [Int64]?, from: Int, to: Int ) -> [Int64]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: original, locals: &__locals )
        __args[1] = jvalue( i: jint(from) )
        __args[2] = jvalue( i: jint(to) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOfRange", methodSig: "([JII)[J", methodCache: &copyOfRange_MethodID_35, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [Int64].self, from: __return )
    }

    open class func copyOfRange( _ _original: [Int64]?, _ _from: Int, _ _to: Int ) -> [Int64]! {
        return copyOfRange( original: _original, from: _from, to: _to )
    }

    /// public static byte[] java.util.Arrays.copyOfRange(byte[],int,int)

    private static var copyOfRange_MethodID_36: jmethodID?

    open class func copyOfRange( original: [Int8]?, from: Int, to: Int ) -> [Int8]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: original, locals: &__locals )
        __args[1] = jvalue( i: jint(from) )
        __args[2] = jvalue( i: jint(to) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOfRange", methodSig: "([BII)[B", methodCache: &copyOfRange_MethodID_36, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [Int8].self, from: __return )
    }

    open class func copyOfRange( _ _original: [Int8]?, _ _from: Int, _ _to: Int ) -> [Int8]! {
        return copyOfRange( original: _original, from: _from, to: _to )
    }

    /// public static java.lang.Object[] java.util.Arrays.copyOfRange(java.lang.Object[],int,int)

    private static var copyOfRange_MethodID_37: jmethodID?

    open class func copyOfRange( original: [JavaObject]?, from: Int, to: Int ) -> [JavaObject]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: original, locals: &__locals )
        __args[1] = jvalue( i: jint(from) )
        __args[2] = jvalue( i: jint(to) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOfRange", methodSig: "([Ljava/lang/Object;II)[Ljava/lang/Object;", methodCache: &copyOfRange_MethodID_37, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [JavaObject].self, from: __return )
    }

    open class func copyOfRange( _ _original: [JavaObject]?, _ _from: Int, _ _to: Int ) -> [JavaObject]! {
        return copyOfRange( original: _original, from: _from, to: _to )
    }

    /// public static java.lang.Object[] java.util.Arrays.copyOfRange(java.lang.Object[],int,int,java.lang.Class)

    private static var copyOfRange_MethodID_38: jmethodID?

    open class func copyOfRange( original: [JavaObject]?, from: Int, to: Int, newType: java_swift.JavaClass? ) -> [JavaObject]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        __args[0] = JNIType.toJava( value: original, locals: &__locals )
        __args[1] = jvalue( i: jint(from) )
        __args[2] = jvalue( i: jint(to) )
        __args[3] = JNIType.toJava( value: newType, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOfRange", methodSig: "([Ljava/lang/Object;IILjava/lang/Class;)[Ljava/lang/Object;", methodCache: &copyOfRange_MethodID_38, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [JavaObject].self, from: __return )
    }

    open class func copyOfRange( _ _original: [JavaObject]?, _ _from: Int, _ _to: Int, _ _newType: java_swift.JavaClass? ) -> [JavaObject]! {
        return copyOfRange( original: _original, from: _from, to: _to, newType: _newType )
    }

    /// public static char[] java.util.Arrays.copyOfRange(char[],int,int)

    private static var copyOfRange_MethodID_39: jmethodID?

    open class func copyOfRange( original: [UInt16]?, from: Int, to: Int ) -> [UInt16]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: original, locals: &__locals )
        __args[1] = jvalue( i: jint(from) )
        __args[2] = jvalue( i: jint(to) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOfRange", methodSig: "([CII)[C", methodCache: &copyOfRange_MethodID_39, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [UInt16].self, from: __return )
    }

    open class func copyOfRange( _ _original: [UInt16]?, _ _from: Int, _ _to: Int ) -> [UInt16]! {
        return copyOfRange( original: _original, from: _from, to: _to )
    }

    /// public static boolean java.util.Arrays.deepEquals(java.lang.Object[],java.lang.Object[])

    private static var deepEquals_MethodID_40: jmethodID?

    open class func deepEquals( a1: [JavaObject]?, a2: [JavaObject]? ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: a1, locals: &__locals )
        __args[1] = JNIType.toJava( value: a2, locals: &__locals )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "deepEquals", methodSig: "([Ljava/lang/Object;[Ljava/lang/Object;)Z", methodCache: &deepEquals_MethodID_40, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open class func deepEquals( _ _a1: [JavaObject]?, _ _a2: [JavaObject]? ) -> Bool {
        return deepEquals( a1: _a1, a2: _a2 )
    }

    /// static boolean java.util.Arrays.deepEquals0(java.lang.Object,java.lang.Object)

    // Skipping method: true false false false false 

    /// public static int java.util.Arrays.deepHashCode(java.lang.Object[])

    private static var deepHashCode_MethodID_41: jmethodID?

    open class func deepHashCode( a: [JavaObject]? ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "deepHashCode", methodSig: "([Ljava/lang/Object;)I", methodCache: &deepHashCode_MethodID_41, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func deepHashCode( _ _a: [JavaObject]? ) -> Int {
        return deepHashCode( a: _a )
    }

    /// public static java.lang.String java.util.Arrays.deepToString(java.lang.Object[])

    private static var deepToString_MethodID_42: jmethodID?

    open class func deepToString( a: [JavaObject]? ) -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "deepToString", methodSig: "([Ljava/lang/Object;)Ljava/lang/String;", methodCache: &deepToString_MethodID_42, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? String( javaObject: __return ) : nil
    }

    open class func deepToString( _ _a: [JavaObject]? ) -> String! {
        return deepToString( a: _a )
    }

    /// private static void java.util.Arrays.deepToString(java.lang.Object[],java.lang.StringBuilder,java.util.Set)

    /// public static boolean java.util.Arrays.equals(boolean[],boolean[])

    private static var equals_MethodID_43: jmethodID?

    open class func equals( a: [Bool]?, a2: [Bool]? ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = JNIType.toJava( value: a2, locals: &__locals )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "equals", methodSig: "([Z[Z)Z", methodCache: &equals_MethodID_43, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open class func equals( _ _a: [Bool]?, _ _a2: [Bool]? ) -> Bool {
        return equals( a: _a, a2: _a2 )
    }

    /// public static boolean java.util.Arrays.equals(double[],double[])

    private static var equals_MethodID_44: jmethodID?

    open class func equals( a: [Double]?, a2: [Double]? ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = JNIType.toJava( value: a2, locals: &__locals )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "equals", methodSig: "([D[D)Z", methodCache: &equals_MethodID_44, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open class func equals( _ _a: [Double]?, _ _a2: [Double]? ) -> Bool {
        return equals( a: _a, a2: _a2 )
    }

    /// public static boolean java.util.Arrays.equals(float[],float[])

    private static var equals_MethodID_45: jmethodID?

    open class func equals( a: [Float]?, a2: [Float]? ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = JNIType.toJava( value: a2, locals: &__locals )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "equals", methodSig: "([F[F)Z", methodCache: &equals_MethodID_45, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open class func equals( _ _a: [Float]?, _ _a2: [Float]? ) -> Bool {
        return equals( a: _a, a2: _a2 )
    }

    /// public static boolean java.util.Arrays.equals(short[],short[])

    private static var equals_MethodID_46: jmethodID?

    open class func equals( a: [Int16]?, a2: [Int16]? ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = JNIType.toJava( value: a2, locals: &__locals )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "equals", methodSig: "([S[S)Z", methodCache: &equals_MethodID_46, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open class func equals( _ _a: [Int16]?, _ _a2: [Int16]? ) -> Bool {
        return equals( a: _a, a2: _a2 )
    }

    /// public static boolean java.util.Arrays.equals(int[],int[])

    private static var equals_MethodID_47: jmethodID?

    open class func equals( a: [Int32]?, a2: [Int32]? ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = JNIType.toJava( value: a2, locals: &__locals )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "equals", methodSig: "([I[I)Z", methodCache: &equals_MethodID_47, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open class func equals( _ _a: [Int32]?, _ _a2: [Int32]? ) -> Bool {
        return equals( a: _a, a2: _a2 )
    }

    /// public static boolean java.util.Arrays.equals(long[],long[])

    private static var equals_MethodID_48: jmethodID?

    open class func equals( a: [Int64]?, a2: [Int64]? ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = JNIType.toJava( value: a2, locals: &__locals )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "equals", methodSig: "([J[J)Z", methodCache: &equals_MethodID_48, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open class func equals( _ _a: [Int64]?, _ _a2: [Int64]? ) -> Bool {
        return equals( a: _a, a2: _a2 )
    }

    /// public static boolean java.util.Arrays.equals(byte[],byte[])

    private static var equals_MethodID_49: jmethodID?

    open class func equals( a: [Int8]?, a2: [Int8]? ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = JNIType.toJava( value: a2, locals: &__locals )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "equals", methodSig: "([B[B)Z", methodCache: &equals_MethodID_49, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open class func equals( _ _a: [Int8]?, _ _a2: [Int8]? ) -> Bool {
        return equals( a: _a, a2: _a2 )
    }

    /// public static boolean java.util.Arrays.equals(java.lang.Object[],java.lang.Object[])

    private static var equals_MethodID_50: jmethodID?

    open class func equals( a: [JavaObject]?, a2: [JavaObject]? ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = JNIType.toJava( value: a2, locals: &__locals )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "equals", methodSig: "([Ljava/lang/Object;[Ljava/lang/Object;)Z", methodCache: &equals_MethodID_50, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open class func equals( _ _a: [JavaObject]?, _ _a2: [JavaObject]? ) -> Bool {
        return equals( a: _a, a2: _a2 )
    }

    /// public static boolean java.util.Arrays.equals(char[],char[])

    private static var equals_MethodID_51: jmethodID?

    open class func equals( a: [UInt16]?, a2: [UInt16]? ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = JNIType.toJava( value: a2, locals: &__locals )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "equals", methodSig: "([C[C)Z", methodCache: &equals_MethodID_51, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open class func equals( _ _a: [UInt16]?, _ _a2: [UInt16]? ) -> Bool {
        return equals( a: _a, a2: _a2 )
    }

    /// public static void java.util.Arrays.fill(boolean[],boolean)

    private static var fill_MethodID_52: jmethodID?

    open class func fill( a: [Bool]?, val: Bool ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( z: jboolean(val ? JNI_TRUE : JNI_FALSE) )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "fill", methodSig: "([ZZ)V", methodCache: &fill_MethodID_52, args: &__args, locals: &__locals )
    }

    open class func fill( _ _a: [Bool]?, _ _val: Bool ) {
        fill( a: _a, val: _val )
    }

    /// public static void java.util.Arrays.fill(boolean[],int,int,boolean)

    private static var fill_MethodID_53: jmethodID?

    open class func fill( a: [Bool]?, fromIndex: Int, toIndex: Int, val: Bool ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        __args[3] = jvalue( z: jboolean(val ? JNI_TRUE : JNI_FALSE) )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "fill", methodSig: "([ZIIZ)V", methodCache: &fill_MethodID_53, args: &__args, locals: &__locals )
    }

    open class func fill( _ _a: [Bool]?, _ _fromIndex: Int, _ _toIndex: Int, _ _val: Bool ) {
        fill( a: _a, fromIndex: _fromIndex, toIndex: _toIndex, val: _val )
    }

    /// public static void java.util.Arrays.fill(double[],double)

    private static var fill_MethodID_54: jmethodID?

    open class func fill( a: [Double]?, val: Double ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( d: val )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "fill", methodSig: "([DD)V", methodCache: &fill_MethodID_54, args: &__args, locals: &__locals )
    }

    open class func fill( _ _a: [Double]?, _ _val: Double ) {
        fill( a: _a, val: _val )
    }

    /// public static void java.util.Arrays.fill(double[],int,int,double)

    private static var fill_MethodID_55: jmethodID?

    open class func fill( a: [Double]?, fromIndex: Int, toIndex: Int, val: Double ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        __args[3] = jvalue( d: val )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "fill", methodSig: "([DIID)V", methodCache: &fill_MethodID_55, args: &__args, locals: &__locals )
    }

    open class func fill( _ _a: [Double]?, _ _fromIndex: Int, _ _toIndex: Int, _ _val: Double ) {
        fill( a: _a, fromIndex: _fromIndex, toIndex: _toIndex, val: _val )
    }

    /// public static void java.util.Arrays.fill(float[],float)

    private static var fill_MethodID_56: jmethodID?

    open class func fill( a: [Float]?, val: Float ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( f: val )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "fill", methodSig: "([FF)V", methodCache: &fill_MethodID_56, args: &__args, locals: &__locals )
    }

    open class func fill( _ _a: [Float]?, _ _val: Float ) {
        fill( a: _a, val: _val )
    }

    /// public static void java.util.Arrays.fill(float[],int,int,float)

    private static var fill_MethodID_57: jmethodID?

    open class func fill( a: [Float]?, fromIndex: Int, toIndex: Int, val: Float ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        __args[3] = jvalue( f: val )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "fill", methodSig: "([FIIF)V", methodCache: &fill_MethodID_57, args: &__args, locals: &__locals )
    }

    open class func fill( _ _a: [Float]?, _ _fromIndex: Int, _ _toIndex: Int, _ _val: Float ) {
        fill( a: _a, fromIndex: _fromIndex, toIndex: _toIndex, val: _val )
    }

    /// public static void java.util.Arrays.fill(short[],int,int,short)

    private static var fill_MethodID_58: jmethodID?

    open class func fill( a: [Int16]?, fromIndex: Int, toIndex: Int, val: Int16 ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        __args[3] = jvalue( s: val )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "fill", methodSig: "([SIIS)V", methodCache: &fill_MethodID_58, args: &__args, locals: &__locals )
    }

    open class func fill( _ _a: [Int16]?, _ _fromIndex: Int, _ _toIndex: Int, _ _val: Int16 ) {
        fill( a: _a, fromIndex: _fromIndex, toIndex: _toIndex, val: _val )
    }

    /// public static void java.util.Arrays.fill(short[],short)

    private static var fill_MethodID_59: jmethodID?

    open class func fill( a: [Int16]?, val: Int16 ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( s: val )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "fill", methodSig: "([SS)V", methodCache: &fill_MethodID_59, args: &__args, locals: &__locals )
    }

    open class func fill( _ _a: [Int16]?, _ _val: Int16 ) {
        fill( a: _a, val: _val )
    }

    /// public static void java.util.Arrays.fill(int[],int)

    private static var fill_MethodID_60: jmethodID?

    open class func fill( a: [Int32]?, val: Int ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( i: jint(val) )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "fill", methodSig: "([II)V", methodCache: &fill_MethodID_60, args: &__args, locals: &__locals )
    }

    open class func fill( _ _a: [Int32]?, _ _val: Int ) {
        fill( a: _a, val: _val )
    }

    /// public static void java.util.Arrays.fill(int[],int,int,int)

    private static var fill_MethodID_61: jmethodID?

    open class func fill( a: [Int32]?, fromIndex: Int, toIndex: Int, val: Int ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        __args[3] = jvalue( i: jint(val) )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "fill", methodSig: "([IIII)V", methodCache: &fill_MethodID_61, args: &__args, locals: &__locals )
    }

    open class func fill( _ _a: [Int32]?, _ _fromIndex: Int, _ _toIndex: Int, _ _val: Int ) {
        fill( a: _a, fromIndex: _fromIndex, toIndex: _toIndex, val: _val )
    }

    /// public static void java.util.Arrays.fill(long[],int,int,long)

    private static var fill_MethodID_62: jmethodID?

    open class func fill( a: [Int64]?, fromIndex: Int, toIndex: Int, val: Int64 ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        __args[3] = jvalue( j: val )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "fill", methodSig: "([JIIJ)V", methodCache: &fill_MethodID_62, args: &__args, locals: &__locals )
    }

    open class func fill( _ _a: [Int64]?, _ _fromIndex: Int, _ _toIndex: Int, _ _val: Int64 ) {
        fill( a: _a, fromIndex: _fromIndex, toIndex: _toIndex, val: _val )
    }

    /// public static void java.util.Arrays.fill(long[],long)

    private static var fill_MethodID_63: jmethodID?

    open class func fill( a: [Int64]?, val: Int64 ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( j: val )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "fill", methodSig: "([JJ)V", methodCache: &fill_MethodID_63, args: &__args, locals: &__locals )
    }

    open class func fill( _ _a: [Int64]?, _ _val: Int64 ) {
        fill( a: _a, val: _val )
    }

    /// public static void java.util.Arrays.fill(byte[],int,int,byte)

    private static var fill_MethodID_64: jmethodID?

    open class func fill( a: [Int8]?, fromIndex: Int, toIndex: Int, val: Int8 ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        __args[3] = jvalue( b: val )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "fill", methodSig: "([BIIB)V", methodCache: &fill_MethodID_64, args: &__args, locals: &__locals )
    }

    open class func fill( _ _a: [Int8]?, _ _fromIndex: Int, _ _toIndex: Int, _ _val: Int8 ) {
        fill( a: _a, fromIndex: _fromIndex, toIndex: _toIndex, val: _val )
    }

    /// public static void java.util.Arrays.fill(byte[],byte)

    private static var fill_MethodID_65: jmethodID?

    open class func fill( a: [Int8]?, val: Int8 ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( b: val )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "fill", methodSig: "([BB)V", methodCache: &fill_MethodID_65, args: &__args, locals: &__locals )
    }

    open class func fill( _ _a: [Int8]?, _ _val: Int8 ) {
        fill( a: _a, val: _val )
    }

    /// public static void java.util.Arrays.fill(java.lang.Object[],int,int,java.lang.Object)

    private static var fill_MethodID_66: jmethodID?

    open class func fill( a: [JavaObject]?, fromIndex: Int, toIndex: Int, val: java_swift.JavaObject? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        __args[3] = JNIType.toJava( value: val, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "fill", methodSig: "([Ljava/lang/Object;IILjava/lang/Object;)V", methodCache: &fill_MethodID_66, args: &__args, locals: &__locals )
    }

    open class func fill( _ _a: [JavaObject]?, _ _fromIndex: Int, _ _toIndex: Int, _ _val: java_swift.JavaObject? ) {
        fill( a: _a, fromIndex: _fromIndex, toIndex: _toIndex, val: _val )
    }

    /// public static void java.util.Arrays.fill(java.lang.Object[],java.lang.Object)

    private static var fill_MethodID_67: jmethodID?

    open class func fill( a: [JavaObject]?, val: java_swift.JavaObject? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = JNIType.toJava( value: val, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "fill", methodSig: "([Ljava/lang/Object;Ljava/lang/Object;)V", methodCache: &fill_MethodID_67, args: &__args, locals: &__locals )
    }

    open class func fill( _ _a: [JavaObject]?, _ _val: java_swift.JavaObject? ) {
        fill( a: _a, val: _val )
    }

    /// public static void java.util.Arrays.fill(char[],int,int,char)

    private static var fill_MethodID_68: jmethodID?

    open class func fill( a: [UInt16]?, fromIndex: Int, toIndex: Int, val: UInt16 ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        __args[3] = jvalue( c: val )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "fill", methodSig: "([CIIC)V", methodCache: &fill_MethodID_68, args: &__args, locals: &__locals )
    }

    open class func fill( _ _a: [UInt16]?, _ _fromIndex: Int, _ _toIndex: Int, _ _val: UInt16 ) {
        fill( a: _a, fromIndex: _fromIndex, toIndex: _toIndex, val: _val )
    }

    /// public static void java.util.Arrays.fill(char[],char)

    private static var fill_MethodID_69: jmethodID?

    open class func fill( a: [UInt16]?, val: UInt16 ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( c: val )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "fill", methodSig: "([CC)V", methodCache: &fill_MethodID_69, args: &__args, locals: &__locals )
    }

    open class func fill( _ _a: [UInt16]?, _ _val: UInt16 ) {
        fill( a: _a, val: _val )
    }

    /// public static int java.util.Arrays.hashCode(boolean[])

    private static var hashCode_MethodID_70: jmethodID?

    open class func hashCode( a: [Bool]? ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "hashCode", methodSig: "([Z)I", methodCache: &hashCode_MethodID_70, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func hashCode( _ _a: [Bool]? ) -> Int {
        return hashCode( a: _a )
    }

    /// public static int java.util.Arrays.hashCode(double[])

    private static var hashCode_MethodID_71: jmethodID?

    open class func hashCode( a: [Double]? ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "hashCode", methodSig: "([D)I", methodCache: &hashCode_MethodID_71, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func hashCode( _ _a: [Double]? ) -> Int {
        return hashCode( a: _a )
    }

    /// public static int java.util.Arrays.hashCode(float[])

    private static var hashCode_MethodID_72: jmethodID?

    open class func hashCode( a: [Float]? ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "hashCode", methodSig: "([F)I", methodCache: &hashCode_MethodID_72, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func hashCode( _ _a: [Float]? ) -> Int {
        return hashCode( a: _a )
    }

    /// public static int java.util.Arrays.hashCode(short[])

    private static var hashCode_MethodID_73: jmethodID?

    open class func hashCode( a: [Int16]? ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "hashCode", methodSig: "([S)I", methodCache: &hashCode_MethodID_73, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func hashCode( _ _a: [Int16]? ) -> Int {
        return hashCode( a: _a )
    }

    /// public static int java.util.Arrays.hashCode(int[])

    private static var hashCode_MethodID_74: jmethodID?

    open class func hashCode( a: [Int32]? ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "hashCode", methodSig: "([I)I", methodCache: &hashCode_MethodID_74, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func hashCode( _ _a: [Int32]? ) -> Int {
        return hashCode( a: _a )
    }

    /// public static int java.util.Arrays.hashCode(long[])

    private static var hashCode_MethodID_75: jmethodID?

    open class func hashCode( a: [Int64]? ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "hashCode", methodSig: "([J)I", methodCache: &hashCode_MethodID_75, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func hashCode( _ _a: [Int64]? ) -> Int {
        return hashCode( a: _a )
    }

    /// public static int java.util.Arrays.hashCode(byte[])

    private static var hashCode_MethodID_76: jmethodID?

    open class func hashCode( a: [Int8]? ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "hashCode", methodSig: "([B)I", methodCache: &hashCode_MethodID_76, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func hashCode( _ _a: [Int8]? ) -> Int {
        return hashCode( a: _a )
    }

    /// public static int java.util.Arrays.hashCode(java.lang.Object[])

    private static var hashCode_MethodID_77: jmethodID?

    open class func hashCode( a: [JavaObject]? ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "hashCode", methodSig: "([Ljava/lang/Object;)I", methodCache: &hashCode_MethodID_77, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func hashCode( _ _a: [JavaObject]? ) -> Int {
        return hashCode( a: _a )
    }

    /// public static int java.util.Arrays.hashCode(char[])

    private static var hashCode_MethodID_78: jmethodID?

    open class func hashCode( a: [UInt16]? ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "hashCode", methodSig: "([C)I", methodCache: &hashCode_MethodID_78, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func hashCode( _ _a: [UInt16]? ) -> Int {
        return hashCode( a: _a )
    }

    /// private static void java.util.Arrays.lambda$parallelSetAll$0(java.lang.Object[],java.util.function.IntFunction,int)

    /// private static void java.util.Arrays.lambda$parallelSetAll$1(int[],java.util.function.IntUnaryOperator,int)

    /// private static void java.util.Arrays.lambda$parallelSetAll$2(long[],java.util.function.IntToLongFunction,int)

    /// private static void java.util.Arrays.lambda$parallelSetAll$3(double[],java.util.function.IntToDoubleFunction,int)

    /// private static void java.util.Arrays.legacyMergeSort(java.lang.Object[])

    /// private static void java.util.Arrays.legacyMergeSort(java.lang.Object[],int,int)

    /// private static void java.util.Arrays.legacyMergeSort(java.lang.Object[],int,int,java.util.Comparator)

    /// private static void java.util.Arrays.legacyMergeSort(java.lang.Object[],java.util.Comparator)

    /// private static void java.util.Arrays.mergeSort(java.lang.Object[],java.lang.Object[],int,int,int)

    /// private static void java.util.Arrays.mergeSort(java.lang.Object[],java.lang.Object[],int,int,int,java.util.Comparator)

    /// public static void java.util.Arrays.parallelPrefix(double[],java.util.function.DoubleBinaryOperator)

    private static var parallelPrefix_MethodID_79: jmethodID?

    open class func parallelPrefix( array: [Double]?, op: DoubleBinaryOperator? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = JNIType.toJava( value: op, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "parallelPrefix", methodSig: "([DLjava/util/function/DoubleBinaryOperator;)V", methodCache: &parallelPrefix_MethodID_79, args: &__args, locals: &__locals )
    }

    open class func parallelPrefix( _ _array: [Double]?, _ _op: DoubleBinaryOperator? ) {
        parallelPrefix( array: _array, op: _op )
    }

    /// public static void java.util.Arrays.parallelPrefix(double[],int,int,java.util.function.DoubleBinaryOperator)

    private static var parallelPrefix_MethodID_80: jmethodID?

    open class func parallelPrefix( array: [Double]?, fromIndex: Int, toIndex: Int, op: DoubleBinaryOperator? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        __args[3] = JNIType.toJava( value: op, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "parallelPrefix", methodSig: "([DIILjava/util/function/DoubleBinaryOperator;)V", methodCache: &parallelPrefix_MethodID_80, args: &__args, locals: &__locals )
    }

    open class func parallelPrefix( _ _array: [Double]?, _ _fromIndex: Int, _ _toIndex: Int, _ _op: DoubleBinaryOperator? ) {
        parallelPrefix( array: _array, fromIndex: _fromIndex, toIndex: _toIndex, op: _op )
    }

    /// public static void java.util.Arrays.parallelPrefix(int[],int,int,java.util.function.IntBinaryOperator)

    private static var parallelPrefix_MethodID_81: jmethodID?

    open class func parallelPrefix( array: [Int32]?, fromIndex: Int, toIndex: Int, op: IntBinaryOperator? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        __args[3] = JNIType.toJava( value: op, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "parallelPrefix", methodSig: "([IIILjava/util/function/IntBinaryOperator;)V", methodCache: &parallelPrefix_MethodID_81, args: &__args, locals: &__locals )
    }

    open class func parallelPrefix( _ _array: [Int32]?, _ _fromIndex: Int, _ _toIndex: Int, _ _op: IntBinaryOperator? ) {
        parallelPrefix( array: _array, fromIndex: _fromIndex, toIndex: _toIndex, op: _op )
    }

    /// public static void java.util.Arrays.parallelPrefix(int[],java.util.function.IntBinaryOperator)

    private static var parallelPrefix_MethodID_82: jmethodID?

    open class func parallelPrefix( array: [Int32]?, op: IntBinaryOperator? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = JNIType.toJava( value: op, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "parallelPrefix", methodSig: "([ILjava/util/function/IntBinaryOperator;)V", methodCache: &parallelPrefix_MethodID_82, args: &__args, locals: &__locals )
    }

    open class func parallelPrefix( _ _array: [Int32]?, _ _op: IntBinaryOperator? ) {
        parallelPrefix( array: _array, op: _op )
    }

    /// public static void java.util.Arrays.parallelPrefix(long[],int,int,java.util.function.LongBinaryOperator)

    private static var parallelPrefix_MethodID_83: jmethodID?

    open class func parallelPrefix( array: [Int64]?, fromIndex: Int, toIndex: Int, op: LongBinaryOperator? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        __args[3] = JNIType.toJava( value: op, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "parallelPrefix", methodSig: "([JIILjava/util/function/LongBinaryOperator;)V", methodCache: &parallelPrefix_MethodID_83, args: &__args, locals: &__locals )
    }

    open class func parallelPrefix( _ _array: [Int64]?, _ _fromIndex: Int, _ _toIndex: Int, _ _op: LongBinaryOperator? ) {
        parallelPrefix( array: _array, fromIndex: _fromIndex, toIndex: _toIndex, op: _op )
    }

    /// public static void java.util.Arrays.parallelPrefix(long[],java.util.function.LongBinaryOperator)

    private static var parallelPrefix_MethodID_84: jmethodID?

    open class func parallelPrefix( array: [Int64]?, op: LongBinaryOperator? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = JNIType.toJava( value: op, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "parallelPrefix", methodSig: "([JLjava/util/function/LongBinaryOperator;)V", methodCache: &parallelPrefix_MethodID_84, args: &__args, locals: &__locals )
    }

    open class func parallelPrefix( _ _array: [Int64]?, _ _op: LongBinaryOperator? ) {
        parallelPrefix( array: _array, op: _op )
    }

    /// public static void java.util.Arrays.parallelPrefix(java.lang.Object[],java.util.function.BinaryOperator)

    private static var parallelPrefix_MethodID_85: jmethodID?

    open class func parallelPrefix( array: [JavaObject]?, op: BinaryOperator? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = JNIType.toJava( value: op, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "parallelPrefix", methodSig: "([Ljava/lang/Object;Ljava/util/function/BinaryOperator;)V", methodCache: &parallelPrefix_MethodID_85, args: &__args, locals: &__locals )
    }

    open class func parallelPrefix( _ _array: [JavaObject]?, _ _op: BinaryOperator? ) {
        parallelPrefix( array: _array, op: _op )
    }

    /// public static void java.util.Arrays.parallelPrefix(java.lang.Object[],int,int,java.util.function.BinaryOperator)

    private static var parallelPrefix_MethodID_86: jmethodID?

    open class func parallelPrefix( array: [JavaObject]?, fromIndex: Int, toIndex: Int, op: BinaryOperator? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        __args[3] = JNIType.toJava( value: op, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "parallelPrefix", methodSig: "([Ljava/lang/Object;IILjava/util/function/BinaryOperator;)V", methodCache: &parallelPrefix_MethodID_86, args: &__args, locals: &__locals )
    }

    open class func parallelPrefix( _ _array: [JavaObject]?, _ _fromIndex: Int, _ _toIndex: Int, _ _op: BinaryOperator? ) {
        parallelPrefix( array: _array, fromIndex: _fromIndex, toIndex: _toIndex, op: _op )
    }

    /// public static void java.util.Arrays.parallelSetAll(double[],java.util.function.IntToDoubleFunction)

    private static var parallelSetAll_MethodID_87: jmethodID?

    open class func parallelSetAll( array: [Double]?, generator: IntToDoubleFunction? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = JNIType.toJava( value: generator, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "parallelSetAll", methodSig: "([DLjava/util/function/IntToDoubleFunction;)V", methodCache: &parallelSetAll_MethodID_87, args: &__args, locals: &__locals )
    }

    open class func parallelSetAll( _ _array: [Double]?, _ _generator: IntToDoubleFunction? ) {
        parallelSetAll( array: _array, generator: _generator )
    }

    /// public static void java.util.Arrays.parallelSetAll(int[],java.util.function.IntUnaryOperator)

    private static var parallelSetAll_MethodID_88: jmethodID?

    open class func parallelSetAll( array: [Int32]?, generator: IntUnaryOperator? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = JNIType.toJava( value: generator, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "parallelSetAll", methodSig: "([ILjava/util/function/IntUnaryOperator;)V", methodCache: &parallelSetAll_MethodID_88, args: &__args, locals: &__locals )
    }

    open class func parallelSetAll( _ _array: [Int32]?, _ _generator: IntUnaryOperator? ) {
        parallelSetAll( array: _array, generator: _generator )
    }

    /// public static void java.util.Arrays.parallelSetAll(long[],java.util.function.IntToLongFunction)

    private static var parallelSetAll_MethodID_89: jmethodID?

    open class func parallelSetAll( array: [Int64]?, generator: IntToLongFunction? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = JNIType.toJava( value: generator, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "parallelSetAll", methodSig: "([JLjava/util/function/IntToLongFunction;)V", methodCache: &parallelSetAll_MethodID_89, args: &__args, locals: &__locals )
    }

    open class func parallelSetAll( _ _array: [Int64]?, _ _generator: IntToLongFunction? ) {
        parallelSetAll( array: _array, generator: _generator )
    }

    /// public static void java.util.Arrays.parallelSetAll(java.lang.Object[],java.util.function.IntFunction)

    private static var parallelSetAll_MethodID_90: jmethodID?

    open class func parallelSetAll( array: [JavaObject]?, generator: IntFunction? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = JNIType.toJava( value: generator, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "parallelSetAll", methodSig: "([Ljava/lang/Object;Ljava/util/function/IntFunction;)V", methodCache: &parallelSetAll_MethodID_90, args: &__args, locals: &__locals )
    }

    open class func parallelSetAll( _ _array: [JavaObject]?, _ _generator: IntFunction? ) {
        parallelSetAll( array: _array, generator: _generator )
    }

    /// public static void java.util.Arrays.parallelSort(double[])

    private static var parallelSort_MethodID_91: jmethodID?

    open class func parallelSort( a: [Double]? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "parallelSort", methodSig: "([D)V", methodCache: &parallelSort_MethodID_91, args: &__args, locals: &__locals )
    }

    open class func parallelSort( _ _a: [Double]? ) {
        parallelSort( a: _a )
    }

    /// public static void java.util.Arrays.parallelSort(double[],int,int)

    private static var parallelSort_MethodID_92: jmethodID?

    open class func parallelSort( a: [Double]?, fromIndex: Int, toIndex: Int ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "parallelSort", methodSig: "([DII)V", methodCache: &parallelSort_MethodID_92, args: &__args, locals: &__locals )
    }

    open class func parallelSort( _ _a: [Double]?, _ _fromIndex: Int, _ _toIndex: Int ) {
        parallelSort( a: _a, fromIndex: _fromIndex, toIndex: _toIndex )
    }

    /// public static void java.util.Arrays.parallelSort(float[])

    private static var parallelSort_MethodID_93: jmethodID?

    open class func parallelSort( a: [Float]? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "parallelSort", methodSig: "([F)V", methodCache: &parallelSort_MethodID_93, args: &__args, locals: &__locals )
    }

    open class func parallelSort( _ _a: [Float]? ) {
        parallelSort( a: _a )
    }

    /// public static void java.util.Arrays.parallelSort(float[],int,int)

    private static var parallelSort_MethodID_94: jmethodID?

    open class func parallelSort( a: [Float]?, fromIndex: Int, toIndex: Int ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "parallelSort", methodSig: "([FII)V", methodCache: &parallelSort_MethodID_94, args: &__args, locals: &__locals )
    }

    open class func parallelSort( _ _a: [Float]?, _ _fromIndex: Int, _ _toIndex: Int ) {
        parallelSort( a: _a, fromIndex: _fromIndex, toIndex: _toIndex )
    }

    /// public static void java.util.Arrays.parallelSort(short[])

    private static var parallelSort_MethodID_95: jmethodID?

    open class func parallelSort( a: [Int16]? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "parallelSort", methodSig: "([S)V", methodCache: &parallelSort_MethodID_95, args: &__args, locals: &__locals )
    }

    open class func parallelSort( _ _a: [Int16]? ) {
        parallelSort( a: _a )
    }

    /// public static void java.util.Arrays.parallelSort(short[],int,int)

    private static var parallelSort_MethodID_96: jmethodID?

    open class func parallelSort( a: [Int16]?, fromIndex: Int, toIndex: Int ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "parallelSort", methodSig: "([SII)V", methodCache: &parallelSort_MethodID_96, args: &__args, locals: &__locals )
    }

    open class func parallelSort( _ _a: [Int16]?, _ _fromIndex: Int, _ _toIndex: Int ) {
        parallelSort( a: _a, fromIndex: _fromIndex, toIndex: _toIndex )
    }

    /// public static void java.util.Arrays.parallelSort(int[])

    private static var parallelSort_MethodID_97: jmethodID?

    open class func parallelSort( a: [Int32]? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "parallelSort", methodSig: "([I)V", methodCache: &parallelSort_MethodID_97, args: &__args, locals: &__locals )
    }

    open class func parallelSort( _ _a: [Int32]? ) {
        parallelSort( a: _a )
    }

    /// public static void java.util.Arrays.parallelSort(int[],int,int)

    private static var parallelSort_MethodID_98: jmethodID?

    open class func parallelSort( a: [Int32]?, fromIndex: Int, toIndex: Int ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "parallelSort", methodSig: "([III)V", methodCache: &parallelSort_MethodID_98, args: &__args, locals: &__locals )
    }

    open class func parallelSort( _ _a: [Int32]?, _ _fromIndex: Int, _ _toIndex: Int ) {
        parallelSort( a: _a, fromIndex: _fromIndex, toIndex: _toIndex )
    }

    /// public static void java.util.Arrays.parallelSort(long[])

    private static var parallelSort_MethodID_99: jmethodID?

    open class func parallelSort( a: [Int64]? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "parallelSort", methodSig: "([J)V", methodCache: &parallelSort_MethodID_99, args: &__args, locals: &__locals )
    }

    open class func parallelSort( _ _a: [Int64]? ) {
        parallelSort( a: _a )
    }

    /// public static void java.util.Arrays.parallelSort(long[],int,int)

    private static var parallelSort_MethodID_100: jmethodID?

    open class func parallelSort( a: [Int64]?, fromIndex: Int, toIndex: Int ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "parallelSort", methodSig: "([JII)V", methodCache: &parallelSort_MethodID_100, args: &__args, locals: &__locals )
    }

    open class func parallelSort( _ _a: [Int64]?, _ _fromIndex: Int, _ _toIndex: Int ) {
        parallelSort( a: _a, fromIndex: _fromIndex, toIndex: _toIndex )
    }

    /// public static void java.util.Arrays.parallelSort(byte[])

    private static var parallelSort_MethodID_101: jmethodID?

    open class func parallelSort( a: [Int8]? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "parallelSort", methodSig: "([B)V", methodCache: &parallelSort_MethodID_101, args: &__args, locals: &__locals )
    }

    open class func parallelSort( _ _a: [Int8]? ) {
        parallelSort( a: _a )
    }

    /// public static void java.util.Arrays.parallelSort(byte[],int,int)

    private static var parallelSort_MethodID_102: jmethodID?

    open class func parallelSort( a: [Int8]?, fromIndex: Int, toIndex: Int ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "parallelSort", methodSig: "([BII)V", methodCache: &parallelSort_MethodID_102, args: &__args, locals: &__locals )
    }

    open class func parallelSort( _ _a: [Int8]?, _ _fromIndex: Int, _ _toIndex: Int ) {
        parallelSort( a: _a, fromIndex: _fromIndex, toIndex: _toIndex )
    }

    /// public static void java.util.Arrays.parallelSort(java.lang.Comparable[])

    private static var parallelSort_MethodID_103: jmethodID?

    open class func parallelSort( a: [JavaComparable]? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "parallelSort", methodSig: "([Ljava/lang/Comparable;)V", methodCache: &parallelSort_MethodID_103, args: &__args, locals: &__locals )
    }

    open class func parallelSort( _ _a: [JavaComparable]? ) {
        parallelSort( a: _a )
    }

    /// public static void java.util.Arrays.parallelSort(java.lang.Comparable[],int,int)

    private static var parallelSort_MethodID_104: jmethodID?

    open class func parallelSort( a: [JavaComparable]?, fromIndex: Int, toIndex: Int ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "parallelSort", methodSig: "([Ljava/lang/Comparable;II)V", methodCache: &parallelSort_MethodID_104, args: &__args, locals: &__locals )
    }

    open class func parallelSort( _ _a: [JavaComparable]?, _ _fromIndex: Int, _ _toIndex: Int ) {
        parallelSort( a: _a, fromIndex: _fromIndex, toIndex: _toIndex )
    }

    /// public static void java.util.Arrays.parallelSort(java.lang.Object[],int,int,java.util.Comparator)

    private static var parallelSort_MethodID_105: jmethodID?

    open class func parallelSort( a: [JavaObject]?, fromIndex: Int, toIndex: Int, cmp: JavaComparator? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        __args[3] = JNIType.toJava( value: cmp, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "parallelSort", methodSig: "([Ljava/lang/Object;IILjava/util/Comparator;)V", methodCache: &parallelSort_MethodID_105, args: &__args, locals: &__locals )
    }

    open class func parallelSort( _ _a: [JavaObject]?, _ _fromIndex: Int, _ _toIndex: Int, _ _cmp: JavaComparator? ) {
        parallelSort( a: _a, fromIndex: _fromIndex, toIndex: _toIndex, cmp: _cmp )
    }

    /// public static void java.util.Arrays.parallelSort(java.lang.Object[],java.util.Comparator)

    private static var parallelSort_MethodID_106: jmethodID?

    open class func parallelSort( a: [JavaObject]?, cmp: JavaComparator? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = JNIType.toJava( value: cmp, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "parallelSort", methodSig: "([Ljava/lang/Object;Ljava/util/Comparator;)V", methodCache: &parallelSort_MethodID_106, args: &__args, locals: &__locals )
    }

    open class func parallelSort( _ _a: [JavaObject]?, _ _cmp: JavaComparator? ) {
        parallelSort( a: _a, cmp: _cmp )
    }

    /// public static void java.util.Arrays.parallelSort(char[])

    private static var parallelSort_MethodID_107: jmethodID?

    open class func parallelSort( a: [UInt16]? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "parallelSort", methodSig: "([C)V", methodCache: &parallelSort_MethodID_107, args: &__args, locals: &__locals )
    }

    open class func parallelSort( _ _a: [UInt16]? ) {
        parallelSort( a: _a )
    }

    /// public static void java.util.Arrays.parallelSort(char[],int,int)

    private static var parallelSort_MethodID_108: jmethodID?

    open class func parallelSort( a: [UInt16]?, fromIndex: Int, toIndex: Int ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "parallelSort", methodSig: "([CII)V", methodCache: &parallelSort_MethodID_108, args: &__args, locals: &__locals )
    }

    open class func parallelSort( _ _a: [UInt16]?, _ _fromIndex: Int, _ _toIndex: Int ) {
        parallelSort( a: _a, fromIndex: _fromIndex, toIndex: _toIndex )
    }

    /// private static void java.util.Arrays.rangeCheck(int,int,int)

    /// public static void java.util.Arrays.setAll(double[],java.util.function.IntToDoubleFunction)

    private static var setAll_MethodID_109: jmethodID?

    open class func setAll( array: [Double]?, generator: IntToDoubleFunction? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = JNIType.toJava( value: generator, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "setAll", methodSig: "([DLjava/util/function/IntToDoubleFunction;)V", methodCache: &setAll_MethodID_109, args: &__args, locals: &__locals )
    }

    open class func setAll( _ _array: [Double]?, _ _generator: IntToDoubleFunction? ) {
        setAll( array: _array, generator: _generator )
    }

    /// public static void java.util.Arrays.setAll(int[],java.util.function.IntUnaryOperator)

    private static var setAll_MethodID_110: jmethodID?

    open class func setAll( array: [Int32]?, generator: IntUnaryOperator? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = JNIType.toJava( value: generator, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "setAll", methodSig: "([ILjava/util/function/IntUnaryOperator;)V", methodCache: &setAll_MethodID_110, args: &__args, locals: &__locals )
    }

    open class func setAll( _ _array: [Int32]?, _ _generator: IntUnaryOperator? ) {
        setAll( array: _array, generator: _generator )
    }

    /// public static void java.util.Arrays.setAll(long[],java.util.function.IntToLongFunction)

    private static var setAll_MethodID_111: jmethodID?

    open class func setAll( array: [Int64]?, generator: IntToLongFunction? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = JNIType.toJava( value: generator, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "setAll", methodSig: "([JLjava/util/function/IntToLongFunction;)V", methodCache: &setAll_MethodID_111, args: &__args, locals: &__locals )
    }

    open class func setAll( _ _array: [Int64]?, _ _generator: IntToLongFunction? ) {
        setAll( array: _array, generator: _generator )
    }

    /// public static void java.util.Arrays.setAll(java.lang.Object[],java.util.function.IntFunction)

    private static var setAll_MethodID_112: jmethodID?

    open class func setAll( array: [JavaObject]?, generator: IntFunction? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = JNIType.toJava( value: generator, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "setAll", methodSig: "([Ljava/lang/Object;Ljava/util/function/IntFunction;)V", methodCache: &setAll_MethodID_112, args: &__args, locals: &__locals )
    }

    open class func setAll( _ _array: [JavaObject]?, _ _generator: IntFunction? ) {
        setAll( array: _array, generator: _generator )
    }

    /// public static void java.util.Arrays.sort(double[])

    private static var sort_MethodID_113: jmethodID?

    open class func sort( a: [Double]? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "sort", methodSig: "([D)V", methodCache: &sort_MethodID_113, args: &__args, locals: &__locals )
    }

    open class func sort( _ _a: [Double]? ) {
        sort( a: _a )
    }

    /// public static void java.util.Arrays.sort(double[],int,int)

    private static var sort_MethodID_114: jmethodID?

    open class func sort( a: [Double]?, fromIndex: Int, toIndex: Int ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "sort", methodSig: "([DII)V", methodCache: &sort_MethodID_114, args: &__args, locals: &__locals )
    }

    open class func sort( _ _a: [Double]?, _ _fromIndex: Int, _ _toIndex: Int ) {
        sort( a: _a, fromIndex: _fromIndex, toIndex: _toIndex )
    }

    /// public static void java.util.Arrays.sort(float[])

    private static var sort_MethodID_115: jmethodID?

    open class func sort( a: [Float]? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "sort", methodSig: "([F)V", methodCache: &sort_MethodID_115, args: &__args, locals: &__locals )
    }

    open class func sort( _ _a: [Float]? ) {
        sort( a: _a )
    }

    /// public static void java.util.Arrays.sort(float[],int,int)

    private static var sort_MethodID_116: jmethodID?

    open class func sort( a: [Float]?, fromIndex: Int, toIndex: Int ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "sort", methodSig: "([FII)V", methodCache: &sort_MethodID_116, args: &__args, locals: &__locals )
    }

    open class func sort( _ _a: [Float]?, _ _fromIndex: Int, _ _toIndex: Int ) {
        sort( a: _a, fromIndex: _fromIndex, toIndex: _toIndex )
    }

    /// public static void java.util.Arrays.sort(short[])

    private static var sort_MethodID_117: jmethodID?

    open class func sort( a: [Int16]? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "sort", methodSig: "([S)V", methodCache: &sort_MethodID_117, args: &__args, locals: &__locals )
    }

    open class func sort( _ _a: [Int16]? ) {
        sort( a: _a )
    }

    /// public static void java.util.Arrays.sort(short[],int,int)

    private static var sort_MethodID_118: jmethodID?

    open class func sort( a: [Int16]?, fromIndex: Int, toIndex: Int ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "sort", methodSig: "([SII)V", methodCache: &sort_MethodID_118, args: &__args, locals: &__locals )
    }

    open class func sort( _ _a: [Int16]?, _ _fromIndex: Int, _ _toIndex: Int ) {
        sort( a: _a, fromIndex: _fromIndex, toIndex: _toIndex )
    }

    /// public static void java.util.Arrays.sort(int[])

    private static var sort_MethodID_119: jmethodID?

    open class func sort( a: [Int32]? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "sort", methodSig: "([I)V", methodCache: &sort_MethodID_119, args: &__args, locals: &__locals )
    }

    open class func sort( _ _a: [Int32]? ) {
        sort( a: _a )
    }

    /// public static void java.util.Arrays.sort(int[],int,int)

    private static var sort_MethodID_120: jmethodID?

    open class func sort( a: [Int32]?, fromIndex: Int, toIndex: Int ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "sort", methodSig: "([III)V", methodCache: &sort_MethodID_120, args: &__args, locals: &__locals )
    }

    open class func sort( _ _a: [Int32]?, _ _fromIndex: Int, _ _toIndex: Int ) {
        sort( a: _a, fromIndex: _fromIndex, toIndex: _toIndex )
    }

    /// public static void java.util.Arrays.sort(long[])

    private static var sort_MethodID_121: jmethodID?

    open class func sort( a: [Int64]? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "sort", methodSig: "([J)V", methodCache: &sort_MethodID_121, args: &__args, locals: &__locals )
    }

    open class func sort( _ _a: [Int64]? ) {
        sort( a: _a )
    }

    /// public static void java.util.Arrays.sort(long[],int,int)

    private static var sort_MethodID_122: jmethodID?

    open class func sort( a: [Int64]?, fromIndex: Int, toIndex: Int ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "sort", methodSig: "([JII)V", methodCache: &sort_MethodID_122, args: &__args, locals: &__locals )
    }

    open class func sort( _ _a: [Int64]?, _ _fromIndex: Int, _ _toIndex: Int ) {
        sort( a: _a, fromIndex: _fromIndex, toIndex: _toIndex )
    }

    /// public static void java.util.Arrays.sort(byte[])

    private static var sort_MethodID_123: jmethodID?

    open class func sort( a: [Int8]? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "sort", methodSig: "([B)V", methodCache: &sort_MethodID_123, args: &__args, locals: &__locals )
    }

    open class func sort( _ _a: [Int8]? ) {
        sort( a: _a )
    }

    /// public static void java.util.Arrays.sort(byte[],int,int)

    private static var sort_MethodID_124: jmethodID?

    open class func sort( a: [Int8]?, fromIndex: Int, toIndex: Int ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "sort", methodSig: "([BII)V", methodCache: &sort_MethodID_124, args: &__args, locals: &__locals )
    }

    open class func sort( _ _a: [Int8]?, _ _fromIndex: Int, _ _toIndex: Int ) {
        sort( a: _a, fromIndex: _fromIndex, toIndex: _toIndex )
    }

    /// public static void java.util.Arrays.sort(java.lang.Object[])

    private static var sort_MethodID_125: jmethodID?

    open class func sort( a: [JavaObject]? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "sort", methodSig: "([Ljava/lang/Object;)V", methodCache: &sort_MethodID_125, args: &__args, locals: &__locals )
    }

    open class func sort( _ _a: [JavaObject]? ) {
        sort( a: _a )
    }

    /// public static void java.util.Arrays.sort(java.lang.Object[],int,int)

    private static var sort_MethodID_126: jmethodID?

    open class func sort( a: [JavaObject]?, fromIndex: Int, toIndex: Int ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "sort", methodSig: "([Ljava/lang/Object;II)V", methodCache: &sort_MethodID_126, args: &__args, locals: &__locals )
    }

    open class func sort( _ _a: [JavaObject]?, _ _fromIndex: Int, _ _toIndex: Int ) {
        sort( a: _a, fromIndex: _fromIndex, toIndex: _toIndex )
    }

    /// public static void java.util.Arrays.sort(java.lang.Object[],int,int,java.util.Comparator)

    private static var sort_MethodID_127: jmethodID?

    open class func sort( a: [JavaObject]?, fromIndex: Int, toIndex: Int, c: JavaComparator? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        __args[3] = JNIType.toJava( value: c, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "sort", methodSig: "([Ljava/lang/Object;IILjava/util/Comparator;)V", methodCache: &sort_MethodID_127, args: &__args, locals: &__locals )
    }

    open class func sort( _ _a: [JavaObject]?, _ _fromIndex: Int, _ _toIndex: Int, _ _c: JavaComparator? ) {
        sort( a: _a, fromIndex: _fromIndex, toIndex: _toIndex, c: _c )
    }

    /// public static void java.util.Arrays.sort(java.lang.Object[],java.util.Comparator)

    private static var sort_MethodID_128: jmethodID?

    open class func sort( a: [JavaObject]?, c: JavaComparator? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = JNIType.toJava( value: c, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "sort", methodSig: "([Ljava/lang/Object;Ljava/util/Comparator;)V", methodCache: &sort_MethodID_128, args: &__args, locals: &__locals )
    }

    open class func sort( _ _a: [JavaObject]?, _ _c: JavaComparator? ) {
        sort( a: _a, c: _c )
    }

    /// public static void java.util.Arrays.sort(char[])

    private static var sort_MethodID_129: jmethodID?

    open class func sort( a: [UInt16]? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "sort", methodSig: "([C)V", methodCache: &sort_MethodID_129, args: &__args, locals: &__locals )
    }

    open class func sort( _ _a: [UInt16]? ) {
        sort( a: _a )
    }

    /// public static void java.util.Arrays.sort(char[],int,int)

    private static var sort_MethodID_130: jmethodID?

    open class func sort( a: [UInt16]?, fromIndex: Int, toIndex: Int ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        __args[1] = jvalue( i: jint(fromIndex) )
        __args[2] = jvalue( i: jint(toIndex) )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "sort", methodSig: "([CII)V", methodCache: &sort_MethodID_130, args: &__args, locals: &__locals )
    }

    open class func sort( _ _a: [UInt16]?, _ _fromIndex: Int, _ _toIndex: Int ) {
        sort( a: _a, fromIndex: _fromIndex, toIndex: _toIndex )
    }

    /// public static java.util.Spliterator$OfDouble java.util.Arrays.spliterator(double[])

    private static var spliterator_MethodID_131: jmethodID?

    open class func spliterator( array: [Double]? ) -> /* interface java.util.Spliterator$OfDouble */ UnavailableProtocol! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "spliterator", methodSig: "([D)Ljava/util/Spliterator$OfDouble;", methodCache: &spliterator_MethodID_131, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? /* interface java.util.Spliterator$OfDouble */ UnavailableProtocolForward( javaObject: __return ) : nil
    }

    open class func spliterator( _ _array: [Double]? ) -> /* interface java.util.Spliterator$OfDouble */ UnavailableProtocol! {
        return spliterator( array: _array )
    }

    /// public static java.util.Spliterator$OfDouble java.util.Arrays.spliterator(double[],int,int)

    private static var spliterator_MethodID_132: jmethodID?

    open class func spliterator( array: [Double]?, startInclusive: Int, endExclusive: Int ) -> /* interface java.util.Spliterator$OfDouble */ UnavailableProtocol! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = jvalue( i: jint(startInclusive) )
        __args[2] = jvalue( i: jint(endExclusive) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "spliterator", methodSig: "([DII)Ljava/util/Spliterator$OfDouble;", methodCache: &spliterator_MethodID_132, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? /* interface java.util.Spliterator$OfDouble */ UnavailableProtocolForward( javaObject: __return ) : nil
    }

    open class func spliterator( _ _array: [Double]?, _ _startInclusive: Int, _ _endExclusive: Int ) -> /* interface java.util.Spliterator$OfDouble */ UnavailableProtocol! {
        return spliterator( array: _array, startInclusive: _startInclusive, endExclusive: _endExclusive )
    }

    /// public static java.util.Spliterator$OfInt java.util.Arrays.spliterator(int[])

    private static var spliterator_MethodID_133: jmethodID?

    open class func spliterator( array: [Int32]? ) -> /* interface java.util.Spliterator$OfInt */ UnavailableProtocol! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "spliterator", methodSig: "([I)Ljava/util/Spliterator$OfInt;", methodCache: &spliterator_MethodID_133, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? /* interface java.util.Spliterator$OfInt */ UnavailableProtocolForward( javaObject: __return ) : nil
    }

    open class func spliterator( _ _array: [Int32]? ) -> /* interface java.util.Spliterator$OfInt */ UnavailableProtocol! {
        return spliterator( array: _array )
    }

    /// public static java.util.Spliterator$OfInt java.util.Arrays.spliterator(int[],int,int)

    private static var spliterator_MethodID_134: jmethodID?

    open class func spliterator( array: [Int32]?, startInclusive: Int, endExclusive: Int ) -> /* interface java.util.Spliterator$OfInt */ UnavailableProtocol! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = jvalue( i: jint(startInclusive) )
        __args[2] = jvalue( i: jint(endExclusive) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "spliterator", methodSig: "([III)Ljava/util/Spliterator$OfInt;", methodCache: &spliterator_MethodID_134, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? /* interface java.util.Spliterator$OfInt */ UnavailableProtocolForward( javaObject: __return ) : nil
    }

    open class func spliterator( _ _array: [Int32]?, _ _startInclusive: Int, _ _endExclusive: Int ) -> /* interface java.util.Spliterator$OfInt */ UnavailableProtocol! {
        return spliterator( array: _array, startInclusive: _startInclusive, endExclusive: _endExclusive )
    }

    /// public static java.util.Spliterator$OfLong java.util.Arrays.spliterator(long[])

    private static var spliterator_MethodID_135: jmethodID?

    open class func spliterator( array: [Int64]? ) -> /* interface java.util.Spliterator$OfLong */ UnavailableProtocol! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "spliterator", methodSig: "([J)Ljava/util/Spliterator$OfLong;", methodCache: &spliterator_MethodID_135, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? /* interface java.util.Spliterator$OfLong */ UnavailableProtocolForward( javaObject: __return ) : nil
    }

    open class func spliterator( _ _array: [Int64]? ) -> /* interface java.util.Spliterator$OfLong */ UnavailableProtocol! {
        return spliterator( array: _array )
    }

    /// public static java.util.Spliterator$OfLong java.util.Arrays.spliterator(long[],int,int)

    private static var spliterator_MethodID_136: jmethodID?

    open class func spliterator( array: [Int64]?, startInclusive: Int, endExclusive: Int ) -> /* interface java.util.Spliterator$OfLong */ UnavailableProtocol! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = jvalue( i: jint(startInclusive) )
        __args[2] = jvalue( i: jint(endExclusive) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "spliterator", methodSig: "([JII)Ljava/util/Spliterator$OfLong;", methodCache: &spliterator_MethodID_136, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? /* interface java.util.Spliterator$OfLong */ UnavailableProtocolForward( javaObject: __return ) : nil
    }

    open class func spliterator( _ _array: [Int64]?, _ _startInclusive: Int, _ _endExclusive: Int ) -> /* interface java.util.Spliterator$OfLong */ UnavailableProtocol! {
        return spliterator( array: _array, startInclusive: _startInclusive, endExclusive: _endExclusive )
    }

    /// public static java.util.Spliterator java.util.Arrays.spliterator(java.lang.Object[])

    private static var spliterator_MethodID_137: jmethodID?

    open class func spliterator( array: [JavaObject]? ) -> Spliterator! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "spliterator", methodSig: "([Ljava/lang/Object;)Ljava/util/Spliterator;", methodCache: &spliterator_MethodID_137, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? SpliteratorForward( javaObject: __return ) : nil
    }

    open class func spliterator( _ _array: [JavaObject]? ) -> Spliterator! {
        return spliterator( array: _array )
    }

    /// public static java.util.Spliterator java.util.Arrays.spliterator(java.lang.Object[],int,int)

    private static var spliterator_MethodID_138: jmethodID?

    open class func spliterator( array: [JavaObject]?, startInclusive: Int, endExclusive: Int ) -> Spliterator! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = jvalue( i: jint(startInclusive) )
        __args[2] = jvalue( i: jint(endExclusive) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "spliterator", methodSig: "([Ljava/lang/Object;II)Ljava/util/Spliterator;", methodCache: &spliterator_MethodID_138, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? SpliteratorForward( javaObject: __return ) : nil
    }

    open class func spliterator( _ _array: [JavaObject]?, _ _startInclusive: Int, _ _endExclusive: Int ) -> Spliterator! {
        return spliterator( array: _array, startInclusive: _startInclusive, endExclusive: _endExclusive )
    }

    /// public static java.util.stream.DoubleStream java.util.Arrays.stream(double[])

    private static var stream_MethodID_139: jmethodID?

    open class func stream( array: [Double]? ) -> DoubleStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "stream", methodSig: "([D)Ljava/util/stream/DoubleStream;", methodCache: &stream_MethodID_139, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? DoubleStreamForward( javaObject: __return ) : nil
    }

    open class func stream( _ _array: [Double]? ) -> DoubleStream! {
        return stream( array: _array )
    }

    /// public static java.util.stream.DoubleStream java.util.Arrays.stream(double[],int,int)

    private static var stream_MethodID_140: jmethodID?

    open class func stream( array: [Double]?, startInclusive: Int, endExclusive: Int ) -> DoubleStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = jvalue( i: jint(startInclusive) )
        __args[2] = jvalue( i: jint(endExclusive) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "stream", methodSig: "([DII)Ljava/util/stream/DoubleStream;", methodCache: &stream_MethodID_140, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? DoubleStreamForward( javaObject: __return ) : nil
    }

    open class func stream( _ _array: [Double]?, _ _startInclusive: Int, _ _endExclusive: Int ) -> DoubleStream! {
        return stream( array: _array, startInclusive: _startInclusive, endExclusive: _endExclusive )
    }

    /// public static java.util.stream.IntStream java.util.Arrays.stream(int[])

    private static var stream_MethodID_141: jmethodID?

    open class func stream( array: [Int32]? ) -> IntStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "stream", methodSig: "([I)Ljava/util/stream/IntStream;", methodCache: &stream_MethodID_141, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? IntStreamForward( javaObject: __return ) : nil
    }

    open class func stream( _ _array: [Int32]? ) -> IntStream! {
        return stream( array: _array )
    }

    /// public static java.util.stream.IntStream java.util.Arrays.stream(int[],int,int)

    private static var stream_MethodID_142: jmethodID?

    open class func stream( array: [Int32]?, startInclusive: Int, endExclusive: Int ) -> IntStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = jvalue( i: jint(startInclusive) )
        __args[2] = jvalue( i: jint(endExclusive) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "stream", methodSig: "([III)Ljava/util/stream/IntStream;", methodCache: &stream_MethodID_142, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? IntStreamForward( javaObject: __return ) : nil
    }

    open class func stream( _ _array: [Int32]?, _ _startInclusive: Int, _ _endExclusive: Int ) -> IntStream! {
        return stream( array: _array, startInclusive: _startInclusive, endExclusive: _endExclusive )
    }

    /// public static java.util.stream.LongStream java.util.Arrays.stream(long[])

    private static var stream_MethodID_143: jmethodID?

    open class func stream( array: [Int64]? ) -> LongStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "stream", methodSig: "([J)Ljava/util/stream/LongStream;", methodCache: &stream_MethodID_143, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? LongStreamForward( javaObject: __return ) : nil
    }

    open class func stream( _ _array: [Int64]? ) -> LongStream! {
        return stream( array: _array )
    }

    /// public static java.util.stream.LongStream java.util.Arrays.stream(long[],int,int)

    private static var stream_MethodID_144: jmethodID?

    open class func stream( array: [Int64]?, startInclusive: Int, endExclusive: Int ) -> LongStream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = jvalue( i: jint(startInclusive) )
        __args[2] = jvalue( i: jint(endExclusive) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "stream", methodSig: "([JII)Ljava/util/stream/LongStream;", methodCache: &stream_MethodID_144, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? LongStreamForward( javaObject: __return ) : nil
    }

    open class func stream( _ _array: [Int64]?, _ _startInclusive: Int, _ _endExclusive: Int ) -> LongStream! {
        return stream( array: _array, startInclusive: _startInclusive, endExclusive: _endExclusive )
    }

    /// public static java.util.stream.Stream java.util.Arrays.stream(java.lang.Object[])

    private static var stream_MethodID_145: jmethodID?

    open class func stream( array: [JavaObject]? ) -> Stream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "stream", methodSig: "([Ljava/lang/Object;)Ljava/util/stream/Stream;", methodCache: &stream_MethodID_145, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? StreamForward( javaObject: __return ) : nil
    }

    open class func stream( _ _array: [JavaObject]? ) -> Stream! {
        return stream( array: _array )
    }

    /// public static java.util.stream.Stream java.util.Arrays.stream(java.lang.Object[],int,int)

    private static var stream_MethodID_146: jmethodID?

    open class func stream( array: [JavaObject]?, startInclusive: Int, endExclusive: Int ) -> Stream! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = jvalue( i: jint(startInclusive) )
        __args[2] = jvalue( i: jint(endExclusive) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "stream", methodSig: "([Ljava/lang/Object;II)Ljava/util/stream/Stream;", methodCache: &stream_MethodID_146, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? StreamForward( javaObject: __return ) : nil
    }

    open class func stream( _ _array: [JavaObject]?, _ _startInclusive: Int, _ _endExclusive: Int ) -> Stream! {
        return stream( array: _array, startInclusive: _startInclusive, endExclusive: _endExclusive )
    }

    /// private static void java.util.Arrays.swap(java.lang.Object[],int,int)

    /// public static java.lang.String java.util.Arrays.toString(boolean[])

    private static var toString_MethodID_147: jmethodID?

    open class func toString( a: [Bool]? ) -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "toString", methodSig: "([Z)Ljava/lang/String;", methodCache: &toString_MethodID_147, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? String( javaObject: __return ) : nil
    }

    open class func toString( _ _a: [Bool]? ) -> String! {
        return toString( a: _a )
    }

    /// public static java.lang.String java.util.Arrays.toString(double[])

    private static var toString_MethodID_148: jmethodID?

    open class func toString( a: [Double]? ) -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "toString", methodSig: "([D)Ljava/lang/String;", methodCache: &toString_MethodID_148, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? String( javaObject: __return ) : nil
    }

    open class func toString( _ _a: [Double]? ) -> String! {
        return toString( a: _a )
    }

    /// public static java.lang.String java.util.Arrays.toString(float[])

    private static var toString_MethodID_149: jmethodID?

    open class func toString( a: [Float]? ) -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "toString", methodSig: "([F)Ljava/lang/String;", methodCache: &toString_MethodID_149, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? String( javaObject: __return ) : nil
    }

    open class func toString( _ _a: [Float]? ) -> String! {
        return toString( a: _a )
    }

    /// public static java.lang.String java.util.Arrays.toString(short[])

    private static var toString_MethodID_150: jmethodID?

    open class func toString( a: [Int16]? ) -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "toString", methodSig: "([S)Ljava/lang/String;", methodCache: &toString_MethodID_150, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? String( javaObject: __return ) : nil
    }

    open class func toString( _ _a: [Int16]? ) -> String! {
        return toString( a: _a )
    }

    /// public static java.lang.String java.util.Arrays.toString(int[])

    private static var toString_MethodID_151: jmethodID?

    open class func toString( a: [Int32]? ) -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "toString", methodSig: "([I)Ljava/lang/String;", methodCache: &toString_MethodID_151, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? String( javaObject: __return ) : nil
    }

    open class func toString( _ _a: [Int32]? ) -> String! {
        return toString( a: _a )
    }

    /// public static java.lang.String java.util.Arrays.toString(long[])

    private static var toString_MethodID_152: jmethodID?

    open class func toString( a: [Int64]? ) -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "toString", methodSig: "([J)Ljava/lang/String;", methodCache: &toString_MethodID_152, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? String( javaObject: __return ) : nil
    }

    open class func toString( _ _a: [Int64]? ) -> String! {
        return toString( a: _a )
    }

    /// public static java.lang.String java.util.Arrays.toString(byte[])

    private static var toString_MethodID_153: jmethodID?

    open class func toString( a: [Int8]? ) -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "toString", methodSig: "([B)Ljava/lang/String;", methodCache: &toString_MethodID_153, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? String( javaObject: __return ) : nil
    }

    open class func toString( _ _a: [Int8]? ) -> String! {
        return toString( a: _a )
    }

    /// public static java.lang.String java.util.Arrays.toString(java.lang.Object[])

    private static var toString_MethodID_154: jmethodID?

    open class func toString( a: [JavaObject]? ) -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "toString", methodSig: "([Ljava/lang/Object;)Ljava/lang/String;", methodCache: &toString_MethodID_154, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? String( javaObject: __return ) : nil
    }

    open class func toString( _ _a: [JavaObject]? ) -> String! {
        return toString( a: _a )
    }

    /// public static java.lang.String java.util.Arrays.toString(char[])

    private static var toString_MethodID_155: jmethodID?

    open class func toString( a: [UInt16]? ) -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: a, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "toString", methodSig: "([C)Ljava/lang/String;", methodCache: &toString_MethodID_155, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? String( javaObject: __return ) : nil
    }

    open class func toString( _ _a: [UInt16]? ) -> String! {
        return toString( a: _a )
    }

}

