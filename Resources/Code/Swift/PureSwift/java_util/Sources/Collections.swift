
import java_swift

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// class java.util.Collections ///

open class Collections: java_swift.JavaObject {

    public convenience init?( casting object: java_swift.JavaObject, _ file: StaticString = #file, _ line: Int = #line ) {
        self.init( javaObject: nil )
        object.withJavaObject {
            self.javaObject = $0
        }
    }

    private static var CollectionsJNIClass: jclass?

    /// private static final int java.util.Collections.BINARYSEARCH_THRESHOLD

    /// private static final int java.util.Collections.COPY_THRESHOLD

    /// public static final java.util.List java.util.Collections.EMPTY_LIST

    private static var EMPTY_LIST_FieldID: jfieldID?

    public static var EMPTY_LIST: List! {
        get {
            let __value = JNIField.GetStaticObjectField( fieldName: "EMPTY_LIST", fieldType: "Ljava/util/List;", fieldCache: &EMPTY_LIST_FieldID, className: "java/util/Collections", classCache: &CollectionsJNIClass )
            defer { JNI.DeleteLocalRef( __value ) }
            return __value != nil ? ListForward( javaObject: __value ) : nil
        }
    }

    /// public static final java.util.Map java.util.Collections.EMPTY_MAP

    private static var EMPTY_MAP_FieldID: jfieldID?

    public static var EMPTY_MAP: java_swift.JavaMap! {
        get {
            let __value = JNIField.GetStaticObjectField( fieldName: "EMPTY_MAP", fieldType: "Ljava/util/Map;", fieldCache: &EMPTY_MAP_FieldID, className: "java/util/Collections", classCache: &CollectionsJNIClass )
            return JNIType.toSwift( type: java_swift.JavaMapForward.self, from: __value )
        }
    }

    /// public static final java.util.Set java.util.Collections.EMPTY_SET

    private static var EMPTY_SET_FieldID: jfieldID?

    public static var EMPTY_SET: java_swift.JavaSet! {
        get {
            let __value = JNIField.GetStaticObjectField( fieldName: "EMPTY_SET", fieldType: "Ljava/util/Set;", fieldCache: &EMPTY_SET_FieldID, className: "java/util/Collections", classCache: &CollectionsJNIClass )
            defer { JNI.DeleteLocalRef( __value ) }
            return __value != nil ? java_swift.JavaSetForward( javaObject: __value ) : nil
        }
    }

    /// private static final int java.util.Collections.FILL_THRESHOLD

    /// private static final int java.util.Collections.INDEXOFSUBLIST_THRESHOLD

    /// private static final int java.util.Collections.REPLACEALL_THRESHOLD

    /// private static final int java.util.Collections.REVERSE_THRESHOLD

    /// private static final int java.util.Collections.ROTATE_THRESHOLD

    /// private static final int java.util.Collections.SHUFFLE_THRESHOLD

    /// private static java.util.Random java.util.Collections.r

    /// private java.util.Collections()

    /// public static boolean java.util.Collections.addAll(java.util.Collection,java.lang.Object[])

    private static var addAll_MethodID_1: jmethodID?

    open class func addAll( c: Collection?, elements: [JavaObject]? ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: c, locals: &__locals )
        __args[1] = JNIType.toJava( value: elements, locals: &__locals )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "addAll", methodSig: "(Ljava/util/Collection;[Ljava/lang/Object;)Z", methodCache: &addAll_MethodID_1, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open class func addAll( _ _c: Collection?, _ _elements: [JavaObject]? ) -> Bool {
        return addAll( c: _c, elements: _elements )
    }

    /// public static java.util.Queue java.util.Collections.asLifoQueue(java.util.Deque)

    private static var asLifoQueue_MethodID_2: jmethodID?

    open class func asLifoQueue( deque: Deque? ) -> Queue! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: deque, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "asLifoQueue", methodSig: "(Ljava/util/Deque;)Ljava/util/Queue;", methodCache: &asLifoQueue_MethodID_2, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? QueueForward( javaObject: __return ) : nil
    }

    open class func asLifoQueue( _ _deque: Deque? ) -> Queue! {
        return asLifoQueue( deque: _deque )
    }

    /// public static int java.util.Collections.binarySearch(java.util.List,java.lang.Object)

    private static var binarySearch_MethodID_3: jmethodID?

    open class func binarySearch( list: List?, key: java_swift.JavaObject? ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: list, locals: &__locals )
        __args[1] = JNIType.toJava( value: key, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "binarySearch", methodSig: "(Ljava/util/List;Ljava/lang/Object;)I", methodCache: &binarySearch_MethodID_3, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func binarySearch( _ _list: List?, _ _key: java_swift.JavaObject? ) -> Int {
        return binarySearch( list: _list, key: _key )
    }

    /// public static int java.util.Collections.binarySearch(java.util.List,java.lang.Object,java.util.Comparator)

    private static var binarySearch_MethodID_4: jmethodID?

    open class func binarySearch( list: List?, key: java_swift.JavaObject?, c: JavaComparator? ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: list, locals: &__locals )
        __args[1] = JNIType.toJava( value: key, locals: &__locals )
        __args[2] = JNIType.toJava( value: c, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "binarySearch", methodSig: "(Ljava/util/List;Ljava/lang/Object;Ljava/util/Comparator;)I", methodCache: &binarySearch_MethodID_4, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func binarySearch( _ _list: List?, _ _key: java_swift.JavaObject?, _ _c: JavaComparator? ) -> Int {
        return binarySearch( list: _list, key: _key, c: _c )
    }

    /// public static java.util.Collection java.util.Collections.checkedCollection(java.util.Collection,java.lang.Class)

    private static var checkedCollection_MethodID_5: jmethodID?

    open class func checkedCollection( c: Collection?, type: java_swift.JavaClass? ) -> Collection! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: c, locals: &__locals )
        __args[1] = JNIType.toJava( value: type, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "checkedCollection", methodSig: "(Ljava/util/Collection;Ljava/lang/Class;)Ljava/util/Collection;", methodCache: &checkedCollection_MethodID_5, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectionForward( javaObject: __return ) : nil
    }

    open class func checkedCollection( _ _c: Collection?, _ _type: java_swift.JavaClass? ) -> Collection! {
        return checkedCollection( c: _c, type: _type )
    }

    /// public static java.util.List java.util.Collections.checkedList(java.util.List,java.lang.Class)

    private static var checkedList_MethodID_6: jmethodID?

    open class func checkedList( list: List?, type: java_swift.JavaClass? ) -> List! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: list, locals: &__locals )
        __args[1] = JNIType.toJava( value: type, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "checkedList", methodSig: "(Ljava/util/List;Ljava/lang/Class;)Ljava/util/List;", methodCache: &checkedList_MethodID_6, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? ListForward( javaObject: __return ) : nil
    }

    open class func checkedList( _ _list: List?, _ _type: java_swift.JavaClass? ) -> List! {
        return checkedList( list: _list, type: _type )
    }

    /// public static java.util.Map java.util.Collections.checkedMap(java.util.Map,java.lang.Class,java.lang.Class)

    private static var checkedMap_MethodID_7: jmethodID?

    open class func checkedMap( m: java_swift.JavaMap?, keyType: java_swift.JavaClass?, valueType: java_swift.JavaClass? ) -> java_swift.JavaMap! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: m, mapClass: "java/util/Map", locals: &__locals )
        __args[1] = JNIType.toJava( value: keyType, locals: &__locals )
        __args[2] = JNIType.toJava( value: valueType, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "checkedMap", methodSig: "(Ljava/util/Map;Ljava/lang/Class;Ljava/lang/Class;)Ljava/util/Map;", methodCache: &checkedMap_MethodID_7, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: java_swift.JavaMapForward.self, from: __return )
    }

    open class func checkedMap( _ _m: java_swift.JavaMap?, _ _keyType: java_swift.JavaClass?, _ _valueType: java_swift.JavaClass? ) -> java_swift.JavaMap! {
        return checkedMap( m: _m, keyType: _keyType, valueType: _valueType )
    }

    /// public static java.util.NavigableMap java.util.Collections.checkedNavigableMap(java.util.NavigableMap,java.lang.Class,java.lang.Class)

    private static var checkedNavigableMap_MethodID_8: jmethodID?

    open class func checkedNavigableMap( m: NavigableMap?, keyType: java_swift.JavaClass?, valueType: java_swift.JavaClass? ) -> NavigableMap! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: m, mapClass: "java/util/NavigableMap", locals: &__locals )
        __args[1] = JNIType.toJava( value: keyType, locals: &__locals )
        __args[2] = JNIType.toJava( value: valueType, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "checkedNavigableMap", methodSig: "(Ljava/util/NavigableMap;Ljava/lang/Class;Ljava/lang/Class;)Ljava/util/NavigableMap;", methodCache: &checkedNavigableMap_MethodID_8, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: NavigableMapForward.self, from: __return )
    }

    open class func checkedNavigableMap( _ _m: NavigableMap?, _ _keyType: java_swift.JavaClass?, _ _valueType: java_swift.JavaClass? ) -> NavigableMap! {
        return checkedNavigableMap( m: _m, keyType: _keyType, valueType: _valueType )
    }

    /// public static java.util.NavigableSet java.util.Collections.checkedNavigableSet(java.util.NavigableSet,java.lang.Class)

    private static var checkedNavigableSet_MethodID_9: jmethodID?

    open class func checkedNavigableSet( s: NavigableSet?, type: java_swift.JavaClass? ) -> NavigableSet! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: s, locals: &__locals )
        __args[1] = JNIType.toJava( value: type, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "checkedNavigableSet", methodSig: "(Ljava/util/NavigableSet;Ljava/lang/Class;)Ljava/util/NavigableSet;", methodCache: &checkedNavigableSet_MethodID_9, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? NavigableSetForward( javaObject: __return ) : nil
    }

    open class func checkedNavigableSet( _ _s: NavigableSet?, _ _type: java_swift.JavaClass? ) -> NavigableSet! {
        return checkedNavigableSet( s: _s, type: _type )
    }

    /// public static java.util.Queue java.util.Collections.checkedQueue(java.util.Queue,java.lang.Class)

    private static var checkedQueue_MethodID_10: jmethodID?

    open class func checkedQueue( queue: Queue?, type: java_swift.JavaClass? ) -> Queue! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: queue, locals: &__locals )
        __args[1] = JNIType.toJava( value: type, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "checkedQueue", methodSig: "(Ljava/util/Queue;Ljava/lang/Class;)Ljava/util/Queue;", methodCache: &checkedQueue_MethodID_10, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? QueueForward( javaObject: __return ) : nil
    }

    open class func checkedQueue( _ _queue: Queue?, _ _type: java_swift.JavaClass? ) -> Queue! {
        return checkedQueue( queue: _queue, type: _type )
    }

    /// public static java.util.Set java.util.Collections.checkedSet(java.util.Set,java.lang.Class)

    private static var checkedSet_MethodID_11: jmethodID?

    open class func checkedSet( s: java_swift.JavaSet?, type: java_swift.JavaClass? ) -> java_swift.JavaSet! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: s, locals: &__locals )
        __args[1] = JNIType.toJava( value: type, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "checkedSet", methodSig: "(Ljava/util/Set;Ljava/lang/Class;)Ljava/util/Set;", methodCache: &checkedSet_MethodID_11, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? java_swift.JavaSetForward( javaObject: __return ) : nil
    }

    open class func checkedSet( _ _s: java_swift.JavaSet?, _ _type: java_swift.JavaClass? ) -> java_swift.JavaSet! {
        return checkedSet( s: _s, type: _type )
    }

    /// public static java.util.SortedMap java.util.Collections.checkedSortedMap(java.util.SortedMap,java.lang.Class,java.lang.Class)

    private static var checkedSortedMap_MethodID_12: jmethodID?

    open class func checkedSortedMap( m: SortedMap?, keyType: java_swift.JavaClass?, valueType: java_swift.JavaClass? ) -> SortedMap! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: m, mapClass: "java/util/SortedMap", locals: &__locals )
        __args[1] = JNIType.toJava( value: keyType, locals: &__locals )
        __args[2] = JNIType.toJava( value: valueType, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "checkedSortedMap", methodSig: "(Ljava/util/SortedMap;Ljava/lang/Class;Ljava/lang/Class;)Ljava/util/SortedMap;", methodCache: &checkedSortedMap_MethodID_12, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: SortedMapForward.self, from: __return )
    }

    open class func checkedSortedMap( _ _m: SortedMap?, _ _keyType: java_swift.JavaClass?, _ _valueType: java_swift.JavaClass? ) -> SortedMap! {
        return checkedSortedMap( m: _m, keyType: _keyType, valueType: _valueType )
    }

    /// public static java.util.SortedSet java.util.Collections.checkedSortedSet(java.util.SortedSet,java.lang.Class)

    private static var checkedSortedSet_MethodID_13: jmethodID?

    open class func checkedSortedSet( s: SortedSet?, type: java_swift.JavaClass? ) -> SortedSet! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: s, locals: &__locals )
        __args[1] = JNIType.toJava( value: type, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "checkedSortedSet", methodSig: "(Ljava/util/SortedSet;Ljava/lang/Class;)Ljava/util/SortedSet;", methodCache: &checkedSortedSet_MethodID_13, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? SortedSetForward( javaObject: __return ) : nil
    }

    open class func checkedSortedSet( _ _s: SortedSet?, _ _type: java_swift.JavaClass? ) -> SortedSet! {
        return checkedSortedSet( s: _s, type: _type )
    }

    /// public static void java.util.Collections.copy(java.util.List,java.util.List)

    private static var copy_MethodID_14: jmethodID?

    open class func copy( dest: List?, src: List? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: dest, locals: &__locals )
        __args[1] = JNIType.toJava( value: src, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "copy", methodSig: "(Ljava/util/List;Ljava/util/List;)V", methodCache: &copy_MethodID_14, args: &__args, locals: &__locals )
    }

    open class func copy( _ _dest: List?, _ _src: List? ) {
        copy( dest: _dest, src: _src )
    }

    /// public static boolean java.util.Collections.disjoint(java.util.Collection,java.util.Collection)

    private static var disjoint_MethodID_15: jmethodID?

    open class func disjoint( c1: Collection?, c2: Collection? ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: c1, locals: &__locals )
        __args[1] = JNIType.toJava( value: c2, locals: &__locals )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "disjoint", methodSig: "(Ljava/util/Collection;Ljava/util/Collection;)Z", methodCache: &disjoint_MethodID_15, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open class func disjoint( _ _c1: Collection?, _ _c2: Collection? ) -> Bool {
        return disjoint( c1: _c1, c2: _c2 )
    }

    /// public static java.util.Enumeration java.util.Collections.emptyEnumeration()

    private static var emptyEnumeration_MethodID_16: jmethodID?

    open class func emptyEnumeration() -> Enumeration! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "emptyEnumeration", methodSig: "()Ljava/util/Enumeration;", methodCache: &emptyEnumeration_MethodID_16, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? EnumerationForward( javaObject: __return ) : nil
    }


    /// public static java.util.Iterator java.util.Collections.emptyIterator()

    private static var emptyIterator_MethodID_17: jmethodID?

    open class func emptyIterator() -> Iterator! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "emptyIterator", methodSig: "()Ljava/util/Iterator;", methodCache: &emptyIterator_MethodID_17, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? IteratorForward( javaObject: __return ) : nil
    }


    /// public static final java.util.List java.util.Collections.emptyList()

    private static var emptyList_MethodID_18: jmethodID?

    open class func emptyList() -> List! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "emptyList", methodSig: "()Ljava/util/List;", methodCache: &emptyList_MethodID_18, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? ListForward( javaObject: __return ) : nil
    }


    /// public static java.util.ListIterator java.util.Collections.emptyListIterator()

    private static var emptyListIterator_MethodID_19: jmethodID?

    open class func emptyListIterator() -> ListIterator! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "emptyListIterator", methodSig: "()Ljava/util/ListIterator;", methodCache: &emptyListIterator_MethodID_19, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? ListIteratorForward( javaObject: __return ) : nil
    }


    /// public static final java.util.Map java.util.Collections.emptyMap()

    private static var emptyMap_MethodID_20: jmethodID?

    open class func emptyMap() -> java_swift.JavaMap! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "emptyMap", methodSig: "()Ljava/util/Map;", methodCache: &emptyMap_MethodID_20, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: java_swift.JavaMapForward.self, from: __return )
    }


    /// public static final java.util.NavigableMap java.util.Collections.emptyNavigableMap()

    private static var emptyNavigableMap_MethodID_21: jmethodID?

    open class func emptyNavigableMap() -> NavigableMap! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "emptyNavigableMap", methodSig: "()Ljava/util/NavigableMap;", methodCache: &emptyNavigableMap_MethodID_21, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: NavigableMapForward.self, from: __return )
    }


    /// public static java.util.NavigableSet java.util.Collections.emptyNavigableSet()

    private static var emptyNavigableSet_MethodID_22: jmethodID?

    open class func emptyNavigableSet() -> NavigableSet! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "emptyNavigableSet", methodSig: "()Ljava/util/NavigableSet;", methodCache: &emptyNavigableSet_MethodID_22, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? NavigableSetForward( javaObject: __return ) : nil
    }


    /// public static final java.util.Set java.util.Collections.emptySet()

    private static var emptySet_MethodID_23: jmethodID?

    open class func emptySet() -> java_swift.JavaSet! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "emptySet", methodSig: "()Ljava/util/Set;", methodCache: &emptySet_MethodID_23, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? java_swift.JavaSetForward( javaObject: __return ) : nil
    }


    /// public static final java.util.SortedMap java.util.Collections.emptySortedMap()

    private static var emptySortedMap_MethodID_24: jmethodID?

    open class func emptySortedMap() -> SortedMap! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "emptySortedMap", methodSig: "()Ljava/util/SortedMap;", methodCache: &emptySortedMap_MethodID_24, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: SortedMapForward.self, from: __return )
    }


    /// public static java.util.SortedSet java.util.Collections.emptySortedSet()

    private static var emptySortedSet_MethodID_25: jmethodID?

    open class func emptySortedSet() -> SortedSet! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "emptySortedSet", methodSig: "()Ljava/util/SortedSet;", methodCache: &emptySortedSet_MethodID_25, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? SortedSetForward( javaObject: __return ) : nil
    }


    /// public static java.util.Enumeration java.util.Collections.enumeration(java.util.Collection)

    private static var enumeration_MethodID_26: jmethodID?

    open class func enumeration( c: Collection? ) -> Enumeration! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: c, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "enumeration", methodSig: "(Ljava/util/Collection;)Ljava/util/Enumeration;", methodCache: &enumeration_MethodID_26, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? EnumerationForward( javaObject: __return ) : nil
    }

    open class func enumeration( _ _c: Collection? ) -> Enumeration! {
        return enumeration( c: _c )
    }

    /// static boolean java.util.Collections.eq(java.lang.Object,java.lang.Object)

    // Skipping method: true false false false false 

    /// public static void java.util.Collections.fill(java.util.List,java.lang.Object)

    private static var fill_MethodID_27: jmethodID?

    open class func fill( list: List?, obj: java_swift.JavaObject? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: list, locals: &__locals )
        __args[1] = JNIType.toJava( value: obj, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "fill", methodSig: "(Ljava/util/List;Ljava/lang/Object;)V", methodCache: &fill_MethodID_27, args: &__args, locals: &__locals )
    }

    open class func fill( _ _list: List?, _ _obj: java_swift.JavaObject? ) {
        fill( list: _list, obj: _obj )
    }

    /// public static int java.util.Collections.frequency(java.util.Collection,java.lang.Object)

    private static var frequency_MethodID_28: jmethodID?

    open class func frequency( c: Collection?, o: java_swift.JavaObject? ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: c, locals: &__locals )
        __args[1] = JNIType.toJava( value: o, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "frequency", methodSig: "(Ljava/util/Collection;Ljava/lang/Object;)I", methodCache: &frequency_MethodID_28, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func frequency( _ _c: Collection?, _ _o: java_swift.JavaObject? ) -> Int {
        return frequency( c: _c, o: _o )
    }

    /// private static java.lang.Object java.util.Collections.get(java.util.ListIterator,int)

    /// public static int java.util.Collections.indexOfSubList(java.util.List,java.util.List)

    private static var indexOfSubList_MethodID_29: jmethodID?

    open class func indexOfSubList( source: List?, target: List? ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: source, locals: &__locals )
        __args[1] = JNIType.toJava( value: target, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "indexOfSubList", methodSig: "(Ljava/util/List;Ljava/util/List;)I", methodCache: &indexOfSubList_MethodID_29, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func indexOfSubList( _ _source: List?, _ _target: List? ) -> Int {
        return indexOfSubList( source: _source, target: _target )
    }

    /// private static int java.util.Collections.indexedBinarySearch(java.util.List,java.lang.Object)

    /// private static int java.util.Collections.indexedBinarySearch(java.util.List,java.lang.Object,java.util.Comparator)

    /// private static int java.util.Collections.iteratorBinarySearch(java.util.List,java.lang.Object)

    /// private static int java.util.Collections.iteratorBinarySearch(java.util.List,java.lang.Object,java.util.Comparator)

    /// public static int java.util.Collections.lastIndexOfSubList(java.util.List,java.util.List)

    private static var lastIndexOfSubList_MethodID_30: jmethodID?

    open class func lastIndexOfSubList( source: List?, target: List? ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: source, locals: &__locals )
        __args[1] = JNIType.toJava( value: target, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "lastIndexOfSubList", methodSig: "(Ljava/util/List;Ljava/util/List;)I", methodCache: &lastIndexOfSubList_MethodID_30, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func lastIndexOfSubList( _ _source: List?, _ _target: List? ) -> Int {
        return lastIndexOfSubList( source: _source, target: _target )
    }

    /// public static java.util.ArrayList java.util.Collections.list(java.util.Enumeration)

    private static var list_MethodID_31: jmethodID?

    open class func list( e: Enumeration? ) -> ArrayList! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: e, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "list", methodSig: "(Ljava/util/Enumeration;)Ljava/util/ArrayList;", methodCache: &list_MethodID_31, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? ArrayList( javaObject: __return ) : nil
    }

    open class func list( _ _e: Enumeration? ) -> ArrayList! {
        return list( e: _e )
    }

    /// public static java.lang.Object java.util.Collections.max(java.util.Collection)

    private static var max_MethodID_32: jmethodID?

    open class func max( coll: Collection? ) -> java_swift.JavaObject! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: coll, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "max", methodSig: "(Ljava/util/Collection;)Ljava/lang/Object;", methodCache: &max_MethodID_32, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? java_swift.JavaObject( javaObject: __return ) : nil
    }

    open class func max( _ _coll: Collection? ) -> java_swift.JavaObject! {
        return max( coll: _coll )
    }

    /// public static java.lang.Object java.util.Collections.max(java.util.Collection,java.util.Comparator)

    private static var max_MethodID_33: jmethodID?

    open class func max( coll: Collection?, comp: JavaComparator? ) -> java_swift.JavaObject! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: coll, locals: &__locals )
        __args[1] = JNIType.toJava( value: comp, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "max", methodSig: "(Ljava/util/Collection;Ljava/util/Comparator;)Ljava/lang/Object;", methodCache: &max_MethodID_33, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? java_swift.JavaObject( javaObject: __return ) : nil
    }

    open class func max( _ _coll: Collection?, _ _comp: JavaComparator? ) -> java_swift.JavaObject! {
        return max( coll: _coll, comp: _comp )
    }

    /// public static java.lang.Object java.util.Collections.min(java.util.Collection)

    private static var min_MethodID_34: jmethodID?

    open class func min( coll: Collection? ) -> java_swift.JavaObject! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: coll, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "min", methodSig: "(Ljava/util/Collection;)Ljava/lang/Object;", methodCache: &min_MethodID_34, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? java_swift.JavaObject( javaObject: __return ) : nil
    }

    open class func min( _ _coll: Collection? ) -> java_swift.JavaObject! {
        return min( coll: _coll )
    }

    /// public static java.lang.Object java.util.Collections.min(java.util.Collection,java.util.Comparator)

    private static var min_MethodID_35: jmethodID?

    open class func min( coll: Collection?, comp: JavaComparator? ) -> java_swift.JavaObject! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: coll, locals: &__locals )
        __args[1] = JNIType.toJava( value: comp, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "min", methodSig: "(Ljava/util/Collection;Ljava/util/Comparator;)Ljava/lang/Object;", methodCache: &min_MethodID_35, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? java_swift.JavaObject( javaObject: __return ) : nil
    }

    open class func min( _ _coll: Collection?, _ _comp: JavaComparator? ) -> java_swift.JavaObject! {
        return min( coll: _coll, comp: _comp )
    }

    /// public static java.util.List java.util.Collections.nCopies(int,java.lang.Object)

    private static var nCopies_MethodID_36: jmethodID?

    open class func nCopies( n: Int, o: java_swift.JavaObject? ) -> List! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = jvalue( i: jint(n) )
        __args[1] = JNIType.toJava( value: o, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "nCopies", methodSig: "(ILjava/lang/Object;)Ljava/util/List;", methodCache: &nCopies_MethodID_36, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? ListForward( javaObject: __return ) : nil
    }

    open class func nCopies( _ _n: Int, _ _o: java_swift.JavaObject? ) -> List! {
        return nCopies( n: _n, o: _o )
    }

    /// public static java.util.Set java.util.Collections.newSetFromMap(java.util.Map)

    private static var newSetFromMap_MethodID_37: jmethodID?

    open class func newSetFromMap( map: java_swift.JavaMap? ) -> java_swift.JavaSet! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: map, mapClass: "java/util/Map", locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "newSetFromMap", methodSig: "(Ljava/util/Map;)Ljava/util/Set;", methodCache: &newSetFromMap_MethodID_37, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? java_swift.JavaSetForward( javaObject: __return ) : nil
    }

    open class func newSetFromMap( _ _map: java_swift.JavaMap? ) -> java_swift.JavaSet! {
        return newSetFromMap( map: _map )
    }

    /// public static boolean java.util.Collections.replaceAll(java.util.List,java.lang.Object,java.lang.Object)

    private static var replaceAll_MethodID_38: jmethodID?

    open class func replaceAll( list: List?, oldVal: java_swift.JavaObject?, newVal: java_swift.JavaObject? ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: list, locals: &__locals )
        __args[1] = JNIType.toJava( value: oldVal, locals: &__locals )
        __args[2] = JNIType.toJava( value: newVal, locals: &__locals )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "replaceAll", methodSig: "(Ljava/util/List;Ljava/lang/Object;Ljava/lang/Object;)Z", methodCache: &replaceAll_MethodID_38, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open class func replaceAll( _ _list: List?, _ _oldVal: java_swift.JavaObject?, _ _newVal: java_swift.JavaObject? ) -> Bool {
        return replaceAll( list: _list, oldVal: _oldVal, newVal: _newVal )
    }

    /// public static void java.util.Collections.reverse(java.util.List)

    private static var reverse_MethodID_39: jmethodID?

    open class func reverse( list: List? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: list, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "reverse", methodSig: "(Ljava/util/List;)V", methodCache: &reverse_MethodID_39, args: &__args, locals: &__locals )
    }

    open class func reverse( _ _list: List? ) {
        reverse( list: _list )
    }

    /// public static java.util.Comparator java.util.Collections.reverseOrder(java.util.Comparator)

    private static var reverseOrder_MethodID_40: jmethodID?

    open class func reverseOrder( cmp: JavaComparator? ) -> JavaComparator! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: cmp, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "reverseOrder", methodSig: "(Ljava/util/Comparator;)Ljava/util/Comparator;", methodCache: &reverseOrder_MethodID_40, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? JavaComparatorForward( javaObject: __return ) : nil
    }

    open class func reverseOrder( _ _cmp: JavaComparator? ) -> JavaComparator! {
        return reverseOrder( cmp: _cmp )
    }

    /// public static java.util.Comparator java.util.Collections.reverseOrder()

    private static var reverseOrder_MethodID_41: jmethodID?

    open class func reverseOrder() -> JavaComparator! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "reverseOrder", methodSig: "()Ljava/util/Comparator;", methodCache: &reverseOrder_MethodID_41, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? JavaComparatorForward( javaObject: __return ) : nil
    }


    /// public static void java.util.Collections.rotate(java.util.List,int)

    private static var rotate_MethodID_42: jmethodID?

    open class func rotate( list: List?, distance: Int ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: list, locals: &__locals )
        __args[1] = jvalue( i: jint(distance) )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "rotate", methodSig: "(Ljava/util/List;I)V", methodCache: &rotate_MethodID_42, args: &__args, locals: &__locals )
    }

    open class func rotate( _ _list: List?, _ _distance: Int ) {
        rotate( list: _list, distance: _distance )
    }

    /// private static void java.util.Collections.rotate1(java.util.List,int)

    /// private static void java.util.Collections.rotate2(java.util.List,int)

    /// public static void java.util.Collections.shuffle(java.util.List)

    private static var shuffle_MethodID_43: jmethodID?

    open class func shuffle( list: List? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: list, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "shuffle", methodSig: "(Ljava/util/List;)V", methodCache: &shuffle_MethodID_43, args: &__args, locals: &__locals )
    }

    open class func shuffle( _ _list: List? ) {
        shuffle( list: _list )
    }

    /// public static void java.util.Collections.shuffle(java.util.List,java.util.Random)

    private static var shuffle_MethodID_44: jmethodID?

    open class func shuffle( list: List?, rnd: Random? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: list, locals: &__locals )
        __args[1] = JNIType.toJava( value: rnd, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "shuffle", methodSig: "(Ljava/util/List;Ljava/util/Random;)V", methodCache: &shuffle_MethodID_44, args: &__args, locals: &__locals )
    }

    open class func shuffle( _ _list: List?, _ _rnd: Random? ) {
        shuffle( list: _list, rnd: _rnd )
    }

    /// public static java.util.Set java.util.Collections.singleton(java.lang.Object)

    private static var singleton_MethodID_45: jmethodID?

    open class func singleton( o: java_swift.JavaObject? ) -> java_swift.JavaSet! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: o, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "singleton", methodSig: "(Ljava/lang/Object;)Ljava/util/Set;", methodCache: &singleton_MethodID_45, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? java_swift.JavaSetForward( javaObject: __return ) : nil
    }

    open class func singleton( _ _o: java_swift.JavaObject? ) -> java_swift.JavaSet! {
        return singleton( o: _o )
    }

    /// static java.util.Iterator java.util.Collections.singletonIterator(java.lang.Object)

    // Skipping method: true false false false false 

    /// public static java.util.List java.util.Collections.singletonList(java.lang.Object)

    private static var singletonList_MethodID_46: jmethodID?

    open class func singletonList( o: java_swift.JavaObject? ) -> List! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: o, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "singletonList", methodSig: "(Ljava/lang/Object;)Ljava/util/List;", methodCache: &singletonList_MethodID_46, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? ListForward( javaObject: __return ) : nil
    }

    open class func singletonList( _ _o: java_swift.JavaObject? ) -> List! {
        return singletonList( o: _o )
    }

    /// public static java.util.Map java.util.Collections.singletonMap(java.lang.Object,java.lang.Object)

    private static var singletonMap_MethodID_47: jmethodID?

    open class func singletonMap( key: java_swift.JavaObject?, value: java_swift.JavaObject? ) -> java_swift.JavaMap! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: key, locals: &__locals )
        __args[1] = JNIType.toJava( value: value, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "singletonMap", methodSig: "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/util/Map;", methodCache: &singletonMap_MethodID_47, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: java_swift.JavaMapForward.self, from: __return )
    }

    open class func singletonMap( _ _key: java_swift.JavaObject?, _ _value: java_swift.JavaObject? ) -> java_swift.JavaMap! {
        return singletonMap( key: _key, value: _value )
    }

    /// static java.util.Spliterator java.util.Collections.singletonSpliterator(java.lang.Object)

    // Skipping method: true false false false false 

    /// public static void java.util.Collections.sort(java.util.List)

    private static var sort_MethodID_48: jmethodID?

    open class func sort( list: List? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: list, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "sort", methodSig: "(Ljava/util/List;)V", methodCache: &sort_MethodID_48, args: &__args, locals: &__locals )
    }

    open class func sort( _ _list: List? ) {
        sort( list: _list )
    }

    /// public static void java.util.Collections.sort(java.util.List,java.util.Comparator)

    private static var sort_MethodID_49: jmethodID?

    open class func sort( list: List?, c: JavaComparator? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: list, locals: &__locals )
        __args[1] = JNIType.toJava( value: c, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "sort", methodSig: "(Ljava/util/List;Ljava/util/Comparator;)V", methodCache: &sort_MethodID_49, args: &__args, locals: &__locals )
    }

    open class func sort( _ _list: List?, _ _c: JavaComparator? ) {
        sort( list: _list, c: _c )
    }

    /// public static void java.util.Collections.swap(java.util.List,int,int)

    private static var swap_MethodID_50: jmethodID?

    open class func swap( list: List?, i: Int, j: Int ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: list, locals: &__locals )
        __args[1] = jvalue( i: jint(i) )
        __args[2] = jvalue( i: jint(j) )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "swap", methodSig: "(Ljava/util/List;II)V", methodCache: &swap_MethodID_50, args: &__args, locals: &__locals )
    }

    open class func swap( _ _list: List?, _ _i: Int, _ _j: Int ) {
        swap( list: _list, i: _i, j: _j )
    }

    /// private static void java.util.Collections.swap(java.lang.Object[],int,int)

    /// public static java.util.Collection java.util.Collections.synchronizedCollection(java.util.Collection)

    private static var synchronizedCollection_MethodID_51: jmethodID?

    open class func synchronizedCollection( c: Collection? ) -> Collection! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: c, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "synchronizedCollection", methodSig: "(Ljava/util/Collection;)Ljava/util/Collection;", methodCache: &synchronizedCollection_MethodID_51, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectionForward( javaObject: __return ) : nil
    }

    open class func synchronizedCollection( _ _c: Collection? ) -> Collection! {
        return synchronizedCollection( c: _c )
    }

    /// static java.util.Collection java.util.Collections.synchronizedCollection(java.util.Collection,java.lang.Object)

    // Skipping method: true false false false false 

    /// public static java.util.List java.util.Collections.synchronizedList(java.util.List)

    private static var synchronizedList_MethodID_52: jmethodID?

    open class func synchronizedList( list: List? ) -> List! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: list, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "synchronizedList", methodSig: "(Ljava/util/List;)Ljava/util/List;", methodCache: &synchronizedList_MethodID_52, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? ListForward( javaObject: __return ) : nil
    }

    open class func synchronizedList( _ _list: List? ) -> List! {
        return synchronizedList( list: _list )
    }

    /// static java.util.List java.util.Collections.synchronizedList(java.util.List,java.lang.Object)

    // Skipping method: true false false false false 

    /// public static java.util.Map java.util.Collections.synchronizedMap(java.util.Map)

    private static var synchronizedMap_MethodID_53: jmethodID?

    open class func synchronizedMap( m: java_swift.JavaMap? ) -> java_swift.JavaMap! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: m, mapClass: "java/util/Map", locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "synchronizedMap", methodSig: "(Ljava/util/Map;)Ljava/util/Map;", methodCache: &synchronizedMap_MethodID_53, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: java_swift.JavaMapForward.self, from: __return )
    }

    open class func synchronizedMap( _ _m: java_swift.JavaMap? ) -> java_swift.JavaMap! {
        return synchronizedMap( m: _m )
    }

    /// public static java.util.NavigableMap java.util.Collections.synchronizedNavigableMap(java.util.NavigableMap)

    private static var synchronizedNavigableMap_MethodID_54: jmethodID?

    open class func synchronizedNavigableMap( m: NavigableMap? ) -> NavigableMap! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: m, mapClass: "java/util/NavigableMap", locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "synchronizedNavigableMap", methodSig: "(Ljava/util/NavigableMap;)Ljava/util/NavigableMap;", methodCache: &synchronizedNavigableMap_MethodID_54, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: NavigableMapForward.self, from: __return )
    }

    open class func synchronizedNavigableMap( _ _m: NavigableMap? ) -> NavigableMap! {
        return synchronizedNavigableMap( m: _m )
    }

    /// public static java.util.NavigableSet java.util.Collections.synchronizedNavigableSet(java.util.NavigableSet)

    private static var synchronizedNavigableSet_MethodID_55: jmethodID?

    open class func synchronizedNavigableSet( s: NavigableSet? ) -> NavigableSet! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: s, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "synchronizedNavigableSet", methodSig: "(Ljava/util/NavigableSet;)Ljava/util/NavigableSet;", methodCache: &synchronizedNavigableSet_MethodID_55, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? NavigableSetForward( javaObject: __return ) : nil
    }

    open class func synchronizedNavigableSet( _ _s: NavigableSet? ) -> NavigableSet! {
        return synchronizedNavigableSet( s: _s )
    }

    /// public static java.util.Set java.util.Collections.synchronizedSet(java.util.Set)

    private static var synchronizedSet_MethodID_56: jmethodID?

    open class func synchronizedSet( s: java_swift.JavaSet? ) -> java_swift.JavaSet! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: s, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "synchronizedSet", methodSig: "(Ljava/util/Set;)Ljava/util/Set;", methodCache: &synchronizedSet_MethodID_56, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? java_swift.JavaSetForward( javaObject: __return ) : nil
    }

    open class func synchronizedSet( _ _s: java_swift.JavaSet? ) -> java_swift.JavaSet! {
        return synchronizedSet( s: _s )
    }

    /// static java.util.Set java.util.Collections.synchronizedSet(java.util.Set,java.lang.Object)

    // Skipping method: true false false false false 

    /// public static java.util.SortedMap java.util.Collections.synchronizedSortedMap(java.util.SortedMap)

    private static var synchronizedSortedMap_MethodID_57: jmethodID?

    open class func synchronizedSortedMap( m: SortedMap? ) -> SortedMap! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: m, mapClass: "java/util/SortedMap", locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "synchronizedSortedMap", methodSig: "(Ljava/util/SortedMap;)Ljava/util/SortedMap;", methodCache: &synchronizedSortedMap_MethodID_57, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: SortedMapForward.self, from: __return )
    }

    open class func synchronizedSortedMap( _ _m: SortedMap? ) -> SortedMap! {
        return synchronizedSortedMap( m: _m )
    }

    /// public static java.util.SortedSet java.util.Collections.synchronizedSortedSet(java.util.SortedSet)

    private static var synchronizedSortedSet_MethodID_58: jmethodID?

    open class func synchronizedSortedSet( s: SortedSet? ) -> SortedSet! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: s, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "synchronizedSortedSet", methodSig: "(Ljava/util/SortedSet;)Ljava/util/SortedSet;", methodCache: &synchronizedSortedSet_MethodID_58, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? SortedSetForward( javaObject: __return ) : nil
    }

    open class func synchronizedSortedSet( _ _s: SortedSet? ) -> SortedSet! {
        return synchronizedSortedSet( s: _s )
    }

    /// public static java.util.Collection java.util.Collections.unmodifiableCollection(java.util.Collection)

    private static var unmodifiableCollection_MethodID_59: jmethodID?

    open class func unmodifiableCollection( c: Collection? ) -> Collection! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: c, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "unmodifiableCollection", methodSig: "(Ljava/util/Collection;)Ljava/util/Collection;", methodCache: &unmodifiableCollection_MethodID_59, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectionForward( javaObject: __return ) : nil
    }

    open class func unmodifiableCollection( _ _c: Collection? ) -> Collection! {
        return unmodifiableCollection( c: _c )
    }

    /// public static java.util.List java.util.Collections.unmodifiableList(java.util.List)

    private static var unmodifiableList_MethodID_60: jmethodID?

    open class func unmodifiableList( list: List? ) -> List! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: list, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "unmodifiableList", methodSig: "(Ljava/util/List;)Ljava/util/List;", methodCache: &unmodifiableList_MethodID_60, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? ListForward( javaObject: __return ) : nil
    }

    open class func unmodifiableList( _ _list: List? ) -> List! {
        return unmodifiableList( list: _list )
    }

    /// public static java.util.Map java.util.Collections.unmodifiableMap(java.util.Map)

    private static var unmodifiableMap_MethodID_61: jmethodID?

    open class func unmodifiableMap( m: java_swift.JavaMap? ) -> java_swift.JavaMap! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: m, mapClass: "java/util/Map", locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "unmodifiableMap", methodSig: "(Ljava/util/Map;)Ljava/util/Map;", methodCache: &unmodifiableMap_MethodID_61, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: java_swift.JavaMapForward.self, from: __return )
    }

    open class func unmodifiableMap( _ _m: java_swift.JavaMap? ) -> java_swift.JavaMap! {
        return unmodifiableMap( m: _m )
    }

    /// public static java.util.NavigableMap java.util.Collections.unmodifiableNavigableMap(java.util.NavigableMap)

    private static var unmodifiableNavigableMap_MethodID_62: jmethodID?

    open class func unmodifiableNavigableMap( m: NavigableMap? ) -> NavigableMap! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: m, mapClass: "java/util/NavigableMap", locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "unmodifiableNavigableMap", methodSig: "(Ljava/util/NavigableMap;)Ljava/util/NavigableMap;", methodCache: &unmodifiableNavigableMap_MethodID_62, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: NavigableMapForward.self, from: __return )
    }

    open class func unmodifiableNavigableMap( _ _m: NavigableMap? ) -> NavigableMap! {
        return unmodifiableNavigableMap( m: _m )
    }

    /// public static java.util.NavigableSet java.util.Collections.unmodifiableNavigableSet(java.util.NavigableSet)

    private static var unmodifiableNavigableSet_MethodID_63: jmethodID?

    open class func unmodifiableNavigableSet( s: NavigableSet? ) -> NavigableSet! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: s, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "unmodifiableNavigableSet", methodSig: "(Ljava/util/NavigableSet;)Ljava/util/NavigableSet;", methodCache: &unmodifiableNavigableSet_MethodID_63, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? NavigableSetForward( javaObject: __return ) : nil
    }

    open class func unmodifiableNavigableSet( _ _s: NavigableSet? ) -> NavigableSet! {
        return unmodifiableNavigableSet( s: _s )
    }

    /// public static java.util.Set java.util.Collections.unmodifiableSet(java.util.Set)

    private static var unmodifiableSet_MethodID_64: jmethodID?

    open class func unmodifiableSet( s: java_swift.JavaSet? ) -> java_swift.JavaSet! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: s, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "unmodifiableSet", methodSig: "(Ljava/util/Set;)Ljava/util/Set;", methodCache: &unmodifiableSet_MethodID_64, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? java_swift.JavaSetForward( javaObject: __return ) : nil
    }

    open class func unmodifiableSet( _ _s: java_swift.JavaSet? ) -> java_swift.JavaSet! {
        return unmodifiableSet( s: _s )
    }

    /// public static java.util.SortedMap java.util.Collections.unmodifiableSortedMap(java.util.SortedMap)

    private static var unmodifiableSortedMap_MethodID_65: jmethodID?

    open class func unmodifiableSortedMap( m: SortedMap? ) -> SortedMap! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: m, mapClass: "java/util/SortedMap", locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "unmodifiableSortedMap", methodSig: "(Ljava/util/SortedMap;)Ljava/util/SortedMap;", methodCache: &unmodifiableSortedMap_MethodID_65, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: SortedMapForward.self, from: __return )
    }

    open class func unmodifiableSortedMap( _ _m: SortedMap? ) -> SortedMap! {
        return unmodifiableSortedMap( m: _m )
    }

    /// public static java.util.SortedSet java.util.Collections.unmodifiableSortedSet(java.util.SortedSet)

    private static var unmodifiableSortedSet_MethodID_66: jmethodID?

    open class func unmodifiableSortedSet( s: SortedSet? ) -> SortedSet! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: s, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "unmodifiableSortedSet", methodSig: "(Ljava/util/SortedSet;)Ljava/util/SortedSet;", methodCache: &unmodifiableSortedSet_MethodID_66, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? SortedSetForward( javaObject: __return ) : nil
    }

    open class func unmodifiableSortedSet( _ _s: SortedSet? ) -> SortedSet! {
        return unmodifiableSortedSet( s: _s )
    }

    /// static java.lang.Object[] java.util.Collections.zeroLengthArray(java.lang.Class)

    // Skipping method: true false false false false 

}

