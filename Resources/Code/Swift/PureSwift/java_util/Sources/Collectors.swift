
import java_swift
import java_lang

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// class java.util.stream.Collectors ///

open class Collectors: java_swift.JavaObject {

    public convenience init?( casting object: java_swift.JavaObject, _ file: StaticString = #file, _ line: Int = #line ) {
        self.init( javaObject: nil )
        object.withJavaObject {
            self.javaObject = $0
        }
    }

    private static var CollectorsJNIClass: jclass?

    /// static final java.util.Set java.util.stream.Collectors.CH_CONCURRENT_ID

    // Skipping field: true false false false false false 

    /// static final java.util.Set java.util.stream.Collectors.CH_CONCURRENT_NOID

    // Skipping field: true false false false false false 

    /// static final java.util.Set java.util.stream.Collectors.CH_ID

    // Skipping field: true false false false false false 

    /// static final java.util.Set java.util.stream.Collectors.CH_NOID

    // Skipping field: true false false false false false 

    /// static final java.util.Set java.util.stream.Collectors.CH_UNORDERED_ID

    // Skipping field: true false false false false false 

    /// private java.util.stream.Collectors()

    /// static java.util.function.Function java.util.stream.Collectors.access$000()

    // Skipping method: true false false false false 

    /// public static java.util.stream.Collector java.util.stream.Collectors.averagingDouble(java.util.function.ToDoubleFunction)

    private static var averagingDouble_MethodID_1: jmethodID?

    open class func averagingDouble( mapper: ToDoubleFunction? ) -> Collector! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: mapper, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Collectors", classCache: &CollectorsJNIClass, methodName: "averagingDouble", methodSig: "(Ljava/util/function/ToDoubleFunction;)Ljava/util/stream/Collector;", methodCache: &averagingDouble_MethodID_1, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectorForward( javaObject: __return ) : nil
    }

    open class func averagingDouble( _ _mapper: ToDoubleFunction? ) -> Collector! {
        return averagingDouble( mapper: _mapper )
    }

    /// public static java.util.stream.Collector java.util.stream.Collectors.averagingInt(java.util.function.ToIntFunction)

    private static var averagingInt_MethodID_2: jmethodID?

    open class func averagingInt( mapper: ToIntFunction? ) -> Collector! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: mapper, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Collectors", classCache: &CollectorsJNIClass, methodName: "averagingInt", methodSig: "(Ljava/util/function/ToIntFunction;)Ljava/util/stream/Collector;", methodCache: &averagingInt_MethodID_2, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectorForward( javaObject: __return ) : nil
    }

    open class func averagingInt( _ _mapper: ToIntFunction? ) -> Collector! {
        return averagingInt( mapper: _mapper )
    }

    /// public static java.util.stream.Collector java.util.stream.Collectors.averagingLong(java.util.function.ToLongFunction)

    private static var averagingLong_MethodID_3: jmethodID?

    open class func averagingLong( mapper: ToLongFunction? ) -> Collector! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: mapper, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Collectors", classCache: &CollectorsJNIClass, methodName: "averagingLong", methodSig: "(Ljava/util/function/ToLongFunction;)Ljava/util/stream/Collector;", methodCache: &averagingLong_MethodID_3, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectorForward( javaObject: __return ) : nil
    }

    open class func averagingLong( _ _mapper: ToLongFunction? ) -> Collector! {
        return averagingLong( mapper: _mapper )
    }

    /// private static java.util.function.Supplier java.util.stream.Collectors.boxSupplier(java.lang.Object)

    /// private static java.util.function.Function java.util.stream.Collectors.castingIdentity()

    /// public static java.util.stream.Collector java.util.stream.Collectors.collectingAndThen(java.util.stream.Collector,java.util.function.Function)

    private static var collectingAndThen_MethodID_4: jmethodID?

    open class func collectingAndThen( downstream: Collector?, finisher: Function? ) -> Collector! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: downstream, locals: &__locals )
        __args[1] = JNIType.toJava( value: finisher, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Collectors", classCache: &CollectorsJNIClass, methodName: "collectingAndThen", methodSig: "(Ljava/util/stream/Collector;Ljava/util/function/Function;)Ljava/util/stream/Collector;", methodCache: &collectingAndThen_MethodID_4, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectorForward( javaObject: __return ) : nil
    }

    open class func collectingAndThen( _ _downstream: Collector?, _ _finisher: Function? ) -> Collector! {
        return collectingAndThen( downstream: _downstream, finisher: _finisher )
    }

    /// static double java.util.stream.Collectors.computeFinalSum(double[])

    // Skipping method: true false false false false 

    /// public static java.util.stream.Collector java.util.stream.Collectors.counting()

    private static var counting_MethodID_5: jmethodID?

    open class func counting() -> Collector! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Collectors", classCache: &CollectorsJNIClass, methodName: "counting", methodSig: "()Ljava/util/stream/Collector;", methodCache: &counting_MethodID_5, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectorForward( javaObject: __return ) : nil
    }


    /// public static java.util.stream.Collector java.util.stream.Collectors.groupingBy(java.util.function.Function)

    private static var groupingBy_MethodID_6: jmethodID?

    open class func groupingBy( classifier: Function? ) -> Collector! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: classifier, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Collectors", classCache: &CollectorsJNIClass, methodName: "groupingBy", methodSig: "(Ljava/util/function/Function;)Ljava/util/stream/Collector;", methodCache: &groupingBy_MethodID_6, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectorForward( javaObject: __return ) : nil
    }

    open class func groupingBy( _ _classifier: Function? ) -> Collector! {
        return groupingBy( classifier: _classifier )
    }

    /// public static java.util.stream.Collector java.util.stream.Collectors.groupingBy(java.util.function.Function,java.util.stream.Collector)

    private static var groupingBy_MethodID_7: jmethodID?

    open class func groupingBy( classifier: Function?, downstream: Collector? ) -> Collector! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: classifier, locals: &__locals )
        __args[1] = JNIType.toJava( value: downstream, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Collectors", classCache: &CollectorsJNIClass, methodName: "groupingBy", methodSig: "(Ljava/util/function/Function;Ljava/util/stream/Collector;)Ljava/util/stream/Collector;", methodCache: &groupingBy_MethodID_7, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectorForward( javaObject: __return ) : nil
    }

    open class func groupingBy( _ _classifier: Function?, _ _downstream: Collector? ) -> Collector! {
        return groupingBy( classifier: _classifier, downstream: _downstream )
    }

    /// public static java.util.stream.Collector java.util.stream.Collectors.groupingBy(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)

    private static var groupingBy_MethodID_8: jmethodID?

    open class func groupingBy( classifier: Function?, mapFactory: Supplier?, downstream: Collector? ) -> Collector! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: classifier, locals: &__locals )
        __args[1] = JNIType.toJava( value: mapFactory, locals: &__locals )
        __args[2] = JNIType.toJava( value: downstream, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Collectors", classCache: &CollectorsJNIClass, methodName: "groupingBy", methodSig: "(Ljava/util/function/Function;Ljava/util/function/Supplier;Ljava/util/stream/Collector;)Ljava/util/stream/Collector;", methodCache: &groupingBy_MethodID_8, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectorForward( javaObject: __return ) : nil
    }

    open class func groupingBy( _ _classifier: Function?, _ _mapFactory: Supplier?, _ _downstream: Collector? ) -> Collector! {
        return groupingBy( classifier: _classifier, mapFactory: _mapFactory, downstream: _downstream )
    }

    /// public static java.util.stream.Collector java.util.stream.Collectors.groupingByConcurrent(java.util.function.Function)

    private static var groupingByConcurrent_MethodID_9: jmethodID?

    open class func groupingByConcurrent( classifier: Function? ) -> Collector! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: classifier, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Collectors", classCache: &CollectorsJNIClass, methodName: "groupingByConcurrent", methodSig: "(Ljava/util/function/Function;)Ljava/util/stream/Collector;", methodCache: &groupingByConcurrent_MethodID_9, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectorForward( javaObject: __return ) : nil
    }

    open class func groupingByConcurrent( _ _classifier: Function? ) -> Collector! {
        return groupingByConcurrent( classifier: _classifier )
    }

    /// public static java.util.stream.Collector java.util.stream.Collectors.groupingByConcurrent(java.util.function.Function,java.util.stream.Collector)

    private static var groupingByConcurrent_MethodID_10: jmethodID?

    open class func groupingByConcurrent( classifier: Function?, downstream: Collector? ) -> Collector! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: classifier, locals: &__locals )
        __args[1] = JNIType.toJava( value: downstream, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Collectors", classCache: &CollectorsJNIClass, methodName: "groupingByConcurrent", methodSig: "(Ljava/util/function/Function;Ljava/util/stream/Collector;)Ljava/util/stream/Collector;", methodCache: &groupingByConcurrent_MethodID_10, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectorForward( javaObject: __return ) : nil
    }

    open class func groupingByConcurrent( _ _classifier: Function?, _ _downstream: Collector? ) -> Collector! {
        return groupingByConcurrent( classifier: _classifier, downstream: _downstream )
    }

    /// public static java.util.stream.Collector java.util.stream.Collectors.groupingByConcurrent(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)

    private static var groupingByConcurrent_MethodID_11: jmethodID?

    open class func groupingByConcurrent( classifier: Function?, mapFactory: Supplier?, downstream: Collector? ) -> Collector! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: classifier, locals: &__locals )
        __args[1] = JNIType.toJava( value: mapFactory, locals: &__locals )
        __args[2] = JNIType.toJava( value: downstream, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Collectors", classCache: &CollectorsJNIClass, methodName: "groupingByConcurrent", methodSig: "(Ljava/util/function/Function;Ljava/util/function/Supplier;Ljava/util/stream/Collector;)Ljava/util/stream/Collector;", methodCache: &groupingByConcurrent_MethodID_11, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectorForward( javaObject: __return ) : nil
    }

    open class func groupingByConcurrent( _ _classifier: Function?, _ _mapFactory: Supplier?, _ _downstream: Collector? ) -> Collector! {
        return groupingByConcurrent( classifier: _classifier, mapFactory: _mapFactory, downstream: _downstream )
    }

    /// public static java.util.stream.Collector java.util.stream.Collectors.joining(java.lang.CharSequence)

    private static var joining_MethodID_12: jmethodID?

    open class func joining( delimiter: java_lang.CharSequence? ) -> Collector! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: delimiter, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Collectors", classCache: &CollectorsJNIClass, methodName: "joining", methodSig: "(Ljava/lang/CharSequence;)Ljava/util/stream/Collector;", methodCache: &joining_MethodID_12, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectorForward( javaObject: __return ) : nil
    }

    open class func joining( _ _delimiter: java_lang.CharSequence? ) -> Collector! {
        return joining( delimiter: _delimiter )
    }

    /// public static java.util.stream.Collector java.util.stream.Collectors.joining(java.lang.CharSequence,java.lang.CharSequence,java.lang.CharSequence)

    private static var joining_MethodID_13: jmethodID?

    open class func joining( delimiter: java_lang.CharSequence?, prefix: java_lang.CharSequence?, suffix: java_lang.CharSequence? ) -> Collector! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: delimiter, locals: &__locals )
        __args[1] = JNIType.toJava( value: prefix, locals: &__locals )
        __args[2] = JNIType.toJava( value: suffix, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Collectors", classCache: &CollectorsJNIClass, methodName: "joining", methodSig: "(Ljava/lang/CharSequence;Ljava/lang/CharSequence;Ljava/lang/CharSequence;)Ljava/util/stream/Collector;", methodCache: &joining_MethodID_13, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectorForward( javaObject: __return ) : nil
    }

    open class func joining( _ _delimiter: java_lang.CharSequence?, _ _prefix: java_lang.CharSequence?, _ _suffix: java_lang.CharSequence? ) -> Collector! {
        return joining( delimiter: _delimiter, prefix: _prefix, suffix: _suffix )
    }

    /// public static java.util.stream.Collector java.util.stream.Collectors.joining()

    private static var joining_MethodID_14: jmethodID?

    open class func joining() -> Collector! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Collectors", classCache: &CollectorsJNIClass, methodName: "joining", methodSig: "()Ljava/util/stream/Collector;", methodCache: &joining_MethodID_14, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectorForward( javaObject: __return ) : nil
    }


    /// private static double[] java.util.stream.Collectors.lambda$averagingDouble$30()

    /// private static void java.util.stream.Collectors.lambda$averagingDouble$31(java.util.function.ToDoubleFunction,double[],java.lang.Object)

    /// private static double[] java.util.stream.Collectors.lambda$averagingDouble$32(double[],double[])

    /// private static java.lang.Double java.util.stream.Collectors.lambda$averagingDouble$33(double[])

    /// private static long[] java.util.stream.Collectors.lambda$averagingInt$22()

    /// private static void java.util.stream.Collectors.lambda$averagingInt$23(java.util.function.ToIntFunction,long[],java.lang.Object)

    /// private static long[] java.util.stream.Collectors.lambda$averagingInt$24(long[],long[])

    /// private static java.lang.Double java.util.stream.Collectors.lambda$averagingInt$25(long[])

    /// private static long[] java.util.stream.Collectors.lambda$averagingLong$26()

    /// private static void java.util.stream.Collectors.lambda$averagingLong$27(java.util.function.ToLongFunction,long[],java.lang.Object)

    /// private static long[] java.util.stream.Collectors.lambda$averagingLong$28(long[],long[])

    /// private static java.lang.Double java.util.stream.Collectors.lambda$averagingLong$29(long[])

    /// private static java.lang.Object[] java.util.stream.Collectors.lambda$boxSupplier$37(java.lang.Object)

    /// private static java.lang.Object java.util.stream.Collectors.lambda$castingIdentity$1(java.lang.Object)

    /// private static java.lang.Long java.util.stream.Collectors.lambda$counting$9(java.lang.Object)

    /// private static void java.util.stream.Collectors.lambda$groupingByConcurrent$49(java.util.function.Function,java.util.function.Supplier,java.util.function.BiConsumer,java.util.concurrent.ConcurrentMap,java.lang.Object)

    /// private static void java.util.stream.Collectors.lambda$groupingByConcurrent$51(java.util.function.Function,java.util.function.Supplier,java.util.function.BiConsumer,java.util.concurrent.ConcurrentMap,java.lang.Object)

    /// private static java.util.concurrent.ConcurrentMap java.util.stream.Collectors.lambda$groupingByConcurrent$53(java.util.function.Function,java.util.concurrent.ConcurrentMap)

    /// private static void java.util.stream.Collectors.lambda$groupingBy$45(java.util.function.Function,java.util.function.Supplier,java.util.function.BiConsumer,java.util.Map,java.lang.Object)

    /// private static java.util.Map java.util.stream.Collectors.lambda$groupingBy$47(java.util.function.Function,java.util.Map)

    /// private static java.lang.StringBuilder java.util.stream.Collectors.lambda$joining$5(java.lang.StringBuilder,java.lang.StringBuilder)

    /// private static java.util.StringJoiner java.util.stream.Collectors.lambda$joining$6(java.lang.CharSequence,java.lang.CharSequence,java.lang.CharSequence)

    /// private static java.util.Map java.util.stream.Collectors.lambda$mapMerger$7(java.util.function.BinaryOperator,java.util.Map,java.util.Map)

    /// private static void java.util.stream.Collectors.lambda$mapping$8(java.util.function.BiConsumer,java.util.function.Function,java.lang.Object,java.lang.Object)

    /// private static java.lang.Object java.util.stream.Collectors.lambda$null$44(java.util.function.Supplier,java.lang.Object)

    /// private static java.lang.Object java.util.stream.Collectors.lambda$null$46(java.util.function.Function,java.lang.Object,java.lang.Object)

    /// private static java.lang.Object java.util.stream.Collectors.lambda$null$48(java.util.function.Supplier,java.lang.Object)

    /// private static java.lang.Object java.util.stream.Collectors.lambda$null$50(java.util.function.Supplier,java.lang.Object)

    /// private static java.lang.Object java.util.stream.Collectors.lambda$null$52(java.util.function.Function,java.lang.Object,java.lang.Object)

    /// private static void java.util.stream.Collectors.lambda$partitioningBy$54(java.util.function.BiConsumer,java.util.function.Predicate,java.util.stream.Collectors$Partition,java.lang.Object)

    /// private static java.util.stream.Collectors$Partition java.util.stream.Collectors.lambda$partitioningBy$55(java.util.function.BinaryOperator,java.util.stream.Collectors$Partition,java.util.stream.Collectors$Partition)

    /// private static java.util.stream.Collectors$Partition java.util.stream.Collectors.lambda$partitioningBy$56(java.util.stream.Collector)

    /// private static java.util.Map java.util.stream.Collectors.lambda$partitioningBy$57(java.util.stream.Collector,java.util.stream.Collectors$Partition)

    /// private static void java.util.stream.Collectors.lambda$reducing$34(java.util.function.BinaryOperator,java.lang.Object[],java.lang.Object)

    /// private static java.lang.Object[] java.util.stream.Collectors.lambda$reducing$35(java.util.function.BinaryOperator,java.lang.Object[],java.lang.Object[])

    /// private static java.lang.Object java.util.stream.Collectors.lambda$reducing$36(java.lang.Object[])

    /// private static java.util.stream.Collectors$1OptionalBox java.util.stream.Collectors.lambda$reducing$38(java.util.function.BinaryOperator)

    /// private static java.util.stream.Collectors$1OptionalBox java.util.stream.Collectors.lambda$reducing$39(java.util.stream.Collectors$1OptionalBox,java.util.stream.Collectors$1OptionalBox)

    /// private static java.util.Optional java.util.stream.Collectors.lambda$reducing$40(java.util.stream.Collectors$1OptionalBox)

    /// private static void java.util.stream.Collectors.lambda$reducing$41(java.util.function.BinaryOperator,java.util.function.Function,java.lang.Object[],java.lang.Object)

    /// private static java.lang.Object[] java.util.stream.Collectors.lambda$reducing$42(java.util.function.BinaryOperator,java.lang.Object[],java.lang.Object[])

    /// private static java.lang.Object java.util.stream.Collectors.lambda$reducing$43(java.lang.Object[])

    /// private static void java.util.stream.Collectors.lambda$summarizingDouble$64(java.util.function.ToDoubleFunction,java.util.DoubleSummaryStatistics,java.lang.Object)

    /// private static java.util.DoubleSummaryStatistics java.util.stream.Collectors.lambda$summarizingDouble$65(java.util.DoubleSummaryStatistics,java.util.DoubleSummaryStatistics)

    /// private static void java.util.stream.Collectors.lambda$summarizingInt$60(java.util.function.ToIntFunction,java.util.IntSummaryStatistics,java.lang.Object)

    /// private static java.util.IntSummaryStatistics java.util.stream.Collectors.lambda$summarizingInt$61(java.util.IntSummaryStatistics,java.util.IntSummaryStatistics)

    /// private static void java.util.stream.Collectors.lambda$summarizingLong$62(java.util.function.ToLongFunction,java.util.LongSummaryStatistics,java.lang.Object)

    /// private static java.util.LongSummaryStatistics java.util.stream.Collectors.lambda$summarizingLong$63(java.util.LongSummaryStatistics,java.util.LongSummaryStatistics)

    /// private static double[] java.util.stream.Collectors.lambda$summingDouble$18()

    /// private static void java.util.stream.Collectors.lambda$summingDouble$19(java.util.function.ToDoubleFunction,double[],java.lang.Object)

    /// private static double[] java.util.stream.Collectors.lambda$summingDouble$20(double[],double[])

    /// private static java.lang.Double java.util.stream.Collectors.lambda$summingDouble$21(double[])

    /// private static int[] java.util.stream.Collectors.lambda$summingInt$10()

    /// private static void java.util.stream.Collectors.lambda$summingInt$11(java.util.function.ToIntFunction,int[],java.lang.Object)

    /// private static int[] java.util.stream.Collectors.lambda$summingInt$12(int[],int[])

    /// private static java.lang.Integer java.util.stream.Collectors.lambda$summingInt$13(int[])

    /// private static long[] java.util.stream.Collectors.lambda$summingLong$14()

    /// private static void java.util.stream.Collectors.lambda$summingLong$15(java.util.function.ToLongFunction,long[],java.lang.Object)

    /// private static long[] java.util.stream.Collectors.lambda$summingLong$16(long[],long[])

    /// private static java.lang.Long java.util.stream.Collectors.lambda$summingLong$17(long[])

    /// private static java.lang.Object java.util.stream.Collectors.lambda$throwingMerger$0(java.lang.Object,java.lang.Object)

    /// private static java.util.Collection java.util.stream.Collectors.lambda$toCollection$2(java.util.Collection,java.util.Collection)

    /// private static void java.util.stream.Collectors.lambda$toConcurrentMap$59(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.concurrent.ConcurrentMap,java.lang.Object)

    /// private static java.util.List java.util.stream.Collectors.lambda$toList$3(java.util.List,java.util.List)

    /// private static void java.util.stream.Collectors.lambda$toMap$58(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.Map,java.lang.Object)

    /// private static java.util.Set java.util.stream.Collectors.lambda$toSet$4(java.util.Set,java.util.Set)

    /// private static java.util.function.BinaryOperator java.util.stream.Collectors.mapMerger(java.util.function.BinaryOperator)

    /// public static java.util.stream.Collector java.util.stream.Collectors.mapping(java.util.function.Function,java.util.stream.Collector)

    private static var mapping_MethodID_15: jmethodID?

    open class func mapping( mapper: Function?, downstream: Collector? ) -> Collector! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: mapper, locals: &__locals )
        __args[1] = JNIType.toJava( value: downstream, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Collectors", classCache: &CollectorsJNIClass, methodName: "mapping", methodSig: "(Ljava/util/function/Function;Ljava/util/stream/Collector;)Ljava/util/stream/Collector;", methodCache: &mapping_MethodID_15, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectorForward( javaObject: __return ) : nil
    }

    open class func mapping( _ _mapper: Function?, _ _downstream: Collector? ) -> Collector! {
        return mapping( mapper: _mapper, downstream: _downstream )
    }

    /// public static java.util.stream.Collector java.util.stream.Collectors.maxBy(java.util.Comparator)

    private static var maxBy_MethodID_16: jmethodID?

    open class func maxBy( comparator: JavaComparator? ) -> Collector! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: comparator, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Collectors", classCache: &CollectorsJNIClass, methodName: "maxBy", methodSig: "(Ljava/util/Comparator;)Ljava/util/stream/Collector;", methodCache: &maxBy_MethodID_16, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectorForward( javaObject: __return ) : nil
    }

    open class func maxBy( _ _comparator: JavaComparator? ) -> Collector! {
        return maxBy( comparator: _comparator )
    }

    /// public static java.util.stream.Collector java.util.stream.Collectors.minBy(java.util.Comparator)

    private static var minBy_MethodID_17: jmethodID?

    open class func minBy( comparator: JavaComparator? ) -> Collector! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: comparator, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Collectors", classCache: &CollectorsJNIClass, methodName: "minBy", methodSig: "(Ljava/util/Comparator;)Ljava/util/stream/Collector;", methodCache: &minBy_MethodID_17, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectorForward( javaObject: __return ) : nil
    }

    open class func minBy( _ _comparator: JavaComparator? ) -> Collector! {
        return minBy( comparator: _comparator )
    }

    /// public static java.util.stream.Collector java.util.stream.Collectors.partitioningBy(java.util.function.Predicate)

    private static var partitioningBy_MethodID_18: jmethodID?

    open class func partitioningBy( predicate: Predicate? ) -> Collector! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: predicate, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Collectors", classCache: &CollectorsJNIClass, methodName: "partitioningBy", methodSig: "(Ljava/util/function/Predicate;)Ljava/util/stream/Collector;", methodCache: &partitioningBy_MethodID_18, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectorForward( javaObject: __return ) : nil
    }

    open class func partitioningBy( _ _predicate: Predicate? ) -> Collector! {
        return partitioningBy( predicate: _predicate )
    }

    /// public static java.util.stream.Collector java.util.stream.Collectors.partitioningBy(java.util.function.Predicate,java.util.stream.Collector)

    private static var partitioningBy_MethodID_19: jmethodID?

    open class func partitioningBy( predicate: Predicate?, downstream: Collector? ) -> Collector! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: predicate, locals: &__locals )
        __args[1] = JNIType.toJava( value: downstream, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Collectors", classCache: &CollectorsJNIClass, methodName: "partitioningBy", methodSig: "(Ljava/util/function/Predicate;Ljava/util/stream/Collector;)Ljava/util/stream/Collector;", methodCache: &partitioningBy_MethodID_19, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectorForward( javaObject: __return ) : nil
    }

    open class func partitioningBy( _ _predicate: Predicate?, _ _downstream: Collector? ) -> Collector! {
        return partitioningBy( predicate: _predicate, downstream: _downstream )
    }

    /// public static java.util.stream.Collector java.util.stream.Collectors.reducing(java.util.function.BinaryOperator)

    private static var reducing_MethodID_20: jmethodID?

    open class func reducing( op: BinaryOperator? ) -> Collector! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: op, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Collectors", classCache: &CollectorsJNIClass, methodName: "reducing", methodSig: "(Ljava/util/function/BinaryOperator;)Ljava/util/stream/Collector;", methodCache: &reducing_MethodID_20, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectorForward( javaObject: __return ) : nil
    }

    open class func reducing( _ _op: BinaryOperator? ) -> Collector! {
        return reducing( op: _op )
    }

    /// public static java.util.stream.Collector java.util.stream.Collectors.reducing(java.lang.Object,java.util.function.BinaryOperator)

    private static var reducing_MethodID_21: jmethodID?

    open class func reducing( identity: java_swift.JavaObject?, op: BinaryOperator? ) -> Collector! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: identity, locals: &__locals )
        __args[1] = JNIType.toJava( value: op, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Collectors", classCache: &CollectorsJNIClass, methodName: "reducing", methodSig: "(Ljava/lang/Object;Ljava/util/function/BinaryOperator;)Ljava/util/stream/Collector;", methodCache: &reducing_MethodID_21, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectorForward( javaObject: __return ) : nil
    }

    open class func reducing( _ _identity: java_swift.JavaObject?, _ _op: BinaryOperator? ) -> Collector! {
        return reducing( identity: _identity, op: _op )
    }

    /// public static java.util.stream.Collector java.util.stream.Collectors.reducing(java.lang.Object,java.util.function.Function,java.util.function.BinaryOperator)

    private static var reducing_MethodID_22: jmethodID?

    open class func reducing( identity: java_swift.JavaObject?, mapper: Function?, op: BinaryOperator? ) -> Collector! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: identity, locals: &__locals )
        __args[1] = JNIType.toJava( value: mapper, locals: &__locals )
        __args[2] = JNIType.toJava( value: op, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Collectors", classCache: &CollectorsJNIClass, methodName: "reducing", methodSig: "(Ljava/lang/Object;Ljava/util/function/Function;Ljava/util/function/BinaryOperator;)Ljava/util/stream/Collector;", methodCache: &reducing_MethodID_22, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectorForward( javaObject: __return ) : nil
    }

    open class func reducing( _ _identity: java_swift.JavaObject?, _ _mapper: Function?, _ _op: BinaryOperator? ) -> Collector! {
        return reducing( identity: _identity, mapper: _mapper, op: _op )
    }

    /// static double[] java.util.stream.Collectors.sumWithCompensation(double[],double)

    // Skipping method: true false false false false 

    /// public static java.util.stream.Collector java.util.stream.Collectors.summarizingDouble(java.util.function.ToDoubleFunction)

    private static var summarizingDouble_MethodID_23: jmethodID?

    open class func summarizingDouble( mapper: ToDoubleFunction? ) -> Collector! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: mapper, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Collectors", classCache: &CollectorsJNIClass, methodName: "summarizingDouble", methodSig: "(Ljava/util/function/ToDoubleFunction;)Ljava/util/stream/Collector;", methodCache: &summarizingDouble_MethodID_23, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectorForward( javaObject: __return ) : nil
    }

    open class func summarizingDouble( _ _mapper: ToDoubleFunction? ) -> Collector! {
        return summarizingDouble( mapper: _mapper )
    }

    /// public static java.util.stream.Collector java.util.stream.Collectors.summarizingInt(java.util.function.ToIntFunction)

    private static var summarizingInt_MethodID_24: jmethodID?

    open class func summarizingInt( mapper: ToIntFunction? ) -> Collector! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: mapper, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Collectors", classCache: &CollectorsJNIClass, methodName: "summarizingInt", methodSig: "(Ljava/util/function/ToIntFunction;)Ljava/util/stream/Collector;", methodCache: &summarizingInt_MethodID_24, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectorForward( javaObject: __return ) : nil
    }

    open class func summarizingInt( _ _mapper: ToIntFunction? ) -> Collector! {
        return summarizingInt( mapper: _mapper )
    }

    /// public static java.util.stream.Collector java.util.stream.Collectors.summarizingLong(java.util.function.ToLongFunction)

    private static var summarizingLong_MethodID_25: jmethodID?

    open class func summarizingLong( mapper: ToLongFunction? ) -> Collector! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: mapper, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Collectors", classCache: &CollectorsJNIClass, methodName: "summarizingLong", methodSig: "(Ljava/util/function/ToLongFunction;)Ljava/util/stream/Collector;", methodCache: &summarizingLong_MethodID_25, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectorForward( javaObject: __return ) : nil
    }

    open class func summarizingLong( _ _mapper: ToLongFunction? ) -> Collector! {
        return summarizingLong( mapper: _mapper )
    }

    /// public static java.util.stream.Collector java.util.stream.Collectors.summingDouble(java.util.function.ToDoubleFunction)

    private static var summingDouble_MethodID_26: jmethodID?

    open class func summingDouble( mapper: ToDoubleFunction? ) -> Collector! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: mapper, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Collectors", classCache: &CollectorsJNIClass, methodName: "summingDouble", methodSig: "(Ljava/util/function/ToDoubleFunction;)Ljava/util/stream/Collector;", methodCache: &summingDouble_MethodID_26, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectorForward( javaObject: __return ) : nil
    }

    open class func summingDouble( _ _mapper: ToDoubleFunction? ) -> Collector! {
        return summingDouble( mapper: _mapper )
    }

    /// public static java.util.stream.Collector java.util.stream.Collectors.summingInt(java.util.function.ToIntFunction)

    private static var summingInt_MethodID_27: jmethodID?

    open class func summingInt( mapper: ToIntFunction? ) -> Collector! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: mapper, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Collectors", classCache: &CollectorsJNIClass, methodName: "summingInt", methodSig: "(Ljava/util/function/ToIntFunction;)Ljava/util/stream/Collector;", methodCache: &summingInt_MethodID_27, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectorForward( javaObject: __return ) : nil
    }

    open class func summingInt( _ _mapper: ToIntFunction? ) -> Collector! {
        return summingInt( mapper: _mapper )
    }

    /// public static java.util.stream.Collector java.util.stream.Collectors.summingLong(java.util.function.ToLongFunction)

    private static var summingLong_MethodID_28: jmethodID?

    open class func summingLong( mapper: ToLongFunction? ) -> Collector! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: mapper, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Collectors", classCache: &CollectorsJNIClass, methodName: "summingLong", methodSig: "(Ljava/util/function/ToLongFunction;)Ljava/util/stream/Collector;", methodCache: &summingLong_MethodID_28, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectorForward( javaObject: __return ) : nil
    }

    open class func summingLong( _ _mapper: ToLongFunction? ) -> Collector! {
        return summingLong( mapper: _mapper )
    }

    /// private static java.util.function.BinaryOperator java.util.stream.Collectors.throwingMerger()

    /// public static java.util.stream.Collector java.util.stream.Collectors.toCollection(java.util.function.Supplier)

    private static var toCollection_MethodID_29: jmethodID?

    open class func toCollection( collectionFactory: Supplier? ) -> Collector! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: collectionFactory, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Collectors", classCache: &CollectorsJNIClass, methodName: "toCollection", methodSig: "(Ljava/util/function/Supplier;)Ljava/util/stream/Collector;", methodCache: &toCollection_MethodID_29, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectorForward( javaObject: __return ) : nil
    }

    open class func toCollection( _ _collectionFactory: Supplier? ) -> Collector! {
        return toCollection( collectionFactory: _collectionFactory )
    }

    /// public static java.util.stream.Collector java.util.stream.Collectors.toConcurrentMap(java.util.function.Function,java.util.function.Function)

    private static var toConcurrentMap_MethodID_30: jmethodID?

    open class func toConcurrentMap( keyMapper: Function?, valueMapper: Function? ) -> Collector! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: keyMapper, locals: &__locals )
        __args[1] = JNIType.toJava( value: valueMapper, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Collectors", classCache: &CollectorsJNIClass, methodName: "toConcurrentMap", methodSig: "(Ljava/util/function/Function;Ljava/util/function/Function;)Ljava/util/stream/Collector;", methodCache: &toConcurrentMap_MethodID_30, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectorForward( javaObject: __return ) : nil
    }

    open class func toConcurrentMap( _ _keyMapper: Function?, _ _valueMapper: Function? ) -> Collector! {
        return toConcurrentMap( keyMapper: _keyMapper, valueMapper: _valueMapper )
    }

    /// public static java.util.stream.Collector java.util.stream.Collectors.toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)

    private static var toConcurrentMap_MethodID_31: jmethodID?

    open class func toConcurrentMap( keyMapper: Function?, valueMapper: Function?, mergeFunction: BinaryOperator? ) -> Collector! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: keyMapper, locals: &__locals )
        __args[1] = JNIType.toJava( value: valueMapper, locals: &__locals )
        __args[2] = JNIType.toJava( value: mergeFunction, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Collectors", classCache: &CollectorsJNIClass, methodName: "toConcurrentMap", methodSig: "(Ljava/util/function/Function;Ljava/util/function/Function;Ljava/util/function/BinaryOperator;)Ljava/util/stream/Collector;", methodCache: &toConcurrentMap_MethodID_31, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectorForward( javaObject: __return ) : nil
    }

    open class func toConcurrentMap( _ _keyMapper: Function?, _ _valueMapper: Function?, _ _mergeFunction: BinaryOperator? ) -> Collector! {
        return toConcurrentMap( keyMapper: _keyMapper, valueMapper: _valueMapper, mergeFunction: _mergeFunction )
    }

    /// public static java.util.stream.Collector java.util.stream.Collectors.toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)

    private static var toConcurrentMap_MethodID_32: jmethodID?

    open class func toConcurrentMap( keyMapper: Function?, valueMapper: Function?, mergeFunction: BinaryOperator?, mapSupplier: Supplier? ) -> Collector! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        __args[0] = JNIType.toJava( value: keyMapper, locals: &__locals )
        __args[1] = JNIType.toJava( value: valueMapper, locals: &__locals )
        __args[2] = JNIType.toJava( value: mergeFunction, locals: &__locals )
        __args[3] = JNIType.toJava( value: mapSupplier, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Collectors", classCache: &CollectorsJNIClass, methodName: "toConcurrentMap", methodSig: "(Ljava/util/function/Function;Ljava/util/function/Function;Ljava/util/function/BinaryOperator;Ljava/util/function/Supplier;)Ljava/util/stream/Collector;", methodCache: &toConcurrentMap_MethodID_32, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectorForward( javaObject: __return ) : nil
    }

    open class func toConcurrentMap( _ _keyMapper: Function?, _ _valueMapper: Function?, _ _mergeFunction: BinaryOperator?, _ _mapSupplier: Supplier? ) -> Collector! {
        return toConcurrentMap( keyMapper: _keyMapper, valueMapper: _valueMapper, mergeFunction: _mergeFunction, mapSupplier: _mapSupplier )
    }

    /// public static java.util.stream.Collector java.util.stream.Collectors.toList()

    private static var toList_MethodID_33: jmethodID?

    open class func toList() -> Collector! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Collectors", classCache: &CollectorsJNIClass, methodName: "toList", methodSig: "()Ljava/util/stream/Collector;", methodCache: &toList_MethodID_33, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectorForward( javaObject: __return ) : nil
    }


    /// public static java.util.stream.Collector java.util.stream.Collectors.toMap(java.util.function.Function,java.util.function.Function)

    private static var toMap_MethodID_34: jmethodID?

    open class func toMap( keyMapper: Function?, valueMapper: Function? ) -> Collector! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: keyMapper, locals: &__locals )
        __args[1] = JNIType.toJava( value: valueMapper, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Collectors", classCache: &CollectorsJNIClass, methodName: "toMap", methodSig: "(Ljava/util/function/Function;Ljava/util/function/Function;)Ljava/util/stream/Collector;", methodCache: &toMap_MethodID_34, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectorForward( javaObject: __return ) : nil
    }

    open class func toMap( _ _keyMapper: Function?, _ _valueMapper: Function? ) -> Collector! {
        return toMap( keyMapper: _keyMapper, valueMapper: _valueMapper )
    }

    /// public static java.util.stream.Collector java.util.stream.Collectors.toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)

    private static var toMap_MethodID_35: jmethodID?

    open class func toMap( keyMapper: Function?, valueMapper: Function?, mergeFunction: BinaryOperator? ) -> Collector! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: keyMapper, locals: &__locals )
        __args[1] = JNIType.toJava( value: valueMapper, locals: &__locals )
        __args[2] = JNIType.toJava( value: mergeFunction, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Collectors", classCache: &CollectorsJNIClass, methodName: "toMap", methodSig: "(Ljava/util/function/Function;Ljava/util/function/Function;Ljava/util/function/BinaryOperator;)Ljava/util/stream/Collector;", methodCache: &toMap_MethodID_35, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectorForward( javaObject: __return ) : nil
    }

    open class func toMap( _ _keyMapper: Function?, _ _valueMapper: Function?, _ _mergeFunction: BinaryOperator? ) -> Collector! {
        return toMap( keyMapper: _keyMapper, valueMapper: _valueMapper, mergeFunction: _mergeFunction )
    }

    /// public static java.util.stream.Collector java.util.stream.Collectors.toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)

    private static var toMap_MethodID_36: jmethodID?

    open class func toMap( keyMapper: Function?, valueMapper: Function?, mergeFunction: BinaryOperator?, mapSupplier: Supplier? ) -> Collector! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        __args[0] = JNIType.toJava( value: keyMapper, locals: &__locals )
        __args[1] = JNIType.toJava( value: valueMapper, locals: &__locals )
        __args[2] = JNIType.toJava( value: mergeFunction, locals: &__locals )
        __args[3] = JNIType.toJava( value: mapSupplier, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Collectors", classCache: &CollectorsJNIClass, methodName: "toMap", methodSig: "(Ljava/util/function/Function;Ljava/util/function/Function;Ljava/util/function/BinaryOperator;Ljava/util/function/Supplier;)Ljava/util/stream/Collector;", methodCache: &toMap_MethodID_36, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectorForward( javaObject: __return ) : nil
    }

    open class func toMap( _ _keyMapper: Function?, _ _valueMapper: Function?, _ _mergeFunction: BinaryOperator?, _ _mapSupplier: Supplier? ) -> Collector! {
        return toMap( keyMapper: _keyMapper, valueMapper: _valueMapper, mergeFunction: _mergeFunction, mapSupplier: _mapSupplier )
    }

    /// public static java.util.stream.Collector java.util.stream.Collectors.toSet()

    private static var toSet_MethodID_37: jmethodID?

    open class func toSet() -> Collector! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/stream/Collectors", classCache: &CollectorsJNIClass, methodName: "toSet", methodSig: "()Ljava/util/stream/Collector;", methodCache: &toSet_MethodID_37, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectorForward( javaObject: __return ) : nil
    }


}

