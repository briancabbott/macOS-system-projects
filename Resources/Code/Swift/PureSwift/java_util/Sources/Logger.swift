
import java_swift
import java_lang

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// class java.util.logging.Logger ///

open class Logger: java_swift.JavaObject {

    public convenience init?( casting object: java_swift.JavaObject, _ file: StaticString = #file, _ line: Int = #line ) {
        self.init( javaObject: nil )
        object.withJavaObject {
            self.javaObject = $0
        }
    }

    private static var LoggerJNIClass: jclass?

    /// static final boolean java.util.logging.Logger.$assertionsDisabled

    // Skipping field: true false false false false false 

    /// public static final java.lang.String java.util.logging.Logger.GLOBAL_LOGGER_NAME

    private static var GLOBAL_LOGGER_NAME_FieldID: jfieldID?

    public static var GLOBAL_LOGGER_NAME: String! {
        get {
            let __value = JNIField.GetStaticObjectField( fieldName: "GLOBAL_LOGGER_NAME", fieldType: "Ljava/lang/String;", fieldCache: &GLOBAL_LOGGER_NAME_FieldID, className: "java/util/logging/Logger", classCache: &LoggerJNIClass )
            defer { JNI.DeleteLocalRef( __value ) }
            return __value != nil ? String( javaObject: __value ) : nil
        }
    }

    /// private static final java.util.logging.Logger$LoggerBundle java.util.logging.Logger.NO_RESOURCE_BUNDLE

    /// private static final java.util.logging.Logger$LoggerBundle java.util.logging.Logger.SYSTEM_BUNDLE

    /// static final java.lang.String java.util.logging.Logger.SYSTEM_LOGGER_RB_NAME

    // Skipping field: true false false false false false 

    /// private static final java.util.logging.Handler[] java.util.logging.Logger.emptyHandlers

    /// public static final java.util.logging.Logger java.util.logging.Logger.global

    private static var global_FieldID: jfieldID?

    public static var global: Logger! {
        get {
            let __value = JNIField.GetStaticObjectField( fieldName: "global", fieldType: "Ljava/util/logging/Logger;", fieldCache: &global_FieldID, className: "java/util/logging/Logger", classCache: &LoggerJNIClass )
            defer { JNI.DeleteLocalRef( __value ) }
            return __value != nil ? Logger( javaObject: __value ) : nil
        }
    }

    /// private static final int java.util.logging.Logger.offValue

    /// private static final java.lang.Object java.util.logging.Logger.treeLock

    /// private boolean java.util.logging.Logger.anonymous

    /// private java.lang.ref.WeakReference java.util.logging.Logger.callersClassLoaderRef

    /// private java.util.ResourceBundle java.util.logging.Logger.catalog

    /// private java.util.Locale java.util.logging.Logger.catalogLocale

    /// private java.lang.String java.util.logging.Logger.catalogName

    /// private volatile java.util.logging.Filter java.util.logging.Logger.filter

    /// private final java.util.concurrent.CopyOnWriteArrayList java.util.logging.Logger.handlers

    /// private final boolean java.util.logging.Logger.isSystemLogger

    /// private java.util.ArrayList java.util.logging.Logger.kids

    /// private volatile java.util.logging.Level java.util.logging.Logger.levelObject

    /// private volatile int java.util.logging.Logger.levelValue

    /// private volatile java.util.logging.Logger$LoggerBundle java.util.logging.Logger.loggerBundle

    /// private volatile java.util.logging.LogManager java.util.logging.Logger.manager

    /// private java.lang.String java.util.logging.Logger.name

    /// private volatile java.util.logging.Logger java.util.logging.Logger.parent

    /// private volatile boolean java.util.logging.Logger.useParentHandlers

    /// private java.util.logging.Logger(java.lang.String)

    /// protected java.util.logging.Logger(java.lang.String,java.lang.String)

    private static var new_MethodID_1: jmethodID?

    public convenience init( name: String?, resourceBundleName: String? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: name, locals: &__locals )
        __args[1] = JNIType.toJava( value: resourceBundleName, locals: &__locals )
        let __object = JNIMethod.NewObject( className: "java/util/logging/Logger", classCache: &Logger.LoggerJNIClass, methodSig: "(Ljava/lang/String;Ljava/lang/String;)V", methodCache: &Logger.new_MethodID_1, args: &__args, locals: &__locals )
        self.init( javaObject: __object )
        JNI.DeleteLocalRef( __object )
    }

    public convenience init( _ _name: String?, _ _resourceBundleName: String? ) {
        self.init( name: _name, resourceBundleName: _resourceBundleName )
    }

    /// java.util.logging.Logger(java.lang.String,java.lang.String,java.lang.Class,java.util.logging.LogManager,boolean)

    // Skipping init: true false false 

    /// static java.util.logging.Logger$LoggerBundle java.util.logging.Logger.access$000()

    // Skipping method: true false false false false 

    /// static java.util.logging.Logger$LoggerBundle java.util.logging.Logger.access$100()

    // Skipping method: true false false false false 

    /// private static java.util.logging.Logger java.util.logging.Logger.demandLogger(java.lang.String,java.lang.String,java.lang.Class)

    /// private static java.util.ResourceBundle java.util.logging.Logger.findSystemResourceBundle(java.util.Locale)

    /// public static java.util.logging.Logger java.util.logging.Logger.getAnonymousLogger(java.lang.String)

    private static var getAnonymousLogger_MethodID_2: jmethodID?

    open class func getAnonymousLogger( resourceBundleName: String? ) -> Logger! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: resourceBundleName, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/logging/Logger", classCache: &LoggerJNIClass, methodName: "getAnonymousLogger", methodSig: "(Ljava/lang/String;)Ljava/util/logging/Logger;", methodCache: &getAnonymousLogger_MethodID_2, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? Logger( javaObject: __return ) : nil
    }

    open class func getAnonymousLogger( _ _resourceBundleName: String? ) -> Logger! {
        return getAnonymousLogger( resourceBundleName: _resourceBundleName )
    }

    /// public static java.util.logging.Logger java.util.logging.Logger.getAnonymousLogger()

    private static var getAnonymousLogger_MethodID_3: jmethodID?

    open class func getAnonymousLogger() -> Logger! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/logging/Logger", classCache: &LoggerJNIClass, methodName: "getAnonymousLogger", methodSig: "()Ljava/util/logging/Logger;", methodCache: &getAnonymousLogger_MethodID_3, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? Logger( javaObject: __return ) : nil
    }


    /// public static final java.util.logging.Logger java.util.logging.Logger.getGlobal()

    private static var getGlobal_MethodID_4: jmethodID?

    open class func getGlobal() -> Logger! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/logging/Logger", classCache: &LoggerJNIClass, methodName: "getGlobal", methodSig: "()Ljava/util/logging/Logger;", methodCache: &getGlobal_MethodID_4, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? Logger( javaObject: __return ) : nil
    }


    /// public static java.util.logging.Logger java.util.logging.Logger.getLogger(java.lang.String)

    private static var getLogger_MethodID_5: jmethodID?

    open class func getLogger( name: String? ) -> Logger! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: name, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/logging/Logger", classCache: &LoggerJNIClass, methodName: "getLogger", methodSig: "(Ljava/lang/String;)Ljava/util/logging/Logger;", methodCache: &getLogger_MethodID_5, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? Logger( javaObject: __return ) : nil
    }

    open class func getLogger( _ _name: String? ) -> Logger! {
        return getLogger( name: _name )
    }

    /// public static java.util.logging.Logger java.util.logging.Logger.getLogger(java.lang.String,java.lang.String)

    private static var getLogger_MethodID_6: jmethodID?

    open class func getLogger( name: String?, resourceBundleName: String? ) -> Logger! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: name, locals: &__locals )
        __args[1] = JNIType.toJava( value: resourceBundleName, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/logging/Logger", classCache: &LoggerJNIClass, methodName: "getLogger", methodSig: "(Ljava/lang/String;Ljava/lang/String;)Ljava/util/logging/Logger;", methodCache: &getLogger_MethodID_6, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? Logger( javaObject: __return ) : nil
    }

    open class func getLogger( _ _name: String?, _ _resourceBundleName: String? ) -> Logger! {
        return getLogger( name: _name, resourceBundleName: _resourceBundleName )
    }

    /// static java.util.logging.Logger java.util.logging.Logger.getPlatformLogger(java.lang.String)

    // Skipping method: true false false false false 

    /// java.util.logging.Handler[] java.util.logging.Logger.accessCheckedHandlers()

    // Skipping method: true false false false false 

    /// public void java.util.logging.Logger.addHandler(java.util.logging.Handler) throws java.lang.SecurityException

    private static var addHandler_MethodID_7: jmethodID?

    open func addHandler( handler: Handler? ) throws /* java.lang.SecurityException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: handler, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "addHandler", methodSig: "(Ljava/util/logging/Handler;)V", methodCache: &Logger.addHandler_MethodID_7, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw java_lang.JavaSecurityException( javaObject: throwable )
        }
    }

    open func addHandler( _ _handler: Handler? ) throws /* java.lang.SecurityException */ {
        try addHandler( handler: _handler )
    }

    /// private void java.util.logging.Logger.checkPermission() throws java.lang.SecurityException

    /// public void java.util.logging.Logger.config(java.lang.String)

    private static var config_MethodID_8: jmethodID?

    open func config( msg: String? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: msg, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "config", methodSig: "(Ljava/lang/String;)V", methodCache: &Logger.config_MethodID_8, args: &__args, locals: &__locals )
    }

    open func config( _ _msg: String? ) {
        config( msg: _msg )
    }

    /// public void java.util.logging.Logger.config(java.util.function.Supplier)

    private static var config_MethodID_9: jmethodID?

    open func config( msgSupplier: Supplier? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: msgSupplier, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "config", methodSig: "(Ljava/util/function/Supplier;)V", methodCache: &Logger.config_MethodID_9, args: &__args, locals: &__locals )
    }

    open func config( _ _msgSupplier: Supplier? ) {
        config( msgSupplier: _msgSupplier )
    }

    /// private void java.util.logging.Logger.doLog(java.util.logging.LogRecord)

    /// private void java.util.logging.Logger.doLog(java.util.logging.LogRecord,java.util.ResourceBundle)

    /// private void java.util.logging.Logger.doLog(java.util.logging.LogRecord,java.lang.String)

    /// private void java.util.logging.Logger.doSetParent(java.util.logging.Logger)

    /// public void java.util.logging.Logger.entering(java.lang.String,java.lang.String)

    private static var entering_MethodID_10: jmethodID?

    open func entering( sourceClass: String?, sourceMethod: String? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: sourceClass, locals: &__locals )
        __args[1] = JNIType.toJava( value: sourceMethod, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "entering", methodSig: "(Ljava/lang/String;Ljava/lang/String;)V", methodCache: &Logger.entering_MethodID_10, args: &__args, locals: &__locals )
    }

    open func entering( _ _sourceClass: String?, _ _sourceMethod: String? ) {
        entering( sourceClass: _sourceClass, sourceMethod: _sourceMethod )
    }

    /// public void java.util.logging.Logger.entering(java.lang.String,java.lang.String,java.lang.Object[])

    private static var entering_MethodID_11: jmethodID?

    open func entering( sourceClass: String?, sourceMethod: String?, params: [JavaObject]? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: sourceClass, locals: &__locals )
        __args[1] = JNIType.toJava( value: sourceMethod, locals: &__locals )
        __args[2] = JNIType.toJava( value: params, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "entering", methodSig: "(Ljava/lang/String;Ljava/lang/String;[Ljava/lang/Object;)V", methodCache: &Logger.entering_MethodID_11, args: &__args, locals: &__locals )
    }

    open func entering( _ _sourceClass: String?, _ _sourceMethod: String?, _ _params: [JavaObject]? ) {
        entering( sourceClass: _sourceClass, sourceMethod: _sourceMethod, params: _params )
    }

    /// public void java.util.logging.Logger.entering(java.lang.String,java.lang.String,java.lang.Object)

    private static var entering_MethodID_12: jmethodID?

    open func entering( sourceClass: String?, sourceMethod: String?, param1: java_swift.JavaObject? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: sourceClass, locals: &__locals )
        __args[1] = JNIType.toJava( value: sourceMethod, locals: &__locals )
        __args[2] = JNIType.toJava( value: param1, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "entering", methodSig: "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/Object;)V", methodCache: &Logger.entering_MethodID_12, args: &__args, locals: &__locals )
    }

    open func entering( _ _sourceClass: String?, _ _sourceMethod: String?, _ _param1: java_swift.JavaObject? ) {
        entering( sourceClass: _sourceClass, sourceMethod: _sourceMethod, param1: _param1 )
    }

    /// public void java.util.logging.Logger.exiting(java.lang.String,java.lang.String)

    private static var exiting_MethodID_13: jmethodID?

    open func exiting( sourceClass: String?, sourceMethod: String? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: sourceClass, locals: &__locals )
        __args[1] = JNIType.toJava( value: sourceMethod, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "exiting", methodSig: "(Ljava/lang/String;Ljava/lang/String;)V", methodCache: &Logger.exiting_MethodID_13, args: &__args, locals: &__locals )
    }

    open func exiting( _ _sourceClass: String?, _ _sourceMethod: String? ) {
        exiting( sourceClass: _sourceClass, sourceMethod: _sourceMethod )
    }

    /// public void java.util.logging.Logger.exiting(java.lang.String,java.lang.String,java.lang.Object)

    private static var exiting_MethodID_14: jmethodID?

    open func exiting( sourceClass: String?, sourceMethod: String?, result: java_swift.JavaObject? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: sourceClass, locals: &__locals )
        __args[1] = JNIType.toJava( value: sourceMethod, locals: &__locals )
        __args[2] = JNIType.toJava( value: result, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "exiting", methodSig: "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/Object;)V", methodCache: &Logger.exiting_MethodID_14, args: &__args, locals: &__locals )
    }

    open func exiting( _ _sourceClass: String?, _ _sourceMethod: String?, _ _result: java_swift.JavaObject? ) {
        exiting( sourceClass: _sourceClass, sourceMethod: _sourceMethod, result: _result )
    }

    /// private synchronized java.util.ResourceBundle java.util.logging.Logger.findResourceBundle(java.lang.String,boolean)

    /// public void java.util.logging.Logger.fine(java.lang.String)

    private static var fine_MethodID_15: jmethodID?

    open func fine( msg: String? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: msg, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "fine", methodSig: "(Ljava/lang/String;)V", methodCache: &Logger.fine_MethodID_15, args: &__args, locals: &__locals )
    }

    open func fine( _ _msg: String? ) {
        fine( msg: _msg )
    }

    /// public void java.util.logging.Logger.fine(java.util.function.Supplier)

    private static var fine_MethodID_16: jmethodID?

    open func fine( msgSupplier: Supplier? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: msgSupplier, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "fine", methodSig: "(Ljava/util/function/Supplier;)V", methodCache: &Logger.fine_MethodID_16, args: &__args, locals: &__locals )
    }

    open func fine( _ _msgSupplier: Supplier? ) {
        fine( msgSupplier: _msgSupplier )
    }

    /// public void java.util.logging.Logger.finer(java.lang.String)

    private static var finer_MethodID_17: jmethodID?

    open func finer( msg: String? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: msg, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "finer", methodSig: "(Ljava/lang/String;)V", methodCache: &Logger.finer_MethodID_17, args: &__args, locals: &__locals )
    }

    open func finer( _ _msg: String? ) {
        finer( msg: _msg )
    }

    /// public void java.util.logging.Logger.finer(java.util.function.Supplier)

    private static var finer_MethodID_18: jmethodID?

    open func finer( msgSupplier: Supplier? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: msgSupplier, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "finer", methodSig: "(Ljava/util/function/Supplier;)V", methodCache: &Logger.finer_MethodID_18, args: &__args, locals: &__locals )
    }

    open func finer( _ _msgSupplier: Supplier? ) {
        finer( msgSupplier: _msgSupplier )
    }

    /// public void java.util.logging.Logger.finest(java.lang.String)

    private static var finest_MethodID_19: jmethodID?

    open func finest( msg: String? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: msg, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "finest", methodSig: "(Ljava/lang/String;)V", methodCache: &Logger.finest_MethodID_19, args: &__args, locals: &__locals )
    }

    open func finest( _ _msg: String? ) {
        finest( msg: _msg )
    }

    /// public void java.util.logging.Logger.finest(java.util.function.Supplier)

    private static var finest_MethodID_20: jmethodID?

    open func finest( msgSupplier: Supplier? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: msgSupplier, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "finest", methodSig: "(Ljava/util/function/Supplier;)V", methodCache: &Logger.finest_MethodID_20, args: &__args, locals: &__locals )
    }

    open func finest( _ _msgSupplier: Supplier? ) {
        finest( msgSupplier: _msgSupplier )
    }

    /// private java.lang.ClassLoader java.util.logging.Logger.getCallersClassLoader()

    /// private java.util.logging.Logger$LoggerBundle java.util.logging.Logger.getEffectiveLoggerBundle()

    /// public java.util.logging.Filter java.util.logging.Logger.getFilter()

    private static var getFilter_MethodID_21: jmethodID?

    open func getFilter() -> Filter! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getFilter", methodSig: "()Ljava/util/logging/Filter;", methodCache: &Logger.getFilter_MethodID_21, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? FilterForward( javaObject: __return ) : nil
    }


    /// public java.util.logging.Handler[] java.util.logging.Logger.getHandlers()

    private static var getHandlers_MethodID_22: jmethodID?

    open func getHandlers() -> [Handler]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getHandlers", methodSig: "()[Ljava/util/logging/Handler;", methodCache: &Logger.getHandlers_MethodID_22, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [Handler].self, from: __return )
    }


    /// public java.util.logging.Level java.util.logging.Logger.getLevel()

    private static var getLevel_MethodID_23: jmethodID?

    open func getLevel() -> Level! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getLevel", methodSig: "()Ljava/util/logging/Level;", methodCache: &Logger.getLevel_MethodID_23, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? Level( javaObject: __return ) : nil
    }


    /// public java.lang.String java.util.logging.Logger.getName()

    private static var getName_MethodID_24: jmethodID?

    open func getName() -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getName", methodSig: "()Ljava/lang/String;", methodCache: &Logger.getName_MethodID_24, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? String( javaObject: __return ) : nil
    }


    /// public java.util.logging.Logger java.util.logging.Logger.getParent()

    private static var getParent_MethodID_25: jmethodID?

    open func getParent() -> Logger! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getParent", methodSig: "()Ljava/util/logging/Logger;", methodCache: &Logger.getParent_MethodID_25, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? Logger( javaObject: __return ) : nil
    }


    /// public java.util.ResourceBundle java.util.logging.Logger.getResourceBundle()

    private static var getResourceBundle_MethodID_26: jmethodID?

    open func getResourceBundle() -> ResourceBundle! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getResourceBundle", methodSig: "()Ljava/util/ResourceBundle;", methodCache: &Logger.getResourceBundle_MethodID_26, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? ResourceBundle( javaObject: __return ) : nil
    }


    /// public java.lang.String java.util.logging.Logger.getResourceBundleName()

    private static var getResourceBundleName_MethodID_27: jmethodID?

    open func getResourceBundleName() -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getResourceBundleName", methodSig: "()Ljava/lang/String;", methodCache: &Logger.getResourceBundleName_MethodID_27, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? String( javaObject: __return ) : nil
    }


    /// public boolean java.util.logging.Logger.getUseParentHandlers()

    private static var getUseParentHandlers_MethodID_28: jmethodID?

    open func getUseParentHandlers() -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "getUseParentHandlers", methodSig: "()Z", methodCache: &Logger.getUseParentHandlers_MethodID_28, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }


    /// public void java.util.logging.Logger.info(java.lang.String)

    private static var info_MethodID_29: jmethodID?

    open func info( msg: String? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: msg, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "info", methodSig: "(Ljava/lang/String;)V", methodCache: &Logger.info_MethodID_29, args: &__args, locals: &__locals )
    }

    open func info( _ _msg: String? ) {
        info( msg: _msg )
    }

    /// public void java.util.logging.Logger.info(java.util.function.Supplier)

    private static var info_MethodID_30: jmethodID?

    open func info( msgSupplier: Supplier? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: msgSupplier, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "info", methodSig: "(Ljava/util/function/Supplier;)V", methodCache: &Logger.info_MethodID_30, args: &__args, locals: &__locals )
    }

    open func info( _ _msgSupplier: Supplier? ) {
        info( msgSupplier: _msgSupplier )
    }

    /// final boolean java.util.logging.Logger.isLevelInitialized()

    // Skipping method: true false false false false 

    /// public boolean java.util.logging.Logger.isLoggable(java.util.logging.Level)

    private static var isLoggable_MethodID_31: jmethodID?

    open func isLoggable( level: Level? ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: level, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isLoggable", methodSig: "(Ljava/util/logging/Level;)Z", methodCache: &Logger.isLoggable_MethodID_31, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open func isLoggable( _ _level: Level? ) -> Bool {
        return isLoggable( level: _level )
    }

    /// public void java.util.logging.Logger.log(java.util.logging.Level,java.lang.String)

    private static var log_MethodID_32: jmethodID?

    open func log( level: Level?, msg: String? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: level, locals: &__locals )
        __args[1] = JNIType.toJava( value: msg, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "log", methodSig: "(Ljava/util/logging/Level;Ljava/lang/String;)V", methodCache: &Logger.log_MethodID_32, args: &__args, locals: &__locals )
    }

    open func log( _ _level: Level?, _ _msg: String? ) {
        log( level: _level, msg: _msg )
    }

    /// public void java.util.logging.Logger.log(java.util.logging.Level,java.lang.String,java.lang.Object[])

    private static var log_MethodID_33: jmethodID?

    open func log( level: Level?, msg: String?, params: [JavaObject]? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: level, locals: &__locals )
        __args[1] = JNIType.toJava( value: msg, locals: &__locals )
        __args[2] = JNIType.toJava( value: params, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "log", methodSig: "(Ljava/util/logging/Level;Ljava/lang/String;[Ljava/lang/Object;)V", methodCache: &Logger.log_MethodID_33, args: &__args, locals: &__locals )
    }

    open func log( _ _level: Level?, _ _msg: String?, _ _params: [JavaObject]? ) {
        log( level: _level, msg: _msg, params: _params )
    }

    /// public void java.util.logging.Logger.log(java.util.logging.Level,java.lang.String,java.lang.Object)

    private static var log_MethodID_34: jmethodID?

    open func log( level: Level?, msg: String?, param1: java_swift.JavaObject? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: level, locals: &__locals )
        __args[1] = JNIType.toJava( value: msg, locals: &__locals )
        __args[2] = JNIType.toJava( value: param1, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "log", methodSig: "(Ljava/util/logging/Level;Ljava/lang/String;Ljava/lang/Object;)V", methodCache: &Logger.log_MethodID_34, args: &__args, locals: &__locals )
    }

    open func log( _ _level: Level?, _ _msg: String?, _ _param1: java_swift.JavaObject? ) {
        log( level: _level, msg: _msg, param1: _param1 )
    }

    /// public void java.util.logging.Logger.log(java.util.logging.Level,java.lang.String,java.lang.Throwable)

    private static var log_MethodID_35: jmethodID?

    open func log( level: Level?, msg: String?, thrown: java_swift.Throwable? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: level, locals: &__locals )
        __args[1] = JNIType.toJava( value: msg, locals: &__locals )
        __args[2] = JNIType.toJava( value: thrown, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "log", methodSig: "(Ljava/util/logging/Level;Ljava/lang/String;Ljava/lang/Throwable;)V", methodCache: &Logger.log_MethodID_35, args: &__args, locals: &__locals )
    }

    open func log( _ _level: Level?, _ _msg: String?, _ _thrown: java_swift.Throwable? ) {
        log( level: _level, msg: _msg, thrown: _thrown )
    }

    /// public void java.util.logging.Logger.log(java.util.logging.Level,java.util.function.Supplier)

    private static var log_MethodID_36: jmethodID?

    open func log( level: Level?, msgSupplier: Supplier? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: level, locals: &__locals )
        __args[1] = JNIType.toJava( value: msgSupplier, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "log", methodSig: "(Ljava/util/logging/Level;Ljava/util/function/Supplier;)V", methodCache: &Logger.log_MethodID_36, args: &__args, locals: &__locals )
    }

    open func log( _ _level: Level?, _ _msgSupplier: Supplier? ) {
        log( level: _level, msgSupplier: _msgSupplier )
    }

    /// public void java.util.logging.Logger.log(java.util.logging.Level,java.lang.Throwable,java.util.function.Supplier)

    private static var log_MethodID_37: jmethodID?

    open func log( level: Level?, thrown: java_swift.Throwable?, msgSupplier: Supplier? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: level, locals: &__locals )
        __args[1] = JNIType.toJava( value: thrown, locals: &__locals )
        __args[2] = JNIType.toJava( value: msgSupplier, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "log", methodSig: "(Ljava/util/logging/Level;Ljava/lang/Throwable;Ljava/util/function/Supplier;)V", methodCache: &Logger.log_MethodID_37, args: &__args, locals: &__locals )
    }

    open func log( _ _level: Level?, _ _thrown: java_swift.Throwable?, _ _msgSupplier: Supplier? ) {
        log( level: _level, thrown: _thrown, msgSupplier: _msgSupplier )
    }

    /// public void java.util.logging.Logger.log(java.util.logging.LogRecord)

    private static var log_MethodID_38: jmethodID?

    open func log( record: LogRecord? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: record, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "log", methodSig: "(Ljava/util/logging/LogRecord;)V", methodCache: &Logger.log_MethodID_38, args: &__args, locals: &__locals )
    }

    open func log( _ _record: LogRecord? ) {
        log( record: _record )
    }

    /// public void java.util.logging.Logger.logp(java.util.logging.Level,java.lang.String,java.lang.String,java.lang.String)

    private static var logp_MethodID_39: jmethodID?

    open func logp( level: Level?, sourceClass: String?, sourceMethod: String?, msg: String? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        __args[0] = JNIType.toJava( value: level, locals: &__locals )
        __args[1] = JNIType.toJava( value: sourceClass, locals: &__locals )
        __args[2] = JNIType.toJava( value: sourceMethod, locals: &__locals )
        __args[3] = JNIType.toJava( value: msg, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "logp", methodSig: "(Ljava/util/logging/Level;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V", methodCache: &Logger.logp_MethodID_39, args: &__args, locals: &__locals )
    }

    open func logp( _ _level: Level?, _ _sourceClass: String?, _ _sourceMethod: String?, _ _msg: String? ) {
        logp( level: _level, sourceClass: _sourceClass, sourceMethod: _sourceMethod, msg: _msg )
    }

    /// public void java.util.logging.Logger.logp(java.util.logging.Level,java.lang.String,java.lang.String,java.lang.String,java.lang.Object[])

    private static var logp_MethodID_40: jmethodID?

    open func logp( level: Level?, sourceClass: String?, sourceMethod: String?, msg: String?, params: [JavaObject]? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 5 )
        __args[0] = JNIType.toJava( value: level, locals: &__locals )
        __args[1] = JNIType.toJava( value: sourceClass, locals: &__locals )
        __args[2] = JNIType.toJava( value: sourceMethod, locals: &__locals )
        __args[3] = JNIType.toJava( value: msg, locals: &__locals )
        __args[4] = JNIType.toJava( value: params, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "logp", methodSig: "(Ljava/util/logging/Level;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;[Ljava/lang/Object;)V", methodCache: &Logger.logp_MethodID_40, args: &__args, locals: &__locals )
    }

    open func logp( _ _level: Level?, _ _sourceClass: String?, _ _sourceMethod: String?, _ _msg: String?, _ _params: [JavaObject]? ) {
        logp( level: _level, sourceClass: _sourceClass, sourceMethod: _sourceMethod, msg: _msg, params: _params )
    }

    /// public void java.util.logging.Logger.logp(java.util.logging.Level,java.lang.String,java.lang.String,java.lang.String,java.lang.Object)

    private static var logp_MethodID_41: jmethodID?

    open func logp( level: Level?, sourceClass: String?, sourceMethod: String?, msg: String?, param1: java_swift.JavaObject? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 5 )
        __args[0] = JNIType.toJava( value: level, locals: &__locals )
        __args[1] = JNIType.toJava( value: sourceClass, locals: &__locals )
        __args[2] = JNIType.toJava( value: sourceMethod, locals: &__locals )
        __args[3] = JNIType.toJava( value: msg, locals: &__locals )
        __args[4] = JNIType.toJava( value: param1, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "logp", methodSig: "(Ljava/util/logging/Level;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/Object;)V", methodCache: &Logger.logp_MethodID_41, args: &__args, locals: &__locals )
    }

    open func logp( _ _level: Level?, _ _sourceClass: String?, _ _sourceMethod: String?, _ _msg: String?, _ _param1: java_swift.JavaObject? ) {
        logp( level: _level, sourceClass: _sourceClass, sourceMethod: _sourceMethod, msg: _msg, param1: _param1 )
    }

    /// public void java.util.logging.Logger.logp(java.util.logging.Level,java.lang.String,java.lang.String,java.lang.String,java.lang.Throwable)

    private static var logp_MethodID_42: jmethodID?

    open func logp( level: Level?, sourceClass: String?, sourceMethod: String?, msg: String?, thrown: java_swift.Throwable? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 5 )
        __args[0] = JNIType.toJava( value: level, locals: &__locals )
        __args[1] = JNIType.toJava( value: sourceClass, locals: &__locals )
        __args[2] = JNIType.toJava( value: sourceMethod, locals: &__locals )
        __args[3] = JNIType.toJava( value: msg, locals: &__locals )
        __args[4] = JNIType.toJava( value: thrown, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "logp", methodSig: "(Ljava/util/logging/Level;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/Throwable;)V", methodCache: &Logger.logp_MethodID_42, args: &__args, locals: &__locals )
    }

    open func logp( _ _level: Level?, _ _sourceClass: String?, _ _sourceMethod: String?, _ _msg: String?, _ _thrown: java_swift.Throwable? ) {
        logp( level: _level, sourceClass: _sourceClass, sourceMethod: _sourceMethod, msg: _msg, thrown: _thrown )
    }

    /// public void java.util.logging.Logger.logp(java.util.logging.Level,java.lang.String,java.lang.String,java.util.function.Supplier)

    private static var logp_MethodID_43: jmethodID?

    open func logp( level: Level?, sourceClass: String?, sourceMethod: String?, msgSupplier: Supplier? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        __args[0] = JNIType.toJava( value: level, locals: &__locals )
        __args[1] = JNIType.toJava( value: sourceClass, locals: &__locals )
        __args[2] = JNIType.toJava( value: sourceMethod, locals: &__locals )
        __args[3] = JNIType.toJava( value: msgSupplier, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "logp", methodSig: "(Ljava/util/logging/Level;Ljava/lang/String;Ljava/lang/String;Ljava/util/function/Supplier;)V", methodCache: &Logger.logp_MethodID_43, args: &__args, locals: &__locals )
    }

    open func logp( _ _level: Level?, _ _sourceClass: String?, _ _sourceMethod: String?, _ _msgSupplier: Supplier? ) {
        logp( level: _level, sourceClass: _sourceClass, sourceMethod: _sourceMethod, msgSupplier: _msgSupplier )
    }

    /// public void java.util.logging.Logger.logp(java.util.logging.Level,java.lang.String,java.lang.String,java.lang.Throwable,java.util.function.Supplier)

    private static var logp_MethodID_44: jmethodID?

    open func logp( level: Level?, sourceClass: String?, sourceMethod: String?, thrown: java_swift.Throwable?, msgSupplier: Supplier? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 5 )
        __args[0] = JNIType.toJava( value: level, locals: &__locals )
        __args[1] = JNIType.toJava( value: sourceClass, locals: &__locals )
        __args[2] = JNIType.toJava( value: sourceMethod, locals: &__locals )
        __args[3] = JNIType.toJava( value: thrown, locals: &__locals )
        __args[4] = JNIType.toJava( value: msgSupplier, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "logp", methodSig: "(Ljava/util/logging/Level;Ljava/lang/String;Ljava/lang/String;Ljava/lang/Throwable;Ljava/util/function/Supplier;)V", methodCache: &Logger.logp_MethodID_44, args: &__args, locals: &__locals )
    }

    open func logp( _ _level: Level?, _ _sourceClass: String?, _ _sourceMethod: String?, _ _thrown: java_swift.Throwable?, _ _msgSupplier: Supplier? ) {
        logp( level: _level, sourceClass: _sourceClass, sourceMethod: _sourceMethod, thrown: _thrown, msgSupplier: _msgSupplier )
    }

    /// public void java.util.logging.Logger.logrb(java.util.logging.Level,java.lang.String,java.lang.String,java.util.ResourceBundle,java.lang.String,java.lang.Object[])

    private static var logrb_MethodID_45: jmethodID?

    open func logrb( level: Level?, sourceClass: String?, sourceMethod: String?, bundle: ResourceBundle?, msg: String?, params: [JavaObject]? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 6 )
        __args[0] = JNIType.toJava( value: level, locals: &__locals )
        __args[1] = JNIType.toJava( value: sourceClass, locals: &__locals )
        __args[2] = JNIType.toJava( value: sourceMethod, locals: &__locals )
        __args[3] = JNIType.toJava( value: bundle, locals: &__locals )
        __args[4] = JNIType.toJava( value: msg, locals: &__locals )
        __args[5] = JNIType.toJava( value: params, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "logrb", methodSig: "(Ljava/util/logging/Level;Ljava/lang/String;Ljava/lang/String;Ljava/util/ResourceBundle;Ljava/lang/String;[Ljava/lang/Object;)V", methodCache: &Logger.logrb_MethodID_45, args: &__args, locals: &__locals )
    }

    open func logrb( _ _level: Level?, _ _sourceClass: String?, _ _sourceMethod: String?, _ _bundle: ResourceBundle?, _ _msg: String?, _ _params: [JavaObject]? ) {
        logrb( level: _level, sourceClass: _sourceClass, sourceMethod: _sourceMethod, bundle: _bundle, msg: _msg, params: _params )
    }

    /// public void java.util.logging.Logger.logrb(java.util.logging.Level,java.lang.String,java.lang.String,java.util.ResourceBundle,java.lang.String,java.lang.Throwable)

    private static var logrb_MethodID_46: jmethodID?

    open func logrb( level: Level?, sourceClass: String?, sourceMethod: String?, bundle: ResourceBundle?, msg: String?, thrown: java_swift.Throwable? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 6 )
        __args[0] = JNIType.toJava( value: level, locals: &__locals )
        __args[1] = JNIType.toJava( value: sourceClass, locals: &__locals )
        __args[2] = JNIType.toJava( value: sourceMethod, locals: &__locals )
        __args[3] = JNIType.toJava( value: bundle, locals: &__locals )
        __args[4] = JNIType.toJava( value: msg, locals: &__locals )
        __args[5] = JNIType.toJava( value: thrown, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "logrb", methodSig: "(Ljava/util/logging/Level;Ljava/lang/String;Ljava/lang/String;Ljava/util/ResourceBundle;Ljava/lang/String;Ljava/lang/Throwable;)V", methodCache: &Logger.logrb_MethodID_46, args: &__args, locals: &__locals )
    }

    open func logrb( _ _level: Level?, _ _sourceClass: String?, _ _sourceMethod: String?, _ _bundle: ResourceBundle?, _ _msg: String?, _ _thrown: java_swift.Throwable? ) {
        logrb( level: _level, sourceClass: _sourceClass, sourceMethod: _sourceMethod, bundle: _bundle, msg: _msg, thrown: _thrown )
    }

    /// public void java.util.logging.Logger.logrb(java.util.logging.Level,java.lang.String,java.lang.String,java.lang.String,java.lang.String)

    private static var logrb_MethodID_47: jmethodID?

    open func logrb( level: Level?, sourceClass: String?, sourceMethod: String?, bundleName: String?, msg: String? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 5 )
        __args[0] = JNIType.toJava( value: level, locals: &__locals )
        __args[1] = JNIType.toJava( value: sourceClass, locals: &__locals )
        __args[2] = JNIType.toJava( value: sourceMethod, locals: &__locals )
        __args[3] = JNIType.toJava( value: bundleName, locals: &__locals )
        __args[4] = JNIType.toJava( value: msg, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "logrb", methodSig: "(Ljava/util/logging/Level;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V", methodCache: &Logger.logrb_MethodID_47, args: &__args, locals: &__locals )
    }

    open func logrb( _ _level: Level?, _ _sourceClass: String?, _ _sourceMethod: String?, _ _bundleName: String?, _ _msg: String? ) {
        logrb( level: _level, sourceClass: _sourceClass, sourceMethod: _sourceMethod, bundleName: _bundleName, msg: _msg )
    }

    /// public void java.util.logging.Logger.logrb(java.util.logging.Level,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.Object[])

    private static var logrb_MethodID_48: jmethodID?

    open func logrb( level: Level?, sourceClass: String?, sourceMethod: String?, bundleName: String?, msg: String?, params: [JavaObject]? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 6 )
        __args[0] = JNIType.toJava( value: level, locals: &__locals )
        __args[1] = JNIType.toJava( value: sourceClass, locals: &__locals )
        __args[2] = JNIType.toJava( value: sourceMethod, locals: &__locals )
        __args[3] = JNIType.toJava( value: bundleName, locals: &__locals )
        __args[4] = JNIType.toJava( value: msg, locals: &__locals )
        __args[5] = JNIType.toJava( value: params, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "logrb", methodSig: "(Ljava/util/logging/Level;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;[Ljava/lang/Object;)V", methodCache: &Logger.logrb_MethodID_48, args: &__args, locals: &__locals )
    }

    open func logrb( _ _level: Level?, _ _sourceClass: String?, _ _sourceMethod: String?, _ _bundleName: String?, _ _msg: String?, _ _params: [JavaObject]? ) {
        logrb( level: _level, sourceClass: _sourceClass, sourceMethod: _sourceMethod, bundleName: _bundleName, msg: _msg, params: _params )
    }

    /// public void java.util.logging.Logger.logrb(java.util.logging.Level,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.Object)

    private static var logrb_MethodID_49: jmethodID?

    open func logrb( level: Level?, sourceClass: String?, sourceMethod: String?, bundleName: String?, msg: String?, param1: java_swift.JavaObject? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 6 )
        __args[0] = JNIType.toJava( value: level, locals: &__locals )
        __args[1] = JNIType.toJava( value: sourceClass, locals: &__locals )
        __args[2] = JNIType.toJava( value: sourceMethod, locals: &__locals )
        __args[3] = JNIType.toJava( value: bundleName, locals: &__locals )
        __args[4] = JNIType.toJava( value: msg, locals: &__locals )
        __args[5] = JNIType.toJava( value: param1, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "logrb", methodSig: "(Ljava/util/logging/Level;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/Object;)V", methodCache: &Logger.logrb_MethodID_49, args: &__args, locals: &__locals )
    }

    open func logrb( _ _level: Level?, _ _sourceClass: String?, _ _sourceMethod: String?, _ _bundleName: String?, _ _msg: String?, _ _param1: java_swift.JavaObject? ) {
        logrb( level: _level, sourceClass: _sourceClass, sourceMethod: _sourceMethod, bundleName: _bundleName, msg: _msg, param1: _param1 )
    }

    /// public void java.util.logging.Logger.logrb(java.util.logging.Level,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.Throwable)

    private static var logrb_MethodID_50: jmethodID?

    open func logrb( level: Level?, sourceClass: String?, sourceMethod: String?, bundleName: String?, msg: String?, thrown: java_swift.Throwable? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 6 )
        __args[0] = JNIType.toJava( value: level, locals: &__locals )
        __args[1] = JNIType.toJava( value: sourceClass, locals: &__locals )
        __args[2] = JNIType.toJava( value: sourceMethod, locals: &__locals )
        __args[3] = JNIType.toJava( value: bundleName, locals: &__locals )
        __args[4] = JNIType.toJava( value: msg, locals: &__locals )
        __args[5] = JNIType.toJava( value: thrown, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "logrb", methodSig: "(Ljava/util/logging/Level;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/Throwable;)V", methodCache: &Logger.logrb_MethodID_50, args: &__args, locals: &__locals )
    }

    open func logrb( _ _level: Level?, _ _sourceClass: String?, _ _sourceMethod: String?, _ _bundleName: String?, _ _msg: String?, _ _thrown: java_swift.Throwable? ) {
        logrb( level: _level, sourceClass: _sourceClass, sourceMethod: _sourceMethod, bundleName: _bundleName, msg: _msg, thrown: _thrown )
    }

    /// final void java.util.logging.Logger.removeChildLogger(java.util.logging.LogManager$LoggerWeakRef)

    // Skipping method: true false false false false 

    /// public void java.util.logging.Logger.removeHandler(java.util.logging.Handler) throws java.lang.SecurityException

    private static var removeHandler_MethodID_51: jmethodID?

    open func removeHandler( handler: Handler? ) throws /* java.lang.SecurityException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: handler, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "removeHandler", methodSig: "(Ljava/util/logging/Handler;)V", methodCache: &Logger.removeHandler_MethodID_51, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw java_lang.JavaSecurityException( javaObject: throwable )
        }
    }

    open func removeHandler( _ _handler: Handler? ) throws /* java.lang.SecurityException */ {
        try removeHandler( handler: _handler )
    }

    /// private void java.util.logging.Logger.setCallersClassLoaderRef(java.lang.Class)

    /// public void java.util.logging.Logger.setFilter(java.util.logging.Filter) throws java.lang.SecurityException

    private static var setFilter_MethodID_52: jmethodID?

    open func setFilter( newFilter: Filter? ) throws /* java.lang.SecurityException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: newFilter, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setFilter", methodSig: "(Ljava/util/logging/Filter;)V", methodCache: &Logger.setFilter_MethodID_52, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw java_lang.JavaSecurityException( javaObject: throwable )
        }
    }

    open func setFilter( _ _newFilter: Filter? ) throws /* java.lang.SecurityException */ {
        try setFilter( newFilter: _newFilter )
    }

    /// public void java.util.logging.Logger.setLevel(java.util.logging.Level) throws java.lang.SecurityException

    private static var setLevel_MethodID_53: jmethodID?

    open func setLevel( newLevel: Level? ) throws /* java.lang.SecurityException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: newLevel, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setLevel", methodSig: "(Ljava/util/logging/Level;)V", methodCache: &Logger.setLevel_MethodID_53, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw java_lang.JavaSecurityException( javaObject: throwable )
        }
    }

    open func setLevel( _ _newLevel: Level? ) throws /* java.lang.SecurityException */ {
        try setLevel( newLevel: _newLevel )
    }

    /// void java.util.logging.Logger.setLogManager(java.util.logging.LogManager)

    // Skipping method: true false false false false 

    /// public void java.util.logging.Logger.setParent(java.util.logging.Logger)

    private static var setParent_MethodID_54: jmethodID?

    open func setParent( parent: Logger? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: parent, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setParent", methodSig: "(Ljava/util/logging/Logger;)V", methodCache: &Logger.setParent_MethodID_54, args: &__args, locals: &__locals )
    }

    open func setParent( _ _parent: Logger? ) {
        setParent( parent: _parent )
    }

    /// public void java.util.logging.Logger.setResourceBundle(java.util.ResourceBundle)

    private static var setResourceBundle_MethodID_55: jmethodID?

    open func setResourceBundle( bundle: ResourceBundle? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: bundle, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setResourceBundle", methodSig: "(Ljava/util/ResourceBundle;)V", methodCache: &Logger.setResourceBundle_MethodID_55, args: &__args, locals: &__locals )
    }

    open func setResourceBundle( _ _bundle: ResourceBundle? ) {
        setResourceBundle( bundle: _bundle )
    }

    /// public void java.util.logging.Logger.setUseParentHandlers(boolean)

    private static var setUseParentHandlers_MethodID_56: jmethodID?

    open func setUseParentHandlers( useParentHandlers: Bool ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( z: jboolean(useParentHandlers ? JNI_TRUE : JNI_FALSE) )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setUseParentHandlers", methodSig: "(Z)V", methodCache: &Logger.setUseParentHandlers_MethodID_56, args: &__args, locals: &__locals )
    }

    open func setUseParentHandlers( _ _useParentHandlers: Bool ) {
        setUseParentHandlers( useParentHandlers: _useParentHandlers )
    }

    /// private synchronized void java.util.logging.Logger.setupResourceInfo(java.lang.String,java.lang.Class)

    /// public void java.util.logging.Logger.severe(java.lang.String)

    private static var severe_MethodID_57: jmethodID?

    open func severe( msg: String? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: msg, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "severe", methodSig: "(Ljava/lang/String;)V", methodCache: &Logger.severe_MethodID_57, args: &__args, locals: &__locals )
    }

    open func severe( _ _msg: String? ) {
        severe( msg: _msg )
    }

    /// public void java.util.logging.Logger.severe(java.util.function.Supplier)

    private static var severe_MethodID_58: jmethodID?

    open func severe( msgSupplier: Supplier? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: msgSupplier, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "severe", methodSig: "(Ljava/util/function/Supplier;)V", methodCache: &Logger.severe_MethodID_58, args: &__args, locals: &__locals )
    }

    open func severe( _ _msgSupplier: Supplier? ) {
        severe( msgSupplier: _msgSupplier )
    }

    /// public void java.util.logging.Logger.throwing(java.lang.String,java.lang.String,java.lang.Throwable)

    private static var throwing_MethodID_59: jmethodID?

    open func throwing( sourceClass: String?, sourceMethod: String?, thrown: java_swift.Throwable? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: sourceClass, locals: &__locals )
        __args[1] = JNIType.toJava( value: sourceMethod, locals: &__locals )
        __args[2] = JNIType.toJava( value: thrown, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "throwing", methodSig: "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/Throwable;)V", methodCache: &Logger.throwing_MethodID_59, args: &__args, locals: &__locals )
    }

    open func throwing( _ _sourceClass: String?, _ _sourceMethod: String?, _ _thrown: java_swift.Throwable? ) {
        throwing( sourceClass: _sourceClass, sourceMethod: _sourceMethod, thrown: _thrown )
    }

    /// private void java.util.logging.Logger.updateEffectiveLevel()

    /// public void java.util.logging.Logger.warning(java.lang.String)

    private static var warning_MethodID_60: jmethodID?

    open func warning( msg: String? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: msg, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "warning", methodSig: "(Ljava/lang/String;)V", methodCache: &Logger.warning_MethodID_60, args: &__args, locals: &__locals )
    }

    open func warning( _ _msg: String? ) {
        warning( msg: _msg )
    }

    /// public void java.util.logging.Logger.warning(java.util.function.Supplier)

    private static var warning_MethodID_61: jmethodID?

    open func warning( msgSupplier: Supplier? ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: msgSupplier, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "warning", methodSig: "(Ljava/util/function/Supplier;)V", methodCache: &Logger.warning_MethodID_61, args: &__args, locals: &__locals )
    }

    open func warning( _ _msgSupplier: Supplier? ) {
        warning( msgSupplier: _msgSupplier )
    }

}

