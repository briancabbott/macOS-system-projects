
import java_swift

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// interface java.util.concurrent.CompletionStage ///

public protocol CompletionStage: JavaProtocol {

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.acceptEither(java.util.concurrent.CompletionStage,java.util.function.Consumer)

    func acceptEither( other: CompletionStage?, action: Consumer? ) -> CompletionStage!

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.acceptEitherAsync(java.util.concurrent.CompletionStage,java.util.function.Consumer)

    func acceptEitherAsync( other: CompletionStage?, action: Consumer? ) -> CompletionStage!

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.acceptEitherAsync(java.util.concurrent.CompletionStage,java.util.function.Consumer,java.util.concurrent.Executor)

    func acceptEitherAsync( other: CompletionStage?, action: Consumer?, executor: Executor? ) -> CompletionStage!

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.applyToEither(java.util.concurrent.CompletionStage,java.util.function.Function)

    func applyToEither( other: CompletionStage?, fn: Function? ) -> CompletionStage!

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.applyToEitherAsync(java.util.concurrent.CompletionStage,java.util.function.Function)

    func applyToEitherAsync( other: CompletionStage?, fn: Function? ) -> CompletionStage!

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.applyToEitherAsync(java.util.concurrent.CompletionStage,java.util.function.Function,java.util.concurrent.Executor)

    func applyToEitherAsync( other: CompletionStage?, fn: Function?, executor: Executor? ) -> CompletionStage!

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.exceptionally(java.util.function.Function)

    func exceptionally( fn: Function? ) -> CompletionStage!

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.handle(java.util.function.BiFunction)

    func handle( fn: BiFunction? ) -> CompletionStage!

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.handleAsync(java.util.function.BiFunction)

    func handleAsync( fn: BiFunction? ) -> CompletionStage!

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.handleAsync(java.util.function.BiFunction,java.util.concurrent.Executor)

    func handleAsync( fn: BiFunction?, executor: Executor? ) -> CompletionStage!

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.runAfterBoth(java.util.concurrent.CompletionStage,java.lang.Runnable)

    func runAfterBoth( other: CompletionStage?, action: java_swift.Runnable? ) -> CompletionStage!

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.runAfterBothAsync(java.util.concurrent.CompletionStage,java.lang.Runnable)

    func runAfterBothAsync( other: CompletionStage?, action: java_swift.Runnable? ) -> CompletionStage!

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.runAfterBothAsync(java.util.concurrent.CompletionStage,java.lang.Runnable,java.util.concurrent.Executor)

    func runAfterBothAsync( other: CompletionStage?, action: java_swift.Runnable?, executor: Executor? ) -> CompletionStage!

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.runAfterEither(java.util.concurrent.CompletionStage,java.lang.Runnable)

    func runAfterEither( other: CompletionStage?, action: java_swift.Runnable? ) -> CompletionStage!

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.runAfterEitherAsync(java.util.concurrent.CompletionStage,java.lang.Runnable)

    func runAfterEitherAsync( other: CompletionStage?, action: java_swift.Runnable? ) -> CompletionStage!

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.runAfterEitherAsync(java.util.concurrent.CompletionStage,java.lang.Runnable,java.util.concurrent.Executor)

    func runAfterEitherAsync( other: CompletionStage?, action: java_swift.Runnable?, executor: Executor? ) -> CompletionStage!

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.thenAccept(java.util.function.Consumer)

    func thenAccept( action: Consumer? ) -> CompletionStage!

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.thenAcceptAsync(java.util.function.Consumer)

    func thenAcceptAsync( action: Consumer? ) -> CompletionStage!

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.thenAcceptAsync(java.util.function.Consumer,java.util.concurrent.Executor)

    func thenAcceptAsync( action: Consumer?, executor: Executor? ) -> CompletionStage!

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.thenAcceptBoth(java.util.concurrent.CompletionStage,java.util.function.BiConsumer)

    func thenAcceptBoth( other: CompletionStage?, action: BiConsumer? ) -> CompletionStage!

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.thenAcceptBothAsync(java.util.concurrent.CompletionStage,java.util.function.BiConsumer)

    func thenAcceptBothAsync( other: CompletionStage?, action: BiConsumer? ) -> CompletionStage!

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.thenAcceptBothAsync(java.util.concurrent.CompletionStage,java.util.function.BiConsumer,java.util.concurrent.Executor)

    func thenAcceptBothAsync( other: CompletionStage?, action: BiConsumer?, executor: Executor? ) -> CompletionStage!

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.thenApply(java.util.function.Function)

    func thenApply( fn: Function? ) -> CompletionStage!

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.thenApplyAsync(java.util.function.Function)

    func thenApplyAsync( fn: Function? ) -> CompletionStage!

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.thenApplyAsync(java.util.function.Function,java.util.concurrent.Executor)

    func thenApplyAsync( fn: Function?, executor: Executor? ) -> CompletionStage!

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.thenCombine(java.util.concurrent.CompletionStage,java.util.function.BiFunction)

    func thenCombine( other: CompletionStage?, fn: BiFunction? ) -> CompletionStage!

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.thenCombineAsync(java.util.concurrent.CompletionStage,java.util.function.BiFunction)

    func thenCombineAsync( other: CompletionStage?, fn: BiFunction? ) -> CompletionStage!

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.thenCombineAsync(java.util.concurrent.CompletionStage,java.util.function.BiFunction,java.util.concurrent.Executor)

    func thenCombineAsync( other: CompletionStage?, fn: BiFunction?, executor: Executor? ) -> CompletionStage!

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.thenCompose(java.util.function.Function)

    func thenCompose( fn: Function? ) -> CompletionStage!

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.thenComposeAsync(java.util.function.Function)

    func thenComposeAsync( fn: Function? ) -> CompletionStage!

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.thenComposeAsync(java.util.function.Function,java.util.concurrent.Executor)

    func thenComposeAsync( fn: Function?, executor: Executor? ) -> CompletionStage!

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.thenRun(java.lang.Runnable)

    func thenRun( action: java_swift.Runnable? ) -> CompletionStage!

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.thenRunAsync(java.lang.Runnable)

    func thenRunAsync( action: java_swift.Runnable? ) -> CompletionStage!

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.thenRunAsync(java.lang.Runnable,java.util.concurrent.Executor)

    func thenRunAsync( action: java_swift.Runnable?, executor: Executor? ) -> CompletionStage!

    /// public abstract java.util.concurrent.CompletableFuture java.util.concurrent.CompletionStage.toCompletableFuture()

    // Skipping method: false false true false false 

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.whenComplete(java.util.function.BiConsumer)

    func whenComplete( action: BiConsumer? ) -> CompletionStage!

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.whenCompleteAsync(java.util.function.BiConsumer)

    func whenCompleteAsync( action: BiConsumer? ) -> CompletionStage!

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.whenCompleteAsync(java.util.function.BiConsumer,java.util.concurrent.Executor)

    func whenCompleteAsync( action: BiConsumer?, executor: Executor? ) -> CompletionStage!

}


open class CompletionStageForward: JNIObjectForward, CompletionStage {

    private static var CompletionStageJNIClass: jclass?

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.acceptEither(java.util.concurrent.CompletionStage,java.util.function.Consumer)

    private static var acceptEither_MethodID_38: jmethodID?

    open func acceptEither( other: CompletionStage?, action: Consumer? ) -> CompletionStage! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: other, locals: &__locals )
        __args[1] = JNIType.toJava( value: action, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "acceptEither", methodSig: "(Ljava/util/concurrent/CompletionStage;Ljava/util/function/Consumer;)Ljava/util/concurrent/CompletionStage;", methodCache: &CompletionStageForward.acceptEither_MethodID_38, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CompletionStageForward( javaObject: __return ) : nil
    }

    open func acceptEither( _ _other: CompletionStage?, _ _action: Consumer? ) -> CompletionStage! {
        return acceptEither( other: _other, action: _action )
    }

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.acceptEitherAsync(java.util.concurrent.CompletionStage,java.util.function.Consumer)

    private static var acceptEitherAsync_MethodID_39: jmethodID?

    open func acceptEitherAsync( other: CompletionStage?, action: Consumer? ) -> CompletionStage! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: other, locals: &__locals )
        __args[1] = JNIType.toJava( value: action, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "acceptEitherAsync", methodSig: "(Ljava/util/concurrent/CompletionStage;Ljava/util/function/Consumer;)Ljava/util/concurrent/CompletionStage;", methodCache: &CompletionStageForward.acceptEitherAsync_MethodID_39, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CompletionStageForward( javaObject: __return ) : nil
    }

    open func acceptEitherAsync( _ _other: CompletionStage?, _ _action: Consumer? ) -> CompletionStage! {
        return acceptEitherAsync( other: _other, action: _action )
    }

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.acceptEitherAsync(java.util.concurrent.CompletionStage,java.util.function.Consumer,java.util.concurrent.Executor)

    private static var acceptEitherAsync_MethodID_40: jmethodID?

    open func acceptEitherAsync( other: CompletionStage?, action: Consumer?, executor: Executor? ) -> CompletionStage! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: other, locals: &__locals )
        __args[1] = JNIType.toJava( value: action, locals: &__locals )
        __args[2] = JNIType.toJava( value: executor, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "acceptEitherAsync", methodSig: "(Ljava/util/concurrent/CompletionStage;Ljava/util/function/Consumer;Ljava/util/concurrent/Executor;)Ljava/util/concurrent/CompletionStage;", methodCache: &CompletionStageForward.acceptEitherAsync_MethodID_40, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CompletionStageForward( javaObject: __return ) : nil
    }

    open func acceptEitherAsync( _ _other: CompletionStage?, _ _action: Consumer?, _ _executor: Executor? ) -> CompletionStage! {
        return acceptEitherAsync( other: _other, action: _action, executor: _executor )
    }

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.applyToEither(java.util.concurrent.CompletionStage,java.util.function.Function)

    private static var applyToEither_MethodID_41: jmethodID?

    open func applyToEither( other: CompletionStage?, fn: Function? ) -> CompletionStage! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: other, locals: &__locals )
        __args[1] = JNIType.toJava( value: fn, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "applyToEither", methodSig: "(Ljava/util/concurrent/CompletionStage;Ljava/util/function/Function;)Ljava/util/concurrent/CompletionStage;", methodCache: &CompletionStageForward.applyToEither_MethodID_41, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CompletionStageForward( javaObject: __return ) : nil
    }

    open func applyToEither( _ _other: CompletionStage?, _ _fn: Function? ) -> CompletionStage! {
        return applyToEither( other: _other, fn: _fn )
    }

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.applyToEitherAsync(java.util.concurrent.CompletionStage,java.util.function.Function)

    private static var applyToEitherAsync_MethodID_42: jmethodID?

    open func applyToEitherAsync( other: CompletionStage?, fn: Function? ) -> CompletionStage! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: other, locals: &__locals )
        __args[1] = JNIType.toJava( value: fn, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "applyToEitherAsync", methodSig: "(Ljava/util/concurrent/CompletionStage;Ljava/util/function/Function;)Ljava/util/concurrent/CompletionStage;", methodCache: &CompletionStageForward.applyToEitherAsync_MethodID_42, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CompletionStageForward( javaObject: __return ) : nil
    }

    open func applyToEitherAsync( _ _other: CompletionStage?, _ _fn: Function? ) -> CompletionStage! {
        return applyToEitherAsync( other: _other, fn: _fn )
    }

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.applyToEitherAsync(java.util.concurrent.CompletionStage,java.util.function.Function,java.util.concurrent.Executor)

    private static var applyToEitherAsync_MethodID_43: jmethodID?

    open func applyToEitherAsync( other: CompletionStage?, fn: Function?, executor: Executor? ) -> CompletionStage! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: other, locals: &__locals )
        __args[1] = JNIType.toJava( value: fn, locals: &__locals )
        __args[2] = JNIType.toJava( value: executor, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "applyToEitherAsync", methodSig: "(Ljava/util/concurrent/CompletionStage;Ljava/util/function/Function;Ljava/util/concurrent/Executor;)Ljava/util/concurrent/CompletionStage;", methodCache: &CompletionStageForward.applyToEitherAsync_MethodID_43, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CompletionStageForward( javaObject: __return ) : nil
    }

    open func applyToEitherAsync( _ _other: CompletionStage?, _ _fn: Function?, _ _executor: Executor? ) -> CompletionStage! {
        return applyToEitherAsync( other: _other, fn: _fn, executor: _executor )
    }

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.exceptionally(java.util.function.Function)

    private static var exceptionally_MethodID_44: jmethodID?

    open func exceptionally( fn: Function? ) -> CompletionStage! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: fn, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "exceptionally", methodSig: "(Ljava/util/function/Function;)Ljava/util/concurrent/CompletionStage;", methodCache: &CompletionStageForward.exceptionally_MethodID_44, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CompletionStageForward( javaObject: __return ) : nil
    }

    open func exceptionally( _ _fn: Function? ) -> CompletionStage! {
        return exceptionally( fn: _fn )
    }

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.handle(java.util.function.BiFunction)

    private static var handle_MethodID_45: jmethodID?

    open func handle( fn: BiFunction? ) -> CompletionStage! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: fn, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "handle", methodSig: "(Ljava/util/function/BiFunction;)Ljava/util/concurrent/CompletionStage;", methodCache: &CompletionStageForward.handle_MethodID_45, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CompletionStageForward( javaObject: __return ) : nil
    }

    open func handle( _ _fn: BiFunction? ) -> CompletionStage! {
        return handle( fn: _fn )
    }

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.handleAsync(java.util.function.BiFunction)

    private static var handleAsync_MethodID_46: jmethodID?

    open func handleAsync( fn: BiFunction? ) -> CompletionStage! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: fn, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "handleAsync", methodSig: "(Ljava/util/function/BiFunction;)Ljava/util/concurrent/CompletionStage;", methodCache: &CompletionStageForward.handleAsync_MethodID_46, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CompletionStageForward( javaObject: __return ) : nil
    }

    open func handleAsync( _ _fn: BiFunction? ) -> CompletionStage! {
        return handleAsync( fn: _fn )
    }

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.handleAsync(java.util.function.BiFunction,java.util.concurrent.Executor)

    private static var handleAsync_MethodID_47: jmethodID?

    open func handleAsync( fn: BiFunction?, executor: Executor? ) -> CompletionStage! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: fn, locals: &__locals )
        __args[1] = JNIType.toJava( value: executor, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "handleAsync", methodSig: "(Ljava/util/function/BiFunction;Ljava/util/concurrent/Executor;)Ljava/util/concurrent/CompletionStage;", methodCache: &CompletionStageForward.handleAsync_MethodID_47, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CompletionStageForward( javaObject: __return ) : nil
    }

    open func handleAsync( _ _fn: BiFunction?, _ _executor: Executor? ) -> CompletionStage! {
        return handleAsync( fn: _fn, executor: _executor )
    }

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.runAfterBoth(java.util.concurrent.CompletionStage,java.lang.Runnable)

    private static var runAfterBoth_MethodID_48: jmethodID?

    open func runAfterBoth( other: CompletionStage?, action: java_swift.Runnable? ) -> CompletionStage! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: other, locals: &__locals )
        __args[1] = JNIType.toJava( value: action, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "runAfterBoth", methodSig: "(Ljava/util/concurrent/CompletionStage;Ljava/lang/Runnable;)Ljava/util/concurrent/CompletionStage;", methodCache: &CompletionStageForward.runAfterBoth_MethodID_48, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CompletionStageForward( javaObject: __return ) : nil
    }

    open func runAfterBoth( _ _other: CompletionStage?, _ _action: java_swift.Runnable? ) -> CompletionStage! {
        return runAfterBoth( other: _other, action: _action )
    }

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.runAfterBothAsync(java.util.concurrent.CompletionStage,java.lang.Runnable)

    private static var runAfterBothAsync_MethodID_49: jmethodID?

    open func runAfterBothAsync( other: CompletionStage?, action: java_swift.Runnable? ) -> CompletionStage! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: other, locals: &__locals )
        __args[1] = JNIType.toJava( value: action, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "runAfterBothAsync", methodSig: "(Ljava/util/concurrent/CompletionStage;Ljava/lang/Runnable;)Ljava/util/concurrent/CompletionStage;", methodCache: &CompletionStageForward.runAfterBothAsync_MethodID_49, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CompletionStageForward( javaObject: __return ) : nil
    }

    open func runAfterBothAsync( _ _other: CompletionStage?, _ _action: java_swift.Runnable? ) -> CompletionStage! {
        return runAfterBothAsync( other: _other, action: _action )
    }

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.runAfterBothAsync(java.util.concurrent.CompletionStage,java.lang.Runnable,java.util.concurrent.Executor)

    private static var runAfterBothAsync_MethodID_50: jmethodID?

    open func runAfterBothAsync( other: CompletionStage?, action: java_swift.Runnable?, executor: Executor? ) -> CompletionStage! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: other, locals: &__locals )
        __args[1] = JNIType.toJava( value: action, locals: &__locals )
        __args[2] = JNIType.toJava( value: executor, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "runAfterBothAsync", methodSig: "(Ljava/util/concurrent/CompletionStage;Ljava/lang/Runnable;Ljava/util/concurrent/Executor;)Ljava/util/concurrent/CompletionStage;", methodCache: &CompletionStageForward.runAfterBothAsync_MethodID_50, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CompletionStageForward( javaObject: __return ) : nil
    }

    open func runAfterBothAsync( _ _other: CompletionStage?, _ _action: java_swift.Runnable?, _ _executor: Executor? ) -> CompletionStage! {
        return runAfterBothAsync( other: _other, action: _action, executor: _executor )
    }

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.runAfterEither(java.util.concurrent.CompletionStage,java.lang.Runnable)

    private static var runAfterEither_MethodID_51: jmethodID?

    open func runAfterEither( other: CompletionStage?, action: java_swift.Runnable? ) -> CompletionStage! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: other, locals: &__locals )
        __args[1] = JNIType.toJava( value: action, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "runAfterEither", methodSig: "(Ljava/util/concurrent/CompletionStage;Ljava/lang/Runnable;)Ljava/util/concurrent/CompletionStage;", methodCache: &CompletionStageForward.runAfterEither_MethodID_51, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CompletionStageForward( javaObject: __return ) : nil
    }

    open func runAfterEither( _ _other: CompletionStage?, _ _action: java_swift.Runnable? ) -> CompletionStage! {
        return runAfterEither( other: _other, action: _action )
    }

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.runAfterEitherAsync(java.util.concurrent.CompletionStage,java.lang.Runnable)

    private static var runAfterEitherAsync_MethodID_52: jmethodID?

    open func runAfterEitherAsync( other: CompletionStage?, action: java_swift.Runnable? ) -> CompletionStage! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: other, locals: &__locals )
        __args[1] = JNIType.toJava( value: action, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "runAfterEitherAsync", methodSig: "(Ljava/util/concurrent/CompletionStage;Ljava/lang/Runnable;)Ljava/util/concurrent/CompletionStage;", methodCache: &CompletionStageForward.runAfterEitherAsync_MethodID_52, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CompletionStageForward( javaObject: __return ) : nil
    }

    open func runAfterEitherAsync( _ _other: CompletionStage?, _ _action: java_swift.Runnable? ) -> CompletionStage! {
        return runAfterEitherAsync( other: _other, action: _action )
    }

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.runAfterEitherAsync(java.util.concurrent.CompletionStage,java.lang.Runnable,java.util.concurrent.Executor)

    private static var runAfterEitherAsync_MethodID_53: jmethodID?

    open func runAfterEitherAsync( other: CompletionStage?, action: java_swift.Runnable?, executor: Executor? ) -> CompletionStage! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: other, locals: &__locals )
        __args[1] = JNIType.toJava( value: action, locals: &__locals )
        __args[2] = JNIType.toJava( value: executor, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "runAfterEitherAsync", methodSig: "(Ljava/util/concurrent/CompletionStage;Ljava/lang/Runnable;Ljava/util/concurrent/Executor;)Ljava/util/concurrent/CompletionStage;", methodCache: &CompletionStageForward.runAfterEitherAsync_MethodID_53, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CompletionStageForward( javaObject: __return ) : nil
    }

    open func runAfterEitherAsync( _ _other: CompletionStage?, _ _action: java_swift.Runnable?, _ _executor: Executor? ) -> CompletionStage! {
        return runAfterEitherAsync( other: _other, action: _action, executor: _executor )
    }

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.thenAccept(java.util.function.Consumer)

    private static var thenAccept_MethodID_54: jmethodID?

    open func thenAccept( action: Consumer? ) -> CompletionStage! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: action, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "thenAccept", methodSig: "(Ljava/util/function/Consumer;)Ljava/util/concurrent/CompletionStage;", methodCache: &CompletionStageForward.thenAccept_MethodID_54, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CompletionStageForward( javaObject: __return ) : nil
    }

    open func thenAccept( _ _action: Consumer? ) -> CompletionStage! {
        return thenAccept( action: _action )
    }

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.thenAcceptAsync(java.util.function.Consumer)

    private static var thenAcceptAsync_MethodID_55: jmethodID?

    open func thenAcceptAsync( action: Consumer? ) -> CompletionStage! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: action, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "thenAcceptAsync", methodSig: "(Ljava/util/function/Consumer;)Ljava/util/concurrent/CompletionStage;", methodCache: &CompletionStageForward.thenAcceptAsync_MethodID_55, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CompletionStageForward( javaObject: __return ) : nil
    }

    open func thenAcceptAsync( _ _action: Consumer? ) -> CompletionStage! {
        return thenAcceptAsync( action: _action )
    }

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.thenAcceptAsync(java.util.function.Consumer,java.util.concurrent.Executor)

    private static var thenAcceptAsync_MethodID_56: jmethodID?

    open func thenAcceptAsync( action: Consumer?, executor: Executor? ) -> CompletionStage! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: action, locals: &__locals )
        __args[1] = JNIType.toJava( value: executor, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "thenAcceptAsync", methodSig: "(Ljava/util/function/Consumer;Ljava/util/concurrent/Executor;)Ljava/util/concurrent/CompletionStage;", methodCache: &CompletionStageForward.thenAcceptAsync_MethodID_56, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CompletionStageForward( javaObject: __return ) : nil
    }

    open func thenAcceptAsync( _ _action: Consumer?, _ _executor: Executor? ) -> CompletionStage! {
        return thenAcceptAsync( action: _action, executor: _executor )
    }

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.thenAcceptBoth(java.util.concurrent.CompletionStage,java.util.function.BiConsumer)

    private static var thenAcceptBoth_MethodID_57: jmethodID?

    open func thenAcceptBoth( other: CompletionStage?, action: BiConsumer? ) -> CompletionStage! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: other, locals: &__locals )
        __args[1] = JNIType.toJava( value: action, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "thenAcceptBoth", methodSig: "(Ljava/util/concurrent/CompletionStage;Ljava/util/function/BiConsumer;)Ljava/util/concurrent/CompletionStage;", methodCache: &CompletionStageForward.thenAcceptBoth_MethodID_57, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CompletionStageForward( javaObject: __return ) : nil
    }

    open func thenAcceptBoth( _ _other: CompletionStage?, _ _action: BiConsumer? ) -> CompletionStage! {
        return thenAcceptBoth( other: _other, action: _action )
    }

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.thenAcceptBothAsync(java.util.concurrent.CompletionStage,java.util.function.BiConsumer)

    private static var thenAcceptBothAsync_MethodID_58: jmethodID?

    open func thenAcceptBothAsync( other: CompletionStage?, action: BiConsumer? ) -> CompletionStage! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: other, locals: &__locals )
        __args[1] = JNIType.toJava( value: action, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "thenAcceptBothAsync", methodSig: "(Ljava/util/concurrent/CompletionStage;Ljava/util/function/BiConsumer;)Ljava/util/concurrent/CompletionStage;", methodCache: &CompletionStageForward.thenAcceptBothAsync_MethodID_58, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CompletionStageForward( javaObject: __return ) : nil
    }

    open func thenAcceptBothAsync( _ _other: CompletionStage?, _ _action: BiConsumer? ) -> CompletionStage! {
        return thenAcceptBothAsync( other: _other, action: _action )
    }

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.thenAcceptBothAsync(java.util.concurrent.CompletionStage,java.util.function.BiConsumer,java.util.concurrent.Executor)

    private static var thenAcceptBothAsync_MethodID_59: jmethodID?

    open func thenAcceptBothAsync( other: CompletionStage?, action: BiConsumer?, executor: Executor? ) -> CompletionStage! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: other, locals: &__locals )
        __args[1] = JNIType.toJava( value: action, locals: &__locals )
        __args[2] = JNIType.toJava( value: executor, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "thenAcceptBothAsync", methodSig: "(Ljava/util/concurrent/CompletionStage;Ljava/util/function/BiConsumer;Ljava/util/concurrent/Executor;)Ljava/util/concurrent/CompletionStage;", methodCache: &CompletionStageForward.thenAcceptBothAsync_MethodID_59, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CompletionStageForward( javaObject: __return ) : nil
    }

    open func thenAcceptBothAsync( _ _other: CompletionStage?, _ _action: BiConsumer?, _ _executor: Executor? ) -> CompletionStage! {
        return thenAcceptBothAsync( other: _other, action: _action, executor: _executor )
    }

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.thenApply(java.util.function.Function)

    private static var thenApply_MethodID_60: jmethodID?

    open func thenApply( fn: Function? ) -> CompletionStage! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: fn, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "thenApply", methodSig: "(Ljava/util/function/Function;)Ljava/util/concurrent/CompletionStage;", methodCache: &CompletionStageForward.thenApply_MethodID_60, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CompletionStageForward( javaObject: __return ) : nil
    }

    open func thenApply( _ _fn: Function? ) -> CompletionStage! {
        return thenApply( fn: _fn )
    }

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.thenApplyAsync(java.util.function.Function)

    private static var thenApplyAsync_MethodID_61: jmethodID?

    open func thenApplyAsync( fn: Function? ) -> CompletionStage! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: fn, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "thenApplyAsync", methodSig: "(Ljava/util/function/Function;)Ljava/util/concurrent/CompletionStage;", methodCache: &CompletionStageForward.thenApplyAsync_MethodID_61, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CompletionStageForward( javaObject: __return ) : nil
    }

    open func thenApplyAsync( _ _fn: Function? ) -> CompletionStage! {
        return thenApplyAsync( fn: _fn )
    }

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.thenApplyAsync(java.util.function.Function,java.util.concurrent.Executor)

    private static var thenApplyAsync_MethodID_62: jmethodID?

    open func thenApplyAsync( fn: Function?, executor: Executor? ) -> CompletionStage! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: fn, locals: &__locals )
        __args[1] = JNIType.toJava( value: executor, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "thenApplyAsync", methodSig: "(Ljava/util/function/Function;Ljava/util/concurrent/Executor;)Ljava/util/concurrent/CompletionStage;", methodCache: &CompletionStageForward.thenApplyAsync_MethodID_62, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CompletionStageForward( javaObject: __return ) : nil
    }

    open func thenApplyAsync( _ _fn: Function?, _ _executor: Executor? ) -> CompletionStage! {
        return thenApplyAsync( fn: _fn, executor: _executor )
    }

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.thenCombine(java.util.concurrent.CompletionStage,java.util.function.BiFunction)

    private static var thenCombine_MethodID_63: jmethodID?

    open func thenCombine( other: CompletionStage?, fn: BiFunction? ) -> CompletionStage! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: other, locals: &__locals )
        __args[1] = JNIType.toJava( value: fn, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "thenCombine", methodSig: "(Ljava/util/concurrent/CompletionStage;Ljava/util/function/BiFunction;)Ljava/util/concurrent/CompletionStage;", methodCache: &CompletionStageForward.thenCombine_MethodID_63, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CompletionStageForward( javaObject: __return ) : nil
    }

    open func thenCombine( _ _other: CompletionStage?, _ _fn: BiFunction? ) -> CompletionStage! {
        return thenCombine( other: _other, fn: _fn )
    }

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.thenCombineAsync(java.util.concurrent.CompletionStage,java.util.function.BiFunction)

    private static var thenCombineAsync_MethodID_64: jmethodID?

    open func thenCombineAsync( other: CompletionStage?, fn: BiFunction? ) -> CompletionStage! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: other, locals: &__locals )
        __args[1] = JNIType.toJava( value: fn, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "thenCombineAsync", methodSig: "(Ljava/util/concurrent/CompletionStage;Ljava/util/function/BiFunction;)Ljava/util/concurrent/CompletionStage;", methodCache: &CompletionStageForward.thenCombineAsync_MethodID_64, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CompletionStageForward( javaObject: __return ) : nil
    }

    open func thenCombineAsync( _ _other: CompletionStage?, _ _fn: BiFunction? ) -> CompletionStage! {
        return thenCombineAsync( other: _other, fn: _fn )
    }

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.thenCombineAsync(java.util.concurrent.CompletionStage,java.util.function.BiFunction,java.util.concurrent.Executor)

    private static var thenCombineAsync_MethodID_65: jmethodID?

    open func thenCombineAsync( other: CompletionStage?, fn: BiFunction?, executor: Executor? ) -> CompletionStage! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: other, locals: &__locals )
        __args[1] = JNIType.toJava( value: fn, locals: &__locals )
        __args[2] = JNIType.toJava( value: executor, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "thenCombineAsync", methodSig: "(Ljava/util/concurrent/CompletionStage;Ljava/util/function/BiFunction;Ljava/util/concurrent/Executor;)Ljava/util/concurrent/CompletionStage;", methodCache: &CompletionStageForward.thenCombineAsync_MethodID_65, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CompletionStageForward( javaObject: __return ) : nil
    }

    open func thenCombineAsync( _ _other: CompletionStage?, _ _fn: BiFunction?, _ _executor: Executor? ) -> CompletionStage! {
        return thenCombineAsync( other: _other, fn: _fn, executor: _executor )
    }

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.thenCompose(java.util.function.Function)

    private static var thenCompose_MethodID_66: jmethodID?

    open func thenCompose( fn: Function? ) -> CompletionStage! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: fn, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "thenCompose", methodSig: "(Ljava/util/function/Function;)Ljava/util/concurrent/CompletionStage;", methodCache: &CompletionStageForward.thenCompose_MethodID_66, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CompletionStageForward( javaObject: __return ) : nil
    }

    open func thenCompose( _ _fn: Function? ) -> CompletionStage! {
        return thenCompose( fn: _fn )
    }

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.thenComposeAsync(java.util.function.Function)

    private static var thenComposeAsync_MethodID_67: jmethodID?

    open func thenComposeAsync( fn: Function? ) -> CompletionStage! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: fn, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "thenComposeAsync", methodSig: "(Ljava/util/function/Function;)Ljava/util/concurrent/CompletionStage;", methodCache: &CompletionStageForward.thenComposeAsync_MethodID_67, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CompletionStageForward( javaObject: __return ) : nil
    }

    open func thenComposeAsync( _ _fn: Function? ) -> CompletionStage! {
        return thenComposeAsync( fn: _fn )
    }

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.thenComposeAsync(java.util.function.Function,java.util.concurrent.Executor)

    private static var thenComposeAsync_MethodID_68: jmethodID?

    open func thenComposeAsync( fn: Function?, executor: Executor? ) -> CompletionStage! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: fn, locals: &__locals )
        __args[1] = JNIType.toJava( value: executor, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "thenComposeAsync", methodSig: "(Ljava/util/function/Function;Ljava/util/concurrent/Executor;)Ljava/util/concurrent/CompletionStage;", methodCache: &CompletionStageForward.thenComposeAsync_MethodID_68, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CompletionStageForward( javaObject: __return ) : nil
    }

    open func thenComposeAsync( _ _fn: Function?, _ _executor: Executor? ) -> CompletionStage! {
        return thenComposeAsync( fn: _fn, executor: _executor )
    }

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.thenRun(java.lang.Runnable)

    private static var thenRun_MethodID_69: jmethodID?

    open func thenRun( action: java_swift.Runnable? ) -> CompletionStage! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: action, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "thenRun", methodSig: "(Ljava/lang/Runnable;)Ljava/util/concurrent/CompletionStage;", methodCache: &CompletionStageForward.thenRun_MethodID_69, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CompletionStageForward( javaObject: __return ) : nil
    }

    open func thenRun( _ _action: java_swift.Runnable? ) -> CompletionStage! {
        return thenRun( action: _action )
    }

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.thenRunAsync(java.lang.Runnable)

    private static var thenRunAsync_MethodID_70: jmethodID?

    open func thenRunAsync( action: java_swift.Runnable? ) -> CompletionStage! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: action, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "thenRunAsync", methodSig: "(Ljava/lang/Runnable;)Ljava/util/concurrent/CompletionStage;", methodCache: &CompletionStageForward.thenRunAsync_MethodID_70, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CompletionStageForward( javaObject: __return ) : nil
    }

    open func thenRunAsync( _ _action: java_swift.Runnable? ) -> CompletionStage! {
        return thenRunAsync( action: _action )
    }

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.thenRunAsync(java.lang.Runnable,java.util.concurrent.Executor)

    private static var thenRunAsync_MethodID_71: jmethodID?

    open func thenRunAsync( action: java_swift.Runnable?, executor: Executor? ) -> CompletionStage! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: action, locals: &__locals )
        __args[1] = JNIType.toJava( value: executor, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "thenRunAsync", methodSig: "(Ljava/lang/Runnable;Ljava/util/concurrent/Executor;)Ljava/util/concurrent/CompletionStage;", methodCache: &CompletionStageForward.thenRunAsync_MethodID_71, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CompletionStageForward( javaObject: __return ) : nil
    }

    open func thenRunAsync( _ _action: java_swift.Runnable?, _ _executor: Executor? ) -> CompletionStage! {
        return thenRunAsync( action: _action, executor: _executor )
    }

    /// public abstract java.util.concurrent.CompletableFuture java.util.concurrent.CompletionStage.toCompletableFuture()

    // Skipping method: false false true false false 

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.whenComplete(java.util.function.BiConsumer)

    private static var whenComplete_MethodID_72: jmethodID?

    open func whenComplete( action: BiConsumer? ) -> CompletionStage! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: action, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "whenComplete", methodSig: "(Ljava/util/function/BiConsumer;)Ljava/util/concurrent/CompletionStage;", methodCache: &CompletionStageForward.whenComplete_MethodID_72, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CompletionStageForward( javaObject: __return ) : nil
    }

    open func whenComplete( _ _action: BiConsumer? ) -> CompletionStage! {
        return whenComplete( action: _action )
    }

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.whenCompleteAsync(java.util.function.BiConsumer)

    private static var whenCompleteAsync_MethodID_73: jmethodID?

    open func whenCompleteAsync( action: BiConsumer? ) -> CompletionStage! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: action, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "whenCompleteAsync", methodSig: "(Ljava/util/function/BiConsumer;)Ljava/util/concurrent/CompletionStage;", methodCache: &CompletionStageForward.whenCompleteAsync_MethodID_73, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CompletionStageForward( javaObject: __return ) : nil
    }

    open func whenCompleteAsync( _ _action: BiConsumer? ) -> CompletionStage! {
        return whenCompleteAsync( action: _action )
    }

    /// public abstract java.util.concurrent.CompletionStage java.util.concurrent.CompletionStage.whenCompleteAsync(java.util.function.BiConsumer,java.util.concurrent.Executor)

    private static var whenCompleteAsync_MethodID_74: jmethodID?

    open func whenCompleteAsync( action: BiConsumer?, executor: Executor? ) -> CompletionStage! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: action, locals: &__locals )
        __args[1] = JNIType.toJava( value: executor, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "whenCompleteAsync", methodSig: "(Ljava/util/function/BiConsumer;Ljava/util/concurrent/Executor;)Ljava/util/concurrent/CompletionStage;", methodCache: &CompletionStageForward.whenCompleteAsync_MethodID_74, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CompletionStageForward( javaObject: __return ) : nil
    }

    open func whenCompleteAsync( _ _action: BiConsumer?, _ _executor: Executor? ) -> CompletionStage! {
        return whenCompleteAsync( action: _action, executor: _executor )
    }

}

