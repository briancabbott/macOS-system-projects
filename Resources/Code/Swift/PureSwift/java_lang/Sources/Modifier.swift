
import java_swift

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// class java.lang.reflect.Modifier ///

open class Modifier: java_swift.JavaObject {

    public convenience init?( casting object: java_swift.JavaObject, _ file: StaticString = #file, _ line: Int = #line ) {
        self.init( javaObject: nil )
        object.withJavaObject {
            self.javaObject = $0
        }
    }

    private static var ModifierJNIClass: jclass?

    /// public static final int java.lang.reflect.Modifier.ABSTRACT

    private static var ABSTRACT_FieldID: jfieldID?

    public static var ABSTRACT: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "ABSTRACT", fieldType: "I", fieldCache: &ABSTRACT_FieldID, className: "java/lang/reflect/Modifier", classCache: &ModifierJNIClass )
            return Int(__value)
        }
    }

    /// static final int java.lang.reflect.Modifier.ACCESS_MODIFIERS

    // Skipping field: true false false false false false 

    /// static final int java.lang.reflect.Modifier.ANNOTATION

    // Skipping field: true false false false false false 

    /// static final int java.lang.reflect.Modifier.BRIDGE

    // Skipping field: true false false false false false 

    /// private static final int java.lang.reflect.Modifier.CLASS_MODIFIERS

    /// private static final int java.lang.reflect.Modifier.CONSTRUCTOR_MODIFIERS

    /// static final int java.lang.reflect.Modifier.ENUM

    // Skipping field: true false false false false false 

    /// private static final int java.lang.reflect.Modifier.FIELD_MODIFIERS

    /// public static final int java.lang.reflect.Modifier.FINAL

    private static var FINAL_FieldID: jfieldID?

    public static var FINAL: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "FINAL", fieldType: "I", fieldCache: &FINAL_FieldID, className: "java/lang/reflect/Modifier", classCache: &ModifierJNIClass )
            return Int(__value)
        }
    }

    /// public static final int java.lang.reflect.Modifier.INTERFACE

    private static var INTERFACE_FieldID: jfieldID?

    public static var INTERFACE: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "INTERFACE", fieldType: "I", fieldCache: &INTERFACE_FieldID, className: "java/lang/reflect/Modifier", classCache: &ModifierJNIClass )
            return Int(__value)
        }
    }

    /// private static final int java.lang.reflect.Modifier.INTERFACE_MODIFIERS

    /// static final int java.lang.reflect.Modifier.MANDATED

    // Skipping field: true false false false false false 

    /// private static final int java.lang.reflect.Modifier.METHOD_MODIFIERS

    /// public static final int java.lang.reflect.Modifier.NATIVE

    private static var NATIVE_FieldID: jfieldID?

    public static var NATIVE: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "NATIVE", fieldType: "I", fieldCache: &NATIVE_FieldID, className: "java/lang/reflect/Modifier", classCache: &ModifierJNIClass )
            return Int(__value)
        }
    }

    /// private static final int java.lang.reflect.Modifier.PARAMETER_MODIFIERS

    /// public static final int java.lang.reflect.Modifier.PRIVATE

    private static var PRIVATE_FieldID: jfieldID?

    public static var PRIVATE: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "PRIVATE", fieldType: "I", fieldCache: &PRIVATE_FieldID, className: "java/lang/reflect/Modifier", classCache: &ModifierJNIClass )
            return Int(__value)
        }
    }

    /// public static final int java.lang.reflect.Modifier.PROTECTED

    private static var PROTECTED_FieldID: jfieldID?

    public static var PROTECTED: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "PROTECTED", fieldType: "I", fieldCache: &PROTECTED_FieldID, className: "java/lang/reflect/Modifier", classCache: &ModifierJNIClass )
            return Int(__value)
        }
    }

    /// public static final int java.lang.reflect.Modifier.PUBLIC

    private static var PUBLIC_FieldID: jfieldID?

    public static var PUBLIC: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "PUBLIC", fieldType: "I", fieldCache: &PUBLIC_FieldID, className: "java/lang/reflect/Modifier", classCache: &ModifierJNIClass )
            return Int(__value)
        }
    }

    /// public static final int java.lang.reflect.Modifier.STATIC

    private static var STATIC_FieldID: jfieldID?

    public static var STATIC: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "STATIC", fieldType: "I", fieldCache: &STATIC_FieldID, className: "java/lang/reflect/Modifier", classCache: &ModifierJNIClass )
            return Int(__value)
        }
    }

    /// public static final int java.lang.reflect.Modifier.STRICT

    private static var STRICT_FieldID: jfieldID?

    public static var STRICT: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "STRICT", fieldType: "I", fieldCache: &STRICT_FieldID, className: "java/lang/reflect/Modifier", classCache: &ModifierJNIClass )
            return Int(__value)
        }
    }

    /// public static final int java.lang.reflect.Modifier.SYNCHRONIZED

    private static var SYNCHRONIZED_FieldID: jfieldID?

    public static var SYNCHRONIZED: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "SYNCHRONIZED", fieldType: "I", fieldCache: &SYNCHRONIZED_FieldID, className: "java/lang/reflect/Modifier", classCache: &ModifierJNIClass )
            return Int(__value)
        }
    }

    /// static final int java.lang.reflect.Modifier.SYNTHETIC

    // Skipping field: true false false false false false 

    /// public static final int java.lang.reflect.Modifier.TRANSIENT

    private static var TRANSIENT_FieldID: jfieldID?

    public static var TRANSIENT: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "TRANSIENT", fieldType: "I", fieldCache: &TRANSIENT_FieldID, className: "java/lang/reflect/Modifier", classCache: &ModifierJNIClass )
            return Int(__value)
        }
    }

    /// static final int java.lang.reflect.Modifier.VARARGS

    // Skipping field: true false false false false false 

    /// public static final int java.lang.reflect.Modifier.VOLATILE

    private static var VOLATILE_FieldID: jfieldID?

    public static var VOLATILE: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "VOLATILE", fieldType: "I", fieldCache: &VOLATILE_FieldID, className: "java/lang/reflect/Modifier", classCache: &ModifierJNIClass )
            return Int(__value)
        }
    }

    /// public java.lang.reflect.Modifier()

    private static var new_MethodID_1: jmethodID?

    public convenience init() {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __object = JNIMethod.NewObject( className: "java/lang/reflect/Modifier", classCache: &Modifier.ModifierJNIClass, methodSig: "()V", methodCache: &Modifier.new_MethodID_1, args: &__args, locals: &__locals )
        self.init( javaObject: __object )
        JNI.DeleteLocalRef( __object )
    }

    /// public static int java.lang.reflect.Modifier.classModifiers()

    private static var classModifiers_MethodID_2: jmethodID?

    open class func classModifiers() -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/lang/reflect/Modifier", classCache: &ModifierJNIClass, methodName: "classModifiers", methodSig: "()I", methodCache: &classModifiers_MethodID_2, args: &__args, locals: &__locals )
        return Int(__return)
    }


    /// public static int java.lang.reflect.Modifier.constructorModifiers()

    private static var constructorModifiers_MethodID_3: jmethodID?

    open class func constructorModifiers() -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/lang/reflect/Modifier", classCache: &ModifierJNIClass, methodName: "constructorModifiers", methodSig: "()I", methodCache: &constructorModifiers_MethodID_3, args: &__args, locals: &__locals )
        return Int(__return)
    }


    /// public static int java.lang.reflect.Modifier.fieldModifiers()

    private static var fieldModifiers_MethodID_4: jmethodID?

    open class func fieldModifiers() -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/lang/reflect/Modifier", classCache: &ModifierJNIClass, methodName: "fieldModifiers", methodSig: "()I", methodCache: &fieldModifiers_MethodID_4, args: &__args, locals: &__locals )
        return Int(__return)
    }


    /// public static int java.lang.reflect.Modifier.interfaceModifiers()

    private static var interfaceModifiers_MethodID_5: jmethodID?

    open class func interfaceModifiers() -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/lang/reflect/Modifier", classCache: &ModifierJNIClass, methodName: "interfaceModifiers", methodSig: "()I", methodCache: &interfaceModifiers_MethodID_5, args: &__args, locals: &__locals )
        return Int(__return)
    }


    /// public static boolean java.lang.reflect.Modifier.isAbstract(int)

    private static var isAbstract_MethodID_6: jmethodID?

    open class func isAbstract( mod: Int ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(mod) )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/lang/reflect/Modifier", classCache: &ModifierJNIClass, methodName: "isAbstract", methodSig: "(I)Z", methodCache: &isAbstract_MethodID_6, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open class func isAbstract( _ _mod: Int ) -> Bool {
        return isAbstract( mod: _mod )
    }

    /// public static boolean java.lang.reflect.Modifier.isFinal(int)

    private static var isFinal_MethodID_7: jmethodID?

    open class func isFinal( mod: Int ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(mod) )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/lang/reflect/Modifier", classCache: &ModifierJNIClass, methodName: "isFinal", methodSig: "(I)Z", methodCache: &isFinal_MethodID_7, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open class func isFinal( _ _mod: Int ) -> Bool {
        return isFinal( mod: _mod )
    }

    /// public static boolean java.lang.reflect.Modifier.isInterface(int)

    private static var isInterface_MethodID_8: jmethodID?

    open class func isInterface( mod: Int ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(mod) )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/lang/reflect/Modifier", classCache: &ModifierJNIClass, methodName: "isInterface", methodSig: "(I)Z", methodCache: &isInterface_MethodID_8, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open class func isInterface( _ _mod: Int ) -> Bool {
        return isInterface( mod: _mod )
    }

    /// static boolean java.lang.reflect.Modifier.isMandated(int)

    // Skipping method: true false false false false 

    /// public static boolean java.lang.reflect.Modifier.isNative(int)

    private static var isNative_MethodID_9: jmethodID?

    open class func isNative( mod: Int ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(mod) )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/lang/reflect/Modifier", classCache: &ModifierJNIClass, methodName: "isNative", methodSig: "(I)Z", methodCache: &isNative_MethodID_9, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open class func isNative( _ _mod: Int ) -> Bool {
        return isNative( mod: _mod )
    }

    /// public static boolean java.lang.reflect.Modifier.isPrivate(int)

    private static var isPrivate_MethodID_10: jmethodID?

    open class func isPrivate( mod: Int ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(mod) )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/lang/reflect/Modifier", classCache: &ModifierJNIClass, methodName: "isPrivate", methodSig: "(I)Z", methodCache: &isPrivate_MethodID_10, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open class func isPrivate( _ _mod: Int ) -> Bool {
        return isPrivate( mod: _mod )
    }

    /// public static boolean java.lang.reflect.Modifier.isProtected(int)

    private static var isProtected_MethodID_11: jmethodID?

    open class func isProtected( mod: Int ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(mod) )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/lang/reflect/Modifier", classCache: &ModifierJNIClass, methodName: "isProtected", methodSig: "(I)Z", methodCache: &isProtected_MethodID_11, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open class func isProtected( _ _mod: Int ) -> Bool {
        return isProtected( mod: _mod )
    }

    /// public static boolean java.lang.reflect.Modifier.isPublic(int)

    private static var isPublic_MethodID_12: jmethodID?

    open class func isPublic( mod: Int ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(mod) )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/lang/reflect/Modifier", classCache: &ModifierJNIClass, methodName: "isPublic", methodSig: "(I)Z", methodCache: &isPublic_MethodID_12, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open class func isPublic( _ _mod: Int ) -> Bool {
        return isPublic( mod: _mod )
    }

    /// public static boolean java.lang.reflect.Modifier.isStatic(int)

    private static var isStatic_MethodID_13: jmethodID?

    open class func isStatic( mod: Int ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(mod) )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/lang/reflect/Modifier", classCache: &ModifierJNIClass, methodName: "isStatic", methodSig: "(I)Z", methodCache: &isStatic_MethodID_13, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open class func isStatic( _ _mod: Int ) -> Bool {
        return isStatic( mod: _mod )
    }

    /// public static boolean java.lang.reflect.Modifier.isStrict(int)

    private static var isStrict_MethodID_14: jmethodID?

    open class func isStrict( mod: Int ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(mod) )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/lang/reflect/Modifier", classCache: &ModifierJNIClass, methodName: "isStrict", methodSig: "(I)Z", methodCache: &isStrict_MethodID_14, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open class func isStrict( _ _mod: Int ) -> Bool {
        return isStrict( mod: _mod )
    }

    /// public static boolean java.lang.reflect.Modifier.isSynchronized(int)

    private static var isSynchronized_MethodID_15: jmethodID?

    open class func isSynchronized( mod: Int ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(mod) )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/lang/reflect/Modifier", classCache: &ModifierJNIClass, methodName: "isSynchronized", methodSig: "(I)Z", methodCache: &isSynchronized_MethodID_15, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open class func isSynchronized( _ _mod: Int ) -> Bool {
        return isSynchronized( mod: _mod )
    }

    /// static boolean java.lang.reflect.Modifier.isSynthetic(int)

    // Skipping method: true false false false false 

    /// public static boolean java.lang.reflect.Modifier.isTransient(int)

    private static var isTransient_MethodID_16: jmethodID?

    open class func isTransient( mod: Int ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(mod) )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/lang/reflect/Modifier", classCache: &ModifierJNIClass, methodName: "isTransient", methodSig: "(I)Z", methodCache: &isTransient_MethodID_16, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open class func isTransient( _ _mod: Int ) -> Bool {
        return isTransient( mod: _mod )
    }

    /// public static boolean java.lang.reflect.Modifier.isVolatile(int)

    private static var isVolatile_MethodID_17: jmethodID?

    open class func isVolatile( mod: Int ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(mod) )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/lang/reflect/Modifier", classCache: &ModifierJNIClass, methodName: "isVolatile", methodSig: "(I)Z", methodCache: &isVolatile_MethodID_17, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open class func isVolatile( _ _mod: Int ) -> Bool {
        return isVolatile( mod: _mod )
    }

    /// public static int java.lang.reflect.Modifier.methodModifiers()

    private static var methodModifiers_MethodID_18: jmethodID?

    open class func methodModifiers() -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/lang/reflect/Modifier", classCache: &ModifierJNIClass, methodName: "methodModifiers", methodSig: "()I", methodCache: &methodModifiers_MethodID_18, args: &__args, locals: &__locals )
        return Int(__return)
    }


    /// public static int java.lang.reflect.Modifier.parameterModifiers()

    private static var parameterModifiers_MethodID_19: jmethodID?

    open class func parameterModifiers() -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/lang/reflect/Modifier", classCache: &ModifierJNIClass, methodName: "parameterModifiers", methodSig: "()I", methodCache: &parameterModifiers_MethodID_19, args: &__args, locals: &__locals )
        return Int(__return)
    }


    /// public static java.lang.String java.lang.reflect.Modifier.toString(int)

    private static var toString_MethodID_20: jmethodID?

    open class func toString( mod: Int ) -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(mod) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/lang/reflect/Modifier", classCache: &ModifierJNIClass, methodName: "toString", methodSig: "(I)Ljava/lang/String;", methodCache: &toString_MethodID_20, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? String( javaObject: __return ) : nil
    }

    open class func toString( _ _mod: Int ) -> String! {
        return toString( mod: _mod )
    }

}

