
import java_swift

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// interface java.lang.management.ThreadMXBean ///

public protocol ThreadMXBean: PlatformManagedObject {

    /// public abstract java.lang.management.ThreadInfo[] java.lang.management.ThreadMXBean.dumpAllThreads(boolean,boolean)

    func dumpAllThreads( lockedMonitors: Bool, lockedSynchronizers: Bool ) -> [ThreadInfo]!

    /// public abstract long[] java.lang.management.ThreadMXBean.findDeadlockedThreads()

    func findDeadlockedThreads() -> [Int64]!

    /// public abstract long[] java.lang.management.ThreadMXBean.findMonitorDeadlockedThreads()

    func findMonitorDeadlockedThreads() -> [Int64]!

    /// public abstract long[] java.lang.management.ThreadMXBean.getAllThreadIds()

    func getAllThreadIds() -> [Int64]!

    /// public abstract long java.lang.management.ThreadMXBean.getCurrentThreadCpuTime()

    func getCurrentThreadCpuTime() -> Int64

    /// public abstract long java.lang.management.ThreadMXBean.getCurrentThreadUserTime()

    func getCurrentThreadUserTime() -> Int64

    /// public abstract int java.lang.management.ThreadMXBean.getDaemonThreadCount()

    func getDaemonThreadCount() -> Int

    /// public abstract int java.lang.management.ThreadMXBean.getPeakThreadCount()

    func getPeakThreadCount() -> Int

    /// public abstract int java.lang.management.ThreadMXBean.getThreadCount()

    func getThreadCount() -> Int

    /// public abstract long java.lang.management.ThreadMXBean.getThreadCpuTime(long)

    func getThreadCpuTime( id: Int64 ) -> Int64

    /// public abstract java.lang.management.ThreadInfo java.lang.management.ThreadMXBean.getThreadInfo(long)

    func getThreadInfo( id: Int64 ) -> ThreadInfo!

    /// public abstract java.lang.management.ThreadInfo java.lang.management.ThreadMXBean.getThreadInfo(long,int)

    func getThreadInfo( id: Int64, maxDepth: Int ) -> ThreadInfo!

    /// public abstract java.lang.management.ThreadInfo[] java.lang.management.ThreadMXBean.getThreadInfo(long[])

    func getThreadInfo( ids: [Int64]? ) -> [ThreadInfo]!

    /// public abstract java.lang.management.ThreadInfo[] java.lang.management.ThreadMXBean.getThreadInfo(long[],boolean,boolean)

    func getThreadInfo( ids: [Int64]?, lockedMonitors: Bool, lockedSynchronizers: Bool ) -> [ThreadInfo]!

    /// public abstract java.lang.management.ThreadInfo[] java.lang.management.ThreadMXBean.getThreadInfo(long[],int)

    func getThreadInfo( ids: [Int64]?, maxDepth: Int ) -> [ThreadInfo]!

    /// public abstract long java.lang.management.ThreadMXBean.getThreadUserTime(long)

    func getThreadUserTime( id: Int64 ) -> Int64

    /// public abstract long java.lang.management.ThreadMXBean.getTotalStartedThreadCount()

    func getTotalStartedThreadCount() -> Int64

    /// public abstract boolean java.lang.management.ThreadMXBean.isCurrentThreadCpuTimeSupported()

    func isCurrentThreadCpuTimeSupported() -> Bool

    /// public abstract boolean java.lang.management.ThreadMXBean.isObjectMonitorUsageSupported()

    func isObjectMonitorUsageSupported() -> Bool

    /// public abstract boolean java.lang.management.ThreadMXBean.isSynchronizerUsageSupported()

    func isSynchronizerUsageSupported() -> Bool

    /// public abstract boolean java.lang.management.ThreadMXBean.isThreadContentionMonitoringEnabled()

    func isThreadContentionMonitoringEnabled() -> Bool

    /// public abstract boolean java.lang.management.ThreadMXBean.isThreadContentionMonitoringSupported()

    func isThreadContentionMonitoringSupported() -> Bool

    /// public abstract boolean java.lang.management.ThreadMXBean.isThreadCpuTimeEnabled()

    func isThreadCpuTimeEnabled() -> Bool

    /// public abstract boolean java.lang.management.ThreadMXBean.isThreadCpuTimeSupported()

    func isThreadCpuTimeSupported() -> Bool

    /// public abstract void java.lang.management.ThreadMXBean.resetPeakThreadCount()

    func resetPeakThreadCount()

    /// public abstract void java.lang.management.ThreadMXBean.setThreadContentionMonitoringEnabled(boolean)

    func setThreadContentionMonitoringEnabled( enable: Bool )

    /// public abstract void java.lang.management.ThreadMXBean.setThreadCpuTimeEnabled(boolean)

    func setThreadCpuTimeEnabled( enable: Bool )

}


open class ThreadMXBeanForward: PlatformManagedObjectForward, ThreadMXBean {

    private static var ThreadMXBeanJNIClass: jclass?

    /// public abstract java.lang.management.ThreadInfo[] java.lang.management.ThreadMXBean.dumpAllThreads(boolean,boolean)

    private static var dumpAllThreads_MethodID_28: jmethodID?

    open func dumpAllThreads( lockedMonitors: Bool, lockedSynchronizers: Bool ) -> [ThreadInfo]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = jvalue( z: jboolean(lockedMonitors ? JNI_TRUE : JNI_FALSE) )
        __args[1] = jvalue( z: jboolean(lockedSynchronizers ? JNI_TRUE : JNI_FALSE) )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "dumpAllThreads", methodSig: "(ZZ)[Ljava/lang/management/ThreadInfo;", methodCache: &ThreadMXBeanForward.dumpAllThreads_MethodID_28, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [ThreadInfo].self, from: __return )
    }

    open func dumpAllThreads( _ _lockedMonitors: Bool, _ _lockedSynchronizers: Bool ) -> [ThreadInfo]! {
        return dumpAllThreads( lockedMonitors: _lockedMonitors, lockedSynchronizers: _lockedSynchronizers )
    }

    /// public abstract long[] java.lang.management.ThreadMXBean.findDeadlockedThreads()

    private static var findDeadlockedThreads_MethodID_29: jmethodID?

    open func findDeadlockedThreads() -> [Int64]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "findDeadlockedThreads", methodSig: "()[J", methodCache: &ThreadMXBeanForward.findDeadlockedThreads_MethodID_29, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [Int64].self, from: __return )
    }


    /// public abstract long[] java.lang.management.ThreadMXBean.findMonitorDeadlockedThreads()

    private static var findMonitorDeadlockedThreads_MethodID_30: jmethodID?

    open func findMonitorDeadlockedThreads() -> [Int64]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "findMonitorDeadlockedThreads", methodSig: "()[J", methodCache: &ThreadMXBeanForward.findMonitorDeadlockedThreads_MethodID_30, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [Int64].self, from: __return )
    }


    /// public abstract long[] java.lang.management.ThreadMXBean.getAllThreadIds()

    private static var getAllThreadIds_MethodID_31: jmethodID?

    open func getAllThreadIds() -> [Int64]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getAllThreadIds", methodSig: "()[J", methodCache: &ThreadMXBeanForward.getAllThreadIds_MethodID_31, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [Int64].self, from: __return )
    }


    /// public abstract long java.lang.management.ThreadMXBean.getCurrentThreadCpuTime()

    private static var getCurrentThreadCpuTime_MethodID_32: jmethodID?

    open func getCurrentThreadCpuTime() -> Int64 {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "getCurrentThreadCpuTime", methodSig: "()J", methodCache: &ThreadMXBeanForward.getCurrentThreadCpuTime_MethodID_32, args: &__args, locals: &__locals )
        return __return
    }


    /// public abstract long java.lang.management.ThreadMXBean.getCurrentThreadUserTime()

    private static var getCurrentThreadUserTime_MethodID_33: jmethodID?

    open func getCurrentThreadUserTime() -> Int64 {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "getCurrentThreadUserTime", methodSig: "()J", methodCache: &ThreadMXBeanForward.getCurrentThreadUserTime_MethodID_33, args: &__args, locals: &__locals )
        return __return
    }


    /// public abstract int java.lang.management.ThreadMXBean.getDaemonThreadCount()

    private static var getDaemonThreadCount_MethodID_34: jmethodID?

    open func getDaemonThreadCount() -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getDaemonThreadCount", methodSig: "()I", methodCache: &ThreadMXBeanForward.getDaemonThreadCount_MethodID_34, args: &__args, locals: &__locals )
        return Int(__return)
    }


    /// public abstract javax.management.ObjectName java.lang.management.PlatformManagedObject.getObjectName()

    // Skipping method: false false true false false 

    /// public abstract int java.lang.management.ThreadMXBean.getPeakThreadCount()

    private static var getPeakThreadCount_MethodID_35: jmethodID?

    open func getPeakThreadCount() -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getPeakThreadCount", methodSig: "()I", methodCache: &ThreadMXBeanForward.getPeakThreadCount_MethodID_35, args: &__args, locals: &__locals )
        return Int(__return)
    }


    /// public abstract int java.lang.management.ThreadMXBean.getThreadCount()

    private static var getThreadCount_MethodID_36: jmethodID?

    open func getThreadCount() -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getThreadCount", methodSig: "()I", methodCache: &ThreadMXBeanForward.getThreadCount_MethodID_36, args: &__args, locals: &__locals )
        return Int(__return)
    }


    /// public abstract long java.lang.management.ThreadMXBean.getThreadCpuTime(long)

    private static var getThreadCpuTime_MethodID_37: jmethodID?

    open func getThreadCpuTime( id: Int64 ) -> Int64 {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( j: id )
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "getThreadCpuTime", methodSig: "(J)J", methodCache: &ThreadMXBeanForward.getThreadCpuTime_MethodID_37, args: &__args, locals: &__locals )
        return __return
    }

    open func getThreadCpuTime( _ _id: Int64 ) -> Int64 {
        return getThreadCpuTime( id: _id )
    }

    /// public abstract java.lang.management.ThreadInfo java.lang.management.ThreadMXBean.getThreadInfo(long)

    private static var getThreadInfo_MethodID_38: jmethodID?

    open func getThreadInfo( id: Int64 ) -> ThreadInfo! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( j: id )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getThreadInfo", methodSig: "(J)Ljava/lang/management/ThreadInfo;", methodCache: &ThreadMXBeanForward.getThreadInfo_MethodID_38, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? ThreadInfo( javaObject: __return ) : nil
    }

    open func getThreadInfo( _ _id: Int64 ) -> ThreadInfo! {
        return getThreadInfo( id: _id )
    }

    /// public abstract java.lang.management.ThreadInfo java.lang.management.ThreadMXBean.getThreadInfo(long,int)

    private static var getThreadInfo_MethodID_39: jmethodID?

    open func getThreadInfo( id: Int64, maxDepth: Int ) -> ThreadInfo! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = jvalue( j: id )
        __args[1] = jvalue( i: jint(maxDepth) )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getThreadInfo", methodSig: "(JI)Ljava/lang/management/ThreadInfo;", methodCache: &ThreadMXBeanForward.getThreadInfo_MethodID_39, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? ThreadInfo( javaObject: __return ) : nil
    }

    open func getThreadInfo( _ _id: Int64, _ _maxDepth: Int ) -> ThreadInfo! {
        return getThreadInfo( id: _id, maxDepth: _maxDepth )
    }

    /// public abstract java.lang.management.ThreadInfo[] java.lang.management.ThreadMXBean.getThreadInfo(long[])

    private static var getThreadInfo_MethodID_40: jmethodID?

    open func getThreadInfo( ids: [Int64]? ) -> [ThreadInfo]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: ids, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getThreadInfo", methodSig: "([J)[Ljava/lang/management/ThreadInfo;", methodCache: &ThreadMXBeanForward.getThreadInfo_MethodID_40, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [ThreadInfo].self, from: __return )
    }

    open func getThreadInfo( _ _ids: [Int64]? ) -> [ThreadInfo]! {
        return getThreadInfo( ids: _ids )
    }

    /// public abstract java.lang.management.ThreadInfo[] java.lang.management.ThreadMXBean.getThreadInfo(long[],boolean,boolean)

    private static var getThreadInfo_MethodID_41: jmethodID?

    open func getThreadInfo( ids: [Int64]?, lockedMonitors: Bool, lockedSynchronizers: Bool ) -> [ThreadInfo]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: ids, locals: &__locals )
        __args[1] = jvalue( z: jboolean(lockedMonitors ? JNI_TRUE : JNI_FALSE) )
        __args[2] = jvalue( z: jboolean(lockedSynchronizers ? JNI_TRUE : JNI_FALSE) )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getThreadInfo", methodSig: "([JZZ)[Ljava/lang/management/ThreadInfo;", methodCache: &ThreadMXBeanForward.getThreadInfo_MethodID_41, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [ThreadInfo].self, from: __return )
    }

    open func getThreadInfo( _ _ids: [Int64]?, _ _lockedMonitors: Bool, _ _lockedSynchronizers: Bool ) -> [ThreadInfo]! {
        return getThreadInfo( ids: _ids, lockedMonitors: _lockedMonitors, lockedSynchronizers: _lockedSynchronizers )
    }

    /// public abstract java.lang.management.ThreadInfo[] java.lang.management.ThreadMXBean.getThreadInfo(long[],int)

    private static var getThreadInfo_MethodID_42: jmethodID?

    open func getThreadInfo( ids: [Int64]?, maxDepth: Int ) -> [ThreadInfo]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: ids, locals: &__locals )
        __args[1] = jvalue( i: jint(maxDepth) )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getThreadInfo", methodSig: "([JI)[Ljava/lang/management/ThreadInfo;", methodCache: &ThreadMXBeanForward.getThreadInfo_MethodID_42, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [ThreadInfo].self, from: __return )
    }

    open func getThreadInfo( _ _ids: [Int64]?, _ _maxDepth: Int ) -> [ThreadInfo]! {
        return getThreadInfo( ids: _ids, maxDepth: _maxDepth )
    }

    /// public abstract long java.lang.management.ThreadMXBean.getThreadUserTime(long)

    private static var getThreadUserTime_MethodID_43: jmethodID?

    open func getThreadUserTime( id: Int64 ) -> Int64 {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( j: id )
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "getThreadUserTime", methodSig: "(J)J", methodCache: &ThreadMXBeanForward.getThreadUserTime_MethodID_43, args: &__args, locals: &__locals )
        return __return
    }

    open func getThreadUserTime( _ _id: Int64 ) -> Int64 {
        return getThreadUserTime( id: _id )
    }

    /// public abstract long java.lang.management.ThreadMXBean.getTotalStartedThreadCount()

    private static var getTotalStartedThreadCount_MethodID_44: jmethodID?

    open func getTotalStartedThreadCount() -> Int64 {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "getTotalStartedThreadCount", methodSig: "()J", methodCache: &ThreadMXBeanForward.getTotalStartedThreadCount_MethodID_44, args: &__args, locals: &__locals )
        return __return
    }


    /// public abstract boolean java.lang.management.ThreadMXBean.isCurrentThreadCpuTimeSupported()

    private static var isCurrentThreadCpuTimeSupported_MethodID_45: jmethodID?

    open func isCurrentThreadCpuTimeSupported() -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isCurrentThreadCpuTimeSupported", methodSig: "()Z", methodCache: &ThreadMXBeanForward.isCurrentThreadCpuTimeSupported_MethodID_45, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }


    /// public abstract boolean java.lang.management.ThreadMXBean.isObjectMonitorUsageSupported()

    private static var isObjectMonitorUsageSupported_MethodID_46: jmethodID?

    open func isObjectMonitorUsageSupported() -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isObjectMonitorUsageSupported", methodSig: "()Z", methodCache: &ThreadMXBeanForward.isObjectMonitorUsageSupported_MethodID_46, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }


    /// public abstract boolean java.lang.management.ThreadMXBean.isSynchronizerUsageSupported()

    private static var isSynchronizerUsageSupported_MethodID_47: jmethodID?

    open func isSynchronizerUsageSupported() -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isSynchronizerUsageSupported", methodSig: "()Z", methodCache: &ThreadMXBeanForward.isSynchronizerUsageSupported_MethodID_47, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }


    /// public abstract boolean java.lang.management.ThreadMXBean.isThreadContentionMonitoringEnabled()

    private static var isThreadContentionMonitoringEnabled_MethodID_48: jmethodID?

    open func isThreadContentionMonitoringEnabled() -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isThreadContentionMonitoringEnabled", methodSig: "()Z", methodCache: &ThreadMXBeanForward.isThreadContentionMonitoringEnabled_MethodID_48, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }


    /// public abstract boolean java.lang.management.ThreadMXBean.isThreadContentionMonitoringSupported()

    private static var isThreadContentionMonitoringSupported_MethodID_49: jmethodID?

    open func isThreadContentionMonitoringSupported() -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isThreadContentionMonitoringSupported", methodSig: "()Z", methodCache: &ThreadMXBeanForward.isThreadContentionMonitoringSupported_MethodID_49, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }


    /// public abstract boolean java.lang.management.ThreadMXBean.isThreadCpuTimeEnabled()

    private static var isThreadCpuTimeEnabled_MethodID_50: jmethodID?

    open func isThreadCpuTimeEnabled() -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isThreadCpuTimeEnabled", methodSig: "()Z", methodCache: &ThreadMXBeanForward.isThreadCpuTimeEnabled_MethodID_50, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }


    /// public abstract boolean java.lang.management.ThreadMXBean.isThreadCpuTimeSupported()

    private static var isThreadCpuTimeSupported_MethodID_51: jmethodID?

    open func isThreadCpuTimeSupported() -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isThreadCpuTimeSupported", methodSig: "()Z", methodCache: &ThreadMXBeanForward.isThreadCpuTimeSupported_MethodID_51, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }


    /// public abstract void java.lang.management.ThreadMXBean.resetPeakThreadCount()

    private static var resetPeakThreadCount_MethodID_52: jmethodID?

    open func resetPeakThreadCount() {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "resetPeakThreadCount", methodSig: "()V", methodCache: &ThreadMXBeanForward.resetPeakThreadCount_MethodID_52, args: &__args, locals: &__locals )
    }


    /// public abstract void java.lang.management.ThreadMXBean.setThreadContentionMonitoringEnabled(boolean)

    private static var setThreadContentionMonitoringEnabled_MethodID_53: jmethodID?

    open func setThreadContentionMonitoringEnabled( enable: Bool ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( z: jboolean(enable ? JNI_TRUE : JNI_FALSE) )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setThreadContentionMonitoringEnabled", methodSig: "(Z)V", methodCache: &ThreadMXBeanForward.setThreadContentionMonitoringEnabled_MethodID_53, args: &__args, locals: &__locals )
    }

    open func setThreadContentionMonitoringEnabled( _ _enable: Bool ) {
        setThreadContentionMonitoringEnabled( enable: _enable )
    }

    /// public abstract void java.lang.management.ThreadMXBean.setThreadCpuTimeEnabled(boolean)

    private static var setThreadCpuTimeEnabled_MethodID_54: jmethodID?

    open func setThreadCpuTimeEnabled( enable: Bool ) {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( z: jboolean(enable ? JNI_TRUE : JNI_FALSE) )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setThreadCpuTimeEnabled", methodSig: "(Z)V", methodCache: &ThreadMXBeanForward.setThreadCpuTimeEnabled_MethodID_54, args: &__args, locals: &__locals )
    }

    open func setThreadCpuTimeEnabled( _ _enable: Bool ) {
        setThreadCpuTimeEnabled( enable: _enable )
    }

    /// In declared protocol but not defined.. ///

    /// public abstract javax.management.ObjectName java.lang.management.PlatformManagedObject.getObjectName()

    // Skipping method: false false true false false 

}

