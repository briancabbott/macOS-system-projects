
import java_swift

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// class java.lang.StrictMath ///

open class StrictMath: java_swift.JavaObject {

    public convenience init?( casting object: java_swift.JavaObject, _ file: StaticString = #file, _ line: Int = #line ) {
        self.init( javaObject: nil )
        object.withJavaObject {
            self.javaObject = $0
        }
    }

    private static var StrictMathJNIClass: jclass?

    /// static final boolean java.lang.StrictMath.$assertionsDisabled

    // Skipping field: true false false false false false 

    /// public static final double java.lang.StrictMath.E

    private static var E_FieldID: jfieldID?

    public static var E: Double {
        get {
            let __value = JNIField.GetStaticDoubleField( fieldName: "E", fieldType: "D", fieldCache: &E_FieldID, className: "java/lang/StrictMath", classCache: &StrictMathJNIClass )
            return __value
        }
    }

    /// public static final double java.lang.StrictMath.PI

    private static var PI_FieldID: jfieldID?

    public static var PI: Double {
        get {
            let __value = JNIField.GetStaticDoubleField( fieldName: "PI", fieldType: "D", fieldCache: &PI_FieldID, className: "java/lang/StrictMath", classCache: &StrictMathJNIClass )
            return __value
        }
    }

    /// private java.lang.StrictMath()

    /// public static native double java.lang.StrictMath.IEEEremainder(double,double)

    private static var IEEEremainder_MethodID_1: jmethodID?

    open class func IEEEremainder( f1: Double, f2: Double ) -> Double {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = jvalue( d: f1 )
        __args[1] = jvalue( d: f2 )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "IEEEremainder", methodSig: "(DD)D", methodCache: &IEEEremainder_MethodID_1, args: &__args, locals: &__locals )
        return __return
    }

    open class func IEEEremainder( _ _f1: Double, _ _f2: Double ) -> Double {
        return IEEEremainder( f1: _f1, f2: _f2 )
    }

    /// public static double java.lang.StrictMath.abs(double)

    private static var abs_MethodID_2: jmethodID?

    open class func abs( a: Double ) -> Double {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( d: a )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "abs", methodSig: "(D)D", methodCache: &abs_MethodID_2, args: &__args, locals: &__locals )
        return __return
    }

    open class func abs( _ _a: Double ) -> Double {
        return abs( a: _a )
    }

    /// public static float java.lang.StrictMath.abs(float)

    private static var abs_MethodID_3: jmethodID?

    open class func abs( a: Float ) -> Float {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( f: a )
        let __return = JNIMethod.CallStaticFloatMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "abs", methodSig: "(F)F", methodCache: &abs_MethodID_3, args: &__args, locals: &__locals )
        return __return
    }

    open class func abs( _ _a: Float ) -> Float {
        return abs( a: _a )
    }

    /// public static int java.lang.StrictMath.abs(int)

    private static var abs_MethodID_4: jmethodID?

    open class func abs( a: Int ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(a) )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "abs", methodSig: "(I)I", methodCache: &abs_MethodID_4, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func abs( _ _a: Int ) -> Int {
        return abs( a: _a )
    }

    /// public static long java.lang.StrictMath.abs(long)

    private static var abs_MethodID_5: jmethodID?

    open class func abs( a: Int64 ) -> Int64 {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( j: a )
        let __return = JNIMethod.CallStaticLongMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "abs", methodSig: "(J)J", methodCache: &abs_MethodID_5, args: &__args, locals: &__locals )
        return __return
    }

    open class func abs( _ _a: Int64 ) -> Int64 {
        return abs( a: _a )
    }

    /// public static native double java.lang.StrictMath.acos(double)

    private static var acos_MethodID_6: jmethodID?

    open class func acos( a: Double ) -> Double {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( d: a )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "acos", methodSig: "(D)D", methodCache: &acos_MethodID_6, args: &__args, locals: &__locals )
        return __return
    }

    open class func acos( _ _a: Double ) -> Double {
        return acos( a: _a )
    }

    /// public static int java.lang.StrictMath.addExact(int,int)

    private static var addExact_MethodID_7: jmethodID?

    open class func addExact( x: Int, y: Int ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = jvalue( i: jint(x) )
        __args[1] = jvalue( i: jint(y) )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "addExact", methodSig: "(II)I", methodCache: &addExact_MethodID_7, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func addExact( _ _x: Int, _ _y: Int ) -> Int {
        return addExact( x: _x, y: _y )
    }

    /// public static long java.lang.StrictMath.addExact(long,long)

    private static var addExact_MethodID_8: jmethodID?

    open class func addExact( x: Int64, y: Int64 ) -> Int64 {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = jvalue( j: x )
        __args[1] = jvalue( j: y )
        let __return = JNIMethod.CallStaticLongMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "addExact", methodSig: "(JJ)J", methodCache: &addExact_MethodID_8, args: &__args, locals: &__locals )
        return __return
    }

    open class func addExact( _ _x: Int64, _ _y: Int64 ) -> Int64 {
        return addExact( x: _x, y: _y )
    }

    /// public static native double java.lang.StrictMath.asin(double)

    private static var asin_MethodID_9: jmethodID?

    open class func asin( a: Double ) -> Double {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( d: a )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "asin", methodSig: "(D)D", methodCache: &asin_MethodID_9, args: &__args, locals: &__locals )
        return __return
    }

    open class func asin( _ _a: Double ) -> Double {
        return asin( a: _a )
    }

    /// public static native double java.lang.StrictMath.atan(double)

    private static var atan_MethodID_10: jmethodID?

    open class func atan( a: Double ) -> Double {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( d: a )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "atan", methodSig: "(D)D", methodCache: &atan_MethodID_10, args: &__args, locals: &__locals )
        return __return
    }

    open class func atan( _ _a: Double ) -> Double {
        return atan( a: _a )
    }

    /// public static native double java.lang.StrictMath.atan2(double,double)

    private static var atan2_MethodID_11: jmethodID?

    open class func atan2( y: Double, x: Double ) -> Double {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = jvalue( d: y )
        __args[1] = jvalue( d: x )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "atan2", methodSig: "(DD)D", methodCache: &atan2_MethodID_11, args: &__args, locals: &__locals )
        return __return
    }

    open class func atan2( _ _y: Double, _ _x: Double ) -> Double {
        return atan2( y: _y, x: _x )
    }

    /// public static native double java.lang.StrictMath.cbrt(double)

    private static var cbrt_MethodID_12: jmethodID?

    open class func cbrt( a: Double ) -> Double {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( d: a )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "cbrt", methodSig: "(D)D", methodCache: &cbrt_MethodID_12, args: &__args, locals: &__locals )
        return __return
    }

    open class func cbrt( _ _a: Double ) -> Double {
        return cbrt( a: _a )
    }

    /// public static double java.lang.StrictMath.ceil(double)

    private static var ceil_MethodID_13: jmethodID?

    open class func ceil( a: Double ) -> Double {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( d: a )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "ceil", methodSig: "(D)D", methodCache: &ceil_MethodID_13, args: &__args, locals: &__locals )
        return __return
    }

    open class func ceil( _ _a: Double ) -> Double {
        return ceil( a: _a )
    }

    /// public static double java.lang.StrictMath.copySign(double,double)

    private static var copySign_MethodID_14: jmethodID?

    open class func copySign( magnitude: Double, sign: Double ) -> Double {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = jvalue( d: magnitude )
        __args[1] = jvalue( d: sign )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "copySign", methodSig: "(DD)D", methodCache: &copySign_MethodID_14, args: &__args, locals: &__locals )
        return __return
    }

    open class func copySign( _ _magnitude: Double, _ _sign: Double ) -> Double {
        return copySign( magnitude: _magnitude, sign: _sign )
    }

    /// public static float java.lang.StrictMath.copySign(float,float)

    private static var copySign_MethodID_15: jmethodID?

    open class func copySign( magnitude: Float, sign: Float ) -> Float {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = jvalue( f: magnitude )
        __args[1] = jvalue( f: sign )
        let __return = JNIMethod.CallStaticFloatMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "copySign", methodSig: "(FF)F", methodCache: &copySign_MethodID_15, args: &__args, locals: &__locals )
        return __return
    }

    open class func copySign( _ _magnitude: Float, _ _sign: Float ) -> Float {
        return copySign( magnitude: _magnitude, sign: _sign )
    }

    /// public static native double java.lang.StrictMath.cos(double)

    private static var cos_MethodID_16: jmethodID?

    open class func cos( a: Double ) -> Double {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( d: a )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "cos", methodSig: "(D)D", methodCache: &cos_MethodID_16, args: &__args, locals: &__locals )
        return __return
    }

    open class func cos( _ _a: Double ) -> Double {
        return cos( a: _a )
    }

    /// public static native double java.lang.StrictMath.cosh(double)

    private static var cosh_MethodID_17: jmethodID?

    open class func cosh( x: Double ) -> Double {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( d: x )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "cosh", methodSig: "(D)D", methodCache: &cosh_MethodID_17, args: &__args, locals: &__locals )
        return __return
    }

    open class func cosh( _ _x: Double ) -> Double {
        return cosh( x: _x )
    }

    /// public static native double java.lang.StrictMath.exp(double)

    private static var exp_MethodID_18: jmethodID?

    open class func exp( a: Double ) -> Double {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( d: a )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "exp", methodSig: "(D)D", methodCache: &exp_MethodID_18, args: &__args, locals: &__locals )
        return __return
    }

    open class func exp( _ _a: Double ) -> Double {
        return exp( a: _a )
    }

    /// public static native double java.lang.StrictMath.expm1(double)

    private static var expm1_MethodID_19: jmethodID?

    open class func expm1( x: Double ) -> Double {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( d: x )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "expm1", methodSig: "(D)D", methodCache: &expm1_MethodID_19, args: &__args, locals: &__locals )
        return __return
    }

    open class func expm1( _ _x: Double ) -> Double {
        return expm1( x: _x )
    }

    /// public static double java.lang.StrictMath.floor(double)

    private static var floor_MethodID_20: jmethodID?

    open class func floor( a: Double ) -> Double {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( d: a )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "floor", methodSig: "(D)D", methodCache: &floor_MethodID_20, args: &__args, locals: &__locals )
        return __return
    }

    open class func floor( _ _a: Double ) -> Double {
        return floor( a: _a )
    }

    /// public static int java.lang.StrictMath.floorDiv(int,int)

    private static var floorDiv_MethodID_21: jmethodID?

    open class func floorDiv( x: Int, y: Int ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = jvalue( i: jint(x) )
        __args[1] = jvalue( i: jint(y) )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "floorDiv", methodSig: "(II)I", methodCache: &floorDiv_MethodID_21, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func floorDiv( _ _x: Int, _ _y: Int ) -> Int {
        return floorDiv( x: _x, y: _y )
    }

    /// public static long java.lang.StrictMath.floorDiv(long,long)

    private static var floorDiv_MethodID_22: jmethodID?

    open class func floorDiv( x: Int64, y: Int64 ) -> Int64 {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = jvalue( j: x )
        __args[1] = jvalue( j: y )
        let __return = JNIMethod.CallStaticLongMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "floorDiv", methodSig: "(JJ)J", methodCache: &floorDiv_MethodID_22, args: &__args, locals: &__locals )
        return __return
    }

    open class func floorDiv( _ _x: Int64, _ _y: Int64 ) -> Int64 {
        return floorDiv( x: _x, y: _y )
    }

    /// public static int java.lang.StrictMath.floorMod(int,int)

    private static var floorMod_MethodID_23: jmethodID?

    open class func floorMod( x: Int, y: Int ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = jvalue( i: jint(x) )
        __args[1] = jvalue( i: jint(y) )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "floorMod", methodSig: "(II)I", methodCache: &floorMod_MethodID_23, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func floorMod( _ _x: Int, _ _y: Int ) -> Int {
        return floorMod( x: _x, y: _y )
    }

    /// public static long java.lang.StrictMath.floorMod(long,long)

    private static var floorMod_MethodID_24: jmethodID?

    open class func floorMod( x: Int64, y: Int64 ) -> Int64 {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = jvalue( j: x )
        __args[1] = jvalue( j: y )
        let __return = JNIMethod.CallStaticLongMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "floorMod", methodSig: "(JJ)J", methodCache: &floorMod_MethodID_24, args: &__args, locals: &__locals )
        return __return
    }

    open class func floorMod( _ _x: Int64, _ _y: Int64 ) -> Int64 {
        return floorMod( x: _x, y: _y )
    }

    /// private static double java.lang.StrictMath.floorOrCeil(double,double,double,double)

    /// public static int java.lang.StrictMath.getExponent(double)

    private static var getExponent_MethodID_25: jmethodID?

    open class func getExponent( d: Double ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( d: d )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "getExponent", methodSig: "(D)I", methodCache: &getExponent_MethodID_25, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func getExponent( _ _d: Double ) -> Int {
        return getExponent( d: _d )
    }

    /// public static int java.lang.StrictMath.getExponent(float)

    private static var getExponent_MethodID_26: jmethodID?

    open class func getExponent( f: Float ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( f: f )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "getExponent", methodSig: "(F)I", methodCache: &getExponent_MethodID_26, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func getExponent( _ _f: Float ) -> Int {
        return getExponent( f: _f )
    }

    /// public static native double java.lang.StrictMath.hypot(double,double)

    private static var hypot_MethodID_27: jmethodID?

    open class func hypot( x: Double, y: Double ) -> Double {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = jvalue( d: x )
        __args[1] = jvalue( d: y )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "hypot", methodSig: "(DD)D", methodCache: &hypot_MethodID_27, args: &__args, locals: &__locals )
        return __return
    }

    open class func hypot( _ _x: Double, _ _y: Double ) -> Double {
        return hypot( x: _x, y: _y )
    }

    /// public static native double java.lang.StrictMath.log(double)

    private static var log_MethodID_28: jmethodID?

    open class func log( a: Double ) -> Double {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( d: a )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "log", methodSig: "(D)D", methodCache: &log_MethodID_28, args: &__args, locals: &__locals )
        return __return
    }

    open class func log( _ _a: Double ) -> Double {
        return log( a: _a )
    }

    /// public static native double java.lang.StrictMath.log10(double)

    private static var log10_MethodID_29: jmethodID?

    open class func log10( a: Double ) -> Double {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( d: a )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "log10", methodSig: "(D)D", methodCache: &log10_MethodID_29, args: &__args, locals: &__locals )
        return __return
    }

    open class func log10( _ _a: Double ) -> Double {
        return log10( a: _a )
    }

    /// public static native double java.lang.StrictMath.log1p(double)

    private static var log1p_MethodID_30: jmethodID?

    open class func log1p( x: Double ) -> Double {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( d: x )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "log1p", methodSig: "(D)D", methodCache: &log1p_MethodID_30, args: &__args, locals: &__locals )
        return __return
    }

    open class func log1p( _ _x: Double ) -> Double {
        return log1p( x: _x )
    }

    /// public static double java.lang.StrictMath.max(double,double)

    private static var max_MethodID_31: jmethodID?

    open class func max( a: Double, b: Double ) -> Double {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = jvalue( d: a )
        __args[1] = jvalue( d: b )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "max", methodSig: "(DD)D", methodCache: &max_MethodID_31, args: &__args, locals: &__locals )
        return __return
    }

    open class func max( _ _a: Double, _ _b: Double ) -> Double {
        return max( a: _a, b: _b )
    }

    /// public static float java.lang.StrictMath.max(float,float)

    private static var max_MethodID_32: jmethodID?

    open class func max( a: Float, b: Float ) -> Float {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = jvalue( f: a )
        __args[1] = jvalue( f: b )
        let __return = JNIMethod.CallStaticFloatMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "max", methodSig: "(FF)F", methodCache: &max_MethodID_32, args: &__args, locals: &__locals )
        return __return
    }

    open class func max( _ _a: Float, _ _b: Float ) -> Float {
        return max( a: _a, b: _b )
    }

    /// public static int java.lang.StrictMath.max(int,int)

    private static var max_MethodID_33: jmethodID?

    open class func max( a: Int, b: Int ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = jvalue( i: jint(a) )
        __args[1] = jvalue( i: jint(b) )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "max", methodSig: "(II)I", methodCache: &max_MethodID_33, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func max( _ _a: Int, _ _b: Int ) -> Int {
        return max( a: _a, b: _b )
    }

    /// public static long java.lang.StrictMath.max(long,long)

    private static var max_MethodID_34: jmethodID?

    open class func max( a: Int64, b: Int64 ) -> Int64 {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = jvalue( j: a )
        __args[1] = jvalue( j: b )
        let __return = JNIMethod.CallStaticLongMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "max", methodSig: "(JJ)J", methodCache: &max_MethodID_34, args: &__args, locals: &__locals )
        return __return
    }

    open class func max( _ _a: Int64, _ _b: Int64 ) -> Int64 {
        return max( a: _a, b: _b )
    }

    /// public static double java.lang.StrictMath.min(double,double)

    private static var min_MethodID_35: jmethodID?

    open class func min( a: Double, b: Double ) -> Double {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = jvalue( d: a )
        __args[1] = jvalue( d: b )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "min", methodSig: "(DD)D", methodCache: &min_MethodID_35, args: &__args, locals: &__locals )
        return __return
    }

    open class func min( _ _a: Double, _ _b: Double ) -> Double {
        return min( a: _a, b: _b )
    }

    /// public static float java.lang.StrictMath.min(float,float)

    private static var min_MethodID_36: jmethodID?

    open class func min( a: Float, b: Float ) -> Float {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = jvalue( f: a )
        __args[1] = jvalue( f: b )
        let __return = JNIMethod.CallStaticFloatMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "min", methodSig: "(FF)F", methodCache: &min_MethodID_36, args: &__args, locals: &__locals )
        return __return
    }

    open class func min( _ _a: Float, _ _b: Float ) -> Float {
        return min( a: _a, b: _b )
    }

    /// public static int java.lang.StrictMath.min(int,int)

    private static var min_MethodID_37: jmethodID?

    open class func min( a: Int, b: Int ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = jvalue( i: jint(a) )
        __args[1] = jvalue( i: jint(b) )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "min", methodSig: "(II)I", methodCache: &min_MethodID_37, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func min( _ _a: Int, _ _b: Int ) -> Int {
        return min( a: _a, b: _b )
    }

    /// public static long java.lang.StrictMath.min(long,long)

    private static var min_MethodID_38: jmethodID?

    open class func min( a: Int64, b: Int64 ) -> Int64 {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = jvalue( j: a )
        __args[1] = jvalue( j: b )
        let __return = JNIMethod.CallStaticLongMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "min", methodSig: "(JJ)J", methodCache: &min_MethodID_38, args: &__args, locals: &__locals )
        return __return
    }

    open class func min( _ _a: Int64, _ _b: Int64 ) -> Int64 {
        return min( a: _a, b: _b )
    }

    /// public static int java.lang.StrictMath.multiplyExact(int,int)

    private static var multiplyExact_MethodID_39: jmethodID?

    open class func multiplyExact( x: Int, y: Int ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = jvalue( i: jint(x) )
        __args[1] = jvalue( i: jint(y) )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "multiplyExact", methodSig: "(II)I", methodCache: &multiplyExact_MethodID_39, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func multiplyExact( _ _x: Int, _ _y: Int ) -> Int {
        return multiplyExact( x: _x, y: _y )
    }

    /// public static long java.lang.StrictMath.multiplyExact(long,long)

    private static var multiplyExact_MethodID_40: jmethodID?

    open class func multiplyExact( x: Int64, y: Int64 ) -> Int64 {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = jvalue( j: x )
        __args[1] = jvalue( j: y )
        let __return = JNIMethod.CallStaticLongMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "multiplyExact", methodSig: "(JJ)J", methodCache: &multiplyExact_MethodID_40, args: &__args, locals: &__locals )
        return __return
    }

    open class func multiplyExact( _ _x: Int64, _ _y: Int64 ) -> Int64 {
        return multiplyExact( x: _x, y: _y )
    }

    /// public static double java.lang.StrictMath.nextAfter(double,double)

    private static var nextAfter_MethodID_41: jmethodID?

    open class func nextAfter( start: Double, direction: Double ) -> Double {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = jvalue( d: start )
        __args[1] = jvalue( d: direction )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "nextAfter", methodSig: "(DD)D", methodCache: &nextAfter_MethodID_41, args: &__args, locals: &__locals )
        return __return
    }

    open class func nextAfter( _ _start: Double, _ _direction: Double ) -> Double {
        return nextAfter( start: _start, direction: _direction )
    }

    /// public static float java.lang.StrictMath.nextAfter(float,double)

    private static var nextAfter_MethodID_42: jmethodID?

    open class func nextAfter( start: Float, direction: Double ) -> Float {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = jvalue( f: start )
        __args[1] = jvalue( d: direction )
        let __return = JNIMethod.CallStaticFloatMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "nextAfter", methodSig: "(FD)F", methodCache: &nextAfter_MethodID_42, args: &__args, locals: &__locals )
        return __return
    }

    open class func nextAfter( _ _start: Float, _ _direction: Double ) -> Float {
        return nextAfter( start: _start, direction: _direction )
    }

    /// public static double java.lang.StrictMath.nextDown(double)

    private static var nextDown_MethodID_43: jmethodID?

    open class func nextDown( d: Double ) -> Double {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( d: d )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "nextDown", methodSig: "(D)D", methodCache: &nextDown_MethodID_43, args: &__args, locals: &__locals )
        return __return
    }

    open class func nextDown( _ _d: Double ) -> Double {
        return nextDown( d: _d )
    }

    /// public static float java.lang.StrictMath.nextDown(float)

    private static var nextDown_MethodID_44: jmethodID?

    open class func nextDown( f: Float ) -> Float {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( f: f )
        let __return = JNIMethod.CallStaticFloatMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "nextDown", methodSig: "(F)F", methodCache: &nextDown_MethodID_44, args: &__args, locals: &__locals )
        return __return
    }

    open class func nextDown( _ _f: Float ) -> Float {
        return nextDown( f: _f )
    }

    /// public static double java.lang.StrictMath.nextUp(double)

    private static var nextUp_MethodID_45: jmethodID?

    open class func nextUp( d: Double ) -> Double {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( d: d )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "nextUp", methodSig: "(D)D", methodCache: &nextUp_MethodID_45, args: &__args, locals: &__locals )
        return __return
    }

    open class func nextUp( _ _d: Double ) -> Double {
        return nextUp( d: _d )
    }

    /// public static float java.lang.StrictMath.nextUp(float)

    private static var nextUp_MethodID_46: jmethodID?

    open class func nextUp( f: Float ) -> Float {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( f: f )
        let __return = JNIMethod.CallStaticFloatMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "nextUp", methodSig: "(F)F", methodCache: &nextUp_MethodID_46, args: &__args, locals: &__locals )
        return __return
    }

    open class func nextUp( _ _f: Float ) -> Float {
        return nextUp( f: _f )
    }

    /// public static native double java.lang.StrictMath.pow(double,double)

    private static var pow_MethodID_47: jmethodID?

    open class func pow( a: Double, b: Double ) -> Double {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = jvalue( d: a )
        __args[1] = jvalue( d: b )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "pow", methodSig: "(DD)D", methodCache: &pow_MethodID_47, args: &__args, locals: &__locals )
        return __return
    }

    open class func pow( _ _a: Double, _ _b: Double ) -> Double {
        return pow( a: _a, b: _b )
    }

    /// public static double java.lang.StrictMath.random()

    private static var random_MethodID_48: jmethodID?

    open class func random() -> Double {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "random", methodSig: "()D", methodCache: &random_MethodID_48, args: &__args, locals: &__locals )
        return __return
    }


    /// public static double java.lang.StrictMath.rint(double)

    private static var rint_MethodID_49: jmethodID?

    open class func rint( a: Double ) -> Double {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( d: a )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "rint", methodSig: "(D)D", methodCache: &rint_MethodID_49, args: &__args, locals: &__locals )
        return __return
    }

    open class func rint( _ _a: Double ) -> Double {
        return rint( a: _a )
    }

    /// public static long java.lang.StrictMath.round(double)

    private static var round_MethodID_50: jmethodID?

    open class func round( a: Double ) -> Int64 {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( d: a )
        let __return = JNIMethod.CallStaticLongMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "round", methodSig: "(D)J", methodCache: &round_MethodID_50, args: &__args, locals: &__locals )
        return __return
    }

    open class func round( _ _a: Double ) -> Int64 {
        return round( a: _a )
    }

    /// public static int java.lang.StrictMath.round(float)

    private static var round_MethodID_51: jmethodID?

    open class func round( a: Float ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( f: a )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "round", methodSig: "(F)I", methodCache: &round_MethodID_51, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func round( _ _a: Float ) -> Int {
        return round( a: _a )
    }

    /// public static double java.lang.StrictMath.scalb(double,int)

    private static var scalb_MethodID_52: jmethodID?

    open class func scalb( d: Double, scaleFactor: Int ) -> Double {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = jvalue( d: d )
        __args[1] = jvalue( i: jint(scaleFactor) )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "scalb", methodSig: "(DI)D", methodCache: &scalb_MethodID_52, args: &__args, locals: &__locals )
        return __return
    }

    open class func scalb( _ _d: Double, _ _scaleFactor: Int ) -> Double {
        return scalb( d: _d, scaleFactor: _scaleFactor )
    }

    /// public static float java.lang.StrictMath.scalb(float,int)

    private static var scalb_MethodID_53: jmethodID?

    open class func scalb( f: Float, scaleFactor: Int ) -> Float {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = jvalue( f: f )
        __args[1] = jvalue( i: jint(scaleFactor) )
        let __return = JNIMethod.CallStaticFloatMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "scalb", methodSig: "(FI)F", methodCache: &scalb_MethodID_53, args: &__args, locals: &__locals )
        return __return
    }

    open class func scalb( _ _f: Float, _ _scaleFactor: Int ) -> Float {
        return scalb( f: _f, scaleFactor: _scaleFactor )
    }

    /// public static double java.lang.StrictMath.signum(double)

    private static var signum_MethodID_54: jmethodID?

    open class func signum( d: Double ) -> Double {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( d: d )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "signum", methodSig: "(D)D", methodCache: &signum_MethodID_54, args: &__args, locals: &__locals )
        return __return
    }

    open class func signum( _ _d: Double ) -> Double {
        return signum( d: _d )
    }

    /// public static float java.lang.StrictMath.signum(float)

    private static var signum_MethodID_55: jmethodID?

    open class func signum( f: Float ) -> Float {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( f: f )
        let __return = JNIMethod.CallStaticFloatMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "signum", methodSig: "(F)F", methodCache: &signum_MethodID_55, args: &__args, locals: &__locals )
        return __return
    }

    open class func signum( _ _f: Float ) -> Float {
        return signum( f: _f )
    }

    /// public static native double java.lang.StrictMath.sin(double)

    private static var sin_MethodID_56: jmethodID?

    open class func sin( a: Double ) -> Double {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( d: a )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "sin", methodSig: "(D)D", methodCache: &sin_MethodID_56, args: &__args, locals: &__locals )
        return __return
    }

    open class func sin( _ _a: Double ) -> Double {
        return sin( a: _a )
    }

    /// public static native double java.lang.StrictMath.sinh(double)

    private static var sinh_MethodID_57: jmethodID?

    open class func sinh( x: Double ) -> Double {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( d: x )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "sinh", methodSig: "(D)D", methodCache: &sinh_MethodID_57, args: &__args, locals: &__locals )
        return __return
    }

    open class func sinh( _ _x: Double ) -> Double {
        return sinh( x: _x )
    }

    /// public static native double java.lang.StrictMath.sqrt(double)

    private static var sqrt_MethodID_58: jmethodID?

    open class func sqrt( a: Double ) -> Double {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( d: a )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "sqrt", methodSig: "(D)D", methodCache: &sqrt_MethodID_58, args: &__args, locals: &__locals )
        return __return
    }

    open class func sqrt( _ _a: Double ) -> Double {
        return sqrt( a: _a )
    }

    /// public static int java.lang.StrictMath.subtractExact(int,int)

    private static var subtractExact_MethodID_59: jmethodID?

    open class func subtractExact( x: Int, y: Int ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = jvalue( i: jint(x) )
        __args[1] = jvalue( i: jint(y) )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "subtractExact", methodSig: "(II)I", methodCache: &subtractExact_MethodID_59, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func subtractExact( _ _x: Int, _ _y: Int ) -> Int {
        return subtractExact( x: _x, y: _y )
    }

    /// public static long java.lang.StrictMath.subtractExact(long,long)

    private static var subtractExact_MethodID_60: jmethodID?

    open class func subtractExact( x: Int64, y: Int64 ) -> Int64 {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = jvalue( j: x )
        __args[1] = jvalue( j: y )
        let __return = JNIMethod.CallStaticLongMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "subtractExact", methodSig: "(JJ)J", methodCache: &subtractExact_MethodID_60, args: &__args, locals: &__locals )
        return __return
    }

    open class func subtractExact( _ _x: Int64, _ _y: Int64 ) -> Int64 {
        return subtractExact( x: _x, y: _y )
    }

    /// public static native double java.lang.StrictMath.tan(double)

    private static var tan_MethodID_61: jmethodID?

    open class func tan( a: Double ) -> Double {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( d: a )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "tan", methodSig: "(D)D", methodCache: &tan_MethodID_61, args: &__args, locals: &__locals )
        return __return
    }

    open class func tan( _ _a: Double ) -> Double {
        return tan( a: _a )
    }

    /// public static native double java.lang.StrictMath.tanh(double)

    private static var tanh_MethodID_62: jmethodID?

    open class func tanh( x: Double ) -> Double {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( d: x )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "tanh", methodSig: "(D)D", methodCache: &tanh_MethodID_62, args: &__args, locals: &__locals )
        return __return
    }

    open class func tanh( _ _x: Double ) -> Double {
        return tanh( x: _x )
    }

    /// public static strictfp double java.lang.StrictMath.toDegrees(double)

    private static var toDegrees_MethodID_63: jmethodID?

    open class func toDegrees( angrad: Double ) -> Double {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( d: angrad )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "toDegrees", methodSig: "(D)D", methodCache: &toDegrees_MethodID_63, args: &__args, locals: &__locals )
        return __return
    }

    open class func toDegrees( _ _angrad: Double ) -> Double {
        return toDegrees( angrad: _angrad )
    }

    /// public static int java.lang.StrictMath.toIntExact(long)

    private static var toIntExact_MethodID_64: jmethodID?

    open class func toIntExact( value: Int64 ) -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( j: value )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "toIntExact", methodSig: "(J)I", methodCache: &toIntExact_MethodID_64, args: &__args, locals: &__locals )
        return Int(__return)
    }

    open class func toIntExact( _ _value: Int64 ) -> Int {
        return toIntExact( value: _value )
    }

    /// public static strictfp double java.lang.StrictMath.toRadians(double)

    private static var toRadians_MethodID_65: jmethodID?

    open class func toRadians( angdeg: Double ) -> Double {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( d: angdeg )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "toRadians", methodSig: "(D)D", methodCache: &toRadians_MethodID_65, args: &__args, locals: &__locals )
        return __return
    }

    open class func toRadians( _ _angdeg: Double ) -> Double {
        return toRadians( angdeg: _angdeg )
    }

    /// public static double java.lang.StrictMath.ulp(double)

    private static var ulp_MethodID_66: jmethodID?

    open class func ulp( d: Double ) -> Double {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( d: d )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "ulp", methodSig: "(D)D", methodCache: &ulp_MethodID_66, args: &__args, locals: &__locals )
        return __return
    }

    open class func ulp( _ _d: Double ) -> Double {
        return ulp( d: _d )
    }

    /// public static float java.lang.StrictMath.ulp(float)

    private static var ulp_MethodID_67: jmethodID?

    open class func ulp( f: Float ) -> Float {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( f: f )
        let __return = JNIMethod.CallStaticFloatMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "ulp", methodSig: "(F)F", methodCache: &ulp_MethodID_67, args: &__args, locals: &__locals )
        return __return
    }

    open class func ulp( _ _f: Float ) -> Float {
        return ulp( f: _f )
    }

}

