
import java_swift

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// class java.lang.reflect.Array ///

open class Array: java_swift.JavaObject {

    public convenience init?( casting object: java_swift.JavaObject, _ file: StaticString = #file, _ line: Int = #line ) {
        self.init( javaObject: nil )
        object.withJavaObject {
            self.javaObject = $0
        }
    }

    private static var ArrayJNIClass: jclass?

    /// private java.lang.reflect.Array()

    /// public static native java.lang.Object java.lang.reflect.Array.get(java.lang.Object,int) throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException

    private static var get_MethodID_1: jmethodID?

    open class func get( array: java_swift.JavaObject?, index: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ -> java_swift.JavaObject! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = jvalue( i: jint(index) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "get", methodSig: "(Ljava/lang/Object;I)Ljava/lang/Object;", methodCache: &get_MethodID_1, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw IllegalArgumentException( javaObject: throwable )
        }
        return __return != nil ? java_swift.JavaObject( javaObject: __return ) : nil
    }

    open class func get( _ _array: java_swift.JavaObject?, _ _index: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ -> java_swift.JavaObject! {
        return try get( array: _array, index: _index )
    }

    /// public static native boolean java.lang.reflect.Array.getBoolean(java.lang.Object,int) throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException

    private static var getBoolean_MethodID_2: jmethodID?

    open class func getBoolean( array: java_swift.JavaObject?, index: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = jvalue( i: jint(index) )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "getBoolean", methodSig: "(Ljava/lang/Object;I)Z", methodCache: &getBoolean_MethodID_2, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw IllegalArgumentException( javaObject: throwable )
        }
        return __return != jboolean(JNI_FALSE)
    }

    open class func getBoolean( _ _array: java_swift.JavaObject?, _ _index: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ -> Bool {
        return try getBoolean( array: _array, index: _index )
    }

    /// public static native byte java.lang.reflect.Array.getByte(java.lang.Object,int) throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException

    private static var getByte_MethodID_3: jmethodID?

    open class func getByte( array: java_swift.JavaObject?, index: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ -> Int8 {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = jvalue( i: jint(index) )
        let __return = JNIMethod.CallStaticByteMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "getByte", methodSig: "(Ljava/lang/Object;I)B", methodCache: &getByte_MethodID_3, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw IllegalArgumentException( javaObject: throwable )
        }
        return __return
    }

    open class func getByte( _ _array: java_swift.JavaObject?, _ _index: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ -> Int8 {
        return try getByte( array: _array, index: _index )
    }

    /// public static native char java.lang.reflect.Array.getChar(java.lang.Object,int) throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException

    private static var getChar_MethodID_4: jmethodID?

    open class func getChar( array: java_swift.JavaObject?, index: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ -> UInt16 {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = jvalue( i: jint(index) )
        let __return = JNIMethod.CallStaticCharMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "getChar", methodSig: "(Ljava/lang/Object;I)C", methodCache: &getChar_MethodID_4, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw IllegalArgumentException( javaObject: throwable )
        }
        return __return
    }

    open class func getChar( _ _array: java_swift.JavaObject?, _ _index: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ -> UInt16 {
        return try getChar( array: _array, index: _index )
    }

    /// public static native double java.lang.reflect.Array.getDouble(java.lang.Object,int) throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException

    private static var getDouble_MethodID_5: jmethodID?

    open class func getDouble( array: java_swift.JavaObject?, index: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ -> Double {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = jvalue( i: jint(index) )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "getDouble", methodSig: "(Ljava/lang/Object;I)D", methodCache: &getDouble_MethodID_5, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw IllegalArgumentException( javaObject: throwable )
        }
        return __return
    }

    open class func getDouble( _ _array: java_swift.JavaObject?, _ _index: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ -> Double {
        return try getDouble( array: _array, index: _index )
    }

    /// public static native float java.lang.reflect.Array.getFloat(java.lang.Object,int) throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException

    private static var getFloat_MethodID_6: jmethodID?

    open class func getFloat( array: java_swift.JavaObject?, index: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ -> Float {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = jvalue( i: jint(index) )
        let __return = JNIMethod.CallStaticFloatMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "getFloat", methodSig: "(Ljava/lang/Object;I)F", methodCache: &getFloat_MethodID_6, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw IllegalArgumentException( javaObject: throwable )
        }
        return __return
    }

    open class func getFloat( _ _array: java_swift.JavaObject?, _ _index: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ -> Float {
        return try getFloat( array: _array, index: _index )
    }

    /// public static native int java.lang.reflect.Array.getInt(java.lang.Object,int) throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException

    private static var getInt_MethodID_7: jmethodID?

    open class func getInt( array: java_swift.JavaObject?, index: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = jvalue( i: jint(index) )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "getInt", methodSig: "(Ljava/lang/Object;I)I", methodCache: &getInt_MethodID_7, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw IllegalArgumentException( javaObject: throwable )
        }
        return Int(__return)
    }

    open class func getInt( _ _array: java_swift.JavaObject?, _ _index: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ -> Int {
        return try getInt( array: _array, index: _index )
    }

    /// public static native int java.lang.reflect.Array.getLength(java.lang.Object) throws java.lang.IllegalArgumentException

    private static var getLength_MethodID_8: jmethodID?

    open class func getLength( array: java_swift.JavaObject? ) throws /* java.lang.IllegalArgumentException */ -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "getLength", methodSig: "(Ljava/lang/Object;)I", methodCache: &getLength_MethodID_8, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw IllegalArgumentException( javaObject: throwable )
        }
        return Int(__return)
    }

    open class func getLength( _ _array: java_swift.JavaObject? ) throws /* java.lang.IllegalArgumentException */ -> Int {
        return try getLength( array: _array )
    }

    /// public static native long java.lang.reflect.Array.getLong(java.lang.Object,int) throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException

    private static var getLong_MethodID_9: jmethodID?

    open class func getLong( array: java_swift.JavaObject?, index: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ -> Int64 {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = jvalue( i: jint(index) )
        let __return = JNIMethod.CallStaticLongMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "getLong", methodSig: "(Ljava/lang/Object;I)J", methodCache: &getLong_MethodID_9, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw IllegalArgumentException( javaObject: throwable )
        }
        return __return
    }

    open class func getLong( _ _array: java_swift.JavaObject?, _ _index: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ -> Int64 {
        return try getLong( array: _array, index: _index )
    }

    /// public static native short java.lang.reflect.Array.getShort(java.lang.Object,int) throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException

    private static var getShort_MethodID_10: jmethodID?

    open class func getShort( array: java_swift.JavaObject?, index: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ -> Int16 {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = jvalue( i: jint(index) )
        let __return = JNIMethod.CallStaticShortMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "getShort", methodSig: "(Ljava/lang/Object;I)S", methodCache: &getShort_MethodID_10, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw IllegalArgumentException( javaObject: throwable )
        }
        return __return
    }

    open class func getShort( _ _array: java_swift.JavaObject?, _ _index: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ -> Int16 {
        return try getShort( array: _array, index: _index )
    }

    /// private static native java.lang.Object java.lang.reflect.Array.multiNewArray(java.lang.Class,int[]) throws java.lang.IllegalArgumentException,java.lang.NegativeArraySizeException

    /// private static native java.lang.Object java.lang.reflect.Array.newArray(java.lang.Class,int) throws java.lang.NegativeArraySizeException

    /// public static java.lang.Object java.lang.reflect.Array.newInstance(java.lang.Class,int) throws java.lang.NegativeArraySizeException

    private static var newInstance_MethodID_11: jmethodID?

    open class func newInstance( componentType: java_swift.JavaClass?, length: Int ) throws /* java.lang.NegativeArraySizeException */ -> java_swift.JavaObject! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: componentType, locals: &__locals )
        __args[1] = jvalue( i: jint(length) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "newInstance", methodSig: "(Ljava/lang/Class;I)Ljava/lang/Object;", methodCache: &newInstance_MethodID_11, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw NegativeArraySizeException( javaObject: throwable )
        }
        return __return != nil ? java_swift.JavaObject( javaObject: __return ) : nil
    }

    open class func newInstance( _ _componentType: java_swift.JavaClass?, _ _length: Int ) throws /* java.lang.NegativeArraySizeException */ -> java_swift.JavaObject! {
        return try newInstance( componentType: _componentType, length: _length )
    }

    /// public static java.lang.Object java.lang.reflect.Array.newInstance(java.lang.Class,int[]) throws java.lang.IllegalArgumentException,java.lang.NegativeArraySizeException

    private static var newInstance_MethodID_12: jmethodID?

    open class func newInstance( componentType: java_swift.JavaClass?, dimensions: [Int32]? ) throws /* java.lang.IllegalArgumentException, java.lang.NegativeArraySizeException */ -> java_swift.JavaObject! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: componentType, locals: &__locals )
        __args[1] = JNIType.toJava( value: dimensions, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "newInstance", methodSig: "(Ljava/lang/Class;[I)Ljava/lang/Object;", methodCache: &newInstance_MethodID_12, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw IllegalArgumentException( javaObject: throwable )
        }
        return __return != nil ? java_swift.JavaObject( javaObject: __return ) : nil
    }

    open class func newInstance( _ _componentType: java_swift.JavaClass?, _ _dimensions: [Int32]? ) throws /* java.lang.IllegalArgumentException, java.lang.NegativeArraySizeException */ -> java_swift.JavaObject! {
        return try newInstance( componentType: _componentType, dimensions: _dimensions )
    }

    /// public static native void java.lang.reflect.Array.set(java.lang.Object,int,java.lang.Object) throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException

    private static var set_MethodID_13: jmethodID?

    open class func set( array: java_swift.JavaObject?, index: Int, value: java_swift.JavaObject? ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = jvalue( i: jint(index) )
        __args[2] = JNIType.toJava( value: value, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "set", methodSig: "(Ljava/lang/Object;ILjava/lang/Object;)V", methodCache: &set_MethodID_13, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw IllegalArgumentException( javaObject: throwable )
        }
    }

    open class func set( _ _array: java_swift.JavaObject?, _ _index: Int, _ _value: java_swift.JavaObject? ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ {
        try set( array: _array, index: _index, value: _value )
    }

    /// public static native void java.lang.reflect.Array.setBoolean(java.lang.Object,int,boolean) throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException

    private static var setBoolean_MethodID_14: jmethodID?

    open class func setBoolean( array: java_swift.JavaObject?, index: Int, z: Bool ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = jvalue( i: jint(index) )
        __args[2] = jvalue( z: jboolean(z ? JNI_TRUE : JNI_FALSE) )
        JNIMethod.CallStaticVoidMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "setBoolean", methodSig: "(Ljava/lang/Object;IZ)V", methodCache: &setBoolean_MethodID_14, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw IllegalArgumentException( javaObject: throwable )
        }
    }

    open class func setBoolean( _ _array: java_swift.JavaObject?, _ _index: Int, _ _z: Bool ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ {
        try setBoolean( array: _array, index: _index, z: _z )
    }

    /// public static native void java.lang.reflect.Array.setByte(java.lang.Object,int,byte) throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException

    private static var setByte_MethodID_15: jmethodID?

    open class func setByte( array: java_swift.JavaObject?, index: Int, b: Int8 ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = jvalue( i: jint(index) )
        __args[2] = jvalue( b: b )
        JNIMethod.CallStaticVoidMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "setByte", methodSig: "(Ljava/lang/Object;IB)V", methodCache: &setByte_MethodID_15, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw IllegalArgumentException( javaObject: throwable )
        }
    }

    open class func setByte( _ _array: java_swift.JavaObject?, _ _index: Int, _ _b: Int8 ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ {
        try setByte( array: _array, index: _index, b: _b )
    }

    /// public static native void java.lang.reflect.Array.setChar(java.lang.Object,int,char) throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException

    private static var setChar_MethodID_16: jmethodID?

    open class func setChar( array: java_swift.JavaObject?, index: Int, c: UInt16 ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = jvalue( i: jint(index) )
        __args[2] = jvalue( c: c )
        JNIMethod.CallStaticVoidMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "setChar", methodSig: "(Ljava/lang/Object;IC)V", methodCache: &setChar_MethodID_16, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw IllegalArgumentException( javaObject: throwable )
        }
    }

    open class func setChar( _ _array: java_swift.JavaObject?, _ _index: Int, _ _c: UInt16 ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ {
        try setChar( array: _array, index: _index, c: _c )
    }

    /// public static native void java.lang.reflect.Array.setDouble(java.lang.Object,int,double) throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException

    private static var setDouble_MethodID_17: jmethodID?

    open class func setDouble( array: java_swift.JavaObject?, index: Int, d: Double ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = jvalue( i: jint(index) )
        __args[2] = jvalue( d: d )
        JNIMethod.CallStaticVoidMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "setDouble", methodSig: "(Ljava/lang/Object;ID)V", methodCache: &setDouble_MethodID_17, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw IllegalArgumentException( javaObject: throwable )
        }
    }

    open class func setDouble( _ _array: java_swift.JavaObject?, _ _index: Int, _ _d: Double ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ {
        try setDouble( array: _array, index: _index, d: _d )
    }

    /// public static native void java.lang.reflect.Array.setFloat(java.lang.Object,int,float) throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException

    private static var setFloat_MethodID_18: jmethodID?

    open class func setFloat( array: java_swift.JavaObject?, index: Int, f: Float ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = jvalue( i: jint(index) )
        __args[2] = jvalue( f: f )
        JNIMethod.CallStaticVoidMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "setFloat", methodSig: "(Ljava/lang/Object;IF)V", methodCache: &setFloat_MethodID_18, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw IllegalArgumentException( javaObject: throwable )
        }
    }

    open class func setFloat( _ _array: java_swift.JavaObject?, _ _index: Int, _ _f: Float ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ {
        try setFloat( array: _array, index: _index, f: _f )
    }

    /// public static native void java.lang.reflect.Array.setInt(java.lang.Object,int,int) throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException

    private static var setInt_MethodID_19: jmethodID?

    open class func setInt( array: java_swift.JavaObject?, index: Int, i: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = jvalue( i: jint(index) )
        __args[2] = jvalue( i: jint(i) )
        JNIMethod.CallStaticVoidMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "setInt", methodSig: "(Ljava/lang/Object;II)V", methodCache: &setInt_MethodID_19, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw IllegalArgumentException( javaObject: throwable )
        }
    }

    open class func setInt( _ _array: java_swift.JavaObject?, _ _index: Int, _ _i: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ {
        try setInt( array: _array, index: _index, i: _i )
    }

    /// public static native void java.lang.reflect.Array.setLong(java.lang.Object,int,long) throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException

    private static var setLong_MethodID_20: jmethodID?

    open class func setLong( array: java_swift.JavaObject?, index: Int, l: Int64 ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = jvalue( i: jint(index) )
        __args[2] = jvalue( j: l )
        JNIMethod.CallStaticVoidMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "setLong", methodSig: "(Ljava/lang/Object;IJ)V", methodCache: &setLong_MethodID_20, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw IllegalArgumentException( javaObject: throwable )
        }
    }

    open class func setLong( _ _array: java_swift.JavaObject?, _ _index: Int, _ _l: Int64 ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ {
        try setLong( array: _array, index: _index, l: _l )
    }

    /// public static native void java.lang.reflect.Array.setShort(java.lang.Object,int,short) throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException

    private static var setShort_MethodID_21: jmethodID?

    open class func setShort( array: java_swift.JavaObject?, index: Int, s: Int16 ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: array, locals: &__locals )
        __args[1] = jvalue( i: jint(index) )
        __args[2] = jvalue( s: s )
        JNIMethod.CallStaticVoidMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "setShort", methodSig: "(Ljava/lang/Object;IS)V", methodCache: &setShort_MethodID_21, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw IllegalArgumentException( javaObject: throwable )
        }
    }

    open class func setShort( _ _array: java_swift.JavaObject?, _ _index: Int, _ _s: Int16 ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ {
        try setShort( array: _array, index: _index, s: _s )
    }

}

