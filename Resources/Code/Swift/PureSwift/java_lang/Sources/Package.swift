
import java_swift

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// class java.lang.Package ///

open class Package: java_swift.JavaObject, AnnotatedElement {

    public convenience init?( casting object: java_swift.JavaObject, _ file: StaticString = #file, _ line: Int = #line ) {
        self.init( javaObject: nil )
        object.withJavaObject {
            self.javaObject = $0
        }
    }

    private static var PackageJNIClass: jclass?

    /// private static java.util.Map java.lang.Package.mans

    /// private static java.util.Map java.lang.Package.pkgs

    /// private static java.util.Map java.lang.Package.urls

    /// private final java.lang.String java.lang.Package.implTitle

    /// private final java.lang.String java.lang.Package.implVendor

    /// private final java.lang.String java.lang.Package.implVersion

    /// private final transient java.lang.ClassLoader java.lang.Package.loader

    /// private transient java.lang.Class java.lang.Package.packageInfo

    /// private final java.lang.String java.lang.Package.pkgName

    /// private final java.net.URL java.lang.Package.sealBase

    /// private final java.lang.String java.lang.Package.specTitle

    /// private final java.lang.String java.lang.Package.specVendor

    /// private final java.lang.String java.lang.Package.specVersion

    /// java.lang.Package(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.net.URL,java.lang.ClassLoader)

    // Skipping init: true false false 

    /// private java.lang.Package(java.lang.String,java.util.jar.Manifest,java.net.URL,java.lang.ClassLoader)

    /// java.lang.Package(java.lang.String,java.util.jar.Manifest,java.net.URL,java.lang.ClassLoader,java.lang.Package$1)

    // Skipping init: true false false 

    /// static java.util.Map java.lang.Package.access$000()

    // Skipping method: true false false false false 

    /// static java.util.jar.Manifest java.lang.Package.access$100(java.lang.String)

    // Skipping method: true false false false false 

    /// static java.util.Map java.lang.Package.access$200()

    // Skipping method: true false false false false 

    /// static java.util.Map java.lang.Package.access$400()

    // Skipping method: true false false false false 

    /// private static java.lang.Package java.lang.Package.defineSystemPackage(java.lang.String,java.lang.String)

    /// public static java.lang.Package java.lang.Package.getPackage(java.lang.String)

    private static var getPackage_MethodID_1: jmethodID?

    open class func getPackage( name: String? ) -> Package! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: name, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/lang/Package", classCache: &PackageJNIClass, methodName: "getPackage", methodSig: "(Ljava/lang/String;)Ljava/lang/Package;", methodCache: &getPackage_MethodID_1, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? Package( javaObject: __return ) : nil
    }

    open class func getPackage( _ _name: String? ) -> Package! {
        return getPackage( name: _name )
    }

    /// static java.lang.Package java.lang.Package.getPackage(java.lang.Class)

    // Skipping method: true false false false false 

    /// public static java.lang.Package[] java.lang.Package.getPackages()

    private static var getPackages_MethodID_2: jmethodID?

    open class func getPackages() -> [Package]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/lang/Package", classCache: &PackageJNIClass, methodName: "getPackages", methodSig: "()[Ljava/lang/Package;", methodCache: &getPackages_MethodID_2, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [Package].self, from: __return )
    }


    /// static java.lang.Package java.lang.Package.getSystemPackage(java.lang.String)

    // Skipping method: true false false false false 

    /// private static native java.lang.String java.lang.Package.getSystemPackage0(java.lang.String)

    /// static java.lang.Package[] java.lang.Package.getSystemPackages()

    // Skipping method: true false false false false 

    /// private static native java.lang.String[] java.lang.Package.getSystemPackages0()

    /// private static java.util.jar.Manifest java.lang.Package.loadManifest(java.lang.String)

    /// public java.lang.annotation.Annotation java.lang.Package.getAnnotation(java.lang.Class)

    private static var getAnnotation_MethodID_3: jmethodID?

    open func getAnnotation( arg0: java_swift.JavaClass? ) -> Annotation! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getAnnotation", methodSig: "(Ljava/lang/Class;)Ljava/lang/annotation/Annotation;", methodCache: &Package.getAnnotation_MethodID_3, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? AnnotationForward( javaObject: __return ) : nil
    }

    open func getAnnotation( _ _arg0: java_swift.JavaClass? ) -> Annotation! {
        return getAnnotation( arg0: _arg0 )
    }

    /// public java.lang.annotation.Annotation[] java.lang.Package.getAnnotations()

    private static var getAnnotations_MethodID_4: jmethodID?

    open func getAnnotations() -> [Annotation]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getAnnotations", methodSig: "()[Ljava/lang/annotation/Annotation;", methodCache: &Package.getAnnotations_MethodID_4, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [AnnotationForward].self, from: __return )
    }


    /// public java.lang.annotation.Annotation[] java.lang.Package.getAnnotationsByType(java.lang.Class)

    private static var getAnnotationsByType_MethodID_5: jmethodID?

    open func getAnnotationsByType( arg0: java_swift.JavaClass? ) -> [Annotation]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getAnnotationsByType", methodSig: "(Ljava/lang/Class;)[Ljava/lang/annotation/Annotation;", methodCache: &Package.getAnnotationsByType_MethodID_5, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [AnnotationForward].self, from: __return )
    }

    open func getAnnotationsByType( _ _arg0: java_swift.JavaClass? ) -> [Annotation]! {
        return getAnnotationsByType( arg0: _arg0 )
    }

    /// public java.lang.annotation.Annotation java.lang.Package.getDeclaredAnnotation(java.lang.Class)

    private static var getDeclaredAnnotation_MethodID_6: jmethodID?

    open func getDeclaredAnnotation( arg0: java_swift.JavaClass? ) -> Annotation! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getDeclaredAnnotation", methodSig: "(Ljava/lang/Class;)Ljava/lang/annotation/Annotation;", methodCache: &Package.getDeclaredAnnotation_MethodID_6, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? AnnotationForward( javaObject: __return ) : nil
    }

    open func getDeclaredAnnotation( _ _arg0: java_swift.JavaClass? ) -> Annotation! {
        return getDeclaredAnnotation( arg0: _arg0 )
    }

    /// public java.lang.annotation.Annotation[] java.lang.Package.getDeclaredAnnotations()

    private static var getDeclaredAnnotations_MethodID_7: jmethodID?

    open func getDeclaredAnnotations() -> [Annotation]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getDeclaredAnnotations", methodSig: "()[Ljava/lang/annotation/Annotation;", methodCache: &Package.getDeclaredAnnotations_MethodID_7, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [AnnotationForward].self, from: __return )
    }


    /// public java.lang.annotation.Annotation[] java.lang.Package.getDeclaredAnnotationsByType(java.lang.Class)

    private static var getDeclaredAnnotationsByType_MethodID_8: jmethodID?

    open func getDeclaredAnnotationsByType( arg0: java_swift.JavaClass? ) -> [Annotation]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getDeclaredAnnotationsByType", methodSig: "(Ljava/lang/Class;)[Ljava/lang/annotation/Annotation;", methodCache: &Package.getDeclaredAnnotationsByType_MethodID_8, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [AnnotationForward].self, from: __return )
    }

    open func getDeclaredAnnotationsByType( _ _arg0: java_swift.JavaClass? ) -> [Annotation]! {
        return getDeclaredAnnotationsByType( arg0: _arg0 )
    }

    /// public java.lang.String java.lang.Package.getImplementationTitle()

    private static var getImplementationTitle_MethodID_9: jmethodID?

    open func getImplementationTitle() -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getImplementationTitle", methodSig: "()Ljava/lang/String;", methodCache: &Package.getImplementationTitle_MethodID_9, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? String( javaObject: __return ) : nil
    }


    /// public java.lang.String java.lang.Package.getImplementationVendor()

    private static var getImplementationVendor_MethodID_10: jmethodID?

    open func getImplementationVendor() -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getImplementationVendor", methodSig: "()Ljava/lang/String;", methodCache: &Package.getImplementationVendor_MethodID_10, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? String( javaObject: __return ) : nil
    }


    /// public java.lang.String java.lang.Package.getImplementationVersion()

    private static var getImplementationVersion_MethodID_11: jmethodID?

    open func getImplementationVersion() -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getImplementationVersion", methodSig: "()Ljava/lang/String;", methodCache: &Package.getImplementationVersion_MethodID_11, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? String( javaObject: __return ) : nil
    }


    /// public java.lang.String java.lang.Package.getName()

    private static var getName_MethodID_12: jmethodID?

    open func getName() -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getName", methodSig: "()Ljava/lang/String;", methodCache: &Package.getName_MethodID_12, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? String( javaObject: __return ) : nil
    }


    /// private java.lang.Class java.lang.Package.getPackageInfo()

    /// public java.lang.String java.lang.Package.getSpecificationTitle()

    private static var getSpecificationTitle_MethodID_13: jmethodID?

    open func getSpecificationTitle() -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getSpecificationTitle", methodSig: "()Ljava/lang/String;", methodCache: &Package.getSpecificationTitle_MethodID_13, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? String( javaObject: __return ) : nil
    }


    /// public java.lang.String java.lang.Package.getSpecificationVendor()

    private static var getSpecificationVendor_MethodID_14: jmethodID?

    open func getSpecificationVendor() -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getSpecificationVendor", methodSig: "()Ljava/lang/String;", methodCache: &Package.getSpecificationVendor_MethodID_14, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? String( javaObject: __return ) : nil
    }


    /// public java.lang.String java.lang.Package.getSpecificationVersion()

    private static var getSpecificationVersion_MethodID_15: jmethodID?

    open func getSpecificationVersion() -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getSpecificationVersion", methodSig: "()Ljava/lang/String;", methodCache: &Package.getSpecificationVersion_MethodID_15, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? String( javaObject: __return ) : nil
    }


    /// public int java.lang.Package.hashCode()

    // Skipping method: false true false false false 

    /// public boolean java.lang.Package.isAnnotationPresent(java.lang.Class)

    private static var isAnnotationPresent_MethodID_16: jmethodID?

    open func isAnnotationPresent( arg0: java_swift.JavaClass? ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isAnnotationPresent", methodSig: "(Ljava/lang/Class;)Z", methodCache: &Package.isAnnotationPresent_MethodID_16, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open func isAnnotationPresent( _ _arg0: java_swift.JavaClass? ) -> Bool {
        return isAnnotationPresent( arg0: _arg0 )
    }

    /// public boolean java.lang.Package.isCompatibleWith(java.lang.String) throws java.lang.NumberFormatException

    private static var isCompatibleWith_MethodID_17: jmethodID?

    open func isCompatibleWith( desired: String? ) throws /* java.lang.NumberFormatException */ -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: desired, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isCompatibleWith", methodSig: "(Ljava/lang/String;)Z", methodCache: &Package.isCompatibleWith_MethodID_17, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw NumberFormatException( javaObject: throwable )
        }
        return __return != jboolean(JNI_FALSE)
    }

    open func isCompatibleWith( _ _desired: String? ) throws /* java.lang.NumberFormatException */ -> Bool {
        return try isCompatibleWith( desired: _desired )
    }

    /// public boolean java.lang.Package.isSealed(java.net.URL)

    private static var isSealed_MethodID_18: jmethodID?

    open func isSealed( url: /* class java.net.URL */ UnavailableObject? ) -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: url, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isSealed", methodSig: "(Ljava/net/URL;)Z", methodCache: &Package.isSealed_MethodID_18, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }

    open func isSealed( _ _url: /* class java.net.URL */ UnavailableObject? ) -> Bool {
        return isSealed( url: _url )
    }

    /// public boolean java.lang.Package.isSealed()

    private static var isSealed_MethodID_19: jmethodID?

    open func isSealed() -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isSealed", methodSig: "()Z", methodCache: &Package.isSealed_MethodID_19, args: &__args, locals: &__locals )
        return __return != jboolean(JNI_FALSE)
    }


    /// public java.lang.String java.lang.Package.toString()

    // Skipping method: false true false false false 

}

