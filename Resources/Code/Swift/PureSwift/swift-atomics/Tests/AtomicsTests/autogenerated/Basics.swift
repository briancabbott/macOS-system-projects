//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift Atomics open source project
//
// Copyright (c) 2020-2021 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//


// #############################################################################
// #                                                                           #
// #            DO NOT EDIT THIS FILE; IT IS AUTOGENERATED.                    #
// #                                                                           #
// #############################################################################


import XCTest
import Atomics

extension Unmanaged: Equatable { // FIXME: This is terrible
  public static func ==(left: Self, right: Self) -> Bool {
    left.toOpaque() == right.toOpaque()
  }
}

private struct Foo: Equatable, CustomStringConvertible {
  var value: Int
  init(_ value: Int) { self.value = value }
  var description: String { "Foo(\(value))" }
}

private class Bar: Equatable, CustomStringConvertible {
  var value: Int
  init(_ value: Int) { self.value = value }
  var description: String { "Bar(\(value))" }
  static func ==(left: Bar, right: Bar) -> Bool {
    left === right
  }
}

#if !(os(Linux) && arch(x86_64)) || ENABLE_DOUBLEWIDE_ATOMICS
private class Baz: Equatable, CustomStringConvertible, AtomicReference {
  var value: Int
  init(_ value: Int) { self.value = value }
  var description: String { "Bar(\(value))" }
  static func ==(left: Baz, right: Baz) -> Bool {
    left === right
  }
}
#endif

private enum Fred: Int, AtomicValue {
  case one
  case two
}

#if true
/// Exercises all operations in a single-threaded context, verifying
/// they provide the expected results.
class BasicAtomicIntTests: XCTestCase {

  func test_create_destroy() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    let w = UnsafeAtomic<Int>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 23)
  }

  func test_load_relaxed() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    let w = UnsafeAtomic<Int>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 23)
  }
  func test_load_acquiring() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .acquiring), 12)

    let w = UnsafeAtomic<Int>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .acquiring), 23)
  }
  func test_load_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .sequentiallyConsistent), 12)

    let w = UnsafeAtomic<Int>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .sequentiallyConsistent), 23)
  }

  func test_store_relaxed() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }
    v.store(23, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    let w = UnsafeAtomic<Int>.create(23)
    defer { w.destroy() }
    w.store(12, ordering: .relaxed)
    XCTAssertEqual(w.load(ordering: .relaxed), 12)
  }
  func test_store_releasing() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }
    v.store(23, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    let w = UnsafeAtomic<Int>.create(23)
    defer { w.destroy() }
    w.store(12, ordering: .releasing)
    XCTAssertEqual(w.load(ordering: .relaxed), 12)
  }
  func test_store_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }
    v.store(23, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    let w = UnsafeAtomic<Int>.create(23)
    defer { w.destroy() }
    w.store(12, ordering: .sequentiallyConsistent)
    XCTAssertEqual(w.load(ordering: .relaxed), 12)
  }

  func test_exchange_relaxed() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .relaxed), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .relaxed), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .relaxed), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_acquiring() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .acquiring), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .acquiring), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .acquiring), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_releasing() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .releasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .releasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .releasing), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .acquiringAndReleasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .acquiringAndReleasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .acquiringAndReleasing), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .sequentiallyConsistent), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .sequentiallyConsistent), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .sequentiallyConsistent), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }

  func test_compareExchange_relaxed() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }

  func test_compareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }



// Integer operations
  func test_loadThenWrappingIncrement_relaxed() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &+ b
    let result2: Int = result1 &+ c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_acquiring() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &+ b
    let result2: Int = result1 &+ c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_releasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &+ b
    let result2: Int = result1 &+ c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_acquiringAndReleasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &+ b
    let result2: Int = result1 &+ c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_sequentiallyConsistent() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &+ b
    let result2: Int = result1 &+ c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_relaxed() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &- b
    let result2: Int = result1 &- c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_acquiring() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &- b
    let result2: Int = result1 &- c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_releasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &- b
    let result2: Int = result1 &- c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_acquiringAndReleasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &- b
    let result2: Int = result1 &- c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_sequentiallyConsistent() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &- b
    let result2: Int = result1 &- c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_relaxed() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a & b
    let result2: Int = result1 & c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_acquiring() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a & b
    let result2: Int = result1 & c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_releasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a & b
    let result2: Int = result1 & c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_acquiringAndReleasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a & b
    let result2: Int = result1 & c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_sequentiallyConsistent() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a & b
    let result2: Int = result1 & c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_relaxed() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a | b
    let result2: Int = result1 | c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_acquiring() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a | b
    let result2: Int = result1 | c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_releasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a | b
    let result2: Int = result1 | c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_acquiringAndReleasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a | b
    let result2: Int = result1 | c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_sequentiallyConsistent() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a | b
    let result2: Int = result1 | c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_relaxed() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a ^ b
    let result2: Int = result1 ^ c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_acquiring() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a ^ b
    let result2: Int = result1 ^ c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_releasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a ^ b
    let result2: Int = result1 ^ c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_acquiringAndReleasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a ^ b
    let result2: Int = result1 ^ c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_sequentiallyConsistent() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a ^ b
    let result2: Int = result1 ^ c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }

  func test_wrappingIncrementThenLoad_relaxed() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &+ b
    let result2: Int = result1 &+ c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_acquiring() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &+ b
    let result2: Int = result1 &+ c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_releasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &+ b
    let result2: Int = result1 &+ c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_acquiringAndReleasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &+ b
    let result2: Int = result1 &+ c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_sequentiallyConsistent() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &+ b
    let result2: Int = result1 &+ c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_relaxed() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &- b
    let result2: Int = result1 &- c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_acquiring() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &- b
    let result2: Int = result1 &- c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_releasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &- b
    let result2: Int = result1 &- c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_acquiringAndReleasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &- b
    let result2: Int = result1 &- c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_sequentiallyConsistent() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &- b
    let result2: Int = result1 &- c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_relaxed() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a & b
    let result2: Int = result1 & c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_acquiring() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a & b
    let result2: Int = result1 & c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_releasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a & b
    let result2: Int = result1 & c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_acquiringAndReleasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a & b
    let result2: Int = result1 & c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_sequentiallyConsistent() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a & b
    let result2: Int = result1 & c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_relaxed() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a | b
    let result2: Int = result1 | c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_acquiring() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a | b
    let result2: Int = result1 | c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_releasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a | b
    let result2: Int = result1 | c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_acquiringAndReleasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a | b
    let result2: Int = result1 | c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_sequentiallyConsistent() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a | b
    let result2: Int = result1 | c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_relaxed() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a ^ b
    let result2: Int = result1 ^ c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_acquiring() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a ^ b
    let result2: Int = result1 ^ c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_releasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a ^ b
    let result2: Int = result1 ^ c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_acquiringAndReleasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a ^ b
    let result2: Int = result1 ^ c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_sequentiallyConsistent() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a ^ b
    let result2: Int = result1 ^ c

    let v = UnsafeAtomic<Int>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }


  public static var allTests = [
    ("test_create_destroy", test_create_destroy),
    ("test_load_relaxed", test_load_relaxed),
    ("test_load_acquiring", test_load_acquiring),
    ("test_load_sequentiallyConsistent", test_load_sequentiallyConsistent),
    ("test_store_relaxed", test_store_relaxed),
    ("test_store_releasing", test_store_releasing),
    ("test_store_sequentiallyConsistent", test_store_sequentiallyConsistent),
    ("test_exchange_relaxed", test_exchange_relaxed),
    ("test_exchange_acquiring", test_exchange_acquiring),
    ("test_exchange_releasing", test_exchange_releasing),
    ("test_exchange_acquiringAndReleasing", test_exchange_acquiringAndReleasing),
    ("test_exchange_sequentiallyConsistent", test_exchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed", test_compareExchange_relaxed),
    ("test_compareExchange_acquiring", test_compareExchange_acquiring),
    ("test_compareExchange_releasing", test_compareExchange_releasing),
    ("test_compareExchange_acquiringAndReleasing", test_compareExchange_acquiringAndReleasing),
    ("test_compareExchange_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed_relaxed", test_compareExchange_relaxed_relaxed),
    ("test_compareExchange_relaxed_acquiring", test_compareExchange_relaxed_acquiring),
    ("test_compareExchange_relaxed_sequentiallyConsistent", test_compareExchange_relaxed_sequentiallyConsistent),
    ("test_compareExchange_acquiring_relaxed", test_compareExchange_acquiring_relaxed),
    ("test_compareExchange_acquiring_acquiring", test_compareExchange_acquiring_acquiring),
    ("test_compareExchange_acquiring_sequentiallyConsistent", test_compareExchange_acquiring_sequentiallyConsistent),
    ("test_compareExchange_releasing_relaxed", test_compareExchange_releasing_relaxed),
    ("test_compareExchange_releasing_acquiring", test_compareExchange_releasing_acquiring),
    ("test_compareExchange_releasing_sequentiallyConsistent", test_compareExchange_releasing_sequentiallyConsistent),
    ("test_compareExchange_acquiringAndReleasing_relaxed", test_compareExchange_acquiringAndReleasing_relaxed),
    ("test_compareExchange_acquiringAndReleasing_acquiring", test_compareExchange_acquiringAndReleasing_acquiring),
    ("test_compareExchange_acquiringAndReleasing_sequentiallyConsistent", test_compareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_compareExchange_sequentiallyConsistent_relaxed", test_compareExchange_sequentiallyConsistent_relaxed),
    ("test_compareExchange_sequentiallyConsistent_acquiring", test_compareExchange_sequentiallyConsistent_acquiring),
    ("test_compareExchange_sequentiallyConsistent_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent_sequentiallyConsistent),
    ("test_weakCompareExchange_relaxed_relaxed", test_weakCompareExchange_relaxed_relaxed),
    ("test_weakCompareExchange_relaxed_acquiring", test_weakCompareExchange_relaxed_acquiring),
    ("test_weakCompareExchange_relaxed_sequentiallyConsistent", test_weakCompareExchange_relaxed_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiring_relaxed", test_weakCompareExchange_acquiring_relaxed),
    ("test_weakCompareExchange_acquiring_acquiring", test_weakCompareExchange_acquiring_acquiring),
    ("test_weakCompareExchange_acquiring_sequentiallyConsistent", test_weakCompareExchange_acquiring_sequentiallyConsistent),
    ("test_weakCompareExchange_releasing_relaxed", test_weakCompareExchange_releasing_relaxed),
    ("test_weakCompareExchange_releasing_acquiring", test_weakCompareExchange_releasing_acquiring),
    ("test_weakCompareExchange_releasing_sequentiallyConsistent", test_weakCompareExchange_releasing_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiringAndReleasing_relaxed", test_weakCompareExchange_acquiringAndReleasing_relaxed),
    ("test_weakCompareExchange_acquiringAndReleasing_acquiring", test_weakCompareExchange_acquiringAndReleasing_acquiring),
    ("test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent", test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_weakCompareExchange_sequentiallyConsistent_relaxed", test_weakCompareExchange_sequentiallyConsistent_relaxed),
    ("test_weakCompareExchange_sequentiallyConsistent_acquiring", test_weakCompareExchange_sequentiallyConsistent_acquiring),
    ("test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent", test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent),
    ("test_loadThenWrappingIncrement_relaxed", test_loadThenWrappingIncrement_relaxed),
    ("test_loadThenWrappingIncrement_acquiring", test_loadThenWrappingIncrement_acquiring),
    ("test_loadThenWrappingIncrement_releasing", test_loadThenWrappingIncrement_releasing),
    ("test_loadThenWrappingIncrement_acquiringAndReleasing", test_loadThenWrappingIncrement_acquiringAndReleasing),
    ("test_loadThenWrappingIncrement_sequentiallyConsistent", test_loadThenWrappingIncrement_sequentiallyConsistent),
    ("test_loadThenWrappingDecrement_relaxed", test_loadThenWrappingDecrement_relaxed),
    ("test_loadThenWrappingDecrement_acquiring", test_loadThenWrappingDecrement_acquiring),
    ("test_loadThenWrappingDecrement_releasing", test_loadThenWrappingDecrement_releasing),
    ("test_loadThenWrappingDecrement_acquiringAndReleasing", test_loadThenWrappingDecrement_acquiringAndReleasing),
    ("test_loadThenWrappingDecrement_sequentiallyConsistent", test_loadThenWrappingDecrement_sequentiallyConsistent),
    ("test_loadThenBitwiseAnd_relaxed", test_loadThenBitwiseAnd_relaxed),
    ("test_loadThenBitwiseAnd_acquiring", test_loadThenBitwiseAnd_acquiring),
    ("test_loadThenBitwiseAnd_releasing", test_loadThenBitwiseAnd_releasing),
    ("test_loadThenBitwiseAnd_acquiringAndReleasing", test_loadThenBitwiseAnd_acquiringAndReleasing),
    ("test_loadThenBitwiseAnd_sequentiallyConsistent", test_loadThenBitwiseAnd_sequentiallyConsistent),
    ("test_loadThenBitwiseOr_relaxed", test_loadThenBitwiseOr_relaxed),
    ("test_loadThenBitwiseOr_acquiring", test_loadThenBitwiseOr_acquiring),
    ("test_loadThenBitwiseOr_releasing", test_loadThenBitwiseOr_releasing),
    ("test_loadThenBitwiseOr_acquiringAndReleasing", test_loadThenBitwiseOr_acquiringAndReleasing),
    ("test_loadThenBitwiseOr_sequentiallyConsistent", test_loadThenBitwiseOr_sequentiallyConsistent),
    ("test_loadThenBitwiseXor_relaxed", test_loadThenBitwiseXor_relaxed),
    ("test_loadThenBitwiseXor_acquiring", test_loadThenBitwiseXor_acquiring),
    ("test_loadThenBitwiseXor_releasing", test_loadThenBitwiseXor_releasing),
    ("test_loadThenBitwiseXor_acquiringAndReleasing", test_loadThenBitwiseXor_acquiringAndReleasing),
    ("test_loadThenBitwiseXor_sequentiallyConsistent", test_loadThenBitwiseXor_sequentiallyConsistent),
    ("test_wrappingIncrementThenLoad_relaxed", test_wrappingIncrementThenLoad_relaxed),
    ("test_wrappingIncrementThenLoad_acquiring", test_wrappingIncrementThenLoad_acquiring),
    ("test_wrappingIncrementThenLoad_releasing", test_wrappingIncrementThenLoad_releasing),
    ("test_wrappingIncrementThenLoad_acquiringAndReleasing", test_wrappingIncrementThenLoad_acquiringAndReleasing),
    ("test_wrappingIncrementThenLoad_sequentiallyConsistent", test_wrappingIncrementThenLoad_sequentiallyConsistent),
    ("test_wrappingDecrementThenLoad_relaxed", test_wrappingDecrementThenLoad_relaxed),
    ("test_wrappingDecrementThenLoad_acquiring", test_wrappingDecrementThenLoad_acquiring),
    ("test_wrappingDecrementThenLoad_releasing", test_wrappingDecrementThenLoad_releasing),
    ("test_wrappingDecrementThenLoad_acquiringAndReleasing", test_wrappingDecrementThenLoad_acquiringAndReleasing),
    ("test_wrappingDecrementThenLoad_sequentiallyConsistent", test_wrappingDecrementThenLoad_sequentiallyConsistent),
    ("test_bitwiseAndThenLoad_relaxed", test_bitwiseAndThenLoad_relaxed),
    ("test_bitwiseAndThenLoad_acquiring", test_bitwiseAndThenLoad_acquiring),
    ("test_bitwiseAndThenLoad_releasing", test_bitwiseAndThenLoad_releasing),
    ("test_bitwiseAndThenLoad_acquiringAndReleasing", test_bitwiseAndThenLoad_acquiringAndReleasing),
    ("test_bitwiseAndThenLoad_sequentiallyConsistent", test_bitwiseAndThenLoad_sequentiallyConsistent),
    ("test_bitwiseOrThenLoad_relaxed", test_bitwiseOrThenLoad_relaxed),
    ("test_bitwiseOrThenLoad_acquiring", test_bitwiseOrThenLoad_acquiring),
    ("test_bitwiseOrThenLoad_releasing", test_bitwiseOrThenLoad_releasing),
    ("test_bitwiseOrThenLoad_acquiringAndReleasing", test_bitwiseOrThenLoad_acquiringAndReleasing),
    ("test_bitwiseOrThenLoad_sequentiallyConsistent", test_bitwiseOrThenLoad_sequentiallyConsistent),
    ("test_bitwiseXorThenLoad_relaxed", test_bitwiseXorThenLoad_relaxed),
    ("test_bitwiseXorThenLoad_acquiring", test_bitwiseXorThenLoad_acquiring),
    ("test_bitwiseXorThenLoad_releasing", test_bitwiseXorThenLoad_releasing),
    ("test_bitwiseXorThenLoad_acquiringAndReleasing", test_bitwiseXorThenLoad_acquiringAndReleasing),
    ("test_bitwiseXorThenLoad_sequentiallyConsistent", test_bitwiseXorThenLoad_sequentiallyConsistent),
  ]
}
#endif
#if true
/// Exercises all operations in a single-threaded context, verifying
/// they provide the expected results.
class BasicAtomicInt8Tests: XCTestCase {

  func test_create_destroy() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    let w = UnsafeAtomic<Int8>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 23)
  }

  func test_load_relaxed() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    let w = UnsafeAtomic<Int8>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 23)
  }
  func test_load_acquiring() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .acquiring), 12)

    let w = UnsafeAtomic<Int8>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .acquiring), 23)
  }
  func test_load_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .sequentiallyConsistent), 12)

    let w = UnsafeAtomic<Int8>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .sequentiallyConsistent), 23)
  }

  func test_store_relaxed() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }
    v.store(23, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    let w = UnsafeAtomic<Int8>.create(23)
    defer { w.destroy() }
    w.store(12, ordering: .relaxed)
    XCTAssertEqual(w.load(ordering: .relaxed), 12)
  }
  func test_store_releasing() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }
    v.store(23, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    let w = UnsafeAtomic<Int8>.create(23)
    defer { w.destroy() }
    w.store(12, ordering: .releasing)
    XCTAssertEqual(w.load(ordering: .relaxed), 12)
  }
  func test_store_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }
    v.store(23, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    let w = UnsafeAtomic<Int8>.create(23)
    defer { w.destroy() }
    w.store(12, ordering: .sequentiallyConsistent)
    XCTAssertEqual(w.load(ordering: .relaxed), 12)
  }

  func test_exchange_relaxed() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .relaxed), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .relaxed), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .relaxed), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_acquiring() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .acquiring), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .acquiring), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .acquiring), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_releasing() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .releasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .releasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .releasing), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .acquiringAndReleasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .acquiringAndReleasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .acquiringAndReleasing), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .sequentiallyConsistent), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .sequentiallyConsistent), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .sequentiallyConsistent), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }

  func test_compareExchange_relaxed() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }

  func test_compareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }



// Integer operations
  func test_loadThenWrappingIncrement_relaxed() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &+ b
    let result2: Int8 = result1 &+ c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_acquiring() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &+ b
    let result2: Int8 = result1 &+ c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_releasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &+ b
    let result2: Int8 = result1 &+ c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_acquiringAndReleasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &+ b
    let result2: Int8 = result1 &+ c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_sequentiallyConsistent() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &+ b
    let result2: Int8 = result1 &+ c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_relaxed() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &- b
    let result2: Int8 = result1 &- c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_acquiring() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &- b
    let result2: Int8 = result1 &- c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_releasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &- b
    let result2: Int8 = result1 &- c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_acquiringAndReleasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &- b
    let result2: Int8 = result1 &- c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_sequentiallyConsistent() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &- b
    let result2: Int8 = result1 &- c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_relaxed() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a & b
    let result2: Int8 = result1 & c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_acquiring() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a & b
    let result2: Int8 = result1 & c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_releasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a & b
    let result2: Int8 = result1 & c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_acquiringAndReleasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a & b
    let result2: Int8 = result1 & c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_sequentiallyConsistent() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a & b
    let result2: Int8 = result1 & c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_relaxed() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a | b
    let result2: Int8 = result1 | c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_acquiring() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a | b
    let result2: Int8 = result1 | c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_releasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a | b
    let result2: Int8 = result1 | c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_acquiringAndReleasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a | b
    let result2: Int8 = result1 | c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_sequentiallyConsistent() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a | b
    let result2: Int8 = result1 | c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_relaxed() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a ^ b
    let result2: Int8 = result1 ^ c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_acquiring() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a ^ b
    let result2: Int8 = result1 ^ c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_releasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a ^ b
    let result2: Int8 = result1 ^ c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_acquiringAndReleasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a ^ b
    let result2: Int8 = result1 ^ c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_sequentiallyConsistent() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a ^ b
    let result2: Int8 = result1 ^ c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }

  func test_wrappingIncrementThenLoad_relaxed() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &+ b
    let result2: Int8 = result1 &+ c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_acquiring() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &+ b
    let result2: Int8 = result1 &+ c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_releasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &+ b
    let result2: Int8 = result1 &+ c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_acquiringAndReleasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &+ b
    let result2: Int8 = result1 &+ c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_sequentiallyConsistent() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &+ b
    let result2: Int8 = result1 &+ c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_relaxed() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &- b
    let result2: Int8 = result1 &- c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_acquiring() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &- b
    let result2: Int8 = result1 &- c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_releasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &- b
    let result2: Int8 = result1 &- c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_acquiringAndReleasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &- b
    let result2: Int8 = result1 &- c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_sequentiallyConsistent() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &- b
    let result2: Int8 = result1 &- c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_relaxed() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a & b
    let result2: Int8 = result1 & c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_acquiring() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a & b
    let result2: Int8 = result1 & c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_releasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a & b
    let result2: Int8 = result1 & c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_acquiringAndReleasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a & b
    let result2: Int8 = result1 & c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_sequentiallyConsistent() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a & b
    let result2: Int8 = result1 & c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_relaxed() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a | b
    let result2: Int8 = result1 | c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_acquiring() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a | b
    let result2: Int8 = result1 | c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_releasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a | b
    let result2: Int8 = result1 | c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_acquiringAndReleasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a | b
    let result2: Int8 = result1 | c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_sequentiallyConsistent() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a | b
    let result2: Int8 = result1 | c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_relaxed() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a ^ b
    let result2: Int8 = result1 ^ c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_acquiring() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a ^ b
    let result2: Int8 = result1 ^ c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_releasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a ^ b
    let result2: Int8 = result1 ^ c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_acquiringAndReleasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a ^ b
    let result2: Int8 = result1 ^ c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_sequentiallyConsistent() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a ^ b
    let result2: Int8 = result1 ^ c

    let v = UnsafeAtomic<Int8>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }


  public static var allTests = [
    ("test_create_destroy", test_create_destroy),
    ("test_load_relaxed", test_load_relaxed),
    ("test_load_acquiring", test_load_acquiring),
    ("test_load_sequentiallyConsistent", test_load_sequentiallyConsistent),
    ("test_store_relaxed", test_store_relaxed),
    ("test_store_releasing", test_store_releasing),
    ("test_store_sequentiallyConsistent", test_store_sequentiallyConsistent),
    ("test_exchange_relaxed", test_exchange_relaxed),
    ("test_exchange_acquiring", test_exchange_acquiring),
    ("test_exchange_releasing", test_exchange_releasing),
    ("test_exchange_acquiringAndReleasing", test_exchange_acquiringAndReleasing),
    ("test_exchange_sequentiallyConsistent", test_exchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed", test_compareExchange_relaxed),
    ("test_compareExchange_acquiring", test_compareExchange_acquiring),
    ("test_compareExchange_releasing", test_compareExchange_releasing),
    ("test_compareExchange_acquiringAndReleasing", test_compareExchange_acquiringAndReleasing),
    ("test_compareExchange_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed_relaxed", test_compareExchange_relaxed_relaxed),
    ("test_compareExchange_relaxed_acquiring", test_compareExchange_relaxed_acquiring),
    ("test_compareExchange_relaxed_sequentiallyConsistent", test_compareExchange_relaxed_sequentiallyConsistent),
    ("test_compareExchange_acquiring_relaxed", test_compareExchange_acquiring_relaxed),
    ("test_compareExchange_acquiring_acquiring", test_compareExchange_acquiring_acquiring),
    ("test_compareExchange_acquiring_sequentiallyConsistent", test_compareExchange_acquiring_sequentiallyConsistent),
    ("test_compareExchange_releasing_relaxed", test_compareExchange_releasing_relaxed),
    ("test_compareExchange_releasing_acquiring", test_compareExchange_releasing_acquiring),
    ("test_compareExchange_releasing_sequentiallyConsistent", test_compareExchange_releasing_sequentiallyConsistent),
    ("test_compareExchange_acquiringAndReleasing_relaxed", test_compareExchange_acquiringAndReleasing_relaxed),
    ("test_compareExchange_acquiringAndReleasing_acquiring", test_compareExchange_acquiringAndReleasing_acquiring),
    ("test_compareExchange_acquiringAndReleasing_sequentiallyConsistent", test_compareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_compareExchange_sequentiallyConsistent_relaxed", test_compareExchange_sequentiallyConsistent_relaxed),
    ("test_compareExchange_sequentiallyConsistent_acquiring", test_compareExchange_sequentiallyConsistent_acquiring),
    ("test_compareExchange_sequentiallyConsistent_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent_sequentiallyConsistent),
    ("test_weakCompareExchange_relaxed_relaxed", test_weakCompareExchange_relaxed_relaxed),
    ("test_weakCompareExchange_relaxed_acquiring", test_weakCompareExchange_relaxed_acquiring),
    ("test_weakCompareExchange_relaxed_sequentiallyConsistent", test_weakCompareExchange_relaxed_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiring_relaxed", test_weakCompareExchange_acquiring_relaxed),
    ("test_weakCompareExchange_acquiring_acquiring", test_weakCompareExchange_acquiring_acquiring),
    ("test_weakCompareExchange_acquiring_sequentiallyConsistent", test_weakCompareExchange_acquiring_sequentiallyConsistent),
    ("test_weakCompareExchange_releasing_relaxed", test_weakCompareExchange_releasing_relaxed),
    ("test_weakCompareExchange_releasing_acquiring", test_weakCompareExchange_releasing_acquiring),
    ("test_weakCompareExchange_releasing_sequentiallyConsistent", test_weakCompareExchange_releasing_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiringAndReleasing_relaxed", test_weakCompareExchange_acquiringAndReleasing_relaxed),
    ("test_weakCompareExchange_acquiringAndReleasing_acquiring", test_weakCompareExchange_acquiringAndReleasing_acquiring),
    ("test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent", test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_weakCompareExchange_sequentiallyConsistent_relaxed", test_weakCompareExchange_sequentiallyConsistent_relaxed),
    ("test_weakCompareExchange_sequentiallyConsistent_acquiring", test_weakCompareExchange_sequentiallyConsistent_acquiring),
    ("test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent", test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent),
    ("test_loadThenWrappingIncrement_relaxed", test_loadThenWrappingIncrement_relaxed),
    ("test_loadThenWrappingIncrement_acquiring", test_loadThenWrappingIncrement_acquiring),
    ("test_loadThenWrappingIncrement_releasing", test_loadThenWrappingIncrement_releasing),
    ("test_loadThenWrappingIncrement_acquiringAndReleasing", test_loadThenWrappingIncrement_acquiringAndReleasing),
    ("test_loadThenWrappingIncrement_sequentiallyConsistent", test_loadThenWrappingIncrement_sequentiallyConsistent),
    ("test_loadThenWrappingDecrement_relaxed", test_loadThenWrappingDecrement_relaxed),
    ("test_loadThenWrappingDecrement_acquiring", test_loadThenWrappingDecrement_acquiring),
    ("test_loadThenWrappingDecrement_releasing", test_loadThenWrappingDecrement_releasing),
    ("test_loadThenWrappingDecrement_acquiringAndReleasing", test_loadThenWrappingDecrement_acquiringAndReleasing),
    ("test_loadThenWrappingDecrement_sequentiallyConsistent", test_loadThenWrappingDecrement_sequentiallyConsistent),
    ("test_loadThenBitwiseAnd_relaxed", test_loadThenBitwiseAnd_relaxed),
    ("test_loadThenBitwiseAnd_acquiring", test_loadThenBitwiseAnd_acquiring),
    ("test_loadThenBitwiseAnd_releasing", test_loadThenBitwiseAnd_releasing),
    ("test_loadThenBitwiseAnd_acquiringAndReleasing", test_loadThenBitwiseAnd_acquiringAndReleasing),
    ("test_loadThenBitwiseAnd_sequentiallyConsistent", test_loadThenBitwiseAnd_sequentiallyConsistent),
    ("test_loadThenBitwiseOr_relaxed", test_loadThenBitwiseOr_relaxed),
    ("test_loadThenBitwiseOr_acquiring", test_loadThenBitwiseOr_acquiring),
    ("test_loadThenBitwiseOr_releasing", test_loadThenBitwiseOr_releasing),
    ("test_loadThenBitwiseOr_acquiringAndReleasing", test_loadThenBitwiseOr_acquiringAndReleasing),
    ("test_loadThenBitwiseOr_sequentiallyConsistent", test_loadThenBitwiseOr_sequentiallyConsistent),
    ("test_loadThenBitwiseXor_relaxed", test_loadThenBitwiseXor_relaxed),
    ("test_loadThenBitwiseXor_acquiring", test_loadThenBitwiseXor_acquiring),
    ("test_loadThenBitwiseXor_releasing", test_loadThenBitwiseXor_releasing),
    ("test_loadThenBitwiseXor_acquiringAndReleasing", test_loadThenBitwiseXor_acquiringAndReleasing),
    ("test_loadThenBitwiseXor_sequentiallyConsistent", test_loadThenBitwiseXor_sequentiallyConsistent),
    ("test_wrappingIncrementThenLoad_relaxed", test_wrappingIncrementThenLoad_relaxed),
    ("test_wrappingIncrementThenLoad_acquiring", test_wrappingIncrementThenLoad_acquiring),
    ("test_wrappingIncrementThenLoad_releasing", test_wrappingIncrementThenLoad_releasing),
    ("test_wrappingIncrementThenLoad_acquiringAndReleasing", test_wrappingIncrementThenLoad_acquiringAndReleasing),
    ("test_wrappingIncrementThenLoad_sequentiallyConsistent", test_wrappingIncrementThenLoad_sequentiallyConsistent),
    ("test_wrappingDecrementThenLoad_relaxed", test_wrappingDecrementThenLoad_relaxed),
    ("test_wrappingDecrementThenLoad_acquiring", test_wrappingDecrementThenLoad_acquiring),
    ("test_wrappingDecrementThenLoad_releasing", test_wrappingDecrementThenLoad_releasing),
    ("test_wrappingDecrementThenLoad_acquiringAndReleasing", test_wrappingDecrementThenLoad_acquiringAndReleasing),
    ("test_wrappingDecrementThenLoad_sequentiallyConsistent", test_wrappingDecrementThenLoad_sequentiallyConsistent),
    ("test_bitwiseAndThenLoad_relaxed", test_bitwiseAndThenLoad_relaxed),
    ("test_bitwiseAndThenLoad_acquiring", test_bitwiseAndThenLoad_acquiring),
    ("test_bitwiseAndThenLoad_releasing", test_bitwiseAndThenLoad_releasing),
    ("test_bitwiseAndThenLoad_acquiringAndReleasing", test_bitwiseAndThenLoad_acquiringAndReleasing),
    ("test_bitwiseAndThenLoad_sequentiallyConsistent", test_bitwiseAndThenLoad_sequentiallyConsistent),
    ("test_bitwiseOrThenLoad_relaxed", test_bitwiseOrThenLoad_relaxed),
    ("test_bitwiseOrThenLoad_acquiring", test_bitwiseOrThenLoad_acquiring),
    ("test_bitwiseOrThenLoad_releasing", test_bitwiseOrThenLoad_releasing),
    ("test_bitwiseOrThenLoad_acquiringAndReleasing", test_bitwiseOrThenLoad_acquiringAndReleasing),
    ("test_bitwiseOrThenLoad_sequentiallyConsistent", test_bitwiseOrThenLoad_sequentiallyConsistent),
    ("test_bitwiseXorThenLoad_relaxed", test_bitwiseXorThenLoad_relaxed),
    ("test_bitwiseXorThenLoad_acquiring", test_bitwiseXorThenLoad_acquiring),
    ("test_bitwiseXorThenLoad_releasing", test_bitwiseXorThenLoad_releasing),
    ("test_bitwiseXorThenLoad_acquiringAndReleasing", test_bitwiseXorThenLoad_acquiringAndReleasing),
    ("test_bitwiseXorThenLoad_sequentiallyConsistent", test_bitwiseXorThenLoad_sequentiallyConsistent),
  ]
}
#endif
#if true
/// Exercises all operations in a single-threaded context, verifying
/// they provide the expected results.
class BasicAtomicInt16Tests: XCTestCase {

  func test_create_destroy() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    let w = UnsafeAtomic<Int16>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 23)
  }

  func test_load_relaxed() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    let w = UnsafeAtomic<Int16>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 23)
  }
  func test_load_acquiring() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .acquiring), 12)

    let w = UnsafeAtomic<Int16>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .acquiring), 23)
  }
  func test_load_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .sequentiallyConsistent), 12)

    let w = UnsafeAtomic<Int16>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .sequentiallyConsistent), 23)
  }

  func test_store_relaxed() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }
    v.store(23, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    let w = UnsafeAtomic<Int16>.create(23)
    defer { w.destroy() }
    w.store(12, ordering: .relaxed)
    XCTAssertEqual(w.load(ordering: .relaxed), 12)
  }
  func test_store_releasing() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }
    v.store(23, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    let w = UnsafeAtomic<Int16>.create(23)
    defer { w.destroy() }
    w.store(12, ordering: .releasing)
    XCTAssertEqual(w.load(ordering: .relaxed), 12)
  }
  func test_store_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }
    v.store(23, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    let w = UnsafeAtomic<Int16>.create(23)
    defer { w.destroy() }
    w.store(12, ordering: .sequentiallyConsistent)
    XCTAssertEqual(w.load(ordering: .relaxed), 12)
  }

  func test_exchange_relaxed() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .relaxed), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .relaxed), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .relaxed), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_acquiring() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .acquiring), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .acquiring), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .acquiring), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_releasing() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .releasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .releasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .releasing), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .acquiringAndReleasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .acquiringAndReleasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .acquiringAndReleasing), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .sequentiallyConsistent), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .sequentiallyConsistent), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .sequentiallyConsistent), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }

  func test_compareExchange_relaxed() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }

  func test_compareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }



// Integer operations
  func test_loadThenWrappingIncrement_relaxed() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &+ b
    let result2: Int16 = result1 &+ c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_acquiring() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &+ b
    let result2: Int16 = result1 &+ c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_releasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &+ b
    let result2: Int16 = result1 &+ c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_acquiringAndReleasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &+ b
    let result2: Int16 = result1 &+ c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_sequentiallyConsistent() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &+ b
    let result2: Int16 = result1 &+ c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_relaxed() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &- b
    let result2: Int16 = result1 &- c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_acquiring() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &- b
    let result2: Int16 = result1 &- c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_releasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &- b
    let result2: Int16 = result1 &- c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_acquiringAndReleasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &- b
    let result2: Int16 = result1 &- c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_sequentiallyConsistent() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &- b
    let result2: Int16 = result1 &- c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_relaxed() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a & b
    let result2: Int16 = result1 & c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_acquiring() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a & b
    let result2: Int16 = result1 & c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_releasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a & b
    let result2: Int16 = result1 & c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_acquiringAndReleasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a & b
    let result2: Int16 = result1 & c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_sequentiallyConsistent() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a & b
    let result2: Int16 = result1 & c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_relaxed() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a | b
    let result2: Int16 = result1 | c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_acquiring() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a | b
    let result2: Int16 = result1 | c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_releasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a | b
    let result2: Int16 = result1 | c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_acquiringAndReleasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a | b
    let result2: Int16 = result1 | c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_sequentiallyConsistent() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a | b
    let result2: Int16 = result1 | c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_relaxed() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a ^ b
    let result2: Int16 = result1 ^ c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_acquiring() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a ^ b
    let result2: Int16 = result1 ^ c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_releasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a ^ b
    let result2: Int16 = result1 ^ c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_acquiringAndReleasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a ^ b
    let result2: Int16 = result1 ^ c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_sequentiallyConsistent() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a ^ b
    let result2: Int16 = result1 ^ c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }

  func test_wrappingIncrementThenLoad_relaxed() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &+ b
    let result2: Int16 = result1 &+ c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_acquiring() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &+ b
    let result2: Int16 = result1 &+ c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_releasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &+ b
    let result2: Int16 = result1 &+ c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_acquiringAndReleasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &+ b
    let result2: Int16 = result1 &+ c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_sequentiallyConsistent() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &+ b
    let result2: Int16 = result1 &+ c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_relaxed() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &- b
    let result2: Int16 = result1 &- c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_acquiring() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &- b
    let result2: Int16 = result1 &- c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_releasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &- b
    let result2: Int16 = result1 &- c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_acquiringAndReleasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &- b
    let result2: Int16 = result1 &- c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_sequentiallyConsistent() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &- b
    let result2: Int16 = result1 &- c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_relaxed() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a & b
    let result2: Int16 = result1 & c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_acquiring() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a & b
    let result2: Int16 = result1 & c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_releasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a & b
    let result2: Int16 = result1 & c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_acquiringAndReleasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a & b
    let result2: Int16 = result1 & c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_sequentiallyConsistent() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a & b
    let result2: Int16 = result1 & c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_relaxed() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a | b
    let result2: Int16 = result1 | c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_acquiring() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a | b
    let result2: Int16 = result1 | c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_releasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a | b
    let result2: Int16 = result1 | c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_acquiringAndReleasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a | b
    let result2: Int16 = result1 | c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_sequentiallyConsistent() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a | b
    let result2: Int16 = result1 | c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_relaxed() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a ^ b
    let result2: Int16 = result1 ^ c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_acquiring() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a ^ b
    let result2: Int16 = result1 ^ c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_releasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a ^ b
    let result2: Int16 = result1 ^ c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_acquiringAndReleasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a ^ b
    let result2: Int16 = result1 ^ c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_sequentiallyConsistent() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a ^ b
    let result2: Int16 = result1 ^ c

    let v = UnsafeAtomic<Int16>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }


  public static var allTests = [
    ("test_create_destroy", test_create_destroy),
    ("test_load_relaxed", test_load_relaxed),
    ("test_load_acquiring", test_load_acquiring),
    ("test_load_sequentiallyConsistent", test_load_sequentiallyConsistent),
    ("test_store_relaxed", test_store_relaxed),
    ("test_store_releasing", test_store_releasing),
    ("test_store_sequentiallyConsistent", test_store_sequentiallyConsistent),
    ("test_exchange_relaxed", test_exchange_relaxed),
    ("test_exchange_acquiring", test_exchange_acquiring),
    ("test_exchange_releasing", test_exchange_releasing),
    ("test_exchange_acquiringAndReleasing", test_exchange_acquiringAndReleasing),
    ("test_exchange_sequentiallyConsistent", test_exchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed", test_compareExchange_relaxed),
    ("test_compareExchange_acquiring", test_compareExchange_acquiring),
    ("test_compareExchange_releasing", test_compareExchange_releasing),
    ("test_compareExchange_acquiringAndReleasing", test_compareExchange_acquiringAndReleasing),
    ("test_compareExchange_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed_relaxed", test_compareExchange_relaxed_relaxed),
    ("test_compareExchange_relaxed_acquiring", test_compareExchange_relaxed_acquiring),
    ("test_compareExchange_relaxed_sequentiallyConsistent", test_compareExchange_relaxed_sequentiallyConsistent),
    ("test_compareExchange_acquiring_relaxed", test_compareExchange_acquiring_relaxed),
    ("test_compareExchange_acquiring_acquiring", test_compareExchange_acquiring_acquiring),
    ("test_compareExchange_acquiring_sequentiallyConsistent", test_compareExchange_acquiring_sequentiallyConsistent),
    ("test_compareExchange_releasing_relaxed", test_compareExchange_releasing_relaxed),
    ("test_compareExchange_releasing_acquiring", test_compareExchange_releasing_acquiring),
    ("test_compareExchange_releasing_sequentiallyConsistent", test_compareExchange_releasing_sequentiallyConsistent),
    ("test_compareExchange_acquiringAndReleasing_relaxed", test_compareExchange_acquiringAndReleasing_relaxed),
    ("test_compareExchange_acquiringAndReleasing_acquiring", test_compareExchange_acquiringAndReleasing_acquiring),
    ("test_compareExchange_acquiringAndReleasing_sequentiallyConsistent", test_compareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_compareExchange_sequentiallyConsistent_relaxed", test_compareExchange_sequentiallyConsistent_relaxed),
    ("test_compareExchange_sequentiallyConsistent_acquiring", test_compareExchange_sequentiallyConsistent_acquiring),
    ("test_compareExchange_sequentiallyConsistent_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent_sequentiallyConsistent),
    ("test_weakCompareExchange_relaxed_relaxed", test_weakCompareExchange_relaxed_relaxed),
    ("test_weakCompareExchange_relaxed_acquiring", test_weakCompareExchange_relaxed_acquiring),
    ("test_weakCompareExchange_relaxed_sequentiallyConsistent", test_weakCompareExchange_relaxed_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiring_relaxed", test_weakCompareExchange_acquiring_relaxed),
    ("test_weakCompareExchange_acquiring_acquiring", test_weakCompareExchange_acquiring_acquiring),
    ("test_weakCompareExchange_acquiring_sequentiallyConsistent", test_weakCompareExchange_acquiring_sequentiallyConsistent),
    ("test_weakCompareExchange_releasing_relaxed", test_weakCompareExchange_releasing_relaxed),
    ("test_weakCompareExchange_releasing_acquiring", test_weakCompareExchange_releasing_acquiring),
    ("test_weakCompareExchange_releasing_sequentiallyConsistent", test_weakCompareExchange_releasing_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiringAndReleasing_relaxed", test_weakCompareExchange_acquiringAndReleasing_relaxed),
    ("test_weakCompareExchange_acquiringAndReleasing_acquiring", test_weakCompareExchange_acquiringAndReleasing_acquiring),
    ("test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent", test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_weakCompareExchange_sequentiallyConsistent_relaxed", test_weakCompareExchange_sequentiallyConsistent_relaxed),
    ("test_weakCompareExchange_sequentiallyConsistent_acquiring", test_weakCompareExchange_sequentiallyConsistent_acquiring),
    ("test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent", test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent),
    ("test_loadThenWrappingIncrement_relaxed", test_loadThenWrappingIncrement_relaxed),
    ("test_loadThenWrappingIncrement_acquiring", test_loadThenWrappingIncrement_acquiring),
    ("test_loadThenWrappingIncrement_releasing", test_loadThenWrappingIncrement_releasing),
    ("test_loadThenWrappingIncrement_acquiringAndReleasing", test_loadThenWrappingIncrement_acquiringAndReleasing),
    ("test_loadThenWrappingIncrement_sequentiallyConsistent", test_loadThenWrappingIncrement_sequentiallyConsistent),
    ("test_loadThenWrappingDecrement_relaxed", test_loadThenWrappingDecrement_relaxed),
    ("test_loadThenWrappingDecrement_acquiring", test_loadThenWrappingDecrement_acquiring),
    ("test_loadThenWrappingDecrement_releasing", test_loadThenWrappingDecrement_releasing),
    ("test_loadThenWrappingDecrement_acquiringAndReleasing", test_loadThenWrappingDecrement_acquiringAndReleasing),
    ("test_loadThenWrappingDecrement_sequentiallyConsistent", test_loadThenWrappingDecrement_sequentiallyConsistent),
    ("test_loadThenBitwiseAnd_relaxed", test_loadThenBitwiseAnd_relaxed),
    ("test_loadThenBitwiseAnd_acquiring", test_loadThenBitwiseAnd_acquiring),
    ("test_loadThenBitwiseAnd_releasing", test_loadThenBitwiseAnd_releasing),
    ("test_loadThenBitwiseAnd_acquiringAndReleasing", test_loadThenBitwiseAnd_acquiringAndReleasing),
    ("test_loadThenBitwiseAnd_sequentiallyConsistent", test_loadThenBitwiseAnd_sequentiallyConsistent),
    ("test_loadThenBitwiseOr_relaxed", test_loadThenBitwiseOr_relaxed),
    ("test_loadThenBitwiseOr_acquiring", test_loadThenBitwiseOr_acquiring),
    ("test_loadThenBitwiseOr_releasing", test_loadThenBitwiseOr_releasing),
    ("test_loadThenBitwiseOr_acquiringAndReleasing", test_loadThenBitwiseOr_acquiringAndReleasing),
    ("test_loadThenBitwiseOr_sequentiallyConsistent", test_loadThenBitwiseOr_sequentiallyConsistent),
    ("test_loadThenBitwiseXor_relaxed", test_loadThenBitwiseXor_relaxed),
    ("test_loadThenBitwiseXor_acquiring", test_loadThenBitwiseXor_acquiring),
    ("test_loadThenBitwiseXor_releasing", test_loadThenBitwiseXor_releasing),
    ("test_loadThenBitwiseXor_acquiringAndReleasing", test_loadThenBitwiseXor_acquiringAndReleasing),
    ("test_loadThenBitwiseXor_sequentiallyConsistent", test_loadThenBitwiseXor_sequentiallyConsistent),
    ("test_wrappingIncrementThenLoad_relaxed", test_wrappingIncrementThenLoad_relaxed),
    ("test_wrappingIncrementThenLoad_acquiring", test_wrappingIncrementThenLoad_acquiring),
    ("test_wrappingIncrementThenLoad_releasing", test_wrappingIncrementThenLoad_releasing),
    ("test_wrappingIncrementThenLoad_acquiringAndReleasing", test_wrappingIncrementThenLoad_acquiringAndReleasing),
    ("test_wrappingIncrementThenLoad_sequentiallyConsistent", test_wrappingIncrementThenLoad_sequentiallyConsistent),
    ("test_wrappingDecrementThenLoad_relaxed", test_wrappingDecrementThenLoad_relaxed),
    ("test_wrappingDecrementThenLoad_acquiring", test_wrappingDecrementThenLoad_acquiring),
    ("test_wrappingDecrementThenLoad_releasing", test_wrappingDecrementThenLoad_releasing),
    ("test_wrappingDecrementThenLoad_acquiringAndReleasing", test_wrappingDecrementThenLoad_acquiringAndReleasing),
    ("test_wrappingDecrementThenLoad_sequentiallyConsistent", test_wrappingDecrementThenLoad_sequentiallyConsistent),
    ("test_bitwiseAndThenLoad_relaxed", test_bitwiseAndThenLoad_relaxed),
    ("test_bitwiseAndThenLoad_acquiring", test_bitwiseAndThenLoad_acquiring),
    ("test_bitwiseAndThenLoad_releasing", test_bitwiseAndThenLoad_releasing),
    ("test_bitwiseAndThenLoad_acquiringAndReleasing", test_bitwiseAndThenLoad_acquiringAndReleasing),
    ("test_bitwiseAndThenLoad_sequentiallyConsistent", test_bitwiseAndThenLoad_sequentiallyConsistent),
    ("test_bitwiseOrThenLoad_relaxed", test_bitwiseOrThenLoad_relaxed),
    ("test_bitwiseOrThenLoad_acquiring", test_bitwiseOrThenLoad_acquiring),
    ("test_bitwiseOrThenLoad_releasing", test_bitwiseOrThenLoad_releasing),
    ("test_bitwiseOrThenLoad_acquiringAndReleasing", test_bitwiseOrThenLoad_acquiringAndReleasing),
    ("test_bitwiseOrThenLoad_sequentiallyConsistent", test_bitwiseOrThenLoad_sequentiallyConsistent),
    ("test_bitwiseXorThenLoad_relaxed", test_bitwiseXorThenLoad_relaxed),
    ("test_bitwiseXorThenLoad_acquiring", test_bitwiseXorThenLoad_acquiring),
    ("test_bitwiseXorThenLoad_releasing", test_bitwiseXorThenLoad_releasing),
    ("test_bitwiseXorThenLoad_acquiringAndReleasing", test_bitwiseXorThenLoad_acquiringAndReleasing),
    ("test_bitwiseXorThenLoad_sequentiallyConsistent", test_bitwiseXorThenLoad_sequentiallyConsistent),
  ]
}
#endif
#if true
/// Exercises all operations in a single-threaded context, verifying
/// they provide the expected results.
class BasicAtomicInt32Tests: XCTestCase {

  func test_create_destroy() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    let w = UnsafeAtomic<Int32>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 23)
  }

  func test_load_relaxed() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    let w = UnsafeAtomic<Int32>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 23)
  }
  func test_load_acquiring() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .acquiring), 12)

    let w = UnsafeAtomic<Int32>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .acquiring), 23)
  }
  func test_load_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .sequentiallyConsistent), 12)

    let w = UnsafeAtomic<Int32>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .sequentiallyConsistent), 23)
  }

  func test_store_relaxed() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }
    v.store(23, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    let w = UnsafeAtomic<Int32>.create(23)
    defer { w.destroy() }
    w.store(12, ordering: .relaxed)
    XCTAssertEqual(w.load(ordering: .relaxed), 12)
  }
  func test_store_releasing() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }
    v.store(23, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    let w = UnsafeAtomic<Int32>.create(23)
    defer { w.destroy() }
    w.store(12, ordering: .releasing)
    XCTAssertEqual(w.load(ordering: .relaxed), 12)
  }
  func test_store_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }
    v.store(23, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    let w = UnsafeAtomic<Int32>.create(23)
    defer { w.destroy() }
    w.store(12, ordering: .sequentiallyConsistent)
    XCTAssertEqual(w.load(ordering: .relaxed), 12)
  }

  func test_exchange_relaxed() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .relaxed), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .relaxed), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .relaxed), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_acquiring() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .acquiring), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .acquiring), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .acquiring), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_releasing() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .releasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .releasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .releasing), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .acquiringAndReleasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .acquiringAndReleasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .acquiringAndReleasing), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .sequentiallyConsistent), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .sequentiallyConsistent), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .sequentiallyConsistent), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }

  func test_compareExchange_relaxed() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }

  func test_compareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }



// Integer operations
  func test_loadThenWrappingIncrement_relaxed() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &+ b
    let result2: Int32 = result1 &+ c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_acquiring() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &+ b
    let result2: Int32 = result1 &+ c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_releasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &+ b
    let result2: Int32 = result1 &+ c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_acquiringAndReleasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &+ b
    let result2: Int32 = result1 &+ c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_sequentiallyConsistent() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &+ b
    let result2: Int32 = result1 &+ c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_relaxed() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &- b
    let result2: Int32 = result1 &- c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_acquiring() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &- b
    let result2: Int32 = result1 &- c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_releasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &- b
    let result2: Int32 = result1 &- c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_acquiringAndReleasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &- b
    let result2: Int32 = result1 &- c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_sequentiallyConsistent() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &- b
    let result2: Int32 = result1 &- c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_relaxed() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a & b
    let result2: Int32 = result1 & c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_acquiring() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a & b
    let result2: Int32 = result1 & c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_releasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a & b
    let result2: Int32 = result1 & c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_acquiringAndReleasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a & b
    let result2: Int32 = result1 & c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_sequentiallyConsistent() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a & b
    let result2: Int32 = result1 & c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_relaxed() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a | b
    let result2: Int32 = result1 | c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_acquiring() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a | b
    let result2: Int32 = result1 | c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_releasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a | b
    let result2: Int32 = result1 | c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_acquiringAndReleasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a | b
    let result2: Int32 = result1 | c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_sequentiallyConsistent() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a | b
    let result2: Int32 = result1 | c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_relaxed() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a ^ b
    let result2: Int32 = result1 ^ c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_acquiring() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a ^ b
    let result2: Int32 = result1 ^ c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_releasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a ^ b
    let result2: Int32 = result1 ^ c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_acquiringAndReleasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a ^ b
    let result2: Int32 = result1 ^ c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_sequentiallyConsistent() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a ^ b
    let result2: Int32 = result1 ^ c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }

  func test_wrappingIncrementThenLoad_relaxed() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &+ b
    let result2: Int32 = result1 &+ c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_acquiring() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &+ b
    let result2: Int32 = result1 &+ c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_releasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &+ b
    let result2: Int32 = result1 &+ c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_acquiringAndReleasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &+ b
    let result2: Int32 = result1 &+ c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_sequentiallyConsistent() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &+ b
    let result2: Int32 = result1 &+ c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_relaxed() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &- b
    let result2: Int32 = result1 &- c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_acquiring() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &- b
    let result2: Int32 = result1 &- c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_releasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &- b
    let result2: Int32 = result1 &- c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_acquiringAndReleasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &- b
    let result2: Int32 = result1 &- c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_sequentiallyConsistent() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &- b
    let result2: Int32 = result1 &- c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_relaxed() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a & b
    let result2: Int32 = result1 & c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_acquiring() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a & b
    let result2: Int32 = result1 & c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_releasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a & b
    let result2: Int32 = result1 & c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_acquiringAndReleasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a & b
    let result2: Int32 = result1 & c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_sequentiallyConsistent() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a & b
    let result2: Int32 = result1 & c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_relaxed() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a | b
    let result2: Int32 = result1 | c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_acquiring() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a | b
    let result2: Int32 = result1 | c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_releasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a | b
    let result2: Int32 = result1 | c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_acquiringAndReleasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a | b
    let result2: Int32 = result1 | c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_sequentiallyConsistent() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a | b
    let result2: Int32 = result1 | c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_relaxed() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a ^ b
    let result2: Int32 = result1 ^ c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_acquiring() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a ^ b
    let result2: Int32 = result1 ^ c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_releasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a ^ b
    let result2: Int32 = result1 ^ c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_acquiringAndReleasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a ^ b
    let result2: Int32 = result1 ^ c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_sequentiallyConsistent() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a ^ b
    let result2: Int32 = result1 ^ c

    let v = UnsafeAtomic<Int32>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }


  public static var allTests = [
    ("test_create_destroy", test_create_destroy),
    ("test_load_relaxed", test_load_relaxed),
    ("test_load_acquiring", test_load_acquiring),
    ("test_load_sequentiallyConsistent", test_load_sequentiallyConsistent),
    ("test_store_relaxed", test_store_relaxed),
    ("test_store_releasing", test_store_releasing),
    ("test_store_sequentiallyConsistent", test_store_sequentiallyConsistent),
    ("test_exchange_relaxed", test_exchange_relaxed),
    ("test_exchange_acquiring", test_exchange_acquiring),
    ("test_exchange_releasing", test_exchange_releasing),
    ("test_exchange_acquiringAndReleasing", test_exchange_acquiringAndReleasing),
    ("test_exchange_sequentiallyConsistent", test_exchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed", test_compareExchange_relaxed),
    ("test_compareExchange_acquiring", test_compareExchange_acquiring),
    ("test_compareExchange_releasing", test_compareExchange_releasing),
    ("test_compareExchange_acquiringAndReleasing", test_compareExchange_acquiringAndReleasing),
    ("test_compareExchange_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed_relaxed", test_compareExchange_relaxed_relaxed),
    ("test_compareExchange_relaxed_acquiring", test_compareExchange_relaxed_acquiring),
    ("test_compareExchange_relaxed_sequentiallyConsistent", test_compareExchange_relaxed_sequentiallyConsistent),
    ("test_compareExchange_acquiring_relaxed", test_compareExchange_acquiring_relaxed),
    ("test_compareExchange_acquiring_acquiring", test_compareExchange_acquiring_acquiring),
    ("test_compareExchange_acquiring_sequentiallyConsistent", test_compareExchange_acquiring_sequentiallyConsistent),
    ("test_compareExchange_releasing_relaxed", test_compareExchange_releasing_relaxed),
    ("test_compareExchange_releasing_acquiring", test_compareExchange_releasing_acquiring),
    ("test_compareExchange_releasing_sequentiallyConsistent", test_compareExchange_releasing_sequentiallyConsistent),
    ("test_compareExchange_acquiringAndReleasing_relaxed", test_compareExchange_acquiringAndReleasing_relaxed),
    ("test_compareExchange_acquiringAndReleasing_acquiring", test_compareExchange_acquiringAndReleasing_acquiring),
    ("test_compareExchange_acquiringAndReleasing_sequentiallyConsistent", test_compareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_compareExchange_sequentiallyConsistent_relaxed", test_compareExchange_sequentiallyConsistent_relaxed),
    ("test_compareExchange_sequentiallyConsistent_acquiring", test_compareExchange_sequentiallyConsistent_acquiring),
    ("test_compareExchange_sequentiallyConsistent_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent_sequentiallyConsistent),
    ("test_weakCompareExchange_relaxed_relaxed", test_weakCompareExchange_relaxed_relaxed),
    ("test_weakCompareExchange_relaxed_acquiring", test_weakCompareExchange_relaxed_acquiring),
    ("test_weakCompareExchange_relaxed_sequentiallyConsistent", test_weakCompareExchange_relaxed_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiring_relaxed", test_weakCompareExchange_acquiring_relaxed),
    ("test_weakCompareExchange_acquiring_acquiring", test_weakCompareExchange_acquiring_acquiring),
    ("test_weakCompareExchange_acquiring_sequentiallyConsistent", test_weakCompareExchange_acquiring_sequentiallyConsistent),
    ("test_weakCompareExchange_releasing_relaxed", test_weakCompareExchange_releasing_relaxed),
    ("test_weakCompareExchange_releasing_acquiring", test_weakCompareExchange_releasing_acquiring),
    ("test_weakCompareExchange_releasing_sequentiallyConsistent", test_weakCompareExchange_releasing_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiringAndReleasing_relaxed", test_weakCompareExchange_acquiringAndReleasing_relaxed),
    ("test_weakCompareExchange_acquiringAndReleasing_acquiring", test_weakCompareExchange_acquiringAndReleasing_acquiring),
    ("test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent", test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_weakCompareExchange_sequentiallyConsistent_relaxed", test_weakCompareExchange_sequentiallyConsistent_relaxed),
    ("test_weakCompareExchange_sequentiallyConsistent_acquiring", test_weakCompareExchange_sequentiallyConsistent_acquiring),
    ("test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent", test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent),
    ("test_loadThenWrappingIncrement_relaxed", test_loadThenWrappingIncrement_relaxed),
    ("test_loadThenWrappingIncrement_acquiring", test_loadThenWrappingIncrement_acquiring),
    ("test_loadThenWrappingIncrement_releasing", test_loadThenWrappingIncrement_releasing),
    ("test_loadThenWrappingIncrement_acquiringAndReleasing", test_loadThenWrappingIncrement_acquiringAndReleasing),
    ("test_loadThenWrappingIncrement_sequentiallyConsistent", test_loadThenWrappingIncrement_sequentiallyConsistent),
    ("test_loadThenWrappingDecrement_relaxed", test_loadThenWrappingDecrement_relaxed),
    ("test_loadThenWrappingDecrement_acquiring", test_loadThenWrappingDecrement_acquiring),
    ("test_loadThenWrappingDecrement_releasing", test_loadThenWrappingDecrement_releasing),
    ("test_loadThenWrappingDecrement_acquiringAndReleasing", test_loadThenWrappingDecrement_acquiringAndReleasing),
    ("test_loadThenWrappingDecrement_sequentiallyConsistent", test_loadThenWrappingDecrement_sequentiallyConsistent),
    ("test_loadThenBitwiseAnd_relaxed", test_loadThenBitwiseAnd_relaxed),
    ("test_loadThenBitwiseAnd_acquiring", test_loadThenBitwiseAnd_acquiring),
    ("test_loadThenBitwiseAnd_releasing", test_loadThenBitwiseAnd_releasing),
    ("test_loadThenBitwiseAnd_acquiringAndReleasing", test_loadThenBitwiseAnd_acquiringAndReleasing),
    ("test_loadThenBitwiseAnd_sequentiallyConsistent", test_loadThenBitwiseAnd_sequentiallyConsistent),
    ("test_loadThenBitwiseOr_relaxed", test_loadThenBitwiseOr_relaxed),
    ("test_loadThenBitwiseOr_acquiring", test_loadThenBitwiseOr_acquiring),
    ("test_loadThenBitwiseOr_releasing", test_loadThenBitwiseOr_releasing),
    ("test_loadThenBitwiseOr_acquiringAndReleasing", test_loadThenBitwiseOr_acquiringAndReleasing),
    ("test_loadThenBitwiseOr_sequentiallyConsistent", test_loadThenBitwiseOr_sequentiallyConsistent),
    ("test_loadThenBitwiseXor_relaxed", test_loadThenBitwiseXor_relaxed),
    ("test_loadThenBitwiseXor_acquiring", test_loadThenBitwiseXor_acquiring),
    ("test_loadThenBitwiseXor_releasing", test_loadThenBitwiseXor_releasing),
    ("test_loadThenBitwiseXor_acquiringAndReleasing", test_loadThenBitwiseXor_acquiringAndReleasing),
    ("test_loadThenBitwiseXor_sequentiallyConsistent", test_loadThenBitwiseXor_sequentiallyConsistent),
    ("test_wrappingIncrementThenLoad_relaxed", test_wrappingIncrementThenLoad_relaxed),
    ("test_wrappingIncrementThenLoad_acquiring", test_wrappingIncrementThenLoad_acquiring),
    ("test_wrappingIncrementThenLoad_releasing", test_wrappingIncrementThenLoad_releasing),
    ("test_wrappingIncrementThenLoad_acquiringAndReleasing", test_wrappingIncrementThenLoad_acquiringAndReleasing),
    ("test_wrappingIncrementThenLoad_sequentiallyConsistent", test_wrappingIncrementThenLoad_sequentiallyConsistent),
    ("test_wrappingDecrementThenLoad_relaxed", test_wrappingDecrementThenLoad_relaxed),
    ("test_wrappingDecrementThenLoad_acquiring", test_wrappingDecrementThenLoad_acquiring),
    ("test_wrappingDecrementThenLoad_releasing", test_wrappingDecrementThenLoad_releasing),
    ("test_wrappingDecrementThenLoad_acquiringAndReleasing", test_wrappingDecrementThenLoad_acquiringAndReleasing),
    ("test_wrappingDecrementThenLoad_sequentiallyConsistent", test_wrappingDecrementThenLoad_sequentiallyConsistent),
    ("test_bitwiseAndThenLoad_relaxed", test_bitwiseAndThenLoad_relaxed),
    ("test_bitwiseAndThenLoad_acquiring", test_bitwiseAndThenLoad_acquiring),
    ("test_bitwiseAndThenLoad_releasing", test_bitwiseAndThenLoad_releasing),
    ("test_bitwiseAndThenLoad_acquiringAndReleasing", test_bitwiseAndThenLoad_acquiringAndReleasing),
    ("test_bitwiseAndThenLoad_sequentiallyConsistent", test_bitwiseAndThenLoad_sequentiallyConsistent),
    ("test_bitwiseOrThenLoad_relaxed", test_bitwiseOrThenLoad_relaxed),
    ("test_bitwiseOrThenLoad_acquiring", test_bitwiseOrThenLoad_acquiring),
    ("test_bitwiseOrThenLoad_releasing", test_bitwiseOrThenLoad_releasing),
    ("test_bitwiseOrThenLoad_acquiringAndReleasing", test_bitwiseOrThenLoad_acquiringAndReleasing),
    ("test_bitwiseOrThenLoad_sequentiallyConsistent", test_bitwiseOrThenLoad_sequentiallyConsistent),
    ("test_bitwiseXorThenLoad_relaxed", test_bitwiseXorThenLoad_relaxed),
    ("test_bitwiseXorThenLoad_acquiring", test_bitwiseXorThenLoad_acquiring),
    ("test_bitwiseXorThenLoad_releasing", test_bitwiseXorThenLoad_releasing),
    ("test_bitwiseXorThenLoad_acquiringAndReleasing", test_bitwiseXorThenLoad_acquiringAndReleasing),
    ("test_bitwiseXorThenLoad_sequentiallyConsistent", test_bitwiseXorThenLoad_sequentiallyConsistent),
  ]
}
#endif
#if true
/// Exercises all operations in a single-threaded context, verifying
/// they provide the expected results.
class BasicAtomicInt64Tests: XCTestCase {

  func test_create_destroy() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    let w = UnsafeAtomic<Int64>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 23)
  }

  func test_load_relaxed() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    let w = UnsafeAtomic<Int64>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 23)
  }
  func test_load_acquiring() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .acquiring), 12)

    let w = UnsafeAtomic<Int64>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .acquiring), 23)
  }
  func test_load_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .sequentiallyConsistent), 12)

    let w = UnsafeAtomic<Int64>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .sequentiallyConsistent), 23)
  }

  func test_store_relaxed() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }
    v.store(23, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    let w = UnsafeAtomic<Int64>.create(23)
    defer { w.destroy() }
    w.store(12, ordering: .relaxed)
    XCTAssertEqual(w.load(ordering: .relaxed), 12)
  }
  func test_store_releasing() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }
    v.store(23, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    let w = UnsafeAtomic<Int64>.create(23)
    defer { w.destroy() }
    w.store(12, ordering: .releasing)
    XCTAssertEqual(w.load(ordering: .relaxed), 12)
  }
  func test_store_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }
    v.store(23, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    let w = UnsafeAtomic<Int64>.create(23)
    defer { w.destroy() }
    w.store(12, ordering: .sequentiallyConsistent)
    XCTAssertEqual(w.load(ordering: .relaxed), 12)
  }

  func test_exchange_relaxed() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .relaxed), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .relaxed), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .relaxed), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_acquiring() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .acquiring), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .acquiring), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .acquiring), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_releasing() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .releasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .releasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .releasing), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .acquiringAndReleasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .acquiringAndReleasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .acquiringAndReleasing), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .sequentiallyConsistent), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .sequentiallyConsistent), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .sequentiallyConsistent), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }

  func test_compareExchange_relaxed() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }

  func test_compareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }



// Integer operations
  func test_loadThenWrappingIncrement_relaxed() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &+ b
    let result2: Int64 = result1 &+ c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_acquiring() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &+ b
    let result2: Int64 = result1 &+ c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_releasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &+ b
    let result2: Int64 = result1 &+ c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_acquiringAndReleasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &+ b
    let result2: Int64 = result1 &+ c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_sequentiallyConsistent() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &+ b
    let result2: Int64 = result1 &+ c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_relaxed() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &- b
    let result2: Int64 = result1 &- c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_acquiring() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &- b
    let result2: Int64 = result1 &- c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_releasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &- b
    let result2: Int64 = result1 &- c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_acquiringAndReleasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &- b
    let result2: Int64 = result1 &- c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_sequentiallyConsistent() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &- b
    let result2: Int64 = result1 &- c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_relaxed() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a & b
    let result2: Int64 = result1 & c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_acquiring() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a & b
    let result2: Int64 = result1 & c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_releasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a & b
    let result2: Int64 = result1 & c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_acquiringAndReleasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a & b
    let result2: Int64 = result1 & c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_sequentiallyConsistent() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a & b
    let result2: Int64 = result1 & c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_relaxed() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a | b
    let result2: Int64 = result1 | c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_acquiring() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a | b
    let result2: Int64 = result1 | c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_releasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a | b
    let result2: Int64 = result1 | c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_acquiringAndReleasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a | b
    let result2: Int64 = result1 | c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_sequentiallyConsistent() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a | b
    let result2: Int64 = result1 | c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_relaxed() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a ^ b
    let result2: Int64 = result1 ^ c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_acquiring() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a ^ b
    let result2: Int64 = result1 ^ c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_releasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a ^ b
    let result2: Int64 = result1 ^ c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_acquiringAndReleasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a ^ b
    let result2: Int64 = result1 ^ c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_sequentiallyConsistent() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a ^ b
    let result2: Int64 = result1 ^ c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }

  func test_wrappingIncrementThenLoad_relaxed() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &+ b
    let result2: Int64 = result1 &+ c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_acquiring() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &+ b
    let result2: Int64 = result1 &+ c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_releasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &+ b
    let result2: Int64 = result1 &+ c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_acquiringAndReleasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &+ b
    let result2: Int64 = result1 &+ c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_sequentiallyConsistent() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &+ b
    let result2: Int64 = result1 &+ c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_relaxed() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &- b
    let result2: Int64 = result1 &- c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_acquiring() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &- b
    let result2: Int64 = result1 &- c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_releasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &- b
    let result2: Int64 = result1 &- c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_acquiringAndReleasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &- b
    let result2: Int64 = result1 &- c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_sequentiallyConsistent() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &- b
    let result2: Int64 = result1 &- c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_relaxed() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a & b
    let result2: Int64 = result1 & c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_acquiring() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a & b
    let result2: Int64 = result1 & c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_releasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a & b
    let result2: Int64 = result1 & c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_acquiringAndReleasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a & b
    let result2: Int64 = result1 & c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_sequentiallyConsistent() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a & b
    let result2: Int64 = result1 & c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_relaxed() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a | b
    let result2: Int64 = result1 | c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_acquiring() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a | b
    let result2: Int64 = result1 | c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_releasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a | b
    let result2: Int64 = result1 | c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_acquiringAndReleasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a | b
    let result2: Int64 = result1 | c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_sequentiallyConsistent() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a | b
    let result2: Int64 = result1 | c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_relaxed() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a ^ b
    let result2: Int64 = result1 ^ c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_acquiring() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a ^ b
    let result2: Int64 = result1 ^ c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_releasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a ^ b
    let result2: Int64 = result1 ^ c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_acquiringAndReleasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a ^ b
    let result2: Int64 = result1 ^ c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_sequentiallyConsistent() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a ^ b
    let result2: Int64 = result1 ^ c

    let v = UnsafeAtomic<Int64>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }


  public static var allTests = [
    ("test_create_destroy", test_create_destroy),
    ("test_load_relaxed", test_load_relaxed),
    ("test_load_acquiring", test_load_acquiring),
    ("test_load_sequentiallyConsistent", test_load_sequentiallyConsistent),
    ("test_store_relaxed", test_store_relaxed),
    ("test_store_releasing", test_store_releasing),
    ("test_store_sequentiallyConsistent", test_store_sequentiallyConsistent),
    ("test_exchange_relaxed", test_exchange_relaxed),
    ("test_exchange_acquiring", test_exchange_acquiring),
    ("test_exchange_releasing", test_exchange_releasing),
    ("test_exchange_acquiringAndReleasing", test_exchange_acquiringAndReleasing),
    ("test_exchange_sequentiallyConsistent", test_exchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed", test_compareExchange_relaxed),
    ("test_compareExchange_acquiring", test_compareExchange_acquiring),
    ("test_compareExchange_releasing", test_compareExchange_releasing),
    ("test_compareExchange_acquiringAndReleasing", test_compareExchange_acquiringAndReleasing),
    ("test_compareExchange_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed_relaxed", test_compareExchange_relaxed_relaxed),
    ("test_compareExchange_relaxed_acquiring", test_compareExchange_relaxed_acquiring),
    ("test_compareExchange_relaxed_sequentiallyConsistent", test_compareExchange_relaxed_sequentiallyConsistent),
    ("test_compareExchange_acquiring_relaxed", test_compareExchange_acquiring_relaxed),
    ("test_compareExchange_acquiring_acquiring", test_compareExchange_acquiring_acquiring),
    ("test_compareExchange_acquiring_sequentiallyConsistent", test_compareExchange_acquiring_sequentiallyConsistent),
    ("test_compareExchange_releasing_relaxed", test_compareExchange_releasing_relaxed),
    ("test_compareExchange_releasing_acquiring", test_compareExchange_releasing_acquiring),
    ("test_compareExchange_releasing_sequentiallyConsistent", test_compareExchange_releasing_sequentiallyConsistent),
    ("test_compareExchange_acquiringAndReleasing_relaxed", test_compareExchange_acquiringAndReleasing_relaxed),
    ("test_compareExchange_acquiringAndReleasing_acquiring", test_compareExchange_acquiringAndReleasing_acquiring),
    ("test_compareExchange_acquiringAndReleasing_sequentiallyConsistent", test_compareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_compareExchange_sequentiallyConsistent_relaxed", test_compareExchange_sequentiallyConsistent_relaxed),
    ("test_compareExchange_sequentiallyConsistent_acquiring", test_compareExchange_sequentiallyConsistent_acquiring),
    ("test_compareExchange_sequentiallyConsistent_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent_sequentiallyConsistent),
    ("test_weakCompareExchange_relaxed_relaxed", test_weakCompareExchange_relaxed_relaxed),
    ("test_weakCompareExchange_relaxed_acquiring", test_weakCompareExchange_relaxed_acquiring),
    ("test_weakCompareExchange_relaxed_sequentiallyConsistent", test_weakCompareExchange_relaxed_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiring_relaxed", test_weakCompareExchange_acquiring_relaxed),
    ("test_weakCompareExchange_acquiring_acquiring", test_weakCompareExchange_acquiring_acquiring),
    ("test_weakCompareExchange_acquiring_sequentiallyConsistent", test_weakCompareExchange_acquiring_sequentiallyConsistent),
    ("test_weakCompareExchange_releasing_relaxed", test_weakCompareExchange_releasing_relaxed),
    ("test_weakCompareExchange_releasing_acquiring", test_weakCompareExchange_releasing_acquiring),
    ("test_weakCompareExchange_releasing_sequentiallyConsistent", test_weakCompareExchange_releasing_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiringAndReleasing_relaxed", test_weakCompareExchange_acquiringAndReleasing_relaxed),
    ("test_weakCompareExchange_acquiringAndReleasing_acquiring", test_weakCompareExchange_acquiringAndReleasing_acquiring),
    ("test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent", test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_weakCompareExchange_sequentiallyConsistent_relaxed", test_weakCompareExchange_sequentiallyConsistent_relaxed),
    ("test_weakCompareExchange_sequentiallyConsistent_acquiring", test_weakCompareExchange_sequentiallyConsistent_acquiring),
    ("test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent", test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent),
    ("test_loadThenWrappingIncrement_relaxed", test_loadThenWrappingIncrement_relaxed),
    ("test_loadThenWrappingIncrement_acquiring", test_loadThenWrappingIncrement_acquiring),
    ("test_loadThenWrappingIncrement_releasing", test_loadThenWrappingIncrement_releasing),
    ("test_loadThenWrappingIncrement_acquiringAndReleasing", test_loadThenWrappingIncrement_acquiringAndReleasing),
    ("test_loadThenWrappingIncrement_sequentiallyConsistent", test_loadThenWrappingIncrement_sequentiallyConsistent),
    ("test_loadThenWrappingDecrement_relaxed", test_loadThenWrappingDecrement_relaxed),
    ("test_loadThenWrappingDecrement_acquiring", test_loadThenWrappingDecrement_acquiring),
    ("test_loadThenWrappingDecrement_releasing", test_loadThenWrappingDecrement_releasing),
    ("test_loadThenWrappingDecrement_acquiringAndReleasing", test_loadThenWrappingDecrement_acquiringAndReleasing),
    ("test_loadThenWrappingDecrement_sequentiallyConsistent", test_loadThenWrappingDecrement_sequentiallyConsistent),
    ("test_loadThenBitwiseAnd_relaxed", test_loadThenBitwiseAnd_relaxed),
    ("test_loadThenBitwiseAnd_acquiring", test_loadThenBitwiseAnd_acquiring),
    ("test_loadThenBitwiseAnd_releasing", test_loadThenBitwiseAnd_releasing),
    ("test_loadThenBitwiseAnd_acquiringAndReleasing", test_loadThenBitwiseAnd_acquiringAndReleasing),
    ("test_loadThenBitwiseAnd_sequentiallyConsistent", test_loadThenBitwiseAnd_sequentiallyConsistent),
    ("test_loadThenBitwiseOr_relaxed", test_loadThenBitwiseOr_relaxed),
    ("test_loadThenBitwiseOr_acquiring", test_loadThenBitwiseOr_acquiring),
    ("test_loadThenBitwiseOr_releasing", test_loadThenBitwiseOr_releasing),
    ("test_loadThenBitwiseOr_acquiringAndReleasing", test_loadThenBitwiseOr_acquiringAndReleasing),
    ("test_loadThenBitwiseOr_sequentiallyConsistent", test_loadThenBitwiseOr_sequentiallyConsistent),
    ("test_loadThenBitwiseXor_relaxed", test_loadThenBitwiseXor_relaxed),
    ("test_loadThenBitwiseXor_acquiring", test_loadThenBitwiseXor_acquiring),
    ("test_loadThenBitwiseXor_releasing", test_loadThenBitwiseXor_releasing),
    ("test_loadThenBitwiseXor_acquiringAndReleasing", test_loadThenBitwiseXor_acquiringAndReleasing),
    ("test_loadThenBitwiseXor_sequentiallyConsistent", test_loadThenBitwiseXor_sequentiallyConsistent),
    ("test_wrappingIncrementThenLoad_relaxed", test_wrappingIncrementThenLoad_relaxed),
    ("test_wrappingIncrementThenLoad_acquiring", test_wrappingIncrementThenLoad_acquiring),
    ("test_wrappingIncrementThenLoad_releasing", test_wrappingIncrementThenLoad_releasing),
    ("test_wrappingIncrementThenLoad_acquiringAndReleasing", test_wrappingIncrementThenLoad_acquiringAndReleasing),
    ("test_wrappingIncrementThenLoad_sequentiallyConsistent", test_wrappingIncrementThenLoad_sequentiallyConsistent),
    ("test_wrappingDecrementThenLoad_relaxed", test_wrappingDecrementThenLoad_relaxed),
    ("test_wrappingDecrementThenLoad_acquiring", test_wrappingDecrementThenLoad_acquiring),
    ("test_wrappingDecrementThenLoad_releasing", test_wrappingDecrementThenLoad_releasing),
    ("test_wrappingDecrementThenLoad_acquiringAndReleasing", test_wrappingDecrementThenLoad_acquiringAndReleasing),
    ("test_wrappingDecrementThenLoad_sequentiallyConsistent", test_wrappingDecrementThenLoad_sequentiallyConsistent),
    ("test_bitwiseAndThenLoad_relaxed", test_bitwiseAndThenLoad_relaxed),
    ("test_bitwiseAndThenLoad_acquiring", test_bitwiseAndThenLoad_acquiring),
    ("test_bitwiseAndThenLoad_releasing", test_bitwiseAndThenLoad_releasing),
    ("test_bitwiseAndThenLoad_acquiringAndReleasing", test_bitwiseAndThenLoad_acquiringAndReleasing),
    ("test_bitwiseAndThenLoad_sequentiallyConsistent", test_bitwiseAndThenLoad_sequentiallyConsistent),
    ("test_bitwiseOrThenLoad_relaxed", test_bitwiseOrThenLoad_relaxed),
    ("test_bitwiseOrThenLoad_acquiring", test_bitwiseOrThenLoad_acquiring),
    ("test_bitwiseOrThenLoad_releasing", test_bitwiseOrThenLoad_releasing),
    ("test_bitwiseOrThenLoad_acquiringAndReleasing", test_bitwiseOrThenLoad_acquiringAndReleasing),
    ("test_bitwiseOrThenLoad_sequentiallyConsistent", test_bitwiseOrThenLoad_sequentiallyConsistent),
    ("test_bitwiseXorThenLoad_relaxed", test_bitwiseXorThenLoad_relaxed),
    ("test_bitwiseXorThenLoad_acquiring", test_bitwiseXorThenLoad_acquiring),
    ("test_bitwiseXorThenLoad_releasing", test_bitwiseXorThenLoad_releasing),
    ("test_bitwiseXorThenLoad_acquiringAndReleasing", test_bitwiseXorThenLoad_acquiringAndReleasing),
    ("test_bitwiseXorThenLoad_sequentiallyConsistent", test_bitwiseXorThenLoad_sequentiallyConsistent),
  ]
}
#endif
#if true
/// Exercises all operations in a single-threaded context, verifying
/// they provide the expected results.
class BasicAtomicUIntTests: XCTestCase {

  func test_create_destroy() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    let w = UnsafeAtomic<UInt>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 23)
  }

  func test_load_relaxed() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    let w = UnsafeAtomic<UInt>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 23)
  }
  func test_load_acquiring() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .acquiring), 12)

    let w = UnsafeAtomic<UInt>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .acquiring), 23)
  }
  func test_load_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .sequentiallyConsistent), 12)

    let w = UnsafeAtomic<UInt>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .sequentiallyConsistent), 23)
  }

  func test_store_relaxed() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }
    v.store(23, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    let w = UnsafeAtomic<UInt>.create(23)
    defer { w.destroy() }
    w.store(12, ordering: .relaxed)
    XCTAssertEqual(w.load(ordering: .relaxed), 12)
  }
  func test_store_releasing() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }
    v.store(23, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    let w = UnsafeAtomic<UInt>.create(23)
    defer { w.destroy() }
    w.store(12, ordering: .releasing)
    XCTAssertEqual(w.load(ordering: .relaxed), 12)
  }
  func test_store_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }
    v.store(23, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    let w = UnsafeAtomic<UInt>.create(23)
    defer { w.destroy() }
    w.store(12, ordering: .sequentiallyConsistent)
    XCTAssertEqual(w.load(ordering: .relaxed), 12)
  }

  func test_exchange_relaxed() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .relaxed), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .relaxed), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .relaxed), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_acquiring() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .acquiring), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .acquiring), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .acquiring), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_releasing() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .releasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .releasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .releasing), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .acquiringAndReleasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .acquiringAndReleasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .acquiringAndReleasing), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .sequentiallyConsistent), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .sequentiallyConsistent), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .sequentiallyConsistent), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }

  func test_compareExchange_relaxed() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }

  func test_compareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }



// Integer operations
  func test_loadThenWrappingIncrement_relaxed() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &+ b
    let result2: UInt = result1 &+ c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_acquiring() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &+ b
    let result2: UInt = result1 &+ c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_releasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &+ b
    let result2: UInt = result1 &+ c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_acquiringAndReleasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &+ b
    let result2: UInt = result1 &+ c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_sequentiallyConsistent() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &+ b
    let result2: UInt = result1 &+ c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_relaxed() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &- b
    let result2: UInt = result1 &- c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_acquiring() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &- b
    let result2: UInt = result1 &- c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_releasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &- b
    let result2: UInt = result1 &- c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_acquiringAndReleasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &- b
    let result2: UInt = result1 &- c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_sequentiallyConsistent() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &- b
    let result2: UInt = result1 &- c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_relaxed() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a & b
    let result2: UInt = result1 & c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_acquiring() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a & b
    let result2: UInt = result1 & c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_releasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a & b
    let result2: UInt = result1 & c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_acquiringAndReleasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a & b
    let result2: UInt = result1 & c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_sequentiallyConsistent() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a & b
    let result2: UInt = result1 & c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_relaxed() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a | b
    let result2: UInt = result1 | c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_acquiring() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a | b
    let result2: UInt = result1 | c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_releasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a | b
    let result2: UInt = result1 | c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_acquiringAndReleasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a | b
    let result2: UInt = result1 | c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_sequentiallyConsistent() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a | b
    let result2: UInt = result1 | c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_relaxed() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a ^ b
    let result2: UInt = result1 ^ c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_acquiring() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a ^ b
    let result2: UInt = result1 ^ c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_releasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a ^ b
    let result2: UInt = result1 ^ c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_acquiringAndReleasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a ^ b
    let result2: UInt = result1 ^ c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_sequentiallyConsistent() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a ^ b
    let result2: UInt = result1 ^ c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }

  func test_wrappingIncrementThenLoad_relaxed() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &+ b
    let result2: UInt = result1 &+ c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_acquiring() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &+ b
    let result2: UInt = result1 &+ c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_releasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &+ b
    let result2: UInt = result1 &+ c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_acquiringAndReleasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &+ b
    let result2: UInt = result1 &+ c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_sequentiallyConsistent() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &+ b
    let result2: UInt = result1 &+ c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_relaxed() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &- b
    let result2: UInt = result1 &- c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_acquiring() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &- b
    let result2: UInt = result1 &- c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_releasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &- b
    let result2: UInt = result1 &- c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_acquiringAndReleasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &- b
    let result2: UInt = result1 &- c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_sequentiallyConsistent() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &- b
    let result2: UInt = result1 &- c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_relaxed() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a & b
    let result2: UInt = result1 & c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_acquiring() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a & b
    let result2: UInt = result1 & c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_releasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a & b
    let result2: UInt = result1 & c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_acquiringAndReleasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a & b
    let result2: UInt = result1 & c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_sequentiallyConsistent() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a & b
    let result2: UInt = result1 & c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_relaxed() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a | b
    let result2: UInt = result1 | c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_acquiring() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a | b
    let result2: UInt = result1 | c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_releasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a | b
    let result2: UInt = result1 | c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_acquiringAndReleasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a | b
    let result2: UInt = result1 | c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_sequentiallyConsistent() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a | b
    let result2: UInt = result1 | c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_relaxed() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a ^ b
    let result2: UInt = result1 ^ c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_acquiring() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a ^ b
    let result2: UInt = result1 ^ c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_releasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a ^ b
    let result2: UInt = result1 ^ c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_acquiringAndReleasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a ^ b
    let result2: UInt = result1 ^ c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_sequentiallyConsistent() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a ^ b
    let result2: UInt = result1 ^ c

    let v = UnsafeAtomic<UInt>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }


  public static var allTests = [
    ("test_create_destroy", test_create_destroy),
    ("test_load_relaxed", test_load_relaxed),
    ("test_load_acquiring", test_load_acquiring),
    ("test_load_sequentiallyConsistent", test_load_sequentiallyConsistent),
    ("test_store_relaxed", test_store_relaxed),
    ("test_store_releasing", test_store_releasing),
    ("test_store_sequentiallyConsistent", test_store_sequentiallyConsistent),
    ("test_exchange_relaxed", test_exchange_relaxed),
    ("test_exchange_acquiring", test_exchange_acquiring),
    ("test_exchange_releasing", test_exchange_releasing),
    ("test_exchange_acquiringAndReleasing", test_exchange_acquiringAndReleasing),
    ("test_exchange_sequentiallyConsistent", test_exchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed", test_compareExchange_relaxed),
    ("test_compareExchange_acquiring", test_compareExchange_acquiring),
    ("test_compareExchange_releasing", test_compareExchange_releasing),
    ("test_compareExchange_acquiringAndReleasing", test_compareExchange_acquiringAndReleasing),
    ("test_compareExchange_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed_relaxed", test_compareExchange_relaxed_relaxed),
    ("test_compareExchange_relaxed_acquiring", test_compareExchange_relaxed_acquiring),
    ("test_compareExchange_relaxed_sequentiallyConsistent", test_compareExchange_relaxed_sequentiallyConsistent),
    ("test_compareExchange_acquiring_relaxed", test_compareExchange_acquiring_relaxed),
    ("test_compareExchange_acquiring_acquiring", test_compareExchange_acquiring_acquiring),
    ("test_compareExchange_acquiring_sequentiallyConsistent", test_compareExchange_acquiring_sequentiallyConsistent),
    ("test_compareExchange_releasing_relaxed", test_compareExchange_releasing_relaxed),
    ("test_compareExchange_releasing_acquiring", test_compareExchange_releasing_acquiring),
    ("test_compareExchange_releasing_sequentiallyConsistent", test_compareExchange_releasing_sequentiallyConsistent),
    ("test_compareExchange_acquiringAndReleasing_relaxed", test_compareExchange_acquiringAndReleasing_relaxed),
    ("test_compareExchange_acquiringAndReleasing_acquiring", test_compareExchange_acquiringAndReleasing_acquiring),
    ("test_compareExchange_acquiringAndReleasing_sequentiallyConsistent", test_compareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_compareExchange_sequentiallyConsistent_relaxed", test_compareExchange_sequentiallyConsistent_relaxed),
    ("test_compareExchange_sequentiallyConsistent_acquiring", test_compareExchange_sequentiallyConsistent_acquiring),
    ("test_compareExchange_sequentiallyConsistent_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent_sequentiallyConsistent),
    ("test_weakCompareExchange_relaxed_relaxed", test_weakCompareExchange_relaxed_relaxed),
    ("test_weakCompareExchange_relaxed_acquiring", test_weakCompareExchange_relaxed_acquiring),
    ("test_weakCompareExchange_relaxed_sequentiallyConsistent", test_weakCompareExchange_relaxed_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiring_relaxed", test_weakCompareExchange_acquiring_relaxed),
    ("test_weakCompareExchange_acquiring_acquiring", test_weakCompareExchange_acquiring_acquiring),
    ("test_weakCompareExchange_acquiring_sequentiallyConsistent", test_weakCompareExchange_acquiring_sequentiallyConsistent),
    ("test_weakCompareExchange_releasing_relaxed", test_weakCompareExchange_releasing_relaxed),
    ("test_weakCompareExchange_releasing_acquiring", test_weakCompareExchange_releasing_acquiring),
    ("test_weakCompareExchange_releasing_sequentiallyConsistent", test_weakCompareExchange_releasing_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiringAndReleasing_relaxed", test_weakCompareExchange_acquiringAndReleasing_relaxed),
    ("test_weakCompareExchange_acquiringAndReleasing_acquiring", test_weakCompareExchange_acquiringAndReleasing_acquiring),
    ("test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent", test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_weakCompareExchange_sequentiallyConsistent_relaxed", test_weakCompareExchange_sequentiallyConsistent_relaxed),
    ("test_weakCompareExchange_sequentiallyConsistent_acquiring", test_weakCompareExchange_sequentiallyConsistent_acquiring),
    ("test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent", test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent),
    ("test_loadThenWrappingIncrement_relaxed", test_loadThenWrappingIncrement_relaxed),
    ("test_loadThenWrappingIncrement_acquiring", test_loadThenWrappingIncrement_acquiring),
    ("test_loadThenWrappingIncrement_releasing", test_loadThenWrappingIncrement_releasing),
    ("test_loadThenWrappingIncrement_acquiringAndReleasing", test_loadThenWrappingIncrement_acquiringAndReleasing),
    ("test_loadThenWrappingIncrement_sequentiallyConsistent", test_loadThenWrappingIncrement_sequentiallyConsistent),
    ("test_loadThenWrappingDecrement_relaxed", test_loadThenWrappingDecrement_relaxed),
    ("test_loadThenWrappingDecrement_acquiring", test_loadThenWrappingDecrement_acquiring),
    ("test_loadThenWrappingDecrement_releasing", test_loadThenWrappingDecrement_releasing),
    ("test_loadThenWrappingDecrement_acquiringAndReleasing", test_loadThenWrappingDecrement_acquiringAndReleasing),
    ("test_loadThenWrappingDecrement_sequentiallyConsistent", test_loadThenWrappingDecrement_sequentiallyConsistent),
    ("test_loadThenBitwiseAnd_relaxed", test_loadThenBitwiseAnd_relaxed),
    ("test_loadThenBitwiseAnd_acquiring", test_loadThenBitwiseAnd_acquiring),
    ("test_loadThenBitwiseAnd_releasing", test_loadThenBitwiseAnd_releasing),
    ("test_loadThenBitwiseAnd_acquiringAndReleasing", test_loadThenBitwiseAnd_acquiringAndReleasing),
    ("test_loadThenBitwiseAnd_sequentiallyConsistent", test_loadThenBitwiseAnd_sequentiallyConsistent),
    ("test_loadThenBitwiseOr_relaxed", test_loadThenBitwiseOr_relaxed),
    ("test_loadThenBitwiseOr_acquiring", test_loadThenBitwiseOr_acquiring),
    ("test_loadThenBitwiseOr_releasing", test_loadThenBitwiseOr_releasing),
    ("test_loadThenBitwiseOr_acquiringAndReleasing", test_loadThenBitwiseOr_acquiringAndReleasing),
    ("test_loadThenBitwiseOr_sequentiallyConsistent", test_loadThenBitwiseOr_sequentiallyConsistent),
    ("test_loadThenBitwiseXor_relaxed", test_loadThenBitwiseXor_relaxed),
    ("test_loadThenBitwiseXor_acquiring", test_loadThenBitwiseXor_acquiring),
    ("test_loadThenBitwiseXor_releasing", test_loadThenBitwiseXor_releasing),
    ("test_loadThenBitwiseXor_acquiringAndReleasing", test_loadThenBitwiseXor_acquiringAndReleasing),
    ("test_loadThenBitwiseXor_sequentiallyConsistent", test_loadThenBitwiseXor_sequentiallyConsistent),
    ("test_wrappingIncrementThenLoad_relaxed", test_wrappingIncrementThenLoad_relaxed),
    ("test_wrappingIncrementThenLoad_acquiring", test_wrappingIncrementThenLoad_acquiring),
    ("test_wrappingIncrementThenLoad_releasing", test_wrappingIncrementThenLoad_releasing),
    ("test_wrappingIncrementThenLoad_acquiringAndReleasing", test_wrappingIncrementThenLoad_acquiringAndReleasing),
    ("test_wrappingIncrementThenLoad_sequentiallyConsistent", test_wrappingIncrementThenLoad_sequentiallyConsistent),
    ("test_wrappingDecrementThenLoad_relaxed", test_wrappingDecrementThenLoad_relaxed),
    ("test_wrappingDecrementThenLoad_acquiring", test_wrappingDecrementThenLoad_acquiring),
    ("test_wrappingDecrementThenLoad_releasing", test_wrappingDecrementThenLoad_releasing),
    ("test_wrappingDecrementThenLoad_acquiringAndReleasing", test_wrappingDecrementThenLoad_acquiringAndReleasing),
    ("test_wrappingDecrementThenLoad_sequentiallyConsistent", test_wrappingDecrementThenLoad_sequentiallyConsistent),
    ("test_bitwiseAndThenLoad_relaxed", test_bitwiseAndThenLoad_relaxed),
    ("test_bitwiseAndThenLoad_acquiring", test_bitwiseAndThenLoad_acquiring),
    ("test_bitwiseAndThenLoad_releasing", test_bitwiseAndThenLoad_releasing),
    ("test_bitwiseAndThenLoad_acquiringAndReleasing", test_bitwiseAndThenLoad_acquiringAndReleasing),
    ("test_bitwiseAndThenLoad_sequentiallyConsistent", test_bitwiseAndThenLoad_sequentiallyConsistent),
    ("test_bitwiseOrThenLoad_relaxed", test_bitwiseOrThenLoad_relaxed),
    ("test_bitwiseOrThenLoad_acquiring", test_bitwiseOrThenLoad_acquiring),
    ("test_bitwiseOrThenLoad_releasing", test_bitwiseOrThenLoad_releasing),
    ("test_bitwiseOrThenLoad_acquiringAndReleasing", test_bitwiseOrThenLoad_acquiringAndReleasing),
    ("test_bitwiseOrThenLoad_sequentiallyConsistent", test_bitwiseOrThenLoad_sequentiallyConsistent),
    ("test_bitwiseXorThenLoad_relaxed", test_bitwiseXorThenLoad_relaxed),
    ("test_bitwiseXorThenLoad_acquiring", test_bitwiseXorThenLoad_acquiring),
    ("test_bitwiseXorThenLoad_releasing", test_bitwiseXorThenLoad_releasing),
    ("test_bitwiseXorThenLoad_acquiringAndReleasing", test_bitwiseXorThenLoad_acquiringAndReleasing),
    ("test_bitwiseXorThenLoad_sequentiallyConsistent", test_bitwiseXorThenLoad_sequentiallyConsistent),
  ]
}
#endif
#if true
/// Exercises all operations in a single-threaded context, verifying
/// they provide the expected results.
class BasicAtomicUInt8Tests: XCTestCase {

  func test_create_destroy() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    let w = UnsafeAtomic<UInt8>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 23)
  }

  func test_load_relaxed() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    let w = UnsafeAtomic<UInt8>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 23)
  }
  func test_load_acquiring() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .acquiring), 12)

    let w = UnsafeAtomic<UInt8>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .acquiring), 23)
  }
  func test_load_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .sequentiallyConsistent), 12)

    let w = UnsafeAtomic<UInt8>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .sequentiallyConsistent), 23)
  }

  func test_store_relaxed() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }
    v.store(23, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    let w = UnsafeAtomic<UInt8>.create(23)
    defer { w.destroy() }
    w.store(12, ordering: .relaxed)
    XCTAssertEqual(w.load(ordering: .relaxed), 12)
  }
  func test_store_releasing() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }
    v.store(23, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    let w = UnsafeAtomic<UInt8>.create(23)
    defer { w.destroy() }
    w.store(12, ordering: .releasing)
    XCTAssertEqual(w.load(ordering: .relaxed), 12)
  }
  func test_store_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }
    v.store(23, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    let w = UnsafeAtomic<UInt8>.create(23)
    defer { w.destroy() }
    w.store(12, ordering: .sequentiallyConsistent)
    XCTAssertEqual(w.load(ordering: .relaxed), 12)
  }

  func test_exchange_relaxed() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .relaxed), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .relaxed), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .relaxed), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_acquiring() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .acquiring), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .acquiring), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .acquiring), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_releasing() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .releasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .releasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .releasing), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .acquiringAndReleasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .acquiringAndReleasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .acquiringAndReleasing), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .sequentiallyConsistent), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .sequentiallyConsistent), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .sequentiallyConsistent), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }

  func test_compareExchange_relaxed() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }

  func test_compareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt8>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }



// Integer operations
  func test_loadThenWrappingIncrement_relaxed() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &+ b
    let result2: UInt8 = result1 &+ c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_acquiring() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &+ b
    let result2: UInt8 = result1 &+ c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_releasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &+ b
    let result2: UInt8 = result1 &+ c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_acquiringAndReleasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &+ b
    let result2: UInt8 = result1 &+ c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_sequentiallyConsistent() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &+ b
    let result2: UInt8 = result1 &+ c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_relaxed() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &- b
    let result2: UInt8 = result1 &- c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_acquiring() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &- b
    let result2: UInt8 = result1 &- c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_releasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &- b
    let result2: UInt8 = result1 &- c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_acquiringAndReleasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &- b
    let result2: UInt8 = result1 &- c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_sequentiallyConsistent() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &- b
    let result2: UInt8 = result1 &- c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_relaxed() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a & b
    let result2: UInt8 = result1 & c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_acquiring() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a & b
    let result2: UInt8 = result1 & c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_releasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a & b
    let result2: UInt8 = result1 & c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_acquiringAndReleasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a & b
    let result2: UInt8 = result1 & c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_sequentiallyConsistent() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a & b
    let result2: UInt8 = result1 & c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_relaxed() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a | b
    let result2: UInt8 = result1 | c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_acquiring() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a | b
    let result2: UInt8 = result1 | c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_releasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a | b
    let result2: UInt8 = result1 | c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_acquiringAndReleasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a | b
    let result2: UInt8 = result1 | c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_sequentiallyConsistent() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a | b
    let result2: UInt8 = result1 | c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_relaxed() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a ^ b
    let result2: UInt8 = result1 ^ c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_acquiring() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a ^ b
    let result2: UInt8 = result1 ^ c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_releasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a ^ b
    let result2: UInt8 = result1 ^ c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_acquiringAndReleasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a ^ b
    let result2: UInt8 = result1 ^ c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_sequentiallyConsistent() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a ^ b
    let result2: UInt8 = result1 ^ c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }

  func test_wrappingIncrementThenLoad_relaxed() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &+ b
    let result2: UInt8 = result1 &+ c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_acquiring() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &+ b
    let result2: UInt8 = result1 &+ c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_releasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &+ b
    let result2: UInt8 = result1 &+ c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_acquiringAndReleasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &+ b
    let result2: UInt8 = result1 &+ c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_sequentiallyConsistent() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &+ b
    let result2: UInt8 = result1 &+ c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_relaxed() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &- b
    let result2: UInt8 = result1 &- c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_acquiring() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &- b
    let result2: UInt8 = result1 &- c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_releasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &- b
    let result2: UInt8 = result1 &- c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_acquiringAndReleasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &- b
    let result2: UInt8 = result1 &- c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_sequentiallyConsistent() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &- b
    let result2: UInt8 = result1 &- c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_relaxed() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a & b
    let result2: UInt8 = result1 & c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_acquiring() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a & b
    let result2: UInt8 = result1 & c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_releasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a & b
    let result2: UInt8 = result1 & c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_acquiringAndReleasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a & b
    let result2: UInt8 = result1 & c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_sequentiallyConsistent() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a & b
    let result2: UInt8 = result1 & c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_relaxed() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a | b
    let result2: UInt8 = result1 | c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_acquiring() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a | b
    let result2: UInt8 = result1 | c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_releasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a | b
    let result2: UInt8 = result1 | c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_acquiringAndReleasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a | b
    let result2: UInt8 = result1 | c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_sequentiallyConsistent() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a | b
    let result2: UInt8 = result1 | c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_relaxed() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a ^ b
    let result2: UInt8 = result1 ^ c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_acquiring() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a ^ b
    let result2: UInt8 = result1 ^ c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_releasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a ^ b
    let result2: UInt8 = result1 ^ c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_acquiringAndReleasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a ^ b
    let result2: UInt8 = result1 ^ c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_sequentiallyConsistent() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a ^ b
    let result2: UInt8 = result1 ^ c

    let v = UnsafeAtomic<UInt8>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }


  public static var allTests = [
    ("test_create_destroy", test_create_destroy),
    ("test_load_relaxed", test_load_relaxed),
    ("test_load_acquiring", test_load_acquiring),
    ("test_load_sequentiallyConsistent", test_load_sequentiallyConsistent),
    ("test_store_relaxed", test_store_relaxed),
    ("test_store_releasing", test_store_releasing),
    ("test_store_sequentiallyConsistent", test_store_sequentiallyConsistent),
    ("test_exchange_relaxed", test_exchange_relaxed),
    ("test_exchange_acquiring", test_exchange_acquiring),
    ("test_exchange_releasing", test_exchange_releasing),
    ("test_exchange_acquiringAndReleasing", test_exchange_acquiringAndReleasing),
    ("test_exchange_sequentiallyConsistent", test_exchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed", test_compareExchange_relaxed),
    ("test_compareExchange_acquiring", test_compareExchange_acquiring),
    ("test_compareExchange_releasing", test_compareExchange_releasing),
    ("test_compareExchange_acquiringAndReleasing", test_compareExchange_acquiringAndReleasing),
    ("test_compareExchange_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed_relaxed", test_compareExchange_relaxed_relaxed),
    ("test_compareExchange_relaxed_acquiring", test_compareExchange_relaxed_acquiring),
    ("test_compareExchange_relaxed_sequentiallyConsistent", test_compareExchange_relaxed_sequentiallyConsistent),
    ("test_compareExchange_acquiring_relaxed", test_compareExchange_acquiring_relaxed),
    ("test_compareExchange_acquiring_acquiring", test_compareExchange_acquiring_acquiring),
    ("test_compareExchange_acquiring_sequentiallyConsistent", test_compareExchange_acquiring_sequentiallyConsistent),
    ("test_compareExchange_releasing_relaxed", test_compareExchange_releasing_relaxed),
    ("test_compareExchange_releasing_acquiring", test_compareExchange_releasing_acquiring),
    ("test_compareExchange_releasing_sequentiallyConsistent", test_compareExchange_releasing_sequentiallyConsistent),
    ("test_compareExchange_acquiringAndReleasing_relaxed", test_compareExchange_acquiringAndReleasing_relaxed),
    ("test_compareExchange_acquiringAndReleasing_acquiring", test_compareExchange_acquiringAndReleasing_acquiring),
    ("test_compareExchange_acquiringAndReleasing_sequentiallyConsistent", test_compareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_compareExchange_sequentiallyConsistent_relaxed", test_compareExchange_sequentiallyConsistent_relaxed),
    ("test_compareExchange_sequentiallyConsistent_acquiring", test_compareExchange_sequentiallyConsistent_acquiring),
    ("test_compareExchange_sequentiallyConsistent_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent_sequentiallyConsistent),
    ("test_weakCompareExchange_relaxed_relaxed", test_weakCompareExchange_relaxed_relaxed),
    ("test_weakCompareExchange_relaxed_acquiring", test_weakCompareExchange_relaxed_acquiring),
    ("test_weakCompareExchange_relaxed_sequentiallyConsistent", test_weakCompareExchange_relaxed_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiring_relaxed", test_weakCompareExchange_acquiring_relaxed),
    ("test_weakCompareExchange_acquiring_acquiring", test_weakCompareExchange_acquiring_acquiring),
    ("test_weakCompareExchange_acquiring_sequentiallyConsistent", test_weakCompareExchange_acquiring_sequentiallyConsistent),
    ("test_weakCompareExchange_releasing_relaxed", test_weakCompareExchange_releasing_relaxed),
    ("test_weakCompareExchange_releasing_acquiring", test_weakCompareExchange_releasing_acquiring),
    ("test_weakCompareExchange_releasing_sequentiallyConsistent", test_weakCompareExchange_releasing_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiringAndReleasing_relaxed", test_weakCompareExchange_acquiringAndReleasing_relaxed),
    ("test_weakCompareExchange_acquiringAndReleasing_acquiring", test_weakCompareExchange_acquiringAndReleasing_acquiring),
    ("test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent", test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_weakCompareExchange_sequentiallyConsistent_relaxed", test_weakCompareExchange_sequentiallyConsistent_relaxed),
    ("test_weakCompareExchange_sequentiallyConsistent_acquiring", test_weakCompareExchange_sequentiallyConsistent_acquiring),
    ("test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent", test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent),
    ("test_loadThenWrappingIncrement_relaxed", test_loadThenWrappingIncrement_relaxed),
    ("test_loadThenWrappingIncrement_acquiring", test_loadThenWrappingIncrement_acquiring),
    ("test_loadThenWrappingIncrement_releasing", test_loadThenWrappingIncrement_releasing),
    ("test_loadThenWrappingIncrement_acquiringAndReleasing", test_loadThenWrappingIncrement_acquiringAndReleasing),
    ("test_loadThenWrappingIncrement_sequentiallyConsistent", test_loadThenWrappingIncrement_sequentiallyConsistent),
    ("test_loadThenWrappingDecrement_relaxed", test_loadThenWrappingDecrement_relaxed),
    ("test_loadThenWrappingDecrement_acquiring", test_loadThenWrappingDecrement_acquiring),
    ("test_loadThenWrappingDecrement_releasing", test_loadThenWrappingDecrement_releasing),
    ("test_loadThenWrappingDecrement_acquiringAndReleasing", test_loadThenWrappingDecrement_acquiringAndReleasing),
    ("test_loadThenWrappingDecrement_sequentiallyConsistent", test_loadThenWrappingDecrement_sequentiallyConsistent),
    ("test_loadThenBitwiseAnd_relaxed", test_loadThenBitwiseAnd_relaxed),
    ("test_loadThenBitwiseAnd_acquiring", test_loadThenBitwiseAnd_acquiring),
    ("test_loadThenBitwiseAnd_releasing", test_loadThenBitwiseAnd_releasing),
    ("test_loadThenBitwiseAnd_acquiringAndReleasing", test_loadThenBitwiseAnd_acquiringAndReleasing),
    ("test_loadThenBitwiseAnd_sequentiallyConsistent", test_loadThenBitwiseAnd_sequentiallyConsistent),
    ("test_loadThenBitwiseOr_relaxed", test_loadThenBitwiseOr_relaxed),
    ("test_loadThenBitwiseOr_acquiring", test_loadThenBitwiseOr_acquiring),
    ("test_loadThenBitwiseOr_releasing", test_loadThenBitwiseOr_releasing),
    ("test_loadThenBitwiseOr_acquiringAndReleasing", test_loadThenBitwiseOr_acquiringAndReleasing),
    ("test_loadThenBitwiseOr_sequentiallyConsistent", test_loadThenBitwiseOr_sequentiallyConsistent),
    ("test_loadThenBitwiseXor_relaxed", test_loadThenBitwiseXor_relaxed),
    ("test_loadThenBitwiseXor_acquiring", test_loadThenBitwiseXor_acquiring),
    ("test_loadThenBitwiseXor_releasing", test_loadThenBitwiseXor_releasing),
    ("test_loadThenBitwiseXor_acquiringAndReleasing", test_loadThenBitwiseXor_acquiringAndReleasing),
    ("test_loadThenBitwiseXor_sequentiallyConsistent", test_loadThenBitwiseXor_sequentiallyConsistent),
    ("test_wrappingIncrementThenLoad_relaxed", test_wrappingIncrementThenLoad_relaxed),
    ("test_wrappingIncrementThenLoad_acquiring", test_wrappingIncrementThenLoad_acquiring),
    ("test_wrappingIncrementThenLoad_releasing", test_wrappingIncrementThenLoad_releasing),
    ("test_wrappingIncrementThenLoad_acquiringAndReleasing", test_wrappingIncrementThenLoad_acquiringAndReleasing),
    ("test_wrappingIncrementThenLoad_sequentiallyConsistent", test_wrappingIncrementThenLoad_sequentiallyConsistent),
    ("test_wrappingDecrementThenLoad_relaxed", test_wrappingDecrementThenLoad_relaxed),
    ("test_wrappingDecrementThenLoad_acquiring", test_wrappingDecrementThenLoad_acquiring),
    ("test_wrappingDecrementThenLoad_releasing", test_wrappingDecrementThenLoad_releasing),
    ("test_wrappingDecrementThenLoad_acquiringAndReleasing", test_wrappingDecrementThenLoad_acquiringAndReleasing),
    ("test_wrappingDecrementThenLoad_sequentiallyConsistent", test_wrappingDecrementThenLoad_sequentiallyConsistent),
    ("test_bitwiseAndThenLoad_relaxed", test_bitwiseAndThenLoad_relaxed),
    ("test_bitwiseAndThenLoad_acquiring", test_bitwiseAndThenLoad_acquiring),
    ("test_bitwiseAndThenLoad_releasing", test_bitwiseAndThenLoad_releasing),
    ("test_bitwiseAndThenLoad_acquiringAndReleasing", test_bitwiseAndThenLoad_acquiringAndReleasing),
    ("test_bitwiseAndThenLoad_sequentiallyConsistent", test_bitwiseAndThenLoad_sequentiallyConsistent),
    ("test_bitwiseOrThenLoad_relaxed", test_bitwiseOrThenLoad_relaxed),
    ("test_bitwiseOrThenLoad_acquiring", test_bitwiseOrThenLoad_acquiring),
    ("test_bitwiseOrThenLoad_releasing", test_bitwiseOrThenLoad_releasing),
    ("test_bitwiseOrThenLoad_acquiringAndReleasing", test_bitwiseOrThenLoad_acquiringAndReleasing),
    ("test_bitwiseOrThenLoad_sequentiallyConsistent", test_bitwiseOrThenLoad_sequentiallyConsistent),
    ("test_bitwiseXorThenLoad_relaxed", test_bitwiseXorThenLoad_relaxed),
    ("test_bitwiseXorThenLoad_acquiring", test_bitwiseXorThenLoad_acquiring),
    ("test_bitwiseXorThenLoad_releasing", test_bitwiseXorThenLoad_releasing),
    ("test_bitwiseXorThenLoad_acquiringAndReleasing", test_bitwiseXorThenLoad_acquiringAndReleasing),
    ("test_bitwiseXorThenLoad_sequentiallyConsistent", test_bitwiseXorThenLoad_sequentiallyConsistent),
  ]
}
#endif
#if true
/// Exercises all operations in a single-threaded context, verifying
/// they provide the expected results.
class BasicAtomicUInt16Tests: XCTestCase {

  func test_create_destroy() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    let w = UnsafeAtomic<UInt16>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 23)
  }

  func test_load_relaxed() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    let w = UnsafeAtomic<UInt16>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 23)
  }
  func test_load_acquiring() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .acquiring), 12)

    let w = UnsafeAtomic<UInt16>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .acquiring), 23)
  }
  func test_load_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .sequentiallyConsistent), 12)

    let w = UnsafeAtomic<UInt16>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .sequentiallyConsistent), 23)
  }

  func test_store_relaxed() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }
    v.store(23, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    let w = UnsafeAtomic<UInt16>.create(23)
    defer { w.destroy() }
    w.store(12, ordering: .relaxed)
    XCTAssertEqual(w.load(ordering: .relaxed), 12)
  }
  func test_store_releasing() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }
    v.store(23, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    let w = UnsafeAtomic<UInt16>.create(23)
    defer { w.destroy() }
    w.store(12, ordering: .releasing)
    XCTAssertEqual(w.load(ordering: .relaxed), 12)
  }
  func test_store_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }
    v.store(23, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    let w = UnsafeAtomic<UInt16>.create(23)
    defer { w.destroy() }
    w.store(12, ordering: .sequentiallyConsistent)
    XCTAssertEqual(w.load(ordering: .relaxed), 12)
  }

  func test_exchange_relaxed() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .relaxed), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .relaxed), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .relaxed), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_acquiring() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .acquiring), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .acquiring), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .acquiring), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_releasing() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .releasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .releasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .releasing), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .acquiringAndReleasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .acquiringAndReleasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .acquiringAndReleasing), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .sequentiallyConsistent), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .sequentiallyConsistent), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .sequentiallyConsistent), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }

  func test_compareExchange_relaxed() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }

  func test_compareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt16>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }



// Integer operations
  func test_loadThenWrappingIncrement_relaxed() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &+ b
    let result2: UInt16 = result1 &+ c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_acquiring() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &+ b
    let result2: UInt16 = result1 &+ c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_releasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &+ b
    let result2: UInt16 = result1 &+ c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_acquiringAndReleasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &+ b
    let result2: UInt16 = result1 &+ c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_sequentiallyConsistent() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &+ b
    let result2: UInt16 = result1 &+ c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_relaxed() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &- b
    let result2: UInt16 = result1 &- c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_acquiring() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &- b
    let result2: UInt16 = result1 &- c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_releasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &- b
    let result2: UInt16 = result1 &- c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_acquiringAndReleasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &- b
    let result2: UInt16 = result1 &- c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_sequentiallyConsistent() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &- b
    let result2: UInt16 = result1 &- c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_relaxed() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a & b
    let result2: UInt16 = result1 & c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_acquiring() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a & b
    let result2: UInt16 = result1 & c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_releasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a & b
    let result2: UInt16 = result1 & c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_acquiringAndReleasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a & b
    let result2: UInt16 = result1 & c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_sequentiallyConsistent() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a & b
    let result2: UInt16 = result1 & c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_relaxed() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a | b
    let result2: UInt16 = result1 | c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_acquiring() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a | b
    let result2: UInt16 = result1 | c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_releasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a | b
    let result2: UInt16 = result1 | c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_acquiringAndReleasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a | b
    let result2: UInt16 = result1 | c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_sequentiallyConsistent() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a | b
    let result2: UInt16 = result1 | c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_relaxed() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a ^ b
    let result2: UInt16 = result1 ^ c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_acquiring() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a ^ b
    let result2: UInt16 = result1 ^ c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_releasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a ^ b
    let result2: UInt16 = result1 ^ c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_acquiringAndReleasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a ^ b
    let result2: UInt16 = result1 ^ c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_sequentiallyConsistent() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a ^ b
    let result2: UInt16 = result1 ^ c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }

  func test_wrappingIncrementThenLoad_relaxed() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &+ b
    let result2: UInt16 = result1 &+ c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_acquiring() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &+ b
    let result2: UInt16 = result1 &+ c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_releasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &+ b
    let result2: UInt16 = result1 &+ c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_acquiringAndReleasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &+ b
    let result2: UInt16 = result1 &+ c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_sequentiallyConsistent() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &+ b
    let result2: UInt16 = result1 &+ c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_relaxed() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &- b
    let result2: UInt16 = result1 &- c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_acquiring() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &- b
    let result2: UInt16 = result1 &- c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_releasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &- b
    let result2: UInt16 = result1 &- c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_acquiringAndReleasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &- b
    let result2: UInt16 = result1 &- c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_sequentiallyConsistent() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &- b
    let result2: UInt16 = result1 &- c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_relaxed() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a & b
    let result2: UInt16 = result1 & c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_acquiring() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a & b
    let result2: UInt16 = result1 & c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_releasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a & b
    let result2: UInt16 = result1 & c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_acquiringAndReleasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a & b
    let result2: UInt16 = result1 & c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_sequentiallyConsistent() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a & b
    let result2: UInt16 = result1 & c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_relaxed() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a | b
    let result2: UInt16 = result1 | c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_acquiring() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a | b
    let result2: UInt16 = result1 | c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_releasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a | b
    let result2: UInt16 = result1 | c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_acquiringAndReleasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a | b
    let result2: UInt16 = result1 | c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_sequentiallyConsistent() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a | b
    let result2: UInt16 = result1 | c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_relaxed() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a ^ b
    let result2: UInt16 = result1 ^ c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_acquiring() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a ^ b
    let result2: UInt16 = result1 ^ c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_releasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a ^ b
    let result2: UInt16 = result1 ^ c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_acquiringAndReleasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a ^ b
    let result2: UInt16 = result1 ^ c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_sequentiallyConsistent() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a ^ b
    let result2: UInt16 = result1 ^ c

    let v = UnsafeAtomic<UInt16>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }


  public static var allTests = [
    ("test_create_destroy", test_create_destroy),
    ("test_load_relaxed", test_load_relaxed),
    ("test_load_acquiring", test_load_acquiring),
    ("test_load_sequentiallyConsistent", test_load_sequentiallyConsistent),
    ("test_store_relaxed", test_store_relaxed),
    ("test_store_releasing", test_store_releasing),
    ("test_store_sequentiallyConsistent", test_store_sequentiallyConsistent),
    ("test_exchange_relaxed", test_exchange_relaxed),
    ("test_exchange_acquiring", test_exchange_acquiring),
    ("test_exchange_releasing", test_exchange_releasing),
    ("test_exchange_acquiringAndReleasing", test_exchange_acquiringAndReleasing),
    ("test_exchange_sequentiallyConsistent", test_exchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed", test_compareExchange_relaxed),
    ("test_compareExchange_acquiring", test_compareExchange_acquiring),
    ("test_compareExchange_releasing", test_compareExchange_releasing),
    ("test_compareExchange_acquiringAndReleasing", test_compareExchange_acquiringAndReleasing),
    ("test_compareExchange_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed_relaxed", test_compareExchange_relaxed_relaxed),
    ("test_compareExchange_relaxed_acquiring", test_compareExchange_relaxed_acquiring),
    ("test_compareExchange_relaxed_sequentiallyConsistent", test_compareExchange_relaxed_sequentiallyConsistent),
    ("test_compareExchange_acquiring_relaxed", test_compareExchange_acquiring_relaxed),
    ("test_compareExchange_acquiring_acquiring", test_compareExchange_acquiring_acquiring),
    ("test_compareExchange_acquiring_sequentiallyConsistent", test_compareExchange_acquiring_sequentiallyConsistent),
    ("test_compareExchange_releasing_relaxed", test_compareExchange_releasing_relaxed),
    ("test_compareExchange_releasing_acquiring", test_compareExchange_releasing_acquiring),
    ("test_compareExchange_releasing_sequentiallyConsistent", test_compareExchange_releasing_sequentiallyConsistent),
    ("test_compareExchange_acquiringAndReleasing_relaxed", test_compareExchange_acquiringAndReleasing_relaxed),
    ("test_compareExchange_acquiringAndReleasing_acquiring", test_compareExchange_acquiringAndReleasing_acquiring),
    ("test_compareExchange_acquiringAndReleasing_sequentiallyConsistent", test_compareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_compareExchange_sequentiallyConsistent_relaxed", test_compareExchange_sequentiallyConsistent_relaxed),
    ("test_compareExchange_sequentiallyConsistent_acquiring", test_compareExchange_sequentiallyConsistent_acquiring),
    ("test_compareExchange_sequentiallyConsistent_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent_sequentiallyConsistent),
    ("test_weakCompareExchange_relaxed_relaxed", test_weakCompareExchange_relaxed_relaxed),
    ("test_weakCompareExchange_relaxed_acquiring", test_weakCompareExchange_relaxed_acquiring),
    ("test_weakCompareExchange_relaxed_sequentiallyConsistent", test_weakCompareExchange_relaxed_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiring_relaxed", test_weakCompareExchange_acquiring_relaxed),
    ("test_weakCompareExchange_acquiring_acquiring", test_weakCompareExchange_acquiring_acquiring),
    ("test_weakCompareExchange_acquiring_sequentiallyConsistent", test_weakCompareExchange_acquiring_sequentiallyConsistent),
    ("test_weakCompareExchange_releasing_relaxed", test_weakCompareExchange_releasing_relaxed),
    ("test_weakCompareExchange_releasing_acquiring", test_weakCompareExchange_releasing_acquiring),
    ("test_weakCompareExchange_releasing_sequentiallyConsistent", test_weakCompareExchange_releasing_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiringAndReleasing_relaxed", test_weakCompareExchange_acquiringAndReleasing_relaxed),
    ("test_weakCompareExchange_acquiringAndReleasing_acquiring", test_weakCompareExchange_acquiringAndReleasing_acquiring),
    ("test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent", test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_weakCompareExchange_sequentiallyConsistent_relaxed", test_weakCompareExchange_sequentiallyConsistent_relaxed),
    ("test_weakCompareExchange_sequentiallyConsistent_acquiring", test_weakCompareExchange_sequentiallyConsistent_acquiring),
    ("test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent", test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent),
    ("test_loadThenWrappingIncrement_relaxed", test_loadThenWrappingIncrement_relaxed),
    ("test_loadThenWrappingIncrement_acquiring", test_loadThenWrappingIncrement_acquiring),
    ("test_loadThenWrappingIncrement_releasing", test_loadThenWrappingIncrement_releasing),
    ("test_loadThenWrappingIncrement_acquiringAndReleasing", test_loadThenWrappingIncrement_acquiringAndReleasing),
    ("test_loadThenWrappingIncrement_sequentiallyConsistent", test_loadThenWrappingIncrement_sequentiallyConsistent),
    ("test_loadThenWrappingDecrement_relaxed", test_loadThenWrappingDecrement_relaxed),
    ("test_loadThenWrappingDecrement_acquiring", test_loadThenWrappingDecrement_acquiring),
    ("test_loadThenWrappingDecrement_releasing", test_loadThenWrappingDecrement_releasing),
    ("test_loadThenWrappingDecrement_acquiringAndReleasing", test_loadThenWrappingDecrement_acquiringAndReleasing),
    ("test_loadThenWrappingDecrement_sequentiallyConsistent", test_loadThenWrappingDecrement_sequentiallyConsistent),
    ("test_loadThenBitwiseAnd_relaxed", test_loadThenBitwiseAnd_relaxed),
    ("test_loadThenBitwiseAnd_acquiring", test_loadThenBitwiseAnd_acquiring),
    ("test_loadThenBitwiseAnd_releasing", test_loadThenBitwiseAnd_releasing),
    ("test_loadThenBitwiseAnd_acquiringAndReleasing", test_loadThenBitwiseAnd_acquiringAndReleasing),
    ("test_loadThenBitwiseAnd_sequentiallyConsistent", test_loadThenBitwiseAnd_sequentiallyConsistent),
    ("test_loadThenBitwiseOr_relaxed", test_loadThenBitwiseOr_relaxed),
    ("test_loadThenBitwiseOr_acquiring", test_loadThenBitwiseOr_acquiring),
    ("test_loadThenBitwiseOr_releasing", test_loadThenBitwiseOr_releasing),
    ("test_loadThenBitwiseOr_acquiringAndReleasing", test_loadThenBitwiseOr_acquiringAndReleasing),
    ("test_loadThenBitwiseOr_sequentiallyConsistent", test_loadThenBitwiseOr_sequentiallyConsistent),
    ("test_loadThenBitwiseXor_relaxed", test_loadThenBitwiseXor_relaxed),
    ("test_loadThenBitwiseXor_acquiring", test_loadThenBitwiseXor_acquiring),
    ("test_loadThenBitwiseXor_releasing", test_loadThenBitwiseXor_releasing),
    ("test_loadThenBitwiseXor_acquiringAndReleasing", test_loadThenBitwiseXor_acquiringAndReleasing),
    ("test_loadThenBitwiseXor_sequentiallyConsistent", test_loadThenBitwiseXor_sequentiallyConsistent),
    ("test_wrappingIncrementThenLoad_relaxed", test_wrappingIncrementThenLoad_relaxed),
    ("test_wrappingIncrementThenLoad_acquiring", test_wrappingIncrementThenLoad_acquiring),
    ("test_wrappingIncrementThenLoad_releasing", test_wrappingIncrementThenLoad_releasing),
    ("test_wrappingIncrementThenLoad_acquiringAndReleasing", test_wrappingIncrementThenLoad_acquiringAndReleasing),
    ("test_wrappingIncrementThenLoad_sequentiallyConsistent", test_wrappingIncrementThenLoad_sequentiallyConsistent),
    ("test_wrappingDecrementThenLoad_relaxed", test_wrappingDecrementThenLoad_relaxed),
    ("test_wrappingDecrementThenLoad_acquiring", test_wrappingDecrementThenLoad_acquiring),
    ("test_wrappingDecrementThenLoad_releasing", test_wrappingDecrementThenLoad_releasing),
    ("test_wrappingDecrementThenLoad_acquiringAndReleasing", test_wrappingDecrementThenLoad_acquiringAndReleasing),
    ("test_wrappingDecrementThenLoad_sequentiallyConsistent", test_wrappingDecrementThenLoad_sequentiallyConsistent),
    ("test_bitwiseAndThenLoad_relaxed", test_bitwiseAndThenLoad_relaxed),
    ("test_bitwiseAndThenLoad_acquiring", test_bitwiseAndThenLoad_acquiring),
    ("test_bitwiseAndThenLoad_releasing", test_bitwiseAndThenLoad_releasing),
    ("test_bitwiseAndThenLoad_acquiringAndReleasing", test_bitwiseAndThenLoad_acquiringAndReleasing),
    ("test_bitwiseAndThenLoad_sequentiallyConsistent", test_bitwiseAndThenLoad_sequentiallyConsistent),
    ("test_bitwiseOrThenLoad_relaxed", test_bitwiseOrThenLoad_relaxed),
    ("test_bitwiseOrThenLoad_acquiring", test_bitwiseOrThenLoad_acquiring),
    ("test_bitwiseOrThenLoad_releasing", test_bitwiseOrThenLoad_releasing),
    ("test_bitwiseOrThenLoad_acquiringAndReleasing", test_bitwiseOrThenLoad_acquiringAndReleasing),
    ("test_bitwiseOrThenLoad_sequentiallyConsistent", test_bitwiseOrThenLoad_sequentiallyConsistent),
    ("test_bitwiseXorThenLoad_relaxed", test_bitwiseXorThenLoad_relaxed),
    ("test_bitwiseXorThenLoad_acquiring", test_bitwiseXorThenLoad_acquiring),
    ("test_bitwiseXorThenLoad_releasing", test_bitwiseXorThenLoad_releasing),
    ("test_bitwiseXorThenLoad_acquiringAndReleasing", test_bitwiseXorThenLoad_acquiringAndReleasing),
    ("test_bitwiseXorThenLoad_sequentiallyConsistent", test_bitwiseXorThenLoad_sequentiallyConsistent),
  ]
}
#endif
#if true
/// Exercises all operations in a single-threaded context, verifying
/// they provide the expected results.
class BasicAtomicUInt32Tests: XCTestCase {

  func test_create_destroy() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    let w = UnsafeAtomic<UInt32>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 23)
  }

  func test_load_relaxed() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    let w = UnsafeAtomic<UInt32>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 23)
  }
  func test_load_acquiring() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .acquiring), 12)

    let w = UnsafeAtomic<UInt32>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .acquiring), 23)
  }
  func test_load_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .sequentiallyConsistent), 12)

    let w = UnsafeAtomic<UInt32>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .sequentiallyConsistent), 23)
  }

  func test_store_relaxed() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }
    v.store(23, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    let w = UnsafeAtomic<UInt32>.create(23)
    defer { w.destroy() }
    w.store(12, ordering: .relaxed)
    XCTAssertEqual(w.load(ordering: .relaxed), 12)
  }
  func test_store_releasing() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }
    v.store(23, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    let w = UnsafeAtomic<UInt32>.create(23)
    defer { w.destroy() }
    w.store(12, ordering: .releasing)
    XCTAssertEqual(w.load(ordering: .relaxed), 12)
  }
  func test_store_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }
    v.store(23, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    let w = UnsafeAtomic<UInt32>.create(23)
    defer { w.destroy() }
    w.store(12, ordering: .sequentiallyConsistent)
    XCTAssertEqual(w.load(ordering: .relaxed), 12)
  }

  func test_exchange_relaxed() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .relaxed), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .relaxed), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .relaxed), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_acquiring() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .acquiring), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .acquiring), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .acquiring), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_releasing() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .releasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .releasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .releasing), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .acquiringAndReleasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .acquiringAndReleasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .acquiringAndReleasing), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .sequentiallyConsistent), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .sequentiallyConsistent), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .sequentiallyConsistent), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }

  func test_compareExchange_relaxed() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }

  func test_compareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt32>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }



// Integer operations
  func test_loadThenWrappingIncrement_relaxed() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &+ b
    let result2: UInt32 = result1 &+ c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_acquiring() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &+ b
    let result2: UInt32 = result1 &+ c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_releasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &+ b
    let result2: UInt32 = result1 &+ c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_acquiringAndReleasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &+ b
    let result2: UInt32 = result1 &+ c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_sequentiallyConsistent() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &+ b
    let result2: UInt32 = result1 &+ c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_relaxed() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &- b
    let result2: UInt32 = result1 &- c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_acquiring() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &- b
    let result2: UInt32 = result1 &- c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_releasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &- b
    let result2: UInt32 = result1 &- c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_acquiringAndReleasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &- b
    let result2: UInt32 = result1 &- c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_sequentiallyConsistent() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &- b
    let result2: UInt32 = result1 &- c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_relaxed() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a & b
    let result2: UInt32 = result1 & c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_acquiring() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a & b
    let result2: UInt32 = result1 & c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_releasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a & b
    let result2: UInt32 = result1 & c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_acquiringAndReleasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a & b
    let result2: UInt32 = result1 & c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_sequentiallyConsistent() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a & b
    let result2: UInt32 = result1 & c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_relaxed() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a | b
    let result2: UInt32 = result1 | c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_acquiring() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a | b
    let result2: UInt32 = result1 | c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_releasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a | b
    let result2: UInt32 = result1 | c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_acquiringAndReleasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a | b
    let result2: UInt32 = result1 | c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_sequentiallyConsistent() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a | b
    let result2: UInt32 = result1 | c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_relaxed() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a ^ b
    let result2: UInt32 = result1 ^ c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_acquiring() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a ^ b
    let result2: UInt32 = result1 ^ c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_releasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a ^ b
    let result2: UInt32 = result1 ^ c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_acquiringAndReleasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a ^ b
    let result2: UInt32 = result1 ^ c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_sequentiallyConsistent() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a ^ b
    let result2: UInt32 = result1 ^ c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }

  func test_wrappingIncrementThenLoad_relaxed() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &+ b
    let result2: UInt32 = result1 &+ c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_acquiring() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &+ b
    let result2: UInt32 = result1 &+ c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_releasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &+ b
    let result2: UInt32 = result1 &+ c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_acquiringAndReleasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &+ b
    let result2: UInt32 = result1 &+ c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_sequentiallyConsistent() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &+ b
    let result2: UInt32 = result1 &+ c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_relaxed() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &- b
    let result2: UInt32 = result1 &- c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_acquiring() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &- b
    let result2: UInt32 = result1 &- c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_releasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &- b
    let result2: UInt32 = result1 &- c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_acquiringAndReleasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &- b
    let result2: UInt32 = result1 &- c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_sequentiallyConsistent() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &- b
    let result2: UInt32 = result1 &- c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_relaxed() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a & b
    let result2: UInt32 = result1 & c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_acquiring() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a & b
    let result2: UInt32 = result1 & c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_releasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a & b
    let result2: UInt32 = result1 & c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_acquiringAndReleasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a & b
    let result2: UInt32 = result1 & c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_sequentiallyConsistent() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a & b
    let result2: UInt32 = result1 & c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_relaxed() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a | b
    let result2: UInt32 = result1 | c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_acquiring() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a | b
    let result2: UInt32 = result1 | c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_releasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a | b
    let result2: UInt32 = result1 | c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_acquiringAndReleasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a | b
    let result2: UInt32 = result1 | c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_sequentiallyConsistent() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a | b
    let result2: UInt32 = result1 | c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_relaxed() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a ^ b
    let result2: UInt32 = result1 ^ c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_acquiring() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a ^ b
    let result2: UInt32 = result1 ^ c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_releasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a ^ b
    let result2: UInt32 = result1 ^ c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_acquiringAndReleasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a ^ b
    let result2: UInt32 = result1 ^ c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_sequentiallyConsistent() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a ^ b
    let result2: UInt32 = result1 ^ c

    let v = UnsafeAtomic<UInt32>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }


  public static var allTests = [
    ("test_create_destroy", test_create_destroy),
    ("test_load_relaxed", test_load_relaxed),
    ("test_load_acquiring", test_load_acquiring),
    ("test_load_sequentiallyConsistent", test_load_sequentiallyConsistent),
    ("test_store_relaxed", test_store_relaxed),
    ("test_store_releasing", test_store_releasing),
    ("test_store_sequentiallyConsistent", test_store_sequentiallyConsistent),
    ("test_exchange_relaxed", test_exchange_relaxed),
    ("test_exchange_acquiring", test_exchange_acquiring),
    ("test_exchange_releasing", test_exchange_releasing),
    ("test_exchange_acquiringAndReleasing", test_exchange_acquiringAndReleasing),
    ("test_exchange_sequentiallyConsistent", test_exchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed", test_compareExchange_relaxed),
    ("test_compareExchange_acquiring", test_compareExchange_acquiring),
    ("test_compareExchange_releasing", test_compareExchange_releasing),
    ("test_compareExchange_acquiringAndReleasing", test_compareExchange_acquiringAndReleasing),
    ("test_compareExchange_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed_relaxed", test_compareExchange_relaxed_relaxed),
    ("test_compareExchange_relaxed_acquiring", test_compareExchange_relaxed_acquiring),
    ("test_compareExchange_relaxed_sequentiallyConsistent", test_compareExchange_relaxed_sequentiallyConsistent),
    ("test_compareExchange_acquiring_relaxed", test_compareExchange_acquiring_relaxed),
    ("test_compareExchange_acquiring_acquiring", test_compareExchange_acquiring_acquiring),
    ("test_compareExchange_acquiring_sequentiallyConsistent", test_compareExchange_acquiring_sequentiallyConsistent),
    ("test_compareExchange_releasing_relaxed", test_compareExchange_releasing_relaxed),
    ("test_compareExchange_releasing_acquiring", test_compareExchange_releasing_acquiring),
    ("test_compareExchange_releasing_sequentiallyConsistent", test_compareExchange_releasing_sequentiallyConsistent),
    ("test_compareExchange_acquiringAndReleasing_relaxed", test_compareExchange_acquiringAndReleasing_relaxed),
    ("test_compareExchange_acquiringAndReleasing_acquiring", test_compareExchange_acquiringAndReleasing_acquiring),
    ("test_compareExchange_acquiringAndReleasing_sequentiallyConsistent", test_compareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_compareExchange_sequentiallyConsistent_relaxed", test_compareExchange_sequentiallyConsistent_relaxed),
    ("test_compareExchange_sequentiallyConsistent_acquiring", test_compareExchange_sequentiallyConsistent_acquiring),
    ("test_compareExchange_sequentiallyConsistent_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent_sequentiallyConsistent),
    ("test_weakCompareExchange_relaxed_relaxed", test_weakCompareExchange_relaxed_relaxed),
    ("test_weakCompareExchange_relaxed_acquiring", test_weakCompareExchange_relaxed_acquiring),
    ("test_weakCompareExchange_relaxed_sequentiallyConsistent", test_weakCompareExchange_relaxed_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiring_relaxed", test_weakCompareExchange_acquiring_relaxed),
    ("test_weakCompareExchange_acquiring_acquiring", test_weakCompareExchange_acquiring_acquiring),
    ("test_weakCompareExchange_acquiring_sequentiallyConsistent", test_weakCompareExchange_acquiring_sequentiallyConsistent),
    ("test_weakCompareExchange_releasing_relaxed", test_weakCompareExchange_releasing_relaxed),
    ("test_weakCompareExchange_releasing_acquiring", test_weakCompareExchange_releasing_acquiring),
    ("test_weakCompareExchange_releasing_sequentiallyConsistent", test_weakCompareExchange_releasing_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiringAndReleasing_relaxed", test_weakCompareExchange_acquiringAndReleasing_relaxed),
    ("test_weakCompareExchange_acquiringAndReleasing_acquiring", test_weakCompareExchange_acquiringAndReleasing_acquiring),
    ("test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent", test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_weakCompareExchange_sequentiallyConsistent_relaxed", test_weakCompareExchange_sequentiallyConsistent_relaxed),
    ("test_weakCompareExchange_sequentiallyConsistent_acquiring", test_weakCompareExchange_sequentiallyConsistent_acquiring),
    ("test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent", test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent),
    ("test_loadThenWrappingIncrement_relaxed", test_loadThenWrappingIncrement_relaxed),
    ("test_loadThenWrappingIncrement_acquiring", test_loadThenWrappingIncrement_acquiring),
    ("test_loadThenWrappingIncrement_releasing", test_loadThenWrappingIncrement_releasing),
    ("test_loadThenWrappingIncrement_acquiringAndReleasing", test_loadThenWrappingIncrement_acquiringAndReleasing),
    ("test_loadThenWrappingIncrement_sequentiallyConsistent", test_loadThenWrappingIncrement_sequentiallyConsistent),
    ("test_loadThenWrappingDecrement_relaxed", test_loadThenWrappingDecrement_relaxed),
    ("test_loadThenWrappingDecrement_acquiring", test_loadThenWrappingDecrement_acquiring),
    ("test_loadThenWrappingDecrement_releasing", test_loadThenWrappingDecrement_releasing),
    ("test_loadThenWrappingDecrement_acquiringAndReleasing", test_loadThenWrappingDecrement_acquiringAndReleasing),
    ("test_loadThenWrappingDecrement_sequentiallyConsistent", test_loadThenWrappingDecrement_sequentiallyConsistent),
    ("test_loadThenBitwiseAnd_relaxed", test_loadThenBitwiseAnd_relaxed),
    ("test_loadThenBitwiseAnd_acquiring", test_loadThenBitwiseAnd_acquiring),
    ("test_loadThenBitwiseAnd_releasing", test_loadThenBitwiseAnd_releasing),
    ("test_loadThenBitwiseAnd_acquiringAndReleasing", test_loadThenBitwiseAnd_acquiringAndReleasing),
    ("test_loadThenBitwiseAnd_sequentiallyConsistent", test_loadThenBitwiseAnd_sequentiallyConsistent),
    ("test_loadThenBitwiseOr_relaxed", test_loadThenBitwiseOr_relaxed),
    ("test_loadThenBitwiseOr_acquiring", test_loadThenBitwiseOr_acquiring),
    ("test_loadThenBitwiseOr_releasing", test_loadThenBitwiseOr_releasing),
    ("test_loadThenBitwiseOr_acquiringAndReleasing", test_loadThenBitwiseOr_acquiringAndReleasing),
    ("test_loadThenBitwiseOr_sequentiallyConsistent", test_loadThenBitwiseOr_sequentiallyConsistent),
    ("test_loadThenBitwiseXor_relaxed", test_loadThenBitwiseXor_relaxed),
    ("test_loadThenBitwiseXor_acquiring", test_loadThenBitwiseXor_acquiring),
    ("test_loadThenBitwiseXor_releasing", test_loadThenBitwiseXor_releasing),
    ("test_loadThenBitwiseXor_acquiringAndReleasing", test_loadThenBitwiseXor_acquiringAndReleasing),
    ("test_loadThenBitwiseXor_sequentiallyConsistent", test_loadThenBitwiseXor_sequentiallyConsistent),
    ("test_wrappingIncrementThenLoad_relaxed", test_wrappingIncrementThenLoad_relaxed),
    ("test_wrappingIncrementThenLoad_acquiring", test_wrappingIncrementThenLoad_acquiring),
    ("test_wrappingIncrementThenLoad_releasing", test_wrappingIncrementThenLoad_releasing),
    ("test_wrappingIncrementThenLoad_acquiringAndReleasing", test_wrappingIncrementThenLoad_acquiringAndReleasing),
    ("test_wrappingIncrementThenLoad_sequentiallyConsistent", test_wrappingIncrementThenLoad_sequentiallyConsistent),
    ("test_wrappingDecrementThenLoad_relaxed", test_wrappingDecrementThenLoad_relaxed),
    ("test_wrappingDecrementThenLoad_acquiring", test_wrappingDecrementThenLoad_acquiring),
    ("test_wrappingDecrementThenLoad_releasing", test_wrappingDecrementThenLoad_releasing),
    ("test_wrappingDecrementThenLoad_acquiringAndReleasing", test_wrappingDecrementThenLoad_acquiringAndReleasing),
    ("test_wrappingDecrementThenLoad_sequentiallyConsistent", test_wrappingDecrementThenLoad_sequentiallyConsistent),
    ("test_bitwiseAndThenLoad_relaxed", test_bitwiseAndThenLoad_relaxed),
    ("test_bitwiseAndThenLoad_acquiring", test_bitwiseAndThenLoad_acquiring),
    ("test_bitwiseAndThenLoad_releasing", test_bitwiseAndThenLoad_releasing),
    ("test_bitwiseAndThenLoad_acquiringAndReleasing", test_bitwiseAndThenLoad_acquiringAndReleasing),
    ("test_bitwiseAndThenLoad_sequentiallyConsistent", test_bitwiseAndThenLoad_sequentiallyConsistent),
    ("test_bitwiseOrThenLoad_relaxed", test_bitwiseOrThenLoad_relaxed),
    ("test_bitwiseOrThenLoad_acquiring", test_bitwiseOrThenLoad_acquiring),
    ("test_bitwiseOrThenLoad_releasing", test_bitwiseOrThenLoad_releasing),
    ("test_bitwiseOrThenLoad_acquiringAndReleasing", test_bitwiseOrThenLoad_acquiringAndReleasing),
    ("test_bitwiseOrThenLoad_sequentiallyConsistent", test_bitwiseOrThenLoad_sequentiallyConsistent),
    ("test_bitwiseXorThenLoad_relaxed", test_bitwiseXorThenLoad_relaxed),
    ("test_bitwiseXorThenLoad_acquiring", test_bitwiseXorThenLoad_acquiring),
    ("test_bitwiseXorThenLoad_releasing", test_bitwiseXorThenLoad_releasing),
    ("test_bitwiseXorThenLoad_acquiringAndReleasing", test_bitwiseXorThenLoad_acquiringAndReleasing),
    ("test_bitwiseXorThenLoad_sequentiallyConsistent", test_bitwiseXorThenLoad_sequentiallyConsistent),
  ]
}
#endif
#if true
/// Exercises all operations in a single-threaded context, verifying
/// they provide the expected results.
class BasicAtomicUInt64Tests: XCTestCase {

  func test_create_destroy() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    let w = UnsafeAtomic<UInt64>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 23)
  }

  func test_load_relaxed() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    let w = UnsafeAtomic<UInt64>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 23)
  }
  func test_load_acquiring() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .acquiring), 12)

    let w = UnsafeAtomic<UInt64>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .acquiring), 23)
  }
  func test_load_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .sequentiallyConsistent), 12)

    let w = UnsafeAtomic<UInt64>.create(23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .sequentiallyConsistent), 23)
  }

  func test_store_relaxed() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }
    v.store(23, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    let w = UnsafeAtomic<UInt64>.create(23)
    defer { w.destroy() }
    w.store(12, ordering: .relaxed)
    XCTAssertEqual(w.load(ordering: .relaxed), 12)
  }
  func test_store_releasing() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }
    v.store(23, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    let w = UnsafeAtomic<UInt64>.create(23)
    defer { w.destroy() }
    w.store(12, ordering: .releasing)
    XCTAssertEqual(w.load(ordering: .relaxed), 12)
  }
  func test_store_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }
    v.store(23, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    let w = UnsafeAtomic<UInt64>.create(23)
    defer { w.destroy() }
    w.store(12, ordering: .sequentiallyConsistent)
    XCTAssertEqual(w.load(ordering: .relaxed), 12)
  }

  func test_exchange_relaxed() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .relaxed), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .relaxed), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .relaxed), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_acquiring() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .acquiring), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .acquiring), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .acquiring), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_releasing() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .releasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .releasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .releasing), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .acquiringAndReleasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .acquiringAndReleasing), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .acquiringAndReleasing), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_exchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(12, ordering: .sequentiallyConsistent), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    XCTAssertEqual(v.exchange(23, ordering: .sequentiallyConsistent), 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    XCTAssertEqual(v.exchange(23, ordering: .sequentiallyConsistent), 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }

  func test_compareExchange_relaxed() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }

  func test_compareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_compareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }
  func test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt64>.create(12)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 12,
      desired: 23,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 23)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)

    (exchanged, original) = v.compareExchange(
      expected: 23,
      desired: 12,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 12)
    XCTAssertEqual(v.load(ordering: .relaxed), 12)
  }



// Integer operations
  func test_loadThenWrappingIncrement_relaxed() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &+ b
    let result2: UInt64 = result1 &+ c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_acquiring() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &+ b
    let result2: UInt64 = result1 &+ c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_releasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &+ b
    let result2: UInt64 = result1 &+ c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_acquiringAndReleasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &+ b
    let result2: UInt64 = result1 &+ c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingIncrement_sequentiallyConsistent() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &+ b
    let result2: UInt64 = result1 &+ c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_relaxed() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &- b
    let result2: UInt64 = result1 &- c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_acquiring() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &- b
    let result2: UInt64 = result1 &- c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_releasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &- b
    let result2: UInt64 = result1 &- c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_acquiringAndReleasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &- b
    let result2: UInt64 = result1 &- c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenWrappingDecrement_sequentiallyConsistent() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &- b
    let result2: UInt64 = result1 &- c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_relaxed() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a & b
    let result2: UInt64 = result1 & c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_acquiring() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a & b
    let result2: UInt64 = result1 & c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_releasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a & b
    let result2: UInt64 = result1 & c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_acquiringAndReleasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a & b
    let result2: UInt64 = result1 & c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseAnd_sequentiallyConsistent() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a & b
    let result2: UInt64 = result1 & c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_relaxed() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a | b
    let result2: UInt64 = result1 | c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_acquiring() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a | b
    let result2: UInt64 = result1 | c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_releasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a | b
    let result2: UInt64 = result1 | c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_acquiringAndReleasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a | b
    let result2: UInt64 = result1 | c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseOr_sequentiallyConsistent() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a | b
    let result2: UInt64 = result1 | c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_relaxed() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a ^ b
    let result2: UInt64 = result1 ^ c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_acquiring() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a ^ b
    let result2: UInt64 = result1 ^ c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_releasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a ^ b
    let result2: UInt64 = result1 ^ c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_acquiringAndReleasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a ^ b
    let result2: UInt64 = result1 ^ c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_loadThenBitwiseXor_sequentiallyConsistent() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a ^ b
    let result2: UInt64 = result1 ^ c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }

  func test_wrappingIncrementThenLoad_relaxed() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &+ b
    let result2: UInt64 = result1 &+ c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_acquiring() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &+ b
    let result2: UInt64 = result1 &+ c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_releasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &+ b
    let result2: UInt64 = result1 &+ c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_acquiringAndReleasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &+ b
    let result2: UInt64 = result1 &+ c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingIncrementThenLoad_sequentiallyConsistent() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &+ b
    let result2: UInt64 = result1 &+ c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_relaxed() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &- b
    let result2: UInt64 = result1 &- c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_acquiring() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &- b
    let result2: UInt64 = result1 &- c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_releasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &- b
    let result2: UInt64 = result1 &- c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_acquiringAndReleasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &- b
    let result2: UInt64 = result1 &- c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_wrappingDecrementThenLoad_sequentiallyConsistent() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &- b
    let result2: UInt64 = result1 &- c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_relaxed() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a & b
    let result2: UInt64 = result1 & c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_acquiring() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a & b
    let result2: UInt64 = result1 & c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_releasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a & b
    let result2: UInt64 = result1 & c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_acquiringAndReleasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a & b
    let result2: UInt64 = result1 & c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseAndThenLoad_sequentiallyConsistent() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a & b
    let result2: UInt64 = result1 & c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_relaxed() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a | b
    let result2: UInt64 = result1 | c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_acquiring() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a | b
    let result2: UInt64 = result1 | c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_releasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a | b
    let result2: UInt64 = result1 | c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_acquiringAndReleasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a | b
    let result2: UInt64 = result1 | c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseOrThenLoad_sequentiallyConsistent() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a | b
    let result2: UInt64 = result1 | c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_relaxed() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a ^ b
    let result2: UInt64 = result1 ^ c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_acquiring() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a ^ b
    let result2: UInt64 = result1 ^ c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_releasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a ^ b
    let result2: UInt64 = result1 ^ c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_acquiringAndReleasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a ^ b
    let result2: UInt64 = result1 ^ c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_bitwiseXorThenLoad_sequentiallyConsistent() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a ^ b
    let result2: UInt64 = result1 ^ c

    let v = UnsafeAtomic<UInt64>.create(a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }


  public static var allTests = [
    ("test_create_destroy", test_create_destroy),
    ("test_load_relaxed", test_load_relaxed),
    ("test_load_acquiring", test_load_acquiring),
    ("test_load_sequentiallyConsistent", test_load_sequentiallyConsistent),
    ("test_store_relaxed", test_store_relaxed),
    ("test_store_releasing", test_store_releasing),
    ("test_store_sequentiallyConsistent", test_store_sequentiallyConsistent),
    ("test_exchange_relaxed", test_exchange_relaxed),
    ("test_exchange_acquiring", test_exchange_acquiring),
    ("test_exchange_releasing", test_exchange_releasing),
    ("test_exchange_acquiringAndReleasing", test_exchange_acquiringAndReleasing),
    ("test_exchange_sequentiallyConsistent", test_exchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed", test_compareExchange_relaxed),
    ("test_compareExchange_acquiring", test_compareExchange_acquiring),
    ("test_compareExchange_releasing", test_compareExchange_releasing),
    ("test_compareExchange_acquiringAndReleasing", test_compareExchange_acquiringAndReleasing),
    ("test_compareExchange_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed_relaxed", test_compareExchange_relaxed_relaxed),
    ("test_compareExchange_relaxed_acquiring", test_compareExchange_relaxed_acquiring),
    ("test_compareExchange_relaxed_sequentiallyConsistent", test_compareExchange_relaxed_sequentiallyConsistent),
    ("test_compareExchange_acquiring_relaxed", test_compareExchange_acquiring_relaxed),
    ("test_compareExchange_acquiring_acquiring", test_compareExchange_acquiring_acquiring),
    ("test_compareExchange_acquiring_sequentiallyConsistent", test_compareExchange_acquiring_sequentiallyConsistent),
    ("test_compareExchange_releasing_relaxed", test_compareExchange_releasing_relaxed),
    ("test_compareExchange_releasing_acquiring", test_compareExchange_releasing_acquiring),
    ("test_compareExchange_releasing_sequentiallyConsistent", test_compareExchange_releasing_sequentiallyConsistent),
    ("test_compareExchange_acquiringAndReleasing_relaxed", test_compareExchange_acquiringAndReleasing_relaxed),
    ("test_compareExchange_acquiringAndReleasing_acquiring", test_compareExchange_acquiringAndReleasing_acquiring),
    ("test_compareExchange_acquiringAndReleasing_sequentiallyConsistent", test_compareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_compareExchange_sequentiallyConsistent_relaxed", test_compareExchange_sequentiallyConsistent_relaxed),
    ("test_compareExchange_sequentiallyConsistent_acquiring", test_compareExchange_sequentiallyConsistent_acquiring),
    ("test_compareExchange_sequentiallyConsistent_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent_sequentiallyConsistent),
    ("test_weakCompareExchange_relaxed_relaxed", test_weakCompareExchange_relaxed_relaxed),
    ("test_weakCompareExchange_relaxed_acquiring", test_weakCompareExchange_relaxed_acquiring),
    ("test_weakCompareExchange_relaxed_sequentiallyConsistent", test_weakCompareExchange_relaxed_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiring_relaxed", test_weakCompareExchange_acquiring_relaxed),
    ("test_weakCompareExchange_acquiring_acquiring", test_weakCompareExchange_acquiring_acquiring),
    ("test_weakCompareExchange_acquiring_sequentiallyConsistent", test_weakCompareExchange_acquiring_sequentiallyConsistent),
    ("test_weakCompareExchange_releasing_relaxed", test_weakCompareExchange_releasing_relaxed),
    ("test_weakCompareExchange_releasing_acquiring", test_weakCompareExchange_releasing_acquiring),
    ("test_weakCompareExchange_releasing_sequentiallyConsistent", test_weakCompareExchange_releasing_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiringAndReleasing_relaxed", test_weakCompareExchange_acquiringAndReleasing_relaxed),
    ("test_weakCompareExchange_acquiringAndReleasing_acquiring", test_weakCompareExchange_acquiringAndReleasing_acquiring),
    ("test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent", test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_weakCompareExchange_sequentiallyConsistent_relaxed", test_weakCompareExchange_sequentiallyConsistent_relaxed),
    ("test_weakCompareExchange_sequentiallyConsistent_acquiring", test_weakCompareExchange_sequentiallyConsistent_acquiring),
    ("test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent", test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent),
    ("test_loadThenWrappingIncrement_relaxed", test_loadThenWrappingIncrement_relaxed),
    ("test_loadThenWrappingIncrement_acquiring", test_loadThenWrappingIncrement_acquiring),
    ("test_loadThenWrappingIncrement_releasing", test_loadThenWrappingIncrement_releasing),
    ("test_loadThenWrappingIncrement_acquiringAndReleasing", test_loadThenWrappingIncrement_acquiringAndReleasing),
    ("test_loadThenWrappingIncrement_sequentiallyConsistent", test_loadThenWrappingIncrement_sequentiallyConsistent),
    ("test_loadThenWrappingDecrement_relaxed", test_loadThenWrappingDecrement_relaxed),
    ("test_loadThenWrappingDecrement_acquiring", test_loadThenWrappingDecrement_acquiring),
    ("test_loadThenWrappingDecrement_releasing", test_loadThenWrappingDecrement_releasing),
    ("test_loadThenWrappingDecrement_acquiringAndReleasing", test_loadThenWrappingDecrement_acquiringAndReleasing),
    ("test_loadThenWrappingDecrement_sequentiallyConsistent", test_loadThenWrappingDecrement_sequentiallyConsistent),
    ("test_loadThenBitwiseAnd_relaxed", test_loadThenBitwiseAnd_relaxed),
    ("test_loadThenBitwiseAnd_acquiring", test_loadThenBitwiseAnd_acquiring),
    ("test_loadThenBitwiseAnd_releasing", test_loadThenBitwiseAnd_releasing),
    ("test_loadThenBitwiseAnd_acquiringAndReleasing", test_loadThenBitwiseAnd_acquiringAndReleasing),
    ("test_loadThenBitwiseAnd_sequentiallyConsistent", test_loadThenBitwiseAnd_sequentiallyConsistent),
    ("test_loadThenBitwiseOr_relaxed", test_loadThenBitwiseOr_relaxed),
    ("test_loadThenBitwiseOr_acquiring", test_loadThenBitwiseOr_acquiring),
    ("test_loadThenBitwiseOr_releasing", test_loadThenBitwiseOr_releasing),
    ("test_loadThenBitwiseOr_acquiringAndReleasing", test_loadThenBitwiseOr_acquiringAndReleasing),
    ("test_loadThenBitwiseOr_sequentiallyConsistent", test_loadThenBitwiseOr_sequentiallyConsistent),
    ("test_loadThenBitwiseXor_relaxed", test_loadThenBitwiseXor_relaxed),
    ("test_loadThenBitwiseXor_acquiring", test_loadThenBitwiseXor_acquiring),
    ("test_loadThenBitwiseXor_releasing", test_loadThenBitwiseXor_releasing),
    ("test_loadThenBitwiseXor_acquiringAndReleasing", test_loadThenBitwiseXor_acquiringAndReleasing),
    ("test_loadThenBitwiseXor_sequentiallyConsistent", test_loadThenBitwiseXor_sequentiallyConsistent),
    ("test_wrappingIncrementThenLoad_relaxed", test_wrappingIncrementThenLoad_relaxed),
    ("test_wrappingIncrementThenLoad_acquiring", test_wrappingIncrementThenLoad_acquiring),
    ("test_wrappingIncrementThenLoad_releasing", test_wrappingIncrementThenLoad_releasing),
    ("test_wrappingIncrementThenLoad_acquiringAndReleasing", test_wrappingIncrementThenLoad_acquiringAndReleasing),
    ("test_wrappingIncrementThenLoad_sequentiallyConsistent", test_wrappingIncrementThenLoad_sequentiallyConsistent),
    ("test_wrappingDecrementThenLoad_relaxed", test_wrappingDecrementThenLoad_relaxed),
    ("test_wrappingDecrementThenLoad_acquiring", test_wrappingDecrementThenLoad_acquiring),
    ("test_wrappingDecrementThenLoad_releasing", test_wrappingDecrementThenLoad_releasing),
    ("test_wrappingDecrementThenLoad_acquiringAndReleasing", test_wrappingDecrementThenLoad_acquiringAndReleasing),
    ("test_wrappingDecrementThenLoad_sequentiallyConsistent", test_wrappingDecrementThenLoad_sequentiallyConsistent),
    ("test_bitwiseAndThenLoad_relaxed", test_bitwiseAndThenLoad_relaxed),
    ("test_bitwiseAndThenLoad_acquiring", test_bitwiseAndThenLoad_acquiring),
    ("test_bitwiseAndThenLoad_releasing", test_bitwiseAndThenLoad_releasing),
    ("test_bitwiseAndThenLoad_acquiringAndReleasing", test_bitwiseAndThenLoad_acquiringAndReleasing),
    ("test_bitwiseAndThenLoad_sequentiallyConsistent", test_bitwiseAndThenLoad_sequentiallyConsistent),
    ("test_bitwiseOrThenLoad_relaxed", test_bitwiseOrThenLoad_relaxed),
    ("test_bitwiseOrThenLoad_acquiring", test_bitwiseOrThenLoad_acquiring),
    ("test_bitwiseOrThenLoad_releasing", test_bitwiseOrThenLoad_releasing),
    ("test_bitwiseOrThenLoad_acquiringAndReleasing", test_bitwiseOrThenLoad_acquiringAndReleasing),
    ("test_bitwiseOrThenLoad_sequentiallyConsistent", test_bitwiseOrThenLoad_sequentiallyConsistent),
    ("test_bitwiseXorThenLoad_relaxed", test_bitwiseXorThenLoad_relaxed),
    ("test_bitwiseXorThenLoad_acquiring", test_bitwiseXorThenLoad_acquiring),
    ("test_bitwiseXorThenLoad_releasing", test_bitwiseXorThenLoad_releasing),
    ("test_bitwiseXorThenLoad_acquiringAndReleasing", test_bitwiseXorThenLoad_acquiringAndReleasing),
    ("test_bitwiseXorThenLoad_sequentiallyConsistent", test_bitwiseXorThenLoad_sequentiallyConsistent),
  ]
}
#endif
#if true
/// Exercises all operations in a single-threaded context, verifying
/// they provide the expected results.
class BasicAtomicBoolTests: XCTestCase {

  func test_create_destroy() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    let w = UnsafeAtomic<Bool>.create(false)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), false)
  }

  func test_load_relaxed() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    let w = UnsafeAtomic<Bool>.create(false)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), false)
  }
  func test_load_acquiring() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .acquiring), true)

    let w = UnsafeAtomic<Bool>.create(false)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .acquiring), false)
  }
  func test_load_sequentiallyConsistent() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .sequentiallyConsistent), true)

    let w = UnsafeAtomic<Bool>.create(false)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .sequentiallyConsistent), false)
  }

  func test_store_relaxed() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }
    v.store(false, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    let w = UnsafeAtomic<Bool>.create(false)
    defer { w.destroy() }
    w.store(true, ordering: .relaxed)
    XCTAssertEqual(w.load(ordering: .relaxed), true)
  }
  func test_store_releasing() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }
    v.store(false, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    let w = UnsafeAtomic<Bool>.create(false)
    defer { w.destroy() }
    w.store(true, ordering: .releasing)
    XCTAssertEqual(w.load(ordering: .relaxed), true)
  }
  func test_store_sequentiallyConsistent() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }
    v.store(false, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    let w = UnsafeAtomic<Bool>.create(false)
    defer { w.destroy() }
    w.store(true, ordering: .sequentiallyConsistent)
    XCTAssertEqual(w.load(ordering: .relaxed), true)
  }

  func test_exchange_relaxed() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(true, ordering: .relaxed), true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    XCTAssertEqual(v.exchange(false, ordering: .relaxed), true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    XCTAssertEqual(v.exchange(false, ordering: .relaxed), false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)
  }
  func test_exchange_acquiring() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(true, ordering: .acquiring), true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    XCTAssertEqual(v.exchange(false, ordering: .acquiring), true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    XCTAssertEqual(v.exchange(false, ordering: .acquiring), false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)
  }
  func test_exchange_releasing() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(true, ordering: .releasing), true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    XCTAssertEqual(v.exchange(false, ordering: .releasing), true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    XCTAssertEqual(v.exchange(false, ordering: .releasing), false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)
  }
  func test_exchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(true, ordering: .acquiringAndReleasing), true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    XCTAssertEqual(v.exchange(false, ordering: .acquiringAndReleasing), true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    XCTAssertEqual(v.exchange(false, ordering: .acquiringAndReleasing), false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)
  }
  func test_exchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(true, ordering: .sequentiallyConsistent), true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    XCTAssertEqual(v.exchange(false, ordering: .sequentiallyConsistent), true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    XCTAssertEqual(v.exchange(false, ordering: .sequentiallyConsistent), false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)
  }

  func test_compareExchange_relaxed() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)
  }
  func test_compareExchange_acquiring() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)
  }
  func test_compareExchange_releasing() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)
  }
  func test_compareExchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)
  }
  func test_compareExchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)
  }

  func test_compareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)
  }
  func test_compareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)
  }
  func test_compareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)
  }
  func test_compareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)
  }
  func test_compareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)
  }
  func test_compareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)
  }
  func test_compareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)
  }
  func test_compareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)
  }
  func test_compareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)
  }
  func test_compareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)
  }
  func test_compareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)
  }
  func test_compareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)
  }
  func test_compareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)
  }
  func test_compareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)
  }
  func test_compareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)
  }
  func test_weakCompareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)
  }
  func test_weakCompareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)
  }
  func test_weakCompareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)
  }
  func test_weakCompareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)
  }
  func test_weakCompareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)
  }
  func test_weakCompareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)
  }
  func test_weakCompareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)
  }
  func test_weakCompareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)
  }
  func test_weakCompareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)
  }
  func test_weakCompareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)
  }
  func test_weakCompareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)
  }
  func test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)
  }
  func test_weakCompareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)
  }
  func test_weakCompareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)
  }
  func test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<Bool>.create(true)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: true,
      desired: false,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), false)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, false)
    XCTAssertEqual(v.load(ordering: .relaxed), true)

    (exchanged, original) = v.compareExchange(
      expected: false,
      desired: true,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, true)
    XCTAssertEqual(v.load(ordering: .relaxed), true)
  }


  // Bool operations
  func test_loadThenLogicalAnd_relaxed() {
    let v = UnsafeAtomic<Bool>.create(false)
    defer { v.destroy() }

    // The truth tables are super tiny, so just check every value
    for a in [false, true] {
      for b in [false, true] {
        v.store(a, ordering: .relaxed)
        let r = v.loadThenLogicalAnd(with: b, ordering: .relaxed)
        XCTAssertEqual(r, a, "a = \(a), b = \(b)")
        XCTAssertEqual(
          v.load(ordering: .relaxed),
          a && b,
          "a = \(a), b =\(b)")
      }
    }
  }
  func test_loadThenLogicalAnd_acquiring() {
    let v = UnsafeAtomic<Bool>.create(false)
    defer { v.destroy() }

    // The truth tables are super tiny, so just check every value
    for a in [false, true] {
      for b in [false, true] {
        v.store(a, ordering: .relaxed)
        let r = v.loadThenLogicalAnd(with: b, ordering: .acquiring)
        XCTAssertEqual(r, a, "a = \(a), b = \(b)")
        XCTAssertEqual(
          v.load(ordering: .relaxed),
          a && b,
          "a = \(a), b =\(b)")
      }
    }
  }
  func test_loadThenLogicalAnd_releasing() {
    let v = UnsafeAtomic<Bool>.create(false)
    defer { v.destroy() }

    // The truth tables are super tiny, so just check every value
    for a in [false, true] {
      for b in [false, true] {
        v.store(a, ordering: .relaxed)
        let r = v.loadThenLogicalAnd(with: b, ordering: .releasing)
        XCTAssertEqual(r, a, "a = \(a), b = \(b)")
        XCTAssertEqual(
          v.load(ordering: .relaxed),
          a && b,
          "a = \(a), b =\(b)")
      }
    }
  }
  func test_loadThenLogicalAnd_acquiringAndReleasing() {
    let v = UnsafeAtomic<Bool>.create(false)
    defer { v.destroy() }

    // The truth tables are super tiny, so just check every value
    for a in [false, true] {
      for b in [false, true] {
        v.store(a, ordering: .relaxed)
        let r = v.loadThenLogicalAnd(with: b, ordering: .acquiringAndReleasing)
        XCTAssertEqual(r, a, "a = \(a), b = \(b)")
        XCTAssertEqual(
          v.load(ordering: .relaxed),
          a && b,
          "a = \(a), b =\(b)")
      }
    }
  }
  func test_loadThenLogicalAnd_sequentiallyConsistent() {
    let v = UnsafeAtomic<Bool>.create(false)
    defer { v.destroy() }

    // The truth tables are super tiny, so just check every value
    for a in [false, true] {
      for b in [false, true] {
        v.store(a, ordering: .relaxed)
        let r = v.loadThenLogicalAnd(with: b, ordering: .sequentiallyConsistent)
        XCTAssertEqual(r, a, "a = \(a), b = \(b)")
        XCTAssertEqual(
          v.load(ordering: .relaxed),
          a && b,
          "a = \(a), b =\(b)")
      }
    }
  }
  func test_loadThenLogicalOr_relaxed() {
    let v = UnsafeAtomic<Bool>.create(false)
    defer { v.destroy() }

    // The truth tables are super tiny, so just check every value
    for a in [false, true] {
      for b in [false, true] {
        v.store(a, ordering: .relaxed)
        let r = v.loadThenLogicalOr(with: b, ordering: .relaxed)
        XCTAssertEqual(r, a, "a = \(a), b = \(b)")
        XCTAssertEqual(
          v.load(ordering: .relaxed),
          a || b,
          "a = \(a), b =\(b)")
      }
    }
  }
  func test_loadThenLogicalOr_acquiring() {
    let v = UnsafeAtomic<Bool>.create(false)
    defer { v.destroy() }

    // The truth tables are super tiny, so just check every value
    for a in [false, true] {
      for b in [false, true] {
        v.store(a, ordering: .relaxed)
        let r = v.loadThenLogicalOr(with: b, ordering: .acquiring)
        XCTAssertEqual(r, a, "a = \(a), b = \(b)")
        XCTAssertEqual(
          v.load(ordering: .relaxed),
          a || b,
          "a = \(a), b =\(b)")
      }
    }
  }
  func test_loadThenLogicalOr_releasing() {
    let v = UnsafeAtomic<Bool>.create(false)
    defer { v.destroy() }

    // The truth tables are super tiny, so just check every value
    for a in [false, true] {
      for b in [false, true] {
        v.store(a, ordering: .relaxed)
        let r = v.loadThenLogicalOr(with: b, ordering: .releasing)
        XCTAssertEqual(r, a, "a = \(a), b = \(b)")
        XCTAssertEqual(
          v.load(ordering: .relaxed),
          a || b,
          "a = \(a), b =\(b)")
      }
    }
  }
  func test_loadThenLogicalOr_acquiringAndReleasing() {
    let v = UnsafeAtomic<Bool>.create(false)
    defer { v.destroy() }

    // The truth tables are super tiny, so just check every value
    for a in [false, true] {
      for b in [false, true] {
        v.store(a, ordering: .relaxed)
        let r = v.loadThenLogicalOr(with: b, ordering: .acquiringAndReleasing)
        XCTAssertEqual(r, a, "a = \(a), b = \(b)")
        XCTAssertEqual(
          v.load(ordering: .relaxed),
          a || b,
          "a = \(a), b =\(b)")
      }
    }
  }
  func test_loadThenLogicalOr_sequentiallyConsistent() {
    let v = UnsafeAtomic<Bool>.create(false)
    defer { v.destroy() }

    // The truth tables are super tiny, so just check every value
    for a in [false, true] {
      for b in [false, true] {
        v.store(a, ordering: .relaxed)
        let r = v.loadThenLogicalOr(with: b, ordering: .sequentiallyConsistent)
        XCTAssertEqual(r, a, "a = \(a), b = \(b)")
        XCTAssertEqual(
          v.load(ordering: .relaxed),
          a || b,
          "a = \(a), b =\(b)")
      }
    }
  }
  func test_loadThenLogicalXor_relaxed() {
    let v = UnsafeAtomic<Bool>.create(false)
    defer { v.destroy() }

    // The truth tables are super tiny, so just check every value
    for a in [false, true] {
      for b in [false, true] {
        v.store(a, ordering: .relaxed)
        let r = v.loadThenLogicalXor(with: b, ordering: .relaxed)
        XCTAssertEqual(r, a, "a = \(a), b = \(b)")
        XCTAssertEqual(
          v.load(ordering: .relaxed),
          a != b,
          "a = \(a), b =\(b)")
      }
    }
  }
  func test_loadThenLogicalXor_acquiring() {
    let v = UnsafeAtomic<Bool>.create(false)
    defer { v.destroy() }

    // The truth tables are super tiny, so just check every value
    for a in [false, true] {
      for b in [false, true] {
        v.store(a, ordering: .relaxed)
        let r = v.loadThenLogicalXor(with: b, ordering: .acquiring)
        XCTAssertEqual(r, a, "a = \(a), b = \(b)")
        XCTAssertEqual(
          v.load(ordering: .relaxed),
          a != b,
          "a = \(a), b =\(b)")
      }
    }
  }
  func test_loadThenLogicalXor_releasing() {
    let v = UnsafeAtomic<Bool>.create(false)
    defer { v.destroy() }

    // The truth tables are super tiny, so just check every value
    for a in [false, true] {
      for b in [false, true] {
        v.store(a, ordering: .relaxed)
        let r = v.loadThenLogicalXor(with: b, ordering: .releasing)
        XCTAssertEqual(r, a, "a = \(a), b = \(b)")
        XCTAssertEqual(
          v.load(ordering: .relaxed),
          a != b,
          "a = \(a), b =\(b)")
      }
    }
  }
  func test_loadThenLogicalXor_acquiringAndReleasing() {
    let v = UnsafeAtomic<Bool>.create(false)
    defer { v.destroy() }

    // The truth tables are super tiny, so just check every value
    for a in [false, true] {
      for b in [false, true] {
        v.store(a, ordering: .relaxed)
        let r = v.loadThenLogicalXor(with: b, ordering: .acquiringAndReleasing)
        XCTAssertEqual(r, a, "a = \(a), b = \(b)")
        XCTAssertEqual(
          v.load(ordering: .relaxed),
          a != b,
          "a = \(a), b =\(b)")
      }
    }
  }
  func test_loadThenLogicalXor_sequentiallyConsistent() {
    let v = UnsafeAtomic<Bool>.create(false)
    defer { v.destroy() }

    // The truth tables are super tiny, so just check every value
    for a in [false, true] {
      for b in [false, true] {
        v.store(a, ordering: .relaxed)
        let r = v.loadThenLogicalXor(with: b, ordering: .sequentiallyConsistent)
        XCTAssertEqual(r, a, "a = \(a), b = \(b)")
        XCTAssertEqual(
          v.load(ordering: .relaxed),
          a != b,
          "a = \(a), b =\(b)")
      }
    }
  }

  func test_logicalAndThenLoad_relaxed() {
    let v = UnsafeAtomic<Bool>.create(false)
    defer { v.destroy() }

    // The truth tables are super tiny, so just check every value
    for a in [false, true] {
      for b in [false, true] {
        v.store(a, ordering: .relaxed)
        let r = v.logicalAndThenLoad(
          with: b,
          ordering: .relaxed)
        XCTAssertEqual(r, a && b, "a = \(a), b = \(b)")
        XCTAssertEqual(
          v.load(ordering: .relaxed),
          a && b,
          "a = \(a), b =\(b)")
      }
    }
  }
  func test_logicalAndThenLoad_acquiring() {
    let v = UnsafeAtomic<Bool>.create(false)
    defer { v.destroy() }

    // The truth tables are super tiny, so just check every value
    for a in [false, true] {
      for b in [false, true] {
        v.store(a, ordering: .relaxed)
        let r = v.logicalAndThenLoad(
          with: b,
          ordering: .acquiring)
        XCTAssertEqual(r, a && b, "a = \(a), b = \(b)")
        XCTAssertEqual(
          v.load(ordering: .relaxed),
          a && b,
          "a = \(a), b =\(b)")
      }
    }
  }
  func test_logicalAndThenLoad_releasing() {
    let v = UnsafeAtomic<Bool>.create(false)
    defer { v.destroy() }

    // The truth tables are super tiny, so just check every value
    for a in [false, true] {
      for b in [false, true] {
        v.store(a, ordering: .relaxed)
        let r = v.logicalAndThenLoad(
          with: b,
          ordering: .releasing)
        XCTAssertEqual(r, a && b, "a = \(a), b = \(b)")
        XCTAssertEqual(
          v.load(ordering: .relaxed),
          a && b,
          "a = \(a), b =\(b)")
      }
    }
  }
  func test_logicalAndThenLoad_acquiringAndReleasing() {
    let v = UnsafeAtomic<Bool>.create(false)
    defer { v.destroy() }

    // The truth tables are super tiny, so just check every value
    for a in [false, true] {
      for b in [false, true] {
        v.store(a, ordering: .relaxed)
        let r = v.logicalAndThenLoad(
          with: b,
          ordering: .acquiringAndReleasing)
        XCTAssertEqual(r, a && b, "a = \(a), b = \(b)")
        XCTAssertEqual(
          v.load(ordering: .relaxed),
          a && b,
          "a = \(a), b =\(b)")
      }
    }
  }
  func test_logicalAndThenLoad_sequentiallyConsistent() {
    let v = UnsafeAtomic<Bool>.create(false)
    defer { v.destroy() }

    // The truth tables are super tiny, so just check every value
    for a in [false, true] {
      for b in [false, true] {
        v.store(a, ordering: .relaxed)
        let r = v.logicalAndThenLoad(
          with: b,
          ordering: .sequentiallyConsistent)
        XCTAssertEqual(r, a && b, "a = \(a), b = \(b)")
        XCTAssertEqual(
          v.load(ordering: .relaxed),
          a && b,
          "a = \(a), b =\(b)")
      }
    }
  }
  func test_logicalOrThenLoad_relaxed() {
    let v = UnsafeAtomic<Bool>.create(false)
    defer { v.destroy() }

    // The truth tables are super tiny, so just check every value
    for a in [false, true] {
      for b in [false, true] {
        v.store(a, ordering: .relaxed)
        let r = v.logicalOrThenLoad(
          with: b,
          ordering: .relaxed)
        XCTAssertEqual(r, a || b, "a = \(a), b = \(b)")
        XCTAssertEqual(
          v.load(ordering: .relaxed),
          a || b,
          "a = \(a), b =\(b)")
      }
    }
  }
  func test_logicalOrThenLoad_acquiring() {
    let v = UnsafeAtomic<Bool>.create(false)
    defer { v.destroy() }

    // The truth tables are super tiny, so just check every value
    for a in [false, true] {
      for b in [false, true] {
        v.store(a, ordering: .relaxed)
        let r = v.logicalOrThenLoad(
          with: b,
          ordering: .acquiring)
        XCTAssertEqual(r, a || b, "a = \(a), b = \(b)")
        XCTAssertEqual(
          v.load(ordering: .relaxed),
          a || b,
          "a = \(a), b =\(b)")
      }
    }
  }
  func test_logicalOrThenLoad_releasing() {
    let v = UnsafeAtomic<Bool>.create(false)
    defer { v.destroy() }

    // The truth tables are super tiny, so just check every value
    for a in [false, true] {
      for b in [false, true] {
        v.store(a, ordering: .relaxed)
        let r = v.logicalOrThenLoad(
          with: b,
          ordering: .releasing)
        XCTAssertEqual(r, a || b, "a = \(a), b = \(b)")
        XCTAssertEqual(
          v.load(ordering: .relaxed),
          a || b,
          "a = \(a), b =\(b)")
      }
    }
  }
  func test_logicalOrThenLoad_acquiringAndReleasing() {
    let v = UnsafeAtomic<Bool>.create(false)
    defer { v.destroy() }

    // The truth tables are super tiny, so just check every value
    for a in [false, true] {
      for b in [false, true] {
        v.store(a, ordering: .relaxed)
        let r = v.logicalOrThenLoad(
          with: b,
          ordering: .acquiringAndReleasing)
        XCTAssertEqual(r, a || b, "a = \(a), b = \(b)")
        XCTAssertEqual(
          v.load(ordering: .relaxed),
          a || b,
          "a = \(a), b =\(b)")
      }
    }
  }
  func test_logicalOrThenLoad_sequentiallyConsistent() {
    let v = UnsafeAtomic<Bool>.create(false)
    defer { v.destroy() }

    // The truth tables are super tiny, so just check every value
    for a in [false, true] {
      for b in [false, true] {
        v.store(a, ordering: .relaxed)
        let r = v.logicalOrThenLoad(
          with: b,
          ordering: .sequentiallyConsistent)
        XCTAssertEqual(r, a || b, "a = \(a), b = \(b)")
        XCTAssertEqual(
          v.load(ordering: .relaxed),
          a || b,
          "a = \(a), b =\(b)")
      }
    }
  }
  func test_logicalXorThenLoad_relaxed() {
    let v = UnsafeAtomic<Bool>.create(false)
    defer { v.destroy() }

    // The truth tables are super tiny, so just check every value
    for a in [false, true] {
      for b in [false, true] {
        v.store(a, ordering: .relaxed)
        let r = v.logicalXorThenLoad(
          with: b,
          ordering: .relaxed)
        XCTAssertEqual(r, a != b, "a = \(a), b = \(b)")
        XCTAssertEqual(
          v.load(ordering: .relaxed),
          a != b,
          "a = \(a), b =\(b)")
      }
    }
  }
  func test_logicalXorThenLoad_acquiring() {
    let v = UnsafeAtomic<Bool>.create(false)
    defer { v.destroy() }

    // The truth tables are super tiny, so just check every value
    for a in [false, true] {
      for b in [false, true] {
        v.store(a, ordering: .relaxed)
        let r = v.logicalXorThenLoad(
          with: b,
          ordering: .acquiring)
        XCTAssertEqual(r, a != b, "a = \(a), b = \(b)")
        XCTAssertEqual(
          v.load(ordering: .relaxed),
          a != b,
          "a = \(a), b =\(b)")
      }
    }
  }
  func test_logicalXorThenLoad_releasing() {
    let v = UnsafeAtomic<Bool>.create(false)
    defer { v.destroy() }

    // The truth tables are super tiny, so just check every value
    for a in [false, true] {
      for b in [false, true] {
        v.store(a, ordering: .relaxed)
        let r = v.logicalXorThenLoad(
          with: b,
          ordering: .releasing)
        XCTAssertEqual(r, a != b, "a = \(a), b = \(b)")
        XCTAssertEqual(
          v.load(ordering: .relaxed),
          a != b,
          "a = \(a), b =\(b)")
      }
    }
  }
  func test_logicalXorThenLoad_acquiringAndReleasing() {
    let v = UnsafeAtomic<Bool>.create(false)
    defer { v.destroy() }

    // The truth tables are super tiny, so just check every value
    for a in [false, true] {
      for b in [false, true] {
        v.store(a, ordering: .relaxed)
        let r = v.logicalXorThenLoad(
          with: b,
          ordering: .acquiringAndReleasing)
        XCTAssertEqual(r, a != b, "a = \(a), b = \(b)")
        XCTAssertEqual(
          v.load(ordering: .relaxed),
          a != b,
          "a = \(a), b =\(b)")
      }
    }
  }
  func test_logicalXorThenLoad_sequentiallyConsistent() {
    let v = UnsafeAtomic<Bool>.create(false)
    defer { v.destroy() }

    // The truth tables are super tiny, so just check every value
    for a in [false, true] {
      for b in [false, true] {
        v.store(a, ordering: .relaxed)
        let r = v.logicalXorThenLoad(
          with: b,
          ordering: .sequentiallyConsistent)
        XCTAssertEqual(r, a != b, "a = \(a), b = \(b)")
        XCTAssertEqual(
          v.load(ordering: .relaxed),
          a != b,
          "a = \(a), b =\(b)")
      }
    }
  }



  public static var allTests = [
    ("test_create_destroy", test_create_destroy),
    ("test_load_relaxed", test_load_relaxed),
    ("test_load_acquiring", test_load_acquiring),
    ("test_load_sequentiallyConsistent", test_load_sequentiallyConsistent),
    ("test_store_relaxed", test_store_relaxed),
    ("test_store_releasing", test_store_releasing),
    ("test_store_sequentiallyConsistent", test_store_sequentiallyConsistent),
    ("test_exchange_relaxed", test_exchange_relaxed),
    ("test_exchange_acquiring", test_exchange_acquiring),
    ("test_exchange_releasing", test_exchange_releasing),
    ("test_exchange_acquiringAndReleasing", test_exchange_acquiringAndReleasing),
    ("test_exchange_sequentiallyConsistent", test_exchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed", test_compareExchange_relaxed),
    ("test_compareExchange_acquiring", test_compareExchange_acquiring),
    ("test_compareExchange_releasing", test_compareExchange_releasing),
    ("test_compareExchange_acquiringAndReleasing", test_compareExchange_acquiringAndReleasing),
    ("test_compareExchange_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed_relaxed", test_compareExchange_relaxed_relaxed),
    ("test_compareExchange_relaxed_acquiring", test_compareExchange_relaxed_acquiring),
    ("test_compareExchange_relaxed_sequentiallyConsistent", test_compareExchange_relaxed_sequentiallyConsistent),
    ("test_compareExchange_acquiring_relaxed", test_compareExchange_acquiring_relaxed),
    ("test_compareExchange_acquiring_acquiring", test_compareExchange_acquiring_acquiring),
    ("test_compareExchange_acquiring_sequentiallyConsistent", test_compareExchange_acquiring_sequentiallyConsistent),
    ("test_compareExchange_releasing_relaxed", test_compareExchange_releasing_relaxed),
    ("test_compareExchange_releasing_acquiring", test_compareExchange_releasing_acquiring),
    ("test_compareExchange_releasing_sequentiallyConsistent", test_compareExchange_releasing_sequentiallyConsistent),
    ("test_compareExchange_acquiringAndReleasing_relaxed", test_compareExchange_acquiringAndReleasing_relaxed),
    ("test_compareExchange_acquiringAndReleasing_acquiring", test_compareExchange_acquiringAndReleasing_acquiring),
    ("test_compareExchange_acquiringAndReleasing_sequentiallyConsistent", test_compareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_compareExchange_sequentiallyConsistent_relaxed", test_compareExchange_sequentiallyConsistent_relaxed),
    ("test_compareExchange_sequentiallyConsistent_acquiring", test_compareExchange_sequentiallyConsistent_acquiring),
    ("test_compareExchange_sequentiallyConsistent_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent_sequentiallyConsistent),
    ("test_weakCompareExchange_relaxed_relaxed", test_weakCompareExchange_relaxed_relaxed),
    ("test_weakCompareExchange_relaxed_acquiring", test_weakCompareExchange_relaxed_acquiring),
    ("test_weakCompareExchange_relaxed_sequentiallyConsistent", test_weakCompareExchange_relaxed_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiring_relaxed", test_weakCompareExchange_acquiring_relaxed),
    ("test_weakCompareExchange_acquiring_acquiring", test_weakCompareExchange_acquiring_acquiring),
    ("test_weakCompareExchange_acquiring_sequentiallyConsistent", test_weakCompareExchange_acquiring_sequentiallyConsistent),
    ("test_weakCompareExchange_releasing_relaxed", test_weakCompareExchange_releasing_relaxed),
    ("test_weakCompareExchange_releasing_acquiring", test_weakCompareExchange_releasing_acquiring),
    ("test_weakCompareExchange_releasing_sequentiallyConsistent", test_weakCompareExchange_releasing_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiringAndReleasing_relaxed", test_weakCompareExchange_acquiringAndReleasing_relaxed),
    ("test_weakCompareExchange_acquiringAndReleasing_acquiring", test_weakCompareExchange_acquiringAndReleasing_acquiring),
    ("test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent", test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_weakCompareExchange_sequentiallyConsistent_relaxed", test_weakCompareExchange_sequentiallyConsistent_relaxed),
    ("test_weakCompareExchange_sequentiallyConsistent_acquiring", test_weakCompareExchange_sequentiallyConsistent_acquiring),
    ("test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent", test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent),
    ("test_loadThenLogicalAnd_relaxed", test_loadThenLogicalAnd_relaxed),
    ("test_loadThenLogicalAnd_acquiring", test_loadThenLogicalAnd_acquiring),
    ("test_loadThenLogicalAnd_releasing", test_loadThenLogicalAnd_releasing),
    ("test_loadThenLogicalAnd_acquiringAndReleasing", test_loadThenLogicalAnd_acquiringAndReleasing),
    ("test_loadThenLogicalAnd_sequentiallyConsistent", test_loadThenLogicalAnd_sequentiallyConsistent),
    ("test_loadThenLogicalOr_relaxed", test_loadThenLogicalOr_relaxed),
    ("test_loadThenLogicalOr_acquiring", test_loadThenLogicalOr_acquiring),
    ("test_loadThenLogicalOr_releasing", test_loadThenLogicalOr_releasing),
    ("test_loadThenLogicalOr_acquiringAndReleasing", test_loadThenLogicalOr_acquiringAndReleasing),
    ("test_loadThenLogicalOr_sequentiallyConsistent", test_loadThenLogicalOr_sequentiallyConsistent),
    ("test_loadThenLogicalXor_relaxed", test_loadThenLogicalXor_relaxed),
    ("test_loadThenLogicalXor_acquiring", test_loadThenLogicalXor_acquiring),
    ("test_loadThenLogicalXor_releasing", test_loadThenLogicalXor_releasing),
    ("test_loadThenLogicalXor_acquiringAndReleasing", test_loadThenLogicalXor_acquiringAndReleasing),
    ("test_loadThenLogicalXor_sequentiallyConsistent", test_loadThenLogicalXor_sequentiallyConsistent),
    ("test_logicalAndThenLoad_relaxed", test_logicalAndThenLoad_relaxed),
    ("test_logicalAndThenLoad_acquiring", test_logicalAndThenLoad_acquiring),
    ("test_logicalAndThenLoad_releasing", test_logicalAndThenLoad_releasing),
    ("test_logicalAndThenLoad_acquiringAndReleasing", test_logicalAndThenLoad_acquiringAndReleasing),
    ("test_logicalAndThenLoad_sequentiallyConsistent", test_logicalAndThenLoad_sequentiallyConsistent),
    ("test_logicalOrThenLoad_relaxed", test_logicalOrThenLoad_relaxed),
    ("test_logicalOrThenLoad_acquiring", test_logicalOrThenLoad_acquiring),
    ("test_logicalOrThenLoad_releasing", test_logicalOrThenLoad_releasing),
    ("test_logicalOrThenLoad_acquiringAndReleasing", test_logicalOrThenLoad_acquiringAndReleasing),
    ("test_logicalOrThenLoad_sequentiallyConsistent", test_logicalOrThenLoad_sequentiallyConsistent),
    ("test_logicalXorThenLoad_relaxed", test_logicalXorThenLoad_relaxed),
    ("test_logicalXorThenLoad_acquiring", test_logicalXorThenLoad_acquiring),
    ("test_logicalXorThenLoad_releasing", test_logicalXorThenLoad_releasing),
    ("test_logicalXorThenLoad_acquiringAndReleasing", test_logicalXorThenLoad_acquiringAndReleasing),
    ("test_logicalXorThenLoad_sequentiallyConsistent", test_logicalXorThenLoad_sequentiallyConsistent),
  ]
}
#endif
#if true
/// Exercises all operations in a single-threaded context, verifying
/// they provide the expected results.
class BasicAtomicPointerTests: XCTestCase {
  private let _mfoo1: UnsafeMutablePointer<Foo> = {
    let p = UnsafeMutablePointer<Foo>.allocate(capacity: 1)
    p.initialize(to: Foo(1))
    return p
  }()
  private let _mfoo2: UnsafeMutablePointer<Foo> = {
    let p = UnsafeMutablePointer<Foo>.allocate(capacity: 1)
    p.initialize(to: Foo(2))
    return p
  }()

  private var _foo1: UnsafePointer<Foo> { UnsafePointer(_mfoo1) }
  private var _foo2: UnsafePointer<Foo> { UnsafePointer(_mfoo2) }

  deinit {
    _mfoo1.deinitialize(count: 1)
    _mfoo1.deallocate()

    _mfoo2.deinitialize(count: 1)
    _mfoo2.deallocate()
  }

  func test_create_destroy() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    let w = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), _foo2)
  }

  func test_load_relaxed() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    let w = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), _foo2)
  }
  func test_load_acquiring() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .acquiring), _foo1)

    let w = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .acquiring), _foo2)
  }
  func test_load_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .sequentiallyConsistent), _foo1)

    let w = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .sequentiallyConsistent), _foo2)
  }

  func test_store_relaxed() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }
    v.store(_foo2, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    let w = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo2)
    defer { w.destroy() }
    w.store(_foo1, ordering: .relaxed)
    XCTAssertEqual(w.load(ordering: .relaxed), _foo1)
  }
  func test_store_releasing() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }
    v.store(_foo2, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    let w = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo2)
    defer { w.destroy() }
    w.store(_foo1, ordering: .releasing)
    XCTAssertEqual(w.load(ordering: .relaxed), _foo1)
  }
  func test_store_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }
    v.store(_foo2, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    let w = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo2)
    defer { w.destroy() }
    w.store(_foo1, ordering: .sequentiallyConsistent)
    XCTAssertEqual(w.load(ordering: .relaxed), _foo1)
  }

  func test_exchange_relaxed() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(_foo1, ordering: .relaxed), _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    XCTAssertEqual(v.exchange(_foo2, ordering: .relaxed), _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    XCTAssertEqual(v.exchange(_foo2, ordering: .relaxed), _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)
  }
  func test_exchange_acquiring() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(_foo1, ordering: .acquiring), _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    XCTAssertEqual(v.exchange(_foo2, ordering: .acquiring), _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    XCTAssertEqual(v.exchange(_foo2, ordering: .acquiring), _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)
  }
  func test_exchange_releasing() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(_foo1, ordering: .releasing), _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    XCTAssertEqual(v.exchange(_foo2, ordering: .releasing), _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    XCTAssertEqual(v.exchange(_foo2, ordering: .releasing), _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)
  }
  func test_exchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(_foo1, ordering: .acquiringAndReleasing), _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    XCTAssertEqual(v.exchange(_foo2, ordering: .acquiringAndReleasing), _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    XCTAssertEqual(v.exchange(_foo2, ordering: .acquiringAndReleasing), _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)
  }
  func test_exchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(_foo1, ordering: .sequentiallyConsistent), _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    XCTAssertEqual(v.exchange(_foo2, ordering: .sequentiallyConsistent), _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    XCTAssertEqual(v.exchange(_foo2, ordering: .sequentiallyConsistent), _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)
  }

  func test_compareExchange_relaxed() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)
  }
  func test_compareExchange_acquiring() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)
  }
  func test_compareExchange_releasing() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)
  }
  func test_compareExchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)
  }
  func test_compareExchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)
  }

  func test_compareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)
  }
  func test_compareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)
  }
  func test_compareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)
  }
  func test_compareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)
  }
  func test_compareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)
  }
  func test_compareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)
  }
  func test_compareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)
  }
  func test_compareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)
  }
  func test_compareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)
  }
  func test_compareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)
  }
  func test_compareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)
  }
  func test_compareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)
  }
  func test_compareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)
  }
  func test_compareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)
  }
  func test_compareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)
  }
  func test_weakCompareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)
  }
  func test_weakCompareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)
  }
  func test_weakCompareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)
  }
  func test_weakCompareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)
  }
  func test_weakCompareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)
  }
  func test_weakCompareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)
  }
  func test_weakCompareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)
  }
  func test_weakCompareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)
  }
  func test_weakCompareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)
  }
  func test_weakCompareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)
  }
  func test_weakCompareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)
  }
  func test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)
  }
  func test_weakCompareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)
  }
  func test_weakCompareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)
  }
  func test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafePointer<Foo>>.create(_foo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo1,
      desired: _foo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: _foo1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo1)
  }





  public static var allTests = [
    ("test_create_destroy", test_create_destroy),
    ("test_load_relaxed", test_load_relaxed),
    ("test_load_acquiring", test_load_acquiring),
    ("test_load_sequentiallyConsistent", test_load_sequentiallyConsistent),
    ("test_store_relaxed", test_store_relaxed),
    ("test_store_releasing", test_store_releasing),
    ("test_store_sequentiallyConsistent", test_store_sequentiallyConsistent),
    ("test_exchange_relaxed", test_exchange_relaxed),
    ("test_exchange_acquiring", test_exchange_acquiring),
    ("test_exchange_releasing", test_exchange_releasing),
    ("test_exchange_acquiringAndReleasing", test_exchange_acquiringAndReleasing),
    ("test_exchange_sequentiallyConsistent", test_exchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed", test_compareExchange_relaxed),
    ("test_compareExchange_acquiring", test_compareExchange_acquiring),
    ("test_compareExchange_releasing", test_compareExchange_releasing),
    ("test_compareExchange_acquiringAndReleasing", test_compareExchange_acquiringAndReleasing),
    ("test_compareExchange_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed_relaxed", test_compareExchange_relaxed_relaxed),
    ("test_compareExchange_relaxed_acquiring", test_compareExchange_relaxed_acquiring),
    ("test_compareExchange_relaxed_sequentiallyConsistent", test_compareExchange_relaxed_sequentiallyConsistent),
    ("test_compareExchange_acquiring_relaxed", test_compareExchange_acquiring_relaxed),
    ("test_compareExchange_acquiring_acquiring", test_compareExchange_acquiring_acquiring),
    ("test_compareExchange_acquiring_sequentiallyConsistent", test_compareExchange_acquiring_sequentiallyConsistent),
    ("test_compareExchange_releasing_relaxed", test_compareExchange_releasing_relaxed),
    ("test_compareExchange_releasing_acquiring", test_compareExchange_releasing_acquiring),
    ("test_compareExchange_releasing_sequentiallyConsistent", test_compareExchange_releasing_sequentiallyConsistent),
    ("test_compareExchange_acquiringAndReleasing_relaxed", test_compareExchange_acquiringAndReleasing_relaxed),
    ("test_compareExchange_acquiringAndReleasing_acquiring", test_compareExchange_acquiringAndReleasing_acquiring),
    ("test_compareExchange_acquiringAndReleasing_sequentiallyConsistent", test_compareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_compareExchange_sequentiallyConsistent_relaxed", test_compareExchange_sequentiallyConsistent_relaxed),
    ("test_compareExchange_sequentiallyConsistent_acquiring", test_compareExchange_sequentiallyConsistent_acquiring),
    ("test_compareExchange_sequentiallyConsistent_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent_sequentiallyConsistent),
    ("test_weakCompareExchange_relaxed_relaxed", test_weakCompareExchange_relaxed_relaxed),
    ("test_weakCompareExchange_relaxed_acquiring", test_weakCompareExchange_relaxed_acquiring),
    ("test_weakCompareExchange_relaxed_sequentiallyConsistent", test_weakCompareExchange_relaxed_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiring_relaxed", test_weakCompareExchange_acquiring_relaxed),
    ("test_weakCompareExchange_acquiring_acquiring", test_weakCompareExchange_acquiring_acquiring),
    ("test_weakCompareExchange_acquiring_sequentiallyConsistent", test_weakCompareExchange_acquiring_sequentiallyConsistent),
    ("test_weakCompareExchange_releasing_relaxed", test_weakCompareExchange_releasing_relaxed),
    ("test_weakCompareExchange_releasing_acquiring", test_weakCompareExchange_releasing_acquiring),
    ("test_weakCompareExchange_releasing_sequentiallyConsistent", test_weakCompareExchange_releasing_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiringAndReleasing_relaxed", test_weakCompareExchange_acquiringAndReleasing_relaxed),
    ("test_weakCompareExchange_acquiringAndReleasing_acquiring", test_weakCompareExchange_acquiringAndReleasing_acquiring),
    ("test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent", test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_weakCompareExchange_sequentiallyConsistent_relaxed", test_weakCompareExchange_sequentiallyConsistent_relaxed),
    ("test_weakCompareExchange_sequentiallyConsistent_acquiring", test_weakCompareExchange_sequentiallyConsistent_acquiring),
    ("test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent", test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent),
  ]
}
#endif
#if true
/// Exercises all operations in a single-threaded context, verifying
/// they provide the expected results.
class BasicAtomicOptionalPointerTests: XCTestCase {
  private let _mfoo1: UnsafeMutablePointer<Foo> = {
    let p = UnsafeMutablePointer<Foo>.allocate(capacity: 1)
    p.initialize(to: Foo(1))
    return p
  }()
  private let _mfoo2: UnsafeMutablePointer<Foo> = {
    let p = UnsafeMutablePointer<Foo>.allocate(capacity: 1)
    p.initialize(to: Foo(2))
    return p
  }()

  private var _foo1: UnsafePointer<Foo> { UnsafePointer(_mfoo1) }
  private var _foo2: UnsafePointer<Foo> { UnsafePointer(_mfoo2) }

  deinit {
    _mfoo1.deinitialize(count: 1)
    _mfoo1.deallocate()

    _mfoo2.deinitialize(count: 1)
    _mfoo2.deallocate()
  }

  func test_create_destroy() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    let w = UnsafeAtomic<UnsafePointer<Foo>?>.create(_foo2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), _foo2)
  }

  func test_load_relaxed() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    let w = UnsafeAtomic<UnsafePointer<Foo>?>.create(_foo2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), _foo2)
  }
  func test_load_acquiring() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .acquiring), nil)

    let w = UnsafeAtomic<UnsafePointer<Foo>?>.create(_foo2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .acquiring), _foo2)
  }
  func test_load_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .sequentiallyConsistent), nil)

    let w = UnsafeAtomic<UnsafePointer<Foo>?>.create(_foo2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .sequentiallyConsistent), _foo2)
  }

  func test_store_relaxed() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }
    v.store(_foo2, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    let w = UnsafeAtomic<UnsafePointer<Foo>?>.create(_foo2)
    defer { w.destroy() }
    w.store(nil, ordering: .relaxed)
    XCTAssertEqual(w.load(ordering: .relaxed), nil)
  }
  func test_store_releasing() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }
    v.store(_foo2, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    let w = UnsafeAtomic<UnsafePointer<Foo>?>.create(_foo2)
    defer { w.destroy() }
    w.store(nil, ordering: .releasing)
    XCTAssertEqual(w.load(ordering: .relaxed), nil)
  }
  func test_store_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }
    v.store(_foo2, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    let w = UnsafeAtomic<UnsafePointer<Foo>?>.create(_foo2)
    defer { w.destroy() }
    w.store(nil, ordering: .sequentiallyConsistent)
    XCTAssertEqual(w.load(ordering: .relaxed), nil)
  }

  func test_exchange_relaxed() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(nil, ordering: .relaxed), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    XCTAssertEqual(v.exchange(_foo2, ordering: .relaxed), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    XCTAssertEqual(v.exchange(_foo2, ordering: .relaxed), _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)
  }
  func test_exchange_acquiring() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(nil, ordering: .acquiring), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    XCTAssertEqual(v.exchange(_foo2, ordering: .acquiring), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    XCTAssertEqual(v.exchange(_foo2, ordering: .acquiring), _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)
  }
  func test_exchange_releasing() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(nil, ordering: .releasing), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    XCTAssertEqual(v.exchange(_foo2, ordering: .releasing), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    XCTAssertEqual(v.exchange(_foo2, ordering: .releasing), _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)
  }
  func test_exchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(nil, ordering: .acquiringAndReleasing), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    XCTAssertEqual(v.exchange(_foo2, ordering: .acquiringAndReleasing), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    XCTAssertEqual(v.exchange(_foo2, ordering: .acquiringAndReleasing), _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)
  }
  func test_exchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(nil, ordering: .sequentiallyConsistent), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    XCTAssertEqual(v.exchange(_foo2, ordering: .sequentiallyConsistent), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    XCTAssertEqual(v.exchange(_foo2, ordering: .sequentiallyConsistent), _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)
  }

  func test_compareExchange_relaxed() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiring() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_releasing() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }

  func test_compareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _foo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _foo2)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _foo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _foo2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }





  public static var allTests = [
    ("test_create_destroy", test_create_destroy),
    ("test_load_relaxed", test_load_relaxed),
    ("test_load_acquiring", test_load_acquiring),
    ("test_load_sequentiallyConsistent", test_load_sequentiallyConsistent),
    ("test_store_relaxed", test_store_relaxed),
    ("test_store_releasing", test_store_releasing),
    ("test_store_sequentiallyConsistent", test_store_sequentiallyConsistent),
    ("test_exchange_relaxed", test_exchange_relaxed),
    ("test_exchange_acquiring", test_exchange_acquiring),
    ("test_exchange_releasing", test_exchange_releasing),
    ("test_exchange_acquiringAndReleasing", test_exchange_acquiringAndReleasing),
    ("test_exchange_sequentiallyConsistent", test_exchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed", test_compareExchange_relaxed),
    ("test_compareExchange_acquiring", test_compareExchange_acquiring),
    ("test_compareExchange_releasing", test_compareExchange_releasing),
    ("test_compareExchange_acquiringAndReleasing", test_compareExchange_acquiringAndReleasing),
    ("test_compareExchange_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed_relaxed", test_compareExchange_relaxed_relaxed),
    ("test_compareExchange_relaxed_acquiring", test_compareExchange_relaxed_acquiring),
    ("test_compareExchange_relaxed_sequentiallyConsistent", test_compareExchange_relaxed_sequentiallyConsistent),
    ("test_compareExchange_acquiring_relaxed", test_compareExchange_acquiring_relaxed),
    ("test_compareExchange_acquiring_acquiring", test_compareExchange_acquiring_acquiring),
    ("test_compareExchange_acquiring_sequentiallyConsistent", test_compareExchange_acquiring_sequentiallyConsistent),
    ("test_compareExchange_releasing_relaxed", test_compareExchange_releasing_relaxed),
    ("test_compareExchange_releasing_acquiring", test_compareExchange_releasing_acquiring),
    ("test_compareExchange_releasing_sequentiallyConsistent", test_compareExchange_releasing_sequentiallyConsistent),
    ("test_compareExchange_acquiringAndReleasing_relaxed", test_compareExchange_acquiringAndReleasing_relaxed),
    ("test_compareExchange_acquiringAndReleasing_acquiring", test_compareExchange_acquiringAndReleasing_acquiring),
    ("test_compareExchange_acquiringAndReleasing_sequentiallyConsistent", test_compareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_compareExchange_sequentiallyConsistent_relaxed", test_compareExchange_sequentiallyConsistent_relaxed),
    ("test_compareExchange_sequentiallyConsistent_acquiring", test_compareExchange_sequentiallyConsistent_acquiring),
    ("test_compareExchange_sequentiallyConsistent_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent_sequentiallyConsistent),
    ("test_weakCompareExchange_relaxed_relaxed", test_weakCompareExchange_relaxed_relaxed),
    ("test_weakCompareExchange_relaxed_acquiring", test_weakCompareExchange_relaxed_acquiring),
    ("test_weakCompareExchange_relaxed_sequentiallyConsistent", test_weakCompareExchange_relaxed_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiring_relaxed", test_weakCompareExchange_acquiring_relaxed),
    ("test_weakCompareExchange_acquiring_acquiring", test_weakCompareExchange_acquiring_acquiring),
    ("test_weakCompareExchange_acquiring_sequentiallyConsistent", test_weakCompareExchange_acquiring_sequentiallyConsistent),
    ("test_weakCompareExchange_releasing_relaxed", test_weakCompareExchange_releasing_relaxed),
    ("test_weakCompareExchange_releasing_acquiring", test_weakCompareExchange_releasing_acquiring),
    ("test_weakCompareExchange_releasing_sequentiallyConsistent", test_weakCompareExchange_releasing_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiringAndReleasing_relaxed", test_weakCompareExchange_acquiringAndReleasing_relaxed),
    ("test_weakCompareExchange_acquiringAndReleasing_acquiring", test_weakCompareExchange_acquiringAndReleasing_acquiring),
    ("test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent", test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_weakCompareExchange_sequentiallyConsistent_relaxed", test_weakCompareExchange_sequentiallyConsistent_relaxed),
    ("test_weakCompareExchange_sequentiallyConsistent_acquiring", test_weakCompareExchange_sequentiallyConsistent_acquiring),
    ("test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent", test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent),
  ]
}
#endif
#if true
/// Exercises all operations in a single-threaded context, verifying
/// they provide the expected results.
class BasicAtomicMutablePointerTests: XCTestCase {
  private let _mfoo1: UnsafeMutablePointer<Foo> = {
    let p = UnsafeMutablePointer<Foo>.allocate(capacity: 1)
    p.initialize(to: Foo(1))
    return p
  }()
  private let _mfoo2: UnsafeMutablePointer<Foo> = {
    let p = UnsafeMutablePointer<Foo>.allocate(capacity: 1)
    p.initialize(to: Foo(2))
    return p
  }()

  private var _foo1: UnsafePointer<Foo> { UnsafePointer(_mfoo1) }
  private var _foo2: UnsafePointer<Foo> { UnsafePointer(_mfoo2) }

  deinit {
    _mfoo1.deinitialize(count: 1)
    _mfoo1.deallocate()

    _mfoo2.deinitialize(count: 1)
    _mfoo2.deallocate()
  }

  func test_create_destroy() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    let w = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), _mfoo2)
  }

  func test_load_relaxed() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    let w = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), _mfoo2)
  }
  func test_load_acquiring() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .acquiring), _mfoo1)

    let w = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .acquiring), _mfoo2)
  }
  func test_load_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .sequentiallyConsistent), _mfoo1)

    let w = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .sequentiallyConsistent), _mfoo2)
  }

  func test_store_relaxed() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }
    v.store(_mfoo2, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    let w = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo2)
    defer { w.destroy() }
    w.store(_mfoo1, ordering: .relaxed)
    XCTAssertEqual(w.load(ordering: .relaxed), _mfoo1)
  }
  func test_store_releasing() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }
    v.store(_mfoo2, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    let w = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo2)
    defer { w.destroy() }
    w.store(_mfoo1, ordering: .releasing)
    XCTAssertEqual(w.load(ordering: .relaxed), _mfoo1)
  }
  func test_store_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }
    v.store(_mfoo2, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    let w = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo2)
    defer { w.destroy() }
    w.store(_mfoo1, ordering: .sequentiallyConsistent)
    XCTAssertEqual(w.load(ordering: .relaxed), _mfoo1)
  }

  func test_exchange_relaxed() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(_mfoo1, ordering: .relaxed), _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    XCTAssertEqual(v.exchange(_mfoo2, ordering: .relaxed), _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    XCTAssertEqual(v.exchange(_mfoo2, ordering: .relaxed), _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)
  }
  func test_exchange_acquiring() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(_mfoo1, ordering: .acquiring), _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    XCTAssertEqual(v.exchange(_mfoo2, ordering: .acquiring), _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    XCTAssertEqual(v.exchange(_mfoo2, ordering: .acquiring), _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)
  }
  func test_exchange_releasing() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(_mfoo1, ordering: .releasing), _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    XCTAssertEqual(v.exchange(_mfoo2, ordering: .releasing), _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    XCTAssertEqual(v.exchange(_mfoo2, ordering: .releasing), _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)
  }
  func test_exchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(_mfoo1, ordering: .acquiringAndReleasing), _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    XCTAssertEqual(v.exchange(_mfoo2, ordering: .acquiringAndReleasing), _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    XCTAssertEqual(v.exchange(_mfoo2, ordering: .acquiringAndReleasing), _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)
  }
  func test_exchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(_mfoo1, ordering: .sequentiallyConsistent), _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    XCTAssertEqual(v.exchange(_mfoo2, ordering: .sequentiallyConsistent), _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    XCTAssertEqual(v.exchange(_mfoo2, ordering: .sequentiallyConsistent), _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)
  }

  func test_compareExchange_relaxed() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)
  }
  func test_compareExchange_acquiring() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)
  }
  func test_compareExchange_releasing() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)
  }
  func test_compareExchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)
  }
  func test_compareExchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)
  }

  func test_compareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)
  }
  func test_compareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)
  }
  func test_compareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)
  }
  func test_compareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)
  }
  func test_compareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)
  }
  func test_compareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)
  }
  func test_compareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)
  }
  func test_compareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)
  }
  func test_compareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)
  }
  func test_compareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)
  }
  func test_compareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)
  }
  func test_compareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)
  }
  func test_compareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)
  }
  func test_compareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)
  }
  func test_compareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)
  }
  func test_weakCompareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)
  }
  func test_weakCompareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)
  }
  func test_weakCompareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)
  }
  func test_weakCompareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)
  }
  func test_weakCompareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)
  }
  func test_weakCompareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)
  }
  func test_weakCompareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)
  }
  func test_weakCompareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)
  }
  func test_weakCompareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)
  }
  func test_weakCompareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)
  }
  func test_weakCompareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)
  }
  func test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)
  }
  func test_weakCompareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)
  }
  func test_weakCompareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)
  }
  func test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>>.create(_mfoo1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo1,
      desired: _mfoo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: _mfoo1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo1)
  }





  public static var allTests = [
    ("test_create_destroy", test_create_destroy),
    ("test_load_relaxed", test_load_relaxed),
    ("test_load_acquiring", test_load_acquiring),
    ("test_load_sequentiallyConsistent", test_load_sequentiallyConsistent),
    ("test_store_relaxed", test_store_relaxed),
    ("test_store_releasing", test_store_releasing),
    ("test_store_sequentiallyConsistent", test_store_sequentiallyConsistent),
    ("test_exchange_relaxed", test_exchange_relaxed),
    ("test_exchange_acquiring", test_exchange_acquiring),
    ("test_exchange_releasing", test_exchange_releasing),
    ("test_exchange_acquiringAndReleasing", test_exchange_acquiringAndReleasing),
    ("test_exchange_sequentiallyConsistent", test_exchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed", test_compareExchange_relaxed),
    ("test_compareExchange_acquiring", test_compareExchange_acquiring),
    ("test_compareExchange_releasing", test_compareExchange_releasing),
    ("test_compareExchange_acquiringAndReleasing", test_compareExchange_acquiringAndReleasing),
    ("test_compareExchange_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed_relaxed", test_compareExchange_relaxed_relaxed),
    ("test_compareExchange_relaxed_acquiring", test_compareExchange_relaxed_acquiring),
    ("test_compareExchange_relaxed_sequentiallyConsistent", test_compareExchange_relaxed_sequentiallyConsistent),
    ("test_compareExchange_acquiring_relaxed", test_compareExchange_acquiring_relaxed),
    ("test_compareExchange_acquiring_acquiring", test_compareExchange_acquiring_acquiring),
    ("test_compareExchange_acquiring_sequentiallyConsistent", test_compareExchange_acquiring_sequentiallyConsistent),
    ("test_compareExchange_releasing_relaxed", test_compareExchange_releasing_relaxed),
    ("test_compareExchange_releasing_acquiring", test_compareExchange_releasing_acquiring),
    ("test_compareExchange_releasing_sequentiallyConsistent", test_compareExchange_releasing_sequentiallyConsistent),
    ("test_compareExchange_acquiringAndReleasing_relaxed", test_compareExchange_acquiringAndReleasing_relaxed),
    ("test_compareExchange_acquiringAndReleasing_acquiring", test_compareExchange_acquiringAndReleasing_acquiring),
    ("test_compareExchange_acquiringAndReleasing_sequentiallyConsistent", test_compareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_compareExchange_sequentiallyConsistent_relaxed", test_compareExchange_sequentiallyConsistent_relaxed),
    ("test_compareExchange_sequentiallyConsistent_acquiring", test_compareExchange_sequentiallyConsistent_acquiring),
    ("test_compareExchange_sequentiallyConsistent_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent_sequentiallyConsistent),
    ("test_weakCompareExchange_relaxed_relaxed", test_weakCompareExchange_relaxed_relaxed),
    ("test_weakCompareExchange_relaxed_acquiring", test_weakCompareExchange_relaxed_acquiring),
    ("test_weakCompareExchange_relaxed_sequentiallyConsistent", test_weakCompareExchange_relaxed_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiring_relaxed", test_weakCompareExchange_acquiring_relaxed),
    ("test_weakCompareExchange_acquiring_acquiring", test_weakCompareExchange_acquiring_acquiring),
    ("test_weakCompareExchange_acquiring_sequentiallyConsistent", test_weakCompareExchange_acquiring_sequentiallyConsistent),
    ("test_weakCompareExchange_releasing_relaxed", test_weakCompareExchange_releasing_relaxed),
    ("test_weakCompareExchange_releasing_acquiring", test_weakCompareExchange_releasing_acquiring),
    ("test_weakCompareExchange_releasing_sequentiallyConsistent", test_weakCompareExchange_releasing_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiringAndReleasing_relaxed", test_weakCompareExchange_acquiringAndReleasing_relaxed),
    ("test_weakCompareExchange_acquiringAndReleasing_acquiring", test_weakCompareExchange_acquiringAndReleasing_acquiring),
    ("test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent", test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_weakCompareExchange_sequentiallyConsistent_relaxed", test_weakCompareExchange_sequentiallyConsistent_relaxed),
    ("test_weakCompareExchange_sequentiallyConsistent_acquiring", test_weakCompareExchange_sequentiallyConsistent_acquiring),
    ("test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent", test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent),
  ]
}
#endif
#if true
/// Exercises all operations in a single-threaded context, verifying
/// they provide the expected results.
class BasicAtomicOptionalMutablePointerTests: XCTestCase {
  private let _mfoo1: UnsafeMutablePointer<Foo> = {
    let p = UnsafeMutablePointer<Foo>.allocate(capacity: 1)
    p.initialize(to: Foo(1))
    return p
  }()
  private let _mfoo2: UnsafeMutablePointer<Foo> = {
    let p = UnsafeMutablePointer<Foo>.allocate(capacity: 1)
    p.initialize(to: Foo(2))
    return p
  }()

  private var _foo1: UnsafePointer<Foo> { UnsafePointer(_mfoo1) }
  private var _foo2: UnsafePointer<Foo> { UnsafePointer(_mfoo2) }

  deinit {
    _mfoo1.deinitialize(count: 1)
    _mfoo1.deallocate()

    _mfoo2.deinitialize(count: 1)
    _mfoo2.deallocate()
  }

  func test_create_destroy() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    let w = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(_mfoo2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), _mfoo2)
  }

  func test_load_relaxed() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    let w = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(_mfoo2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), _mfoo2)
  }
  func test_load_acquiring() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .acquiring), nil)

    let w = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(_mfoo2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .acquiring), _mfoo2)
  }
  func test_load_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .sequentiallyConsistent), nil)

    let w = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(_mfoo2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .sequentiallyConsistent), _mfoo2)
  }

  func test_store_relaxed() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }
    v.store(_mfoo2, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    let w = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(_mfoo2)
    defer { w.destroy() }
    w.store(nil, ordering: .relaxed)
    XCTAssertEqual(w.load(ordering: .relaxed), nil)
  }
  func test_store_releasing() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }
    v.store(_mfoo2, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    let w = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(_mfoo2)
    defer { w.destroy() }
    w.store(nil, ordering: .releasing)
    XCTAssertEqual(w.load(ordering: .relaxed), nil)
  }
  func test_store_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }
    v.store(_mfoo2, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    let w = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(_mfoo2)
    defer { w.destroy() }
    w.store(nil, ordering: .sequentiallyConsistent)
    XCTAssertEqual(w.load(ordering: .relaxed), nil)
  }

  func test_exchange_relaxed() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(nil, ordering: .relaxed), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    XCTAssertEqual(v.exchange(_mfoo2, ordering: .relaxed), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    XCTAssertEqual(v.exchange(_mfoo2, ordering: .relaxed), _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)
  }
  func test_exchange_acquiring() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(nil, ordering: .acquiring), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    XCTAssertEqual(v.exchange(_mfoo2, ordering: .acquiring), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    XCTAssertEqual(v.exchange(_mfoo2, ordering: .acquiring), _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)
  }
  func test_exchange_releasing() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(nil, ordering: .releasing), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    XCTAssertEqual(v.exchange(_mfoo2, ordering: .releasing), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    XCTAssertEqual(v.exchange(_mfoo2, ordering: .releasing), _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)
  }
  func test_exchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(nil, ordering: .acquiringAndReleasing), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    XCTAssertEqual(v.exchange(_mfoo2, ordering: .acquiringAndReleasing), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    XCTAssertEqual(v.exchange(_mfoo2, ordering: .acquiringAndReleasing), _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)
  }
  func test_exchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(nil, ordering: .sequentiallyConsistent), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    XCTAssertEqual(v.exchange(_mfoo2, ordering: .sequentiallyConsistent), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    XCTAssertEqual(v.exchange(_mfoo2, ordering: .sequentiallyConsistent), _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)
  }

  func test_compareExchange_relaxed() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiring() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_releasing() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }

  func test_compareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutablePointer<Foo>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mfoo2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mfoo2)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mfoo2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mfoo2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }





  public static var allTests = [
    ("test_create_destroy", test_create_destroy),
    ("test_load_relaxed", test_load_relaxed),
    ("test_load_acquiring", test_load_acquiring),
    ("test_load_sequentiallyConsistent", test_load_sequentiallyConsistent),
    ("test_store_relaxed", test_store_relaxed),
    ("test_store_releasing", test_store_releasing),
    ("test_store_sequentiallyConsistent", test_store_sequentiallyConsistent),
    ("test_exchange_relaxed", test_exchange_relaxed),
    ("test_exchange_acquiring", test_exchange_acquiring),
    ("test_exchange_releasing", test_exchange_releasing),
    ("test_exchange_acquiringAndReleasing", test_exchange_acquiringAndReleasing),
    ("test_exchange_sequentiallyConsistent", test_exchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed", test_compareExchange_relaxed),
    ("test_compareExchange_acquiring", test_compareExchange_acquiring),
    ("test_compareExchange_releasing", test_compareExchange_releasing),
    ("test_compareExchange_acquiringAndReleasing", test_compareExchange_acquiringAndReleasing),
    ("test_compareExchange_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed_relaxed", test_compareExchange_relaxed_relaxed),
    ("test_compareExchange_relaxed_acquiring", test_compareExchange_relaxed_acquiring),
    ("test_compareExchange_relaxed_sequentiallyConsistent", test_compareExchange_relaxed_sequentiallyConsistent),
    ("test_compareExchange_acquiring_relaxed", test_compareExchange_acquiring_relaxed),
    ("test_compareExchange_acquiring_acquiring", test_compareExchange_acquiring_acquiring),
    ("test_compareExchange_acquiring_sequentiallyConsistent", test_compareExchange_acquiring_sequentiallyConsistent),
    ("test_compareExchange_releasing_relaxed", test_compareExchange_releasing_relaxed),
    ("test_compareExchange_releasing_acquiring", test_compareExchange_releasing_acquiring),
    ("test_compareExchange_releasing_sequentiallyConsistent", test_compareExchange_releasing_sequentiallyConsistent),
    ("test_compareExchange_acquiringAndReleasing_relaxed", test_compareExchange_acquiringAndReleasing_relaxed),
    ("test_compareExchange_acquiringAndReleasing_acquiring", test_compareExchange_acquiringAndReleasing_acquiring),
    ("test_compareExchange_acquiringAndReleasing_sequentiallyConsistent", test_compareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_compareExchange_sequentiallyConsistent_relaxed", test_compareExchange_sequentiallyConsistent_relaxed),
    ("test_compareExchange_sequentiallyConsistent_acquiring", test_compareExchange_sequentiallyConsistent_acquiring),
    ("test_compareExchange_sequentiallyConsistent_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent_sequentiallyConsistent),
    ("test_weakCompareExchange_relaxed_relaxed", test_weakCompareExchange_relaxed_relaxed),
    ("test_weakCompareExchange_relaxed_acquiring", test_weakCompareExchange_relaxed_acquiring),
    ("test_weakCompareExchange_relaxed_sequentiallyConsistent", test_weakCompareExchange_relaxed_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiring_relaxed", test_weakCompareExchange_acquiring_relaxed),
    ("test_weakCompareExchange_acquiring_acquiring", test_weakCompareExchange_acquiring_acquiring),
    ("test_weakCompareExchange_acquiring_sequentiallyConsistent", test_weakCompareExchange_acquiring_sequentiallyConsistent),
    ("test_weakCompareExchange_releasing_relaxed", test_weakCompareExchange_releasing_relaxed),
    ("test_weakCompareExchange_releasing_acquiring", test_weakCompareExchange_releasing_acquiring),
    ("test_weakCompareExchange_releasing_sequentiallyConsistent", test_weakCompareExchange_releasing_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiringAndReleasing_relaxed", test_weakCompareExchange_acquiringAndReleasing_relaxed),
    ("test_weakCompareExchange_acquiringAndReleasing_acquiring", test_weakCompareExchange_acquiringAndReleasing_acquiring),
    ("test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent", test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_weakCompareExchange_sequentiallyConsistent_relaxed", test_weakCompareExchange_sequentiallyConsistent_relaxed),
    ("test_weakCompareExchange_sequentiallyConsistent_acquiring", test_weakCompareExchange_sequentiallyConsistent_acquiring),
    ("test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent", test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent),
  ]
}
#endif
#if true
/// Exercises all operations in a single-threaded context, verifying
/// they provide the expected results.
class BasicAtomicRawPointerTests: XCTestCase {
  private let _mraw1 = UnsafeMutableRawPointer.allocate(byteCount: 16, alignment: 1)
  private let _mraw2 = UnsafeMutableRawPointer.allocate(byteCount: 16, alignment: 1)

  private var _raw1: UnsafeRawPointer { UnsafeRawPointer(_mraw1) }
  private var _raw2: UnsafeRawPointer { UnsafeRawPointer(_mraw2) }

  deinit {
    _mraw1.deallocate()
    _mraw2.deallocate()
  }

  func test_create_destroy() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    let w = UnsafeAtomic<UnsafeRawPointer>.create(_raw2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), _raw2)
  }

  func test_load_relaxed() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    let w = UnsafeAtomic<UnsafeRawPointer>.create(_raw2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), _raw2)
  }
  func test_load_acquiring() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .acquiring), _raw1)

    let w = UnsafeAtomic<UnsafeRawPointer>.create(_raw2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .acquiring), _raw2)
  }
  func test_load_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .sequentiallyConsistent), _raw1)

    let w = UnsafeAtomic<UnsafeRawPointer>.create(_raw2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .sequentiallyConsistent), _raw2)
  }

  func test_store_relaxed() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }
    v.store(_raw2, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    let w = UnsafeAtomic<UnsafeRawPointer>.create(_raw2)
    defer { w.destroy() }
    w.store(_raw1, ordering: .relaxed)
    XCTAssertEqual(w.load(ordering: .relaxed), _raw1)
  }
  func test_store_releasing() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }
    v.store(_raw2, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    let w = UnsafeAtomic<UnsafeRawPointer>.create(_raw2)
    defer { w.destroy() }
    w.store(_raw1, ordering: .releasing)
    XCTAssertEqual(w.load(ordering: .relaxed), _raw1)
  }
  func test_store_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }
    v.store(_raw2, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    let w = UnsafeAtomic<UnsafeRawPointer>.create(_raw2)
    defer { w.destroy() }
    w.store(_raw1, ordering: .sequentiallyConsistent)
    XCTAssertEqual(w.load(ordering: .relaxed), _raw1)
  }

  func test_exchange_relaxed() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(_raw1, ordering: .relaxed), _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    XCTAssertEqual(v.exchange(_raw2, ordering: .relaxed), _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    XCTAssertEqual(v.exchange(_raw2, ordering: .relaxed), _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)
  }
  func test_exchange_acquiring() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(_raw1, ordering: .acquiring), _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    XCTAssertEqual(v.exchange(_raw2, ordering: .acquiring), _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    XCTAssertEqual(v.exchange(_raw2, ordering: .acquiring), _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)
  }
  func test_exchange_releasing() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(_raw1, ordering: .releasing), _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    XCTAssertEqual(v.exchange(_raw2, ordering: .releasing), _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    XCTAssertEqual(v.exchange(_raw2, ordering: .releasing), _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)
  }
  func test_exchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(_raw1, ordering: .acquiringAndReleasing), _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    XCTAssertEqual(v.exchange(_raw2, ordering: .acquiringAndReleasing), _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    XCTAssertEqual(v.exchange(_raw2, ordering: .acquiringAndReleasing), _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)
  }
  func test_exchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(_raw1, ordering: .sequentiallyConsistent), _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    XCTAssertEqual(v.exchange(_raw2, ordering: .sequentiallyConsistent), _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    XCTAssertEqual(v.exchange(_raw2, ordering: .sequentiallyConsistent), _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)
  }

  func test_compareExchange_relaxed() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)
  }
  func test_compareExchange_acquiring() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)
  }
  func test_compareExchange_releasing() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)
  }
  func test_compareExchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)
  }
  func test_compareExchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)
  }

  func test_compareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)
  }
  func test_compareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)
  }
  func test_compareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)
  }
  func test_compareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)
  }
  func test_compareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)
  }
  func test_compareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)
  }
  func test_compareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)
  }
  func test_compareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)
  }
  func test_compareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)
  }
  func test_compareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)
  }
  func test_compareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)
  }
  func test_compareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)
  }
  func test_compareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)
  }
  func test_compareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)
  }
  func test_compareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)
  }
  func test_weakCompareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)
  }
  func test_weakCompareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)
  }
  func test_weakCompareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)
  }
  func test_weakCompareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)
  }
  func test_weakCompareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)
  }
  func test_weakCompareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)
  }
  func test_weakCompareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)
  }
  func test_weakCompareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)
  }
  func test_weakCompareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)
  }
  func test_weakCompareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)
  }
  func test_weakCompareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)
  }
  func test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)
  }
  func test_weakCompareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)
  }
  func test_weakCompareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)
  }
  func test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeRawPointer>.create(_raw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw1,
      desired: _raw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: _raw1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw1)
  }





  public static var allTests = [
    ("test_create_destroy", test_create_destroy),
    ("test_load_relaxed", test_load_relaxed),
    ("test_load_acquiring", test_load_acquiring),
    ("test_load_sequentiallyConsistent", test_load_sequentiallyConsistent),
    ("test_store_relaxed", test_store_relaxed),
    ("test_store_releasing", test_store_releasing),
    ("test_store_sequentiallyConsistent", test_store_sequentiallyConsistent),
    ("test_exchange_relaxed", test_exchange_relaxed),
    ("test_exchange_acquiring", test_exchange_acquiring),
    ("test_exchange_releasing", test_exchange_releasing),
    ("test_exchange_acquiringAndReleasing", test_exchange_acquiringAndReleasing),
    ("test_exchange_sequentiallyConsistent", test_exchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed", test_compareExchange_relaxed),
    ("test_compareExchange_acquiring", test_compareExchange_acquiring),
    ("test_compareExchange_releasing", test_compareExchange_releasing),
    ("test_compareExchange_acquiringAndReleasing", test_compareExchange_acquiringAndReleasing),
    ("test_compareExchange_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed_relaxed", test_compareExchange_relaxed_relaxed),
    ("test_compareExchange_relaxed_acquiring", test_compareExchange_relaxed_acquiring),
    ("test_compareExchange_relaxed_sequentiallyConsistent", test_compareExchange_relaxed_sequentiallyConsistent),
    ("test_compareExchange_acquiring_relaxed", test_compareExchange_acquiring_relaxed),
    ("test_compareExchange_acquiring_acquiring", test_compareExchange_acquiring_acquiring),
    ("test_compareExchange_acquiring_sequentiallyConsistent", test_compareExchange_acquiring_sequentiallyConsistent),
    ("test_compareExchange_releasing_relaxed", test_compareExchange_releasing_relaxed),
    ("test_compareExchange_releasing_acquiring", test_compareExchange_releasing_acquiring),
    ("test_compareExchange_releasing_sequentiallyConsistent", test_compareExchange_releasing_sequentiallyConsistent),
    ("test_compareExchange_acquiringAndReleasing_relaxed", test_compareExchange_acquiringAndReleasing_relaxed),
    ("test_compareExchange_acquiringAndReleasing_acquiring", test_compareExchange_acquiringAndReleasing_acquiring),
    ("test_compareExchange_acquiringAndReleasing_sequentiallyConsistent", test_compareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_compareExchange_sequentiallyConsistent_relaxed", test_compareExchange_sequentiallyConsistent_relaxed),
    ("test_compareExchange_sequentiallyConsistent_acquiring", test_compareExchange_sequentiallyConsistent_acquiring),
    ("test_compareExchange_sequentiallyConsistent_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent_sequentiallyConsistent),
    ("test_weakCompareExchange_relaxed_relaxed", test_weakCompareExchange_relaxed_relaxed),
    ("test_weakCompareExchange_relaxed_acquiring", test_weakCompareExchange_relaxed_acquiring),
    ("test_weakCompareExchange_relaxed_sequentiallyConsistent", test_weakCompareExchange_relaxed_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiring_relaxed", test_weakCompareExchange_acquiring_relaxed),
    ("test_weakCompareExchange_acquiring_acquiring", test_weakCompareExchange_acquiring_acquiring),
    ("test_weakCompareExchange_acquiring_sequentiallyConsistent", test_weakCompareExchange_acquiring_sequentiallyConsistent),
    ("test_weakCompareExchange_releasing_relaxed", test_weakCompareExchange_releasing_relaxed),
    ("test_weakCompareExchange_releasing_acquiring", test_weakCompareExchange_releasing_acquiring),
    ("test_weakCompareExchange_releasing_sequentiallyConsistent", test_weakCompareExchange_releasing_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiringAndReleasing_relaxed", test_weakCompareExchange_acquiringAndReleasing_relaxed),
    ("test_weakCompareExchange_acquiringAndReleasing_acquiring", test_weakCompareExchange_acquiringAndReleasing_acquiring),
    ("test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent", test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_weakCompareExchange_sequentiallyConsistent_relaxed", test_weakCompareExchange_sequentiallyConsistent_relaxed),
    ("test_weakCompareExchange_sequentiallyConsistent_acquiring", test_weakCompareExchange_sequentiallyConsistent_acquiring),
    ("test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent", test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent),
  ]
}
#endif
#if true
/// Exercises all operations in a single-threaded context, verifying
/// they provide the expected results.
class BasicAtomicOptionalRawPointerTests: XCTestCase {
  private let _mraw1 = UnsafeMutableRawPointer.allocate(byteCount: 16, alignment: 1)
  private let _mraw2 = UnsafeMutableRawPointer.allocate(byteCount: 16, alignment: 1)

  private var _raw1: UnsafeRawPointer { UnsafeRawPointer(_mraw1) }
  private var _raw2: UnsafeRawPointer { UnsafeRawPointer(_mraw2) }

  deinit {
    _mraw1.deallocate()
    _mraw2.deallocate()
  }

  func test_create_destroy() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    let w = UnsafeAtomic<UnsafeRawPointer?>.create(_raw2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), _raw2)
  }

  func test_load_relaxed() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    let w = UnsafeAtomic<UnsafeRawPointer?>.create(_raw2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), _raw2)
  }
  func test_load_acquiring() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .acquiring), nil)

    let w = UnsafeAtomic<UnsafeRawPointer?>.create(_raw2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .acquiring), _raw2)
  }
  func test_load_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .sequentiallyConsistent), nil)

    let w = UnsafeAtomic<UnsafeRawPointer?>.create(_raw2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .sequentiallyConsistent), _raw2)
  }

  func test_store_relaxed() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }
    v.store(_raw2, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    let w = UnsafeAtomic<UnsafeRawPointer?>.create(_raw2)
    defer { w.destroy() }
    w.store(nil, ordering: .relaxed)
    XCTAssertEqual(w.load(ordering: .relaxed), nil)
  }
  func test_store_releasing() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }
    v.store(_raw2, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    let w = UnsafeAtomic<UnsafeRawPointer?>.create(_raw2)
    defer { w.destroy() }
    w.store(nil, ordering: .releasing)
    XCTAssertEqual(w.load(ordering: .relaxed), nil)
  }
  func test_store_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }
    v.store(_raw2, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    let w = UnsafeAtomic<UnsafeRawPointer?>.create(_raw2)
    defer { w.destroy() }
    w.store(nil, ordering: .sequentiallyConsistent)
    XCTAssertEqual(w.load(ordering: .relaxed), nil)
  }

  func test_exchange_relaxed() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(nil, ordering: .relaxed), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    XCTAssertEqual(v.exchange(_raw2, ordering: .relaxed), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    XCTAssertEqual(v.exchange(_raw2, ordering: .relaxed), _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)
  }
  func test_exchange_acquiring() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(nil, ordering: .acquiring), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    XCTAssertEqual(v.exchange(_raw2, ordering: .acquiring), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    XCTAssertEqual(v.exchange(_raw2, ordering: .acquiring), _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)
  }
  func test_exchange_releasing() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(nil, ordering: .releasing), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    XCTAssertEqual(v.exchange(_raw2, ordering: .releasing), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    XCTAssertEqual(v.exchange(_raw2, ordering: .releasing), _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)
  }
  func test_exchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(nil, ordering: .acquiringAndReleasing), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    XCTAssertEqual(v.exchange(_raw2, ordering: .acquiringAndReleasing), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    XCTAssertEqual(v.exchange(_raw2, ordering: .acquiringAndReleasing), _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)
  }
  func test_exchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(nil, ordering: .sequentiallyConsistent), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    XCTAssertEqual(v.exchange(_raw2, ordering: .sequentiallyConsistent), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    XCTAssertEqual(v.exchange(_raw2, ordering: .sequentiallyConsistent), _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)
  }

  func test_compareExchange_relaxed() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiring() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_releasing() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }

  func test_compareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _raw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _raw2)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _raw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _raw2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }





  public static var allTests = [
    ("test_create_destroy", test_create_destroy),
    ("test_load_relaxed", test_load_relaxed),
    ("test_load_acquiring", test_load_acquiring),
    ("test_load_sequentiallyConsistent", test_load_sequentiallyConsistent),
    ("test_store_relaxed", test_store_relaxed),
    ("test_store_releasing", test_store_releasing),
    ("test_store_sequentiallyConsistent", test_store_sequentiallyConsistent),
    ("test_exchange_relaxed", test_exchange_relaxed),
    ("test_exchange_acquiring", test_exchange_acquiring),
    ("test_exchange_releasing", test_exchange_releasing),
    ("test_exchange_acquiringAndReleasing", test_exchange_acquiringAndReleasing),
    ("test_exchange_sequentiallyConsistent", test_exchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed", test_compareExchange_relaxed),
    ("test_compareExchange_acquiring", test_compareExchange_acquiring),
    ("test_compareExchange_releasing", test_compareExchange_releasing),
    ("test_compareExchange_acquiringAndReleasing", test_compareExchange_acquiringAndReleasing),
    ("test_compareExchange_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed_relaxed", test_compareExchange_relaxed_relaxed),
    ("test_compareExchange_relaxed_acquiring", test_compareExchange_relaxed_acquiring),
    ("test_compareExchange_relaxed_sequentiallyConsistent", test_compareExchange_relaxed_sequentiallyConsistent),
    ("test_compareExchange_acquiring_relaxed", test_compareExchange_acquiring_relaxed),
    ("test_compareExchange_acquiring_acquiring", test_compareExchange_acquiring_acquiring),
    ("test_compareExchange_acquiring_sequentiallyConsistent", test_compareExchange_acquiring_sequentiallyConsistent),
    ("test_compareExchange_releasing_relaxed", test_compareExchange_releasing_relaxed),
    ("test_compareExchange_releasing_acquiring", test_compareExchange_releasing_acquiring),
    ("test_compareExchange_releasing_sequentiallyConsistent", test_compareExchange_releasing_sequentiallyConsistent),
    ("test_compareExchange_acquiringAndReleasing_relaxed", test_compareExchange_acquiringAndReleasing_relaxed),
    ("test_compareExchange_acquiringAndReleasing_acquiring", test_compareExchange_acquiringAndReleasing_acquiring),
    ("test_compareExchange_acquiringAndReleasing_sequentiallyConsistent", test_compareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_compareExchange_sequentiallyConsistent_relaxed", test_compareExchange_sequentiallyConsistent_relaxed),
    ("test_compareExchange_sequentiallyConsistent_acquiring", test_compareExchange_sequentiallyConsistent_acquiring),
    ("test_compareExchange_sequentiallyConsistent_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent_sequentiallyConsistent),
    ("test_weakCompareExchange_relaxed_relaxed", test_weakCompareExchange_relaxed_relaxed),
    ("test_weakCompareExchange_relaxed_acquiring", test_weakCompareExchange_relaxed_acquiring),
    ("test_weakCompareExchange_relaxed_sequentiallyConsistent", test_weakCompareExchange_relaxed_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiring_relaxed", test_weakCompareExchange_acquiring_relaxed),
    ("test_weakCompareExchange_acquiring_acquiring", test_weakCompareExchange_acquiring_acquiring),
    ("test_weakCompareExchange_acquiring_sequentiallyConsistent", test_weakCompareExchange_acquiring_sequentiallyConsistent),
    ("test_weakCompareExchange_releasing_relaxed", test_weakCompareExchange_releasing_relaxed),
    ("test_weakCompareExchange_releasing_acquiring", test_weakCompareExchange_releasing_acquiring),
    ("test_weakCompareExchange_releasing_sequentiallyConsistent", test_weakCompareExchange_releasing_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiringAndReleasing_relaxed", test_weakCompareExchange_acquiringAndReleasing_relaxed),
    ("test_weakCompareExchange_acquiringAndReleasing_acquiring", test_weakCompareExchange_acquiringAndReleasing_acquiring),
    ("test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent", test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_weakCompareExchange_sequentiallyConsistent_relaxed", test_weakCompareExchange_sequentiallyConsistent_relaxed),
    ("test_weakCompareExchange_sequentiallyConsistent_acquiring", test_weakCompareExchange_sequentiallyConsistent_acquiring),
    ("test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent", test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent),
  ]
}
#endif
#if true
/// Exercises all operations in a single-threaded context, verifying
/// they provide the expected results.
class BasicAtomicMutableRawPointerTests: XCTestCase {
  private let _mraw1 = UnsafeMutableRawPointer.allocate(byteCount: 16, alignment: 1)
  private let _mraw2 = UnsafeMutableRawPointer.allocate(byteCount: 16, alignment: 1)

  private var _raw1: UnsafeRawPointer { UnsafeRawPointer(_mraw1) }
  private var _raw2: UnsafeRawPointer { UnsafeRawPointer(_mraw2) }

  deinit {
    _mraw1.deallocate()
    _mraw2.deallocate()
  }

  func test_create_destroy() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    let w = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), _mraw2)
  }

  func test_load_relaxed() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    let w = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), _mraw2)
  }
  func test_load_acquiring() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .acquiring), _mraw1)

    let w = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .acquiring), _mraw2)
  }
  func test_load_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .sequentiallyConsistent), _mraw1)

    let w = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .sequentiallyConsistent), _mraw2)
  }

  func test_store_relaxed() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }
    v.store(_mraw2, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    let w = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw2)
    defer { w.destroy() }
    w.store(_mraw1, ordering: .relaxed)
    XCTAssertEqual(w.load(ordering: .relaxed), _mraw1)
  }
  func test_store_releasing() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }
    v.store(_mraw2, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    let w = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw2)
    defer { w.destroy() }
    w.store(_mraw1, ordering: .releasing)
    XCTAssertEqual(w.load(ordering: .relaxed), _mraw1)
  }
  func test_store_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }
    v.store(_mraw2, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    let w = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw2)
    defer { w.destroy() }
    w.store(_mraw1, ordering: .sequentiallyConsistent)
    XCTAssertEqual(w.load(ordering: .relaxed), _mraw1)
  }

  func test_exchange_relaxed() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(_mraw1, ordering: .relaxed), _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    XCTAssertEqual(v.exchange(_mraw2, ordering: .relaxed), _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    XCTAssertEqual(v.exchange(_mraw2, ordering: .relaxed), _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)
  }
  func test_exchange_acquiring() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(_mraw1, ordering: .acquiring), _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    XCTAssertEqual(v.exchange(_mraw2, ordering: .acquiring), _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    XCTAssertEqual(v.exchange(_mraw2, ordering: .acquiring), _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)
  }
  func test_exchange_releasing() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(_mraw1, ordering: .releasing), _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    XCTAssertEqual(v.exchange(_mraw2, ordering: .releasing), _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    XCTAssertEqual(v.exchange(_mraw2, ordering: .releasing), _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)
  }
  func test_exchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(_mraw1, ordering: .acquiringAndReleasing), _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    XCTAssertEqual(v.exchange(_mraw2, ordering: .acquiringAndReleasing), _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    XCTAssertEqual(v.exchange(_mraw2, ordering: .acquiringAndReleasing), _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)
  }
  func test_exchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(_mraw1, ordering: .sequentiallyConsistent), _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    XCTAssertEqual(v.exchange(_mraw2, ordering: .sequentiallyConsistent), _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    XCTAssertEqual(v.exchange(_mraw2, ordering: .sequentiallyConsistent), _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)
  }

  func test_compareExchange_relaxed() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)
  }
  func test_compareExchange_acquiring() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)
  }
  func test_compareExchange_releasing() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)
  }
  func test_compareExchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)
  }
  func test_compareExchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)
  }

  func test_compareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)
  }
  func test_compareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)
  }
  func test_compareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)
  }
  func test_compareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)
  }
  func test_compareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)
  }
  func test_compareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)
  }
  func test_compareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)
  }
  func test_compareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)
  }
  func test_compareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)
  }
  func test_compareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)
  }
  func test_compareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)
  }
  func test_compareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)
  }
  func test_compareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)
  }
  func test_compareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)
  }
  func test_compareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)
  }
  func test_weakCompareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)
  }
  func test_weakCompareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)
  }
  func test_weakCompareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)
  }
  func test_weakCompareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)
  }
  func test_weakCompareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)
  }
  func test_weakCompareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)
  }
  func test_weakCompareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)
  }
  func test_weakCompareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)
  }
  func test_weakCompareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)
  }
  func test_weakCompareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)
  }
  func test_weakCompareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)
  }
  func test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)
  }
  func test_weakCompareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)
  }
  func test_weakCompareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)
  }
  func test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer>.create(_mraw1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw1,
      desired: _mraw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: _mraw1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw1)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw1)
  }





  public static var allTests = [
    ("test_create_destroy", test_create_destroy),
    ("test_load_relaxed", test_load_relaxed),
    ("test_load_acquiring", test_load_acquiring),
    ("test_load_sequentiallyConsistent", test_load_sequentiallyConsistent),
    ("test_store_relaxed", test_store_relaxed),
    ("test_store_releasing", test_store_releasing),
    ("test_store_sequentiallyConsistent", test_store_sequentiallyConsistent),
    ("test_exchange_relaxed", test_exchange_relaxed),
    ("test_exchange_acquiring", test_exchange_acquiring),
    ("test_exchange_releasing", test_exchange_releasing),
    ("test_exchange_acquiringAndReleasing", test_exchange_acquiringAndReleasing),
    ("test_exchange_sequentiallyConsistent", test_exchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed", test_compareExchange_relaxed),
    ("test_compareExchange_acquiring", test_compareExchange_acquiring),
    ("test_compareExchange_releasing", test_compareExchange_releasing),
    ("test_compareExchange_acquiringAndReleasing", test_compareExchange_acquiringAndReleasing),
    ("test_compareExchange_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed_relaxed", test_compareExchange_relaxed_relaxed),
    ("test_compareExchange_relaxed_acquiring", test_compareExchange_relaxed_acquiring),
    ("test_compareExchange_relaxed_sequentiallyConsistent", test_compareExchange_relaxed_sequentiallyConsistent),
    ("test_compareExchange_acquiring_relaxed", test_compareExchange_acquiring_relaxed),
    ("test_compareExchange_acquiring_acquiring", test_compareExchange_acquiring_acquiring),
    ("test_compareExchange_acquiring_sequentiallyConsistent", test_compareExchange_acquiring_sequentiallyConsistent),
    ("test_compareExchange_releasing_relaxed", test_compareExchange_releasing_relaxed),
    ("test_compareExchange_releasing_acquiring", test_compareExchange_releasing_acquiring),
    ("test_compareExchange_releasing_sequentiallyConsistent", test_compareExchange_releasing_sequentiallyConsistent),
    ("test_compareExchange_acquiringAndReleasing_relaxed", test_compareExchange_acquiringAndReleasing_relaxed),
    ("test_compareExchange_acquiringAndReleasing_acquiring", test_compareExchange_acquiringAndReleasing_acquiring),
    ("test_compareExchange_acquiringAndReleasing_sequentiallyConsistent", test_compareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_compareExchange_sequentiallyConsistent_relaxed", test_compareExchange_sequentiallyConsistent_relaxed),
    ("test_compareExchange_sequentiallyConsistent_acquiring", test_compareExchange_sequentiallyConsistent_acquiring),
    ("test_compareExchange_sequentiallyConsistent_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent_sequentiallyConsistent),
    ("test_weakCompareExchange_relaxed_relaxed", test_weakCompareExchange_relaxed_relaxed),
    ("test_weakCompareExchange_relaxed_acquiring", test_weakCompareExchange_relaxed_acquiring),
    ("test_weakCompareExchange_relaxed_sequentiallyConsistent", test_weakCompareExchange_relaxed_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiring_relaxed", test_weakCompareExchange_acquiring_relaxed),
    ("test_weakCompareExchange_acquiring_acquiring", test_weakCompareExchange_acquiring_acquiring),
    ("test_weakCompareExchange_acquiring_sequentiallyConsistent", test_weakCompareExchange_acquiring_sequentiallyConsistent),
    ("test_weakCompareExchange_releasing_relaxed", test_weakCompareExchange_releasing_relaxed),
    ("test_weakCompareExchange_releasing_acquiring", test_weakCompareExchange_releasing_acquiring),
    ("test_weakCompareExchange_releasing_sequentiallyConsistent", test_weakCompareExchange_releasing_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiringAndReleasing_relaxed", test_weakCompareExchange_acquiringAndReleasing_relaxed),
    ("test_weakCompareExchange_acquiringAndReleasing_acquiring", test_weakCompareExchange_acquiringAndReleasing_acquiring),
    ("test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent", test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_weakCompareExchange_sequentiallyConsistent_relaxed", test_weakCompareExchange_sequentiallyConsistent_relaxed),
    ("test_weakCompareExchange_sequentiallyConsistent_acquiring", test_weakCompareExchange_sequentiallyConsistent_acquiring),
    ("test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent", test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent),
  ]
}
#endif
#if true
/// Exercises all operations in a single-threaded context, verifying
/// they provide the expected results.
class BasicAtomicOptionalMutableRawPointerTests: XCTestCase {
  private let _mraw1 = UnsafeMutableRawPointer.allocate(byteCount: 16, alignment: 1)
  private let _mraw2 = UnsafeMutableRawPointer.allocate(byteCount: 16, alignment: 1)

  private var _raw1: UnsafeRawPointer { UnsafeRawPointer(_mraw1) }
  private var _raw2: UnsafeRawPointer { UnsafeRawPointer(_mraw2) }

  deinit {
    _mraw1.deallocate()
    _mraw2.deallocate()
  }

  func test_create_destroy() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    let w = UnsafeAtomic<UnsafeMutableRawPointer?>.create(_mraw2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), _mraw2)
  }

  func test_load_relaxed() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    let w = UnsafeAtomic<UnsafeMutableRawPointer?>.create(_mraw2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), _mraw2)
  }
  func test_load_acquiring() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .acquiring), nil)

    let w = UnsafeAtomic<UnsafeMutableRawPointer?>.create(_mraw2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .acquiring), _mraw2)
  }
  func test_load_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .sequentiallyConsistent), nil)

    let w = UnsafeAtomic<UnsafeMutableRawPointer?>.create(_mraw2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .sequentiallyConsistent), _mraw2)
  }

  func test_store_relaxed() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }
    v.store(_mraw2, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    let w = UnsafeAtomic<UnsafeMutableRawPointer?>.create(_mraw2)
    defer { w.destroy() }
    w.store(nil, ordering: .relaxed)
    XCTAssertEqual(w.load(ordering: .relaxed), nil)
  }
  func test_store_releasing() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }
    v.store(_mraw2, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    let w = UnsafeAtomic<UnsafeMutableRawPointer?>.create(_mraw2)
    defer { w.destroy() }
    w.store(nil, ordering: .releasing)
    XCTAssertEqual(w.load(ordering: .relaxed), nil)
  }
  func test_store_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }
    v.store(_mraw2, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    let w = UnsafeAtomic<UnsafeMutableRawPointer?>.create(_mraw2)
    defer { w.destroy() }
    w.store(nil, ordering: .sequentiallyConsistent)
    XCTAssertEqual(w.load(ordering: .relaxed), nil)
  }

  func test_exchange_relaxed() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(nil, ordering: .relaxed), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    XCTAssertEqual(v.exchange(_mraw2, ordering: .relaxed), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    XCTAssertEqual(v.exchange(_mraw2, ordering: .relaxed), _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)
  }
  func test_exchange_acquiring() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(nil, ordering: .acquiring), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    XCTAssertEqual(v.exchange(_mraw2, ordering: .acquiring), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    XCTAssertEqual(v.exchange(_mraw2, ordering: .acquiring), _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)
  }
  func test_exchange_releasing() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(nil, ordering: .releasing), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    XCTAssertEqual(v.exchange(_mraw2, ordering: .releasing), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    XCTAssertEqual(v.exchange(_mraw2, ordering: .releasing), _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)
  }
  func test_exchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(nil, ordering: .acquiringAndReleasing), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    XCTAssertEqual(v.exchange(_mraw2, ordering: .acquiringAndReleasing), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    XCTAssertEqual(v.exchange(_mraw2, ordering: .acquiringAndReleasing), _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)
  }
  func test_exchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(nil, ordering: .sequentiallyConsistent), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    XCTAssertEqual(v.exchange(_mraw2, ordering: .sequentiallyConsistent), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    XCTAssertEqual(v.exchange(_mraw2, ordering: .sequentiallyConsistent), _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)
  }

  func test_compareExchange_relaxed() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiring() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_releasing() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }

  func test_compareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<UnsafeMutableRawPointer?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _mraw2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), _mraw2)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _mraw2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _mraw2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }





  public static var allTests = [
    ("test_create_destroy", test_create_destroy),
    ("test_load_relaxed", test_load_relaxed),
    ("test_load_acquiring", test_load_acquiring),
    ("test_load_sequentiallyConsistent", test_load_sequentiallyConsistent),
    ("test_store_relaxed", test_store_relaxed),
    ("test_store_releasing", test_store_releasing),
    ("test_store_sequentiallyConsistent", test_store_sequentiallyConsistent),
    ("test_exchange_relaxed", test_exchange_relaxed),
    ("test_exchange_acquiring", test_exchange_acquiring),
    ("test_exchange_releasing", test_exchange_releasing),
    ("test_exchange_acquiringAndReleasing", test_exchange_acquiringAndReleasing),
    ("test_exchange_sequentiallyConsistent", test_exchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed", test_compareExchange_relaxed),
    ("test_compareExchange_acquiring", test_compareExchange_acquiring),
    ("test_compareExchange_releasing", test_compareExchange_releasing),
    ("test_compareExchange_acquiringAndReleasing", test_compareExchange_acquiringAndReleasing),
    ("test_compareExchange_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed_relaxed", test_compareExchange_relaxed_relaxed),
    ("test_compareExchange_relaxed_acquiring", test_compareExchange_relaxed_acquiring),
    ("test_compareExchange_relaxed_sequentiallyConsistent", test_compareExchange_relaxed_sequentiallyConsistent),
    ("test_compareExchange_acquiring_relaxed", test_compareExchange_acquiring_relaxed),
    ("test_compareExchange_acquiring_acquiring", test_compareExchange_acquiring_acquiring),
    ("test_compareExchange_acquiring_sequentiallyConsistent", test_compareExchange_acquiring_sequentiallyConsistent),
    ("test_compareExchange_releasing_relaxed", test_compareExchange_releasing_relaxed),
    ("test_compareExchange_releasing_acquiring", test_compareExchange_releasing_acquiring),
    ("test_compareExchange_releasing_sequentiallyConsistent", test_compareExchange_releasing_sequentiallyConsistent),
    ("test_compareExchange_acquiringAndReleasing_relaxed", test_compareExchange_acquiringAndReleasing_relaxed),
    ("test_compareExchange_acquiringAndReleasing_acquiring", test_compareExchange_acquiringAndReleasing_acquiring),
    ("test_compareExchange_acquiringAndReleasing_sequentiallyConsistent", test_compareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_compareExchange_sequentiallyConsistent_relaxed", test_compareExchange_sequentiallyConsistent_relaxed),
    ("test_compareExchange_sequentiallyConsistent_acquiring", test_compareExchange_sequentiallyConsistent_acquiring),
    ("test_compareExchange_sequentiallyConsistent_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent_sequentiallyConsistent),
    ("test_weakCompareExchange_relaxed_relaxed", test_weakCompareExchange_relaxed_relaxed),
    ("test_weakCompareExchange_relaxed_acquiring", test_weakCompareExchange_relaxed_acquiring),
    ("test_weakCompareExchange_relaxed_sequentiallyConsistent", test_weakCompareExchange_relaxed_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiring_relaxed", test_weakCompareExchange_acquiring_relaxed),
    ("test_weakCompareExchange_acquiring_acquiring", test_weakCompareExchange_acquiring_acquiring),
    ("test_weakCompareExchange_acquiring_sequentiallyConsistent", test_weakCompareExchange_acquiring_sequentiallyConsistent),
    ("test_weakCompareExchange_releasing_relaxed", test_weakCompareExchange_releasing_relaxed),
    ("test_weakCompareExchange_releasing_acquiring", test_weakCompareExchange_releasing_acquiring),
    ("test_weakCompareExchange_releasing_sequentiallyConsistent", test_weakCompareExchange_releasing_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiringAndReleasing_relaxed", test_weakCompareExchange_acquiringAndReleasing_relaxed),
    ("test_weakCompareExchange_acquiringAndReleasing_acquiring", test_weakCompareExchange_acquiringAndReleasing_acquiring),
    ("test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent", test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_weakCompareExchange_sequentiallyConsistent_relaxed", test_weakCompareExchange_sequentiallyConsistent_relaxed),
    ("test_weakCompareExchange_sequentiallyConsistent_acquiring", test_weakCompareExchange_sequentiallyConsistent_acquiring),
    ("test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent", test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent),
  ]
}
#endif
#if true
/// Exercises all operations in a single-threaded context, verifying
/// they provide the expected results.
class BasicAtomicUnmanagedTests: XCTestCase {
  private let _bar1 = Unmanaged<Bar>.passRetained(Bar(1))
  private let _bar2 = Unmanaged<Bar>.passRetained(Bar(2))

  deinit {
    _bar1.release()
    _bar2.release()
  }

  func test_create_destroy() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    let w = UnsafeAtomic<Unmanaged<Bar>>.create(_bar2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), _bar2)
  }

  func test_load_relaxed() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    let w = UnsafeAtomic<Unmanaged<Bar>>.create(_bar2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), _bar2)
  }
  func test_load_acquiring() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .acquiring), _bar1)

    let w = UnsafeAtomic<Unmanaged<Bar>>.create(_bar2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .acquiring), _bar2)
  }
  func test_load_sequentiallyConsistent() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .sequentiallyConsistent), _bar1)

    let w = UnsafeAtomic<Unmanaged<Bar>>.create(_bar2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .sequentiallyConsistent), _bar2)
  }

  func test_store_relaxed() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }
    v.store(_bar2, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    let w = UnsafeAtomic<Unmanaged<Bar>>.create(_bar2)
    defer { w.destroy() }
    w.store(_bar1, ordering: .relaxed)
    XCTAssertEqual(w.load(ordering: .relaxed), _bar1)
  }
  func test_store_releasing() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }
    v.store(_bar2, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    let w = UnsafeAtomic<Unmanaged<Bar>>.create(_bar2)
    defer { w.destroy() }
    w.store(_bar1, ordering: .releasing)
    XCTAssertEqual(w.load(ordering: .relaxed), _bar1)
  }
  func test_store_sequentiallyConsistent() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }
    v.store(_bar2, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    let w = UnsafeAtomic<Unmanaged<Bar>>.create(_bar2)
    defer { w.destroy() }
    w.store(_bar1, ordering: .sequentiallyConsistent)
    XCTAssertEqual(w.load(ordering: .relaxed), _bar1)
  }

  func test_exchange_relaxed() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(_bar1, ordering: .relaxed), _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    XCTAssertEqual(v.exchange(_bar2, ordering: .relaxed), _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    XCTAssertEqual(v.exchange(_bar2, ordering: .relaxed), _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)
  }
  func test_exchange_acquiring() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(_bar1, ordering: .acquiring), _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    XCTAssertEqual(v.exchange(_bar2, ordering: .acquiring), _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    XCTAssertEqual(v.exchange(_bar2, ordering: .acquiring), _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)
  }
  func test_exchange_releasing() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(_bar1, ordering: .releasing), _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    XCTAssertEqual(v.exchange(_bar2, ordering: .releasing), _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    XCTAssertEqual(v.exchange(_bar2, ordering: .releasing), _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)
  }
  func test_exchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(_bar1, ordering: .acquiringAndReleasing), _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    XCTAssertEqual(v.exchange(_bar2, ordering: .acquiringAndReleasing), _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    XCTAssertEqual(v.exchange(_bar2, ordering: .acquiringAndReleasing), _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)
  }
  func test_exchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(_bar1, ordering: .sequentiallyConsistent), _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    XCTAssertEqual(v.exchange(_bar2, ordering: .sequentiallyConsistent), _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    XCTAssertEqual(v.exchange(_bar2, ordering: .sequentiallyConsistent), _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)
  }

  func test_compareExchange_relaxed() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)
  }
  func test_compareExchange_acquiring() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)
  }
  func test_compareExchange_releasing() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)
  }
  func test_compareExchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)
  }
  func test_compareExchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)
  }

  func test_compareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)
  }
  func test_compareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)
  }
  func test_compareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)
  }
  func test_compareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)
  }
  func test_compareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)
  }
  func test_compareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)
  }
  func test_compareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)
  }
  func test_compareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)
  }
  func test_compareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)
  }
  func test_compareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)
  }
  func test_compareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)
  }
  func test_compareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)
  }
  func test_compareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)
  }
  func test_compareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)
  }
  func test_compareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)
  }
  func test_weakCompareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)
  }
  func test_weakCompareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)
  }
  func test_weakCompareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)
  }
  func test_weakCompareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)
  }
  func test_weakCompareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)
  }
  func test_weakCompareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)
  }
  func test_weakCompareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)
  }
  func test_weakCompareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)
  }
  func test_weakCompareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)
  }
  func test_weakCompareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)
  }
  func test_weakCompareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)
  }
  func test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)
  }
  func test_weakCompareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)
  }
  func test_weakCompareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)
  }
  func test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<Unmanaged<Bar>>.create(_bar1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar1,
      desired: _bar2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: _bar1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar1)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar1)
  }





  public static var allTests = [
    ("test_create_destroy", test_create_destroy),
    ("test_load_relaxed", test_load_relaxed),
    ("test_load_acquiring", test_load_acquiring),
    ("test_load_sequentiallyConsistent", test_load_sequentiallyConsistent),
    ("test_store_relaxed", test_store_relaxed),
    ("test_store_releasing", test_store_releasing),
    ("test_store_sequentiallyConsistent", test_store_sequentiallyConsistent),
    ("test_exchange_relaxed", test_exchange_relaxed),
    ("test_exchange_acquiring", test_exchange_acquiring),
    ("test_exchange_releasing", test_exchange_releasing),
    ("test_exchange_acquiringAndReleasing", test_exchange_acquiringAndReleasing),
    ("test_exchange_sequentiallyConsistent", test_exchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed", test_compareExchange_relaxed),
    ("test_compareExchange_acquiring", test_compareExchange_acquiring),
    ("test_compareExchange_releasing", test_compareExchange_releasing),
    ("test_compareExchange_acquiringAndReleasing", test_compareExchange_acquiringAndReleasing),
    ("test_compareExchange_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed_relaxed", test_compareExchange_relaxed_relaxed),
    ("test_compareExchange_relaxed_acquiring", test_compareExchange_relaxed_acquiring),
    ("test_compareExchange_relaxed_sequentiallyConsistent", test_compareExchange_relaxed_sequentiallyConsistent),
    ("test_compareExchange_acquiring_relaxed", test_compareExchange_acquiring_relaxed),
    ("test_compareExchange_acquiring_acquiring", test_compareExchange_acquiring_acquiring),
    ("test_compareExchange_acquiring_sequentiallyConsistent", test_compareExchange_acquiring_sequentiallyConsistent),
    ("test_compareExchange_releasing_relaxed", test_compareExchange_releasing_relaxed),
    ("test_compareExchange_releasing_acquiring", test_compareExchange_releasing_acquiring),
    ("test_compareExchange_releasing_sequentiallyConsistent", test_compareExchange_releasing_sequentiallyConsistent),
    ("test_compareExchange_acquiringAndReleasing_relaxed", test_compareExchange_acquiringAndReleasing_relaxed),
    ("test_compareExchange_acquiringAndReleasing_acquiring", test_compareExchange_acquiringAndReleasing_acquiring),
    ("test_compareExchange_acquiringAndReleasing_sequentiallyConsistent", test_compareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_compareExchange_sequentiallyConsistent_relaxed", test_compareExchange_sequentiallyConsistent_relaxed),
    ("test_compareExchange_sequentiallyConsistent_acquiring", test_compareExchange_sequentiallyConsistent_acquiring),
    ("test_compareExchange_sequentiallyConsistent_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent_sequentiallyConsistent),
    ("test_weakCompareExchange_relaxed_relaxed", test_weakCompareExchange_relaxed_relaxed),
    ("test_weakCompareExchange_relaxed_acquiring", test_weakCompareExchange_relaxed_acquiring),
    ("test_weakCompareExchange_relaxed_sequentiallyConsistent", test_weakCompareExchange_relaxed_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiring_relaxed", test_weakCompareExchange_acquiring_relaxed),
    ("test_weakCompareExchange_acquiring_acquiring", test_weakCompareExchange_acquiring_acquiring),
    ("test_weakCompareExchange_acquiring_sequentiallyConsistent", test_weakCompareExchange_acquiring_sequentiallyConsistent),
    ("test_weakCompareExchange_releasing_relaxed", test_weakCompareExchange_releasing_relaxed),
    ("test_weakCompareExchange_releasing_acquiring", test_weakCompareExchange_releasing_acquiring),
    ("test_weakCompareExchange_releasing_sequentiallyConsistent", test_weakCompareExchange_releasing_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiringAndReleasing_relaxed", test_weakCompareExchange_acquiringAndReleasing_relaxed),
    ("test_weakCompareExchange_acquiringAndReleasing_acquiring", test_weakCompareExchange_acquiringAndReleasing_acquiring),
    ("test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent", test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_weakCompareExchange_sequentiallyConsistent_relaxed", test_weakCompareExchange_sequentiallyConsistent_relaxed),
    ("test_weakCompareExchange_sequentiallyConsistent_acquiring", test_weakCompareExchange_sequentiallyConsistent_acquiring),
    ("test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent", test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent),
  ]
}
#endif
#if true
/// Exercises all operations in a single-threaded context, verifying
/// they provide the expected results.
class BasicAtomicOptionalUnmanagedTests: XCTestCase {
  private let _bar1 = Unmanaged<Bar>.passRetained(Bar(1))
  private let _bar2 = Unmanaged<Bar>.passRetained(Bar(2))

  deinit {
    _bar1.release()
    _bar2.release()
  }

  func test_create_destroy() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    let w = UnsafeAtomic<Unmanaged<Bar>?>.create(_bar2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), _bar2)
  }

  func test_load_relaxed() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    let w = UnsafeAtomic<Unmanaged<Bar>?>.create(_bar2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), _bar2)
  }
  func test_load_acquiring() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .acquiring), nil)

    let w = UnsafeAtomic<Unmanaged<Bar>?>.create(_bar2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .acquiring), _bar2)
  }
  func test_load_sequentiallyConsistent() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .sequentiallyConsistent), nil)

    let w = UnsafeAtomic<Unmanaged<Bar>?>.create(_bar2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .sequentiallyConsistent), _bar2)
  }

  func test_store_relaxed() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }
    v.store(_bar2, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    let w = UnsafeAtomic<Unmanaged<Bar>?>.create(_bar2)
    defer { w.destroy() }
    w.store(nil, ordering: .relaxed)
    XCTAssertEqual(w.load(ordering: .relaxed), nil)
  }
  func test_store_releasing() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }
    v.store(_bar2, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    let w = UnsafeAtomic<Unmanaged<Bar>?>.create(_bar2)
    defer { w.destroy() }
    w.store(nil, ordering: .releasing)
    XCTAssertEqual(w.load(ordering: .relaxed), nil)
  }
  func test_store_sequentiallyConsistent() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }
    v.store(_bar2, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    let w = UnsafeAtomic<Unmanaged<Bar>?>.create(_bar2)
    defer { w.destroy() }
    w.store(nil, ordering: .sequentiallyConsistent)
    XCTAssertEqual(w.load(ordering: .relaxed), nil)
  }

  func test_exchange_relaxed() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(nil, ordering: .relaxed), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    XCTAssertEqual(v.exchange(_bar2, ordering: .relaxed), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    XCTAssertEqual(v.exchange(_bar2, ordering: .relaxed), _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)
  }
  func test_exchange_acquiring() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(nil, ordering: .acquiring), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    XCTAssertEqual(v.exchange(_bar2, ordering: .acquiring), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    XCTAssertEqual(v.exchange(_bar2, ordering: .acquiring), _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)
  }
  func test_exchange_releasing() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(nil, ordering: .releasing), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    XCTAssertEqual(v.exchange(_bar2, ordering: .releasing), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    XCTAssertEqual(v.exchange(_bar2, ordering: .releasing), _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)
  }
  func test_exchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(nil, ordering: .acquiringAndReleasing), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    XCTAssertEqual(v.exchange(_bar2, ordering: .acquiringAndReleasing), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    XCTAssertEqual(v.exchange(_bar2, ordering: .acquiringAndReleasing), _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)
  }
  func test_exchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(nil, ordering: .sequentiallyConsistent), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    XCTAssertEqual(v.exchange(_bar2, ordering: .sequentiallyConsistent), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    XCTAssertEqual(v.exchange(_bar2, ordering: .sequentiallyConsistent), _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)
  }

  func test_compareExchange_relaxed() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiring() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_releasing() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }

  func test_compareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<Unmanaged<Bar>?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _bar2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), _bar2)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _bar2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _bar2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }





  public static var allTests = [
    ("test_create_destroy", test_create_destroy),
    ("test_load_relaxed", test_load_relaxed),
    ("test_load_acquiring", test_load_acquiring),
    ("test_load_sequentiallyConsistent", test_load_sequentiallyConsistent),
    ("test_store_relaxed", test_store_relaxed),
    ("test_store_releasing", test_store_releasing),
    ("test_store_sequentiallyConsistent", test_store_sequentiallyConsistent),
    ("test_exchange_relaxed", test_exchange_relaxed),
    ("test_exchange_acquiring", test_exchange_acquiring),
    ("test_exchange_releasing", test_exchange_releasing),
    ("test_exchange_acquiringAndReleasing", test_exchange_acquiringAndReleasing),
    ("test_exchange_sequentiallyConsistent", test_exchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed", test_compareExchange_relaxed),
    ("test_compareExchange_acquiring", test_compareExchange_acquiring),
    ("test_compareExchange_releasing", test_compareExchange_releasing),
    ("test_compareExchange_acquiringAndReleasing", test_compareExchange_acquiringAndReleasing),
    ("test_compareExchange_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed_relaxed", test_compareExchange_relaxed_relaxed),
    ("test_compareExchange_relaxed_acquiring", test_compareExchange_relaxed_acquiring),
    ("test_compareExchange_relaxed_sequentiallyConsistent", test_compareExchange_relaxed_sequentiallyConsistent),
    ("test_compareExchange_acquiring_relaxed", test_compareExchange_acquiring_relaxed),
    ("test_compareExchange_acquiring_acquiring", test_compareExchange_acquiring_acquiring),
    ("test_compareExchange_acquiring_sequentiallyConsistent", test_compareExchange_acquiring_sequentiallyConsistent),
    ("test_compareExchange_releasing_relaxed", test_compareExchange_releasing_relaxed),
    ("test_compareExchange_releasing_acquiring", test_compareExchange_releasing_acquiring),
    ("test_compareExchange_releasing_sequentiallyConsistent", test_compareExchange_releasing_sequentiallyConsistent),
    ("test_compareExchange_acquiringAndReleasing_relaxed", test_compareExchange_acquiringAndReleasing_relaxed),
    ("test_compareExchange_acquiringAndReleasing_acquiring", test_compareExchange_acquiringAndReleasing_acquiring),
    ("test_compareExchange_acquiringAndReleasing_sequentiallyConsistent", test_compareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_compareExchange_sequentiallyConsistent_relaxed", test_compareExchange_sequentiallyConsistent_relaxed),
    ("test_compareExchange_sequentiallyConsistent_acquiring", test_compareExchange_sequentiallyConsistent_acquiring),
    ("test_compareExchange_sequentiallyConsistent_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent_sequentiallyConsistent),
    ("test_weakCompareExchange_relaxed_relaxed", test_weakCompareExchange_relaxed_relaxed),
    ("test_weakCompareExchange_relaxed_acquiring", test_weakCompareExchange_relaxed_acquiring),
    ("test_weakCompareExchange_relaxed_sequentiallyConsistent", test_weakCompareExchange_relaxed_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiring_relaxed", test_weakCompareExchange_acquiring_relaxed),
    ("test_weakCompareExchange_acquiring_acquiring", test_weakCompareExchange_acquiring_acquiring),
    ("test_weakCompareExchange_acquiring_sequentiallyConsistent", test_weakCompareExchange_acquiring_sequentiallyConsistent),
    ("test_weakCompareExchange_releasing_relaxed", test_weakCompareExchange_releasing_relaxed),
    ("test_weakCompareExchange_releasing_acquiring", test_weakCompareExchange_releasing_acquiring),
    ("test_weakCompareExchange_releasing_sequentiallyConsistent", test_weakCompareExchange_releasing_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiringAndReleasing_relaxed", test_weakCompareExchange_acquiringAndReleasing_relaxed),
    ("test_weakCompareExchange_acquiringAndReleasing_acquiring", test_weakCompareExchange_acquiringAndReleasing_acquiring),
    ("test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent", test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_weakCompareExchange_sequentiallyConsistent_relaxed", test_weakCompareExchange_sequentiallyConsistent_relaxed),
    ("test_weakCompareExchange_sequentiallyConsistent_acquiring", test_weakCompareExchange_sequentiallyConsistent_acquiring),
    ("test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent", test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent),
  ]
}
#endif
#if true
/// Exercises all operations in a single-threaded context, verifying
/// they provide the expected results.
class BasicAtomicRawRepresentableTests: XCTestCase {

  func test_create_destroy() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    let w = UnsafeAtomic<Fred>.create(Fred.two)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), Fred.two)
  }

  func test_load_relaxed() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    let w = UnsafeAtomic<Fred>.create(Fred.two)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), Fred.two)
  }
  func test_load_acquiring() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .acquiring), Fred.one)

    let w = UnsafeAtomic<Fred>.create(Fred.two)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .acquiring), Fred.two)
  }
  func test_load_sequentiallyConsistent() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .sequentiallyConsistent), Fred.one)

    let w = UnsafeAtomic<Fred>.create(Fred.two)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .sequentiallyConsistent), Fred.two)
  }

  func test_store_relaxed() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }
    v.store(Fred.two, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    let w = UnsafeAtomic<Fred>.create(Fred.two)
    defer { w.destroy() }
    w.store(Fred.one, ordering: .relaxed)
    XCTAssertEqual(w.load(ordering: .relaxed), Fred.one)
  }
  func test_store_releasing() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }
    v.store(Fred.two, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    let w = UnsafeAtomic<Fred>.create(Fred.two)
    defer { w.destroy() }
    w.store(Fred.one, ordering: .releasing)
    XCTAssertEqual(w.load(ordering: .relaxed), Fred.one)
  }
  func test_store_sequentiallyConsistent() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }
    v.store(Fred.two, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    let w = UnsafeAtomic<Fred>.create(Fred.two)
    defer { w.destroy() }
    w.store(Fred.one, ordering: .sequentiallyConsistent)
    XCTAssertEqual(w.load(ordering: .relaxed), Fred.one)
  }

  func test_exchange_relaxed() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(Fred.one, ordering: .relaxed), Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    XCTAssertEqual(v.exchange(Fred.two, ordering: .relaxed), Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    XCTAssertEqual(v.exchange(Fred.two, ordering: .relaxed), Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)
  }
  func test_exchange_acquiring() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(Fred.one, ordering: .acquiring), Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    XCTAssertEqual(v.exchange(Fred.two, ordering: .acquiring), Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    XCTAssertEqual(v.exchange(Fred.two, ordering: .acquiring), Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)
  }
  func test_exchange_releasing() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(Fred.one, ordering: .releasing), Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    XCTAssertEqual(v.exchange(Fred.two, ordering: .releasing), Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    XCTAssertEqual(v.exchange(Fred.two, ordering: .releasing), Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)
  }
  func test_exchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(Fred.one, ordering: .acquiringAndReleasing), Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    XCTAssertEqual(v.exchange(Fred.two, ordering: .acquiringAndReleasing), Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    XCTAssertEqual(v.exchange(Fred.two, ordering: .acquiringAndReleasing), Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)
  }
  func test_exchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(Fred.one, ordering: .sequentiallyConsistent), Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    XCTAssertEqual(v.exchange(Fred.two, ordering: .sequentiallyConsistent), Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    XCTAssertEqual(v.exchange(Fred.two, ordering: .sequentiallyConsistent), Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)
  }

  func test_compareExchange_relaxed() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)
  }
  func test_compareExchange_acquiring() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)
  }
  func test_compareExchange_releasing() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)
  }
  func test_compareExchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)
  }
  func test_compareExchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)
  }

  func test_compareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)
  }
  func test_compareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)
  }
  func test_compareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)
  }
  func test_compareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)
  }
  func test_compareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)
  }
  func test_compareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)
  }
  func test_compareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)
  }
  func test_compareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)
  }
  func test_compareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)
  }
  func test_compareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)
  }
  func test_compareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)
  }
  func test_compareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)
  }
  func test_compareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)
  }
  func test_compareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)
  }
  func test_compareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)
  }
  func test_weakCompareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)
  }
  func test_weakCompareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)
  }
  func test_weakCompareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)
  }
  func test_weakCompareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)
  }
  func test_weakCompareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)
  }
  func test_weakCompareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)
  }
  func test_weakCompareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)
  }
  func test_weakCompareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)
  }
  func test_weakCompareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)
  }
  func test_weakCompareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)
  }
  func test_weakCompareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)
  }
  func test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)
  }
  func test_weakCompareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)
  }
  func test_weakCompareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)
  }
  func test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<Fred>.create(Fred.one)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.one,
      desired: Fred.two,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.two)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, Fred.two)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)

    (exchanged, original) = v.compareExchange(
      expected: Fred.two,
      desired: Fred.one,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, Fred.one)
    XCTAssertEqual(v.load(ordering: .relaxed), Fred.one)
  }





  public static var allTests = [
    ("test_create_destroy", test_create_destroy),
    ("test_load_relaxed", test_load_relaxed),
    ("test_load_acquiring", test_load_acquiring),
    ("test_load_sequentiallyConsistent", test_load_sequentiallyConsistent),
    ("test_store_relaxed", test_store_relaxed),
    ("test_store_releasing", test_store_releasing),
    ("test_store_sequentiallyConsistent", test_store_sequentiallyConsistent),
    ("test_exchange_relaxed", test_exchange_relaxed),
    ("test_exchange_acquiring", test_exchange_acquiring),
    ("test_exchange_releasing", test_exchange_releasing),
    ("test_exchange_acquiringAndReleasing", test_exchange_acquiringAndReleasing),
    ("test_exchange_sequentiallyConsistent", test_exchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed", test_compareExchange_relaxed),
    ("test_compareExchange_acquiring", test_compareExchange_acquiring),
    ("test_compareExchange_releasing", test_compareExchange_releasing),
    ("test_compareExchange_acquiringAndReleasing", test_compareExchange_acquiringAndReleasing),
    ("test_compareExchange_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed_relaxed", test_compareExchange_relaxed_relaxed),
    ("test_compareExchange_relaxed_acquiring", test_compareExchange_relaxed_acquiring),
    ("test_compareExchange_relaxed_sequentiallyConsistent", test_compareExchange_relaxed_sequentiallyConsistent),
    ("test_compareExchange_acquiring_relaxed", test_compareExchange_acquiring_relaxed),
    ("test_compareExchange_acquiring_acquiring", test_compareExchange_acquiring_acquiring),
    ("test_compareExchange_acquiring_sequentiallyConsistent", test_compareExchange_acquiring_sequentiallyConsistent),
    ("test_compareExchange_releasing_relaxed", test_compareExchange_releasing_relaxed),
    ("test_compareExchange_releasing_acquiring", test_compareExchange_releasing_acquiring),
    ("test_compareExchange_releasing_sequentiallyConsistent", test_compareExchange_releasing_sequentiallyConsistent),
    ("test_compareExchange_acquiringAndReleasing_relaxed", test_compareExchange_acquiringAndReleasing_relaxed),
    ("test_compareExchange_acquiringAndReleasing_acquiring", test_compareExchange_acquiringAndReleasing_acquiring),
    ("test_compareExchange_acquiringAndReleasing_sequentiallyConsistent", test_compareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_compareExchange_sequentiallyConsistent_relaxed", test_compareExchange_sequentiallyConsistent_relaxed),
    ("test_compareExchange_sequentiallyConsistent_acquiring", test_compareExchange_sequentiallyConsistent_acquiring),
    ("test_compareExchange_sequentiallyConsistent_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent_sequentiallyConsistent),
    ("test_weakCompareExchange_relaxed_relaxed", test_weakCompareExchange_relaxed_relaxed),
    ("test_weakCompareExchange_relaxed_acquiring", test_weakCompareExchange_relaxed_acquiring),
    ("test_weakCompareExchange_relaxed_sequentiallyConsistent", test_weakCompareExchange_relaxed_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiring_relaxed", test_weakCompareExchange_acquiring_relaxed),
    ("test_weakCompareExchange_acquiring_acquiring", test_weakCompareExchange_acquiring_acquiring),
    ("test_weakCompareExchange_acquiring_sequentiallyConsistent", test_weakCompareExchange_acquiring_sequentiallyConsistent),
    ("test_weakCompareExchange_releasing_relaxed", test_weakCompareExchange_releasing_relaxed),
    ("test_weakCompareExchange_releasing_acquiring", test_weakCompareExchange_releasing_acquiring),
    ("test_weakCompareExchange_releasing_sequentiallyConsistent", test_weakCompareExchange_releasing_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiringAndReleasing_relaxed", test_weakCompareExchange_acquiringAndReleasing_relaxed),
    ("test_weakCompareExchange_acquiringAndReleasing_acquiring", test_weakCompareExchange_acquiringAndReleasing_acquiring),
    ("test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent", test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_weakCompareExchange_sequentiallyConsistent_relaxed", test_weakCompareExchange_sequentiallyConsistent_relaxed),
    ("test_weakCompareExchange_sequentiallyConsistent_acquiring", test_weakCompareExchange_sequentiallyConsistent_acquiring),
    ("test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent", test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent),
  ]
}
#endif
#if !(os(Linux) && arch(x86_64)) || ENABLE_DOUBLEWIDE_ATOMICS
/// Exercises all operations in a single-threaded context, verifying
/// they provide the expected results.
class BasicAtomicDoubleWordTests: XCTestCase {

  func test_create_destroy() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    let w = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 50, low: 32))
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))
  }

  func test_load_relaxed() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    let w = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 50, low: 32))
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))
  }
  func test_load_acquiring() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .acquiring), DoubleWord(high: 100, low: 64))

    let w = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 50, low: 32))
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .acquiring), DoubleWord(high: 50, low: 32))
  }
  func test_load_sequentiallyConsistent() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .sequentiallyConsistent), DoubleWord(high: 100, low: 64))

    let w = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 50, low: 32))
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .sequentiallyConsistent), DoubleWord(high: 50, low: 32))
  }

  func test_store_relaxed() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }
    v.store(DoubleWord(high: 50, low: 32), ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    let w = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 50, low: 32))
    defer { w.destroy() }
    w.store(DoubleWord(high: 100, low: 64), ordering: .relaxed)
    XCTAssertEqual(w.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))
  }
  func test_store_releasing() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }
    v.store(DoubleWord(high: 50, low: 32), ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    let w = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 50, low: 32))
    defer { w.destroy() }
    w.store(DoubleWord(high: 100, low: 64), ordering: .releasing)
    XCTAssertEqual(w.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))
  }
  func test_store_sequentiallyConsistent() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }
    v.store(DoubleWord(high: 50, low: 32), ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    let w = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 50, low: 32))
    defer { w.destroy() }
    w.store(DoubleWord(high: 100, low: 64), ordering: .sequentiallyConsistent)
    XCTAssertEqual(w.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))
  }

  func test_exchange_relaxed() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(DoubleWord(high: 100, low: 64), ordering: .relaxed), DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    XCTAssertEqual(v.exchange(DoubleWord(high: 50, low: 32), ordering: .relaxed), DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    XCTAssertEqual(v.exchange(DoubleWord(high: 50, low: 32), ordering: .relaxed), DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))
  }
  func test_exchange_acquiring() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(DoubleWord(high: 100, low: 64), ordering: .acquiring), DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    XCTAssertEqual(v.exchange(DoubleWord(high: 50, low: 32), ordering: .acquiring), DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    XCTAssertEqual(v.exchange(DoubleWord(high: 50, low: 32), ordering: .acquiring), DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))
  }
  func test_exchange_releasing() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(DoubleWord(high: 100, low: 64), ordering: .releasing), DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    XCTAssertEqual(v.exchange(DoubleWord(high: 50, low: 32), ordering: .releasing), DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    XCTAssertEqual(v.exchange(DoubleWord(high: 50, low: 32), ordering: .releasing), DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))
  }
  func test_exchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(DoubleWord(high: 100, low: 64), ordering: .acquiringAndReleasing), DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    XCTAssertEqual(v.exchange(DoubleWord(high: 50, low: 32), ordering: .acquiringAndReleasing), DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    XCTAssertEqual(v.exchange(DoubleWord(high: 50, low: 32), ordering: .acquiringAndReleasing), DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))
  }
  func test_exchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(DoubleWord(high: 100, low: 64), ordering: .sequentiallyConsistent), DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    XCTAssertEqual(v.exchange(DoubleWord(high: 50, low: 32), ordering: .sequentiallyConsistent), DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    XCTAssertEqual(v.exchange(DoubleWord(high: 50, low: 32), ordering: .sequentiallyConsistent), DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))
  }

  func test_compareExchange_relaxed() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))
  }
  func test_compareExchange_acquiring() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))
  }
  func test_compareExchange_releasing() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))
  }
  func test_compareExchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))
  }
  func test_compareExchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))
  }

  func test_compareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))
  }
  func test_compareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))
  }
  func test_compareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))
  }
  func test_compareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))
  }
  func test_compareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))
  }
  func test_compareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))
  }
  func test_compareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))
  }
  func test_compareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))
  }
  func test_compareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))
  }
  func test_compareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))
  }
  func test_compareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))
  }
  func test_compareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))
  }
  func test_compareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))
  }
  func test_compareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))
  }
  func test_compareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))
  }
  func test_weakCompareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))
  }
  func test_weakCompareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))
  }
  func test_weakCompareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))
  }
  func test_weakCompareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))
  }
  func test_weakCompareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))
  }
  func test_weakCompareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))
  }
  func test_weakCompareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))
  }
  func test_weakCompareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))
  }
  func test_weakCompareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))
  }
  func test_weakCompareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))
  }
  func test_weakCompareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))
  }
  func test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))
  }
  func test_weakCompareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))
  }
  func test_weakCompareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))
  }
  func test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<DoubleWord>.create(DoubleWord(high: 100, low: 64))
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 100, low: 64),
      desired: DoubleWord(high: 50, low: 32),
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 50, low: 32))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 50, low: 32))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))

    (exchanged, original) = v.compareExchange(
      expected: DoubleWord(high: 50, low: 32),
      desired: DoubleWord(high: 100, low: 64),
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, DoubleWord(high: 100, low: 64))
    XCTAssertEqual(v.load(ordering: .relaxed), DoubleWord(high: 100, low: 64))
  }





  public static var allTests = [
    ("test_create_destroy", test_create_destroy),
    ("test_load_relaxed", test_load_relaxed),
    ("test_load_acquiring", test_load_acquiring),
    ("test_load_sequentiallyConsistent", test_load_sequentiallyConsistent),
    ("test_store_relaxed", test_store_relaxed),
    ("test_store_releasing", test_store_releasing),
    ("test_store_sequentiallyConsistent", test_store_sequentiallyConsistent),
    ("test_exchange_relaxed", test_exchange_relaxed),
    ("test_exchange_acquiring", test_exchange_acquiring),
    ("test_exchange_releasing", test_exchange_releasing),
    ("test_exchange_acquiringAndReleasing", test_exchange_acquiringAndReleasing),
    ("test_exchange_sequentiallyConsistent", test_exchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed", test_compareExchange_relaxed),
    ("test_compareExchange_acquiring", test_compareExchange_acquiring),
    ("test_compareExchange_releasing", test_compareExchange_releasing),
    ("test_compareExchange_acquiringAndReleasing", test_compareExchange_acquiringAndReleasing),
    ("test_compareExchange_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed_relaxed", test_compareExchange_relaxed_relaxed),
    ("test_compareExchange_relaxed_acquiring", test_compareExchange_relaxed_acquiring),
    ("test_compareExchange_relaxed_sequentiallyConsistent", test_compareExchange_relaxed_sequentiallyConsistent),
    ("test_compareExchange_acquiring_relaxed", test_compareExchange_acquiring_relaxed),
    ("test_compareExchange_acquiring_acquiring", test_compareExchange_acquiring_acquiring),
    ("test_compareExchange_acquiring_sequentiallyConsistent", test_compareExchange_acquiring_sequentiallyConsistent),
    ("test_compareExchange_releasing_relaxed", test_compareExchange_releasing_relaxed),
    ("test_compareExchange_releasing_acquiring", test_compareExchange_releasing_acquiring),
    ("test_compareExchange_releasing_sequentiallyConsistent", test_compareExchange_releasing_sequentiallyConsistent),
    ("test_compareExchange_acquiringAndReleasing_relaxed", test_compareExchange_acquiringAndReleasing_relaxed),
    ("test_compareExchange_acquiringAndReleasing_acquiring", test_compareExchange_acquiringAndReleasing_acquiring),
    ("test_compareExchange_acquiringAndReleasing_sequentiallyConsistent", test_compareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_compareExchange_sequentiallyConsistent_relaxed", test_compareExchange_sequentiallyConsistent_relaxed),
    ("test_compareExchange_sequentiallyConsistent_acquiring", test_compareExchange_sequentiallyConsistent_acquiring),
    ("test_compareExchange_sequentiallyConsistent_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent_sequentiallyConsistent),
    ("test_weakCompareExchange_relaxed_relaxed", test_weakCompareExchange_relaxed_relaxed),
    ("test_weakCompareExchange_relaxed_acquiring", test_weakCompareExchange_relaxed_acquiring),
    ("test_weakCompareExchange_relaxed_sequentiallyConsistent", test_weakCompareExchange_relaxed_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiring_relaxed", test_weakCompareExchange_acquiring_relaxed),
    ("test_weakCompareExchange_acquiring_acquiring", test_weakCompareExchange_acquiring_acquiring),
    ("test_weakCompareExchange_acquiring_sequentiallyConsistent", test_weakCompareExchange_acquiring_sequentiallyConsistent),
    ("test_weakCompareExchange_releasing_relaxed", test_weakCompareExchange_releasing_relaxed),
    ("test_weakCompareExchange_releasing_acquiring", test_weakCompareExchange_releasing_acquiring),
    ("test_weakCompareExchange_releasing_sequentiallyConsistent", test_weakCompareExchange_releasing_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiringAndReleasing_relaxed", test_weakCompareExchange_acquiringAndReleasing_relaxed),
    ("test_weakCompareExchange_acquiringAndReleasing_acquiring", test_weakCompareExchange_acquiringAndReleasing_acquiring),
    ("test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent", test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_weakCompareExchange_sequentiallyConsistent_relaxed", test_weakCompareExchange_sequentiallyConsistent_relaxed),
    ("test_weakCompareExchange_sequentiallyConsistent_acquiring", test_weakCompareExchange_sequentiallyConsistent_acquiring),
    ("test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent", test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent),
  ]
}
#endif
#if !(os(Linux) && arch(x86_64)) || ENABLE_DOUBLEWIDE_ATOMICS
/// Exercises all operations in a single-threaded context, verifying
/// they provide the expected results.
class BasicAtomicReferenceTests: XCTestCase {
  private let _baz1 = Baz(1)
  private let _baz2 = Baz(2)

  func test_create_destroy() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    let w = UnsafeAtomic<Baz>.create(_baz2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), _baz2)
  }

  func test_load_relaxed() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    let w = UnsafeAtomic<Baz>.create(_baz2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), _baz2)
  }
  func test_load_acquiring() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .acquiring), _baz1)

    let w = UnsafeAtomic<Baz>.create(_baz2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .acquiring), _baz2)
  }
  func test_load_sequentiallyConsistent() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .sequentiallyConsistent), _baz1)

    let w = UnsafeAtomic<Baz>.create(_baz2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .sequentiallyConsistent), _baz2)
  }

  func test_store_relaxed() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }
    v.store(_baz2, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    let w = UnsafeAtomic<Baz>.create(_baz2)
    defer { w.destroy() }
    w.store(_baz1, ordering: .relaxed)
    XCTAssertEqual(w.load(ordering: .relaxed), _baz1)
  }
  func test_store_releasing() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }
    v.store(_baz2, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    let w = UnsafeAtomic<Baz>.create(_baz2)
    defer { w.destroy() }
    w.store(_baz1, ordering: .releasing)
    XCTAssertEqual(w.load(ordering: .relaxed), _baz1)
  }
  func test_store_sequentiallyConsistent() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }
    v.store(_baz2, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    let w = UnsafeAtomic<Baz>.create(_baz2)
    defer { w.destroy() }
    w.store(_baz1, ordering: .sequentiallyConsistent)
    XCTAssertEqual(w.load(ordering: .relaxed), _baz1)
  }

  func test_exchange_relaxed() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(_baz1, ordering: .relaxed), _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    XCTAssertEqual(v.exchange(_baz2, ordering: .relaxed), _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    XCTAssertEqual(v.exchange(_baz2, ordering: .relaxed), _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)
  }
  func test_exchange_acquiring() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(_baz1, ordering: .acquiring), _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    XCTAssertEqual(v.exchange(_baz2, ordering: .acquiring), _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    XCTAssertEqual(v.exchange(_baz2, ordering: .acquiring), _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)
  }
  func test_exchange_releasing() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(_baz1, ordering: .releasing), _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    XCTAssertEqual(v.exchange(_baz2, ordering: .releasing), _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    XCTAssertEqual(v.exchange(_baz2, ordering: .releasing), _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)
  }
  func test_exchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(_baz1, ordering: .acquiringAndReleasing), _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    XCTAssertEqual(v.exchange(_baz2, ordering: .acquiringAndReleasing), _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    XCTAssertEqual(v.exchange(_baz2, ordering: .acquiringAndReleasing), _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)
  }
  func test_exchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(_baz1, ordering: .sequentiallyConsistent), _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    XCTAssertEqual(v.exchange(_baz2, ordering: .sequentiallyConsistent), _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    XCTAssertEqual(v.exchange(_baz2, ordering: .sequentiallyConsistent), _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)
  }

  func test_compareExchange_relaxed() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)
  }
  func test_compareExchange_acquiring() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)
  }
  func test_compareExchange_releasing() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)
  }
  func test_compareExchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)
  }
  func test_compareExchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)
  }

  func test_compareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)
  }
  func test_compareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)
  }
  func test_compareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)
  }
  func test_compareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)
  }
  func test_compareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)
  }
  func test_compareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)
  }
  func test_compareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)
  }
  func test_compareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)
  }
  func test_compareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)
  }
  func test_compareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)
  }
  func test_compareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)
  }
  func test_compareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)
  }
  func test_compareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)
  }
  func test_compareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)
  }
  func test_compareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)
  }
  func test_weakCompareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)
  }
  func test_weakCompareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)
  }
  func test_weakCompareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)
  }
  func test_weakCompareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)
  }
  func test_weakCompareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)
  }
  func test_weakCompareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)
  }
  func test_weakCompareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)
  }
  func test_weakCompareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)
  }
  func test_weakCompareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)
  }
  func test_weakCompareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)
  }
  func test_weakCompareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)
  }
  func test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)
  }
  func test_weakCompareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)
  }
  func test_weakCompareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)
  }
  func test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<Baz>.create(_baz1)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz1,
      desired: _baz2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: _baz1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz1)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz1)
  }





  public static var allTests = [
    ("test_create_destroy", test_create_destroy),
    ("test_load_relaxed", test_load_relaxed),
    ("test_load_acquiring", test_load_acquiring),
    ("test_load_sequentiallyConsistent", test_load_sequentiallyConsistent),
    ("test_store_relaxed", test_store_relaxed),
    ("test_store_releasing", test_store_releasing),
    ("test_store_sequentiallyConsistent", test_store_sequentiallyConsistent),
    ("test_exchange_relaxed", test_exchange_relaxed),
    ("test_exchange_acquiring", test_exchange_acquiring),
    ("test_exchange_releasing", test_exchange_releasing),
    ("test_exchange_acquiringAndReleasing", test_exchange_acquiringAndReleasing),
    ("test_exchange_sequentiallyConsistent", test_exchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed", test_compareExchange_relaxed),
    ("test_compareExchange_acquiring", test_compareExchange_acquiring),
    ("test_compareExchange_releasing", test_compareExchange_releasing),
    ("test_compareExchange_acquiringAndReleasing", test_compareExchange_acquiringAndReleasing),
    ("test_compareExchange_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed_relaxed", test_compareExchange_relaxed_relaxed),
    ("test_compareExchange_relaxed_acquiring", test_compareExchange_relaxed_acquiring),
    ("test_compareExchange_relaxed_sequentiallyConsistent", test_compareExchange_relaxed_sequentiallyConsistent),
    ("test_compareExchange_acquiring_relaxed", test_compareExchange_acquiring_relaxed),
    ("test_compareExchange_acquiring_acquiring", test_compareExchange_acquiring_acquiring),
    ("test_compareExchange_acquiring_sequentiallyConsistent", test_compareExchange_acquiring_sequentiallyConsistent),
    ("test_compareExchange_releasing_relaxed", test_compareExchange_releasing_relaxed),
    ("test_compareExchange_releasing_acquiring", test_compareExchange_releasing_acquiring),
    ("test_compareExchange_releasing_sequentiallyConsistent", test_compareExchange_releasing_sequentiallyConsistent),
    ("test_compareExchange_acquiringAndReleasing_relaxed", test_compareExchange_acquiringAndReleasing_relaxed),
    ("test_compareExchange_acquiringAndReleasing_acquiring", test_compareExchange_acquiringAndReleasing_acquiring),
    ("test_compareExchange_acquiringAndReleasing_sequentiallyConsistent", test_compareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_compareExchange_sequentiallyConsistent_relaxed", test_compareExchange_sequentiallyConsistent_relaxed),
    ("test_compareExchange_sequentiallyConsistent_acquiring", test_compareExchange_sequentiallyConsistent_acquiring),
    ("test_compareExchange_sequentiallyConsistent_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent_sequentiallyConsistent),
    ("test_weakCompareExchange_relaxed_relaxed", test_weakCompareExchange_relaxed_relaxed),
    ("test_weakCompareExchange_relaxed_acquiring", test_weakCompareExchange_relaxed_acquiring),
    ("test_weakCompareExchange_relaxed_sequentiallyConsistent", test_weakCompareExchange_relaxed_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiring_relaxed", test_weakCompareExchange_acquiring_relaxed),
    ("test_weakCompareExchange_acquiring_acquiring", test_weakCompareExchange_acquiring_acquiring),
    ("test_weakCompareExchange_acquiring_sequentiallyConsistent", test_weakCompareExchange_acquiring_sequentiallyConsistent),
    ("test_weakCompareExchange_releasing_relaxed", test_weakCompareExchange_releasing_relaxed),
    ("test_weakCompareExchange_releasing_acquiring", test_weakCompareExchange_releasing_acquiring),
    ("test_weakCompareExchange_releasing_sequentiallyConsistent", test_weakCompareExchange_releasing_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiringAndReleasing_relaxed", test_weakCompareExchange_acquiringAndReleasing_relaxed),
    ("test_weakCompareExchange_acquiringAndReleasing_acquiring", test_weakCompareExchange_acquiringAndReleasing_acquiring),
    ("test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent", test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_weakCompareExchange_sequentiallyConsistent_relaxed", test_weakCompareExchange_sequentiallyConsistent_relaxed),
    ("test_weakCompareExchange_sequentiallyConsistent_acquiring", test_weakCompareExchange_sequentiallyConsistent_acquiring),
    ("test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent", test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent),
  ]
}
#endif
#if !(os(Linux) && arch(x86_64)) || ENABLE_DOUBLEWIDE_ATOMICS
/// Exercises all operations in a single-threaded context, verifying
/// they provide the expected results.
class BasicAtomicOptionalReferenceTests: XCTestCase {
  private let _baz1 = Baz(1)
  private let _baz2 = Baz(2)

  func test_create_destroy() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    let w = UnsafeAtomic<Baz?>.create(_baz2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), _baz2)
  }

  func test_load_relaxed() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    let w = UnsafeAtomic<Baz?>.create(_baz2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), _baz2)
  }
  func test_load_acquiring() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .acquiring), nil)

    let w = UnsafeAtomic<Baz?>.create(_baz2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .acquiring), _baz2)
  }
  func test_load_sequentiallyConsistent() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .sequentiallyConsistent), nil)

    let w = UnsafeAtomic<Baz?>.create(_baz2)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .sequentiallyConsistent), _baz2)
  }

  func test_store_relaxed() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }
    v.store(_baz2, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    let w = UnsafeAtomic<Baz?>.create(_baz2)
    defer { w.destroy() }
    w.store(nil, ordering: .relaxed)
    XCTAssertEqual(w.load(ordering: .relaxed), nil)
  }
  func test_store_releasing() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }
    v.store(_baz2, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    let w = UnsafeAtomic<Baz?>.create(_baz2)
    defer { w.destroy() }
    w.store(nil, ordering: .releasing)
    XCTAssertEqual(w.load(ordering: .relaxed), nil)
  }
  func test_store_sequentiallyConsistent() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }
    v.store(_baz2, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    let w = UnsafeAtomic<Baz?>.create(_baz2)
    defer { w.destroy() }
    w.store(nil, ordering: .sequentiallyConsistent)
    XCTAssertEqual(w.load(ordering: .relaxed), nil)
  }

  func test_exchange_relaxed() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(nil, ordering: .relaxed), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    XCTAssertEqual(v.exchange(_baz2, ordering: .relaxed), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    XCTAssertEqual(v.exchange(_baz2, ordering: .relaxed), _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)
  }
  func test_exchange_acquiring() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(nil, ordering: .acquiring), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    XCTAssertEqual(v.exchange(_baz2, ordering: .acquiring), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    XCTAssertEqual(v.exchange(_baz2, ordering: .acquiring), _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)
  }
  func test_exchange_releasing() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(nil, ordering: .releasing), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    XCTAssertEqual(v.exchange(_baz2, ordering: .releasing), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    XCTAssertEqual(v.exchange(_baz2, ordering: .releasing), _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)
  }
  func test_exchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(nil, ordering: .acquiringAndReleasing), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    XCTAssertEqual(v.exchange(_baz2, ordering: .acquiringAndReleasing), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    XCTAssertEqual(v.exchange(_baz2, ordering: .acquiringAndReleasing), _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)
  }
  func test_exchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(nil, ordering: .sequentiallyConsistent), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    XCTAssertEqual(v.exchange(_baz2, ordering: .sequentiallyConsistent), nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    XCTAssertEqual(v.exchange(_baz2, ordering: .sequentiallyConsistent), _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)
  }

  func test_compareExchange_relaxed() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiring() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_releasing() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }

  func test_compareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_compareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }
  func test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<Baz?>.create(nil)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: nil,
      desired: _baz2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), _baz2)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, _baz2)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)

    (exchanged, original) = v.compareExchange(
      expected: _baz2,
      desired: nil,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, nil)
    XCTAssertEqual(v.load(ordering: .relaxed), nil)
  }





  public static var allTests = [
    ("test_create_destroy", test_create_destroy),
    ("test_load_relaxed", test_load_relaxed),
    ("test_load_acquiring", test_load_acquiring),
    ("test_load_sequentiallyConsistent", test_load_sequentiallyConsistent),
    ("test_store_relaxed", test_store_relaxed),
    ("test_store_releasing", test_store_releasing),
    ("test_store_sequentiallyConsistent", test_store_sequentiallyConsistent),
    ("test_exchange_relaxed", test_exchange_relaxed),
    ("test_exchange_acquiring", test_exchange_acquiring),
    ("test_exchange_releasing", test_exchange_releasing),
    ("test_exchange_acquiringAndReleasing", test_exchange_acquiringAndReleasing),
    ("test_exchange_sequentiallyConsistent", test_exchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed", test_compareExchange_relaxed),
    ("test_compareExchange_acquiring", test_compareExchange_acquiring),
    ("test_compareExchange_releasing", test_compareExchange_releasing),
    ("test_compareExchange_acquiringAndReleasing", test_compareExchange_acquiringAndReleasing),
    ("test_compareExchange_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent),
    ("test_compareExchange_relaxed_relaxed", test_compareExchange_relaxed_relaxed),
    ("test_compareExchange_relaxed_acquiring", test_compareExchange_relaxed_acquiring),
    ("test_compareExchange_relaxed_sequentiallyConsistent", test_compareExchange_relaxed_sequentiallyConsistent),
    ("test_compareExchange_acquiring_relaxed", test_compareExchange_acquiring_relaxed),
    ("test_compareExchange_acquiring_acquiring", test_compareExchange_acquiring_acquiring),
    ("test_compareExchange_acquiring_sequentiallyConsistent", test_compareExchange_acquiring_sequentiallyConsistent),
    ("test_compareExchange_releasing_relaxed", test_compareExchange_releasing_relaxed),
    ("test_compareExchange_releasing_acquiring", test_compareExchange_releasing_acquiring),
    ("test_compareExchange_releasing_sequentiallyConsistent", test_compareExchange_releasing_sequentiallyConsistent),
    ("test_compareExchange_acquiringAndReleasing_relaxed", test_compareExchange_acquiringAndReleasing_relaxed),
    ("test_compareExchange_acquiringAndReleasing_acquiring", test_compareExchange_acquiringAndReleasing_acquiring),
    ("test_compareExchange_acquiringAndReleasing_sequentiallyConsistent", test_compareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_compareExchange_sequentiallyConsistent_relaxed", test_compareExchange_sequentiallyConsistent_relaxed),
    ("test_compareExchange_sequentiallyConsistent_acquiring", test_compareExchange_sequentiallyConsistent_acquiring),
    ("test_compareExchange_sequentiallyConsistent_sequentiallyConsistent", test_compareExchange_sequentiallyConsistent_sequentiallyConsistent),
    ("test_weakCompareExchange_relaxed_relaxed", test_weakCompareExchange_relaxed_relaxed),
    ("test_weakCompareExchange_relaxed_acquiring", test_weakCompareExchange_relaxed_acquiring),
    ("test_weakCompareExchange_relaxed_sequentiallyConsistent", test_weakCompareExchange_relaxed_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiring_relaxed", test_weakCompareExchange_acquiring_relaxed),
    ("test_weakCompareExchange_acquiring_acquiring", test_weakCompareExchange_acquiring_acquiring),
    ("test_weakCompareExchange_acquiring_sequentiallyConsistent", test_weakCompareExchange_acquiring_sequentiallyConsistent),
    ("test_weakCompareExchange_releasing_relaxed", test_weakCompareExchange_releasing_relaxed),
    ("test_weakCompareExchange_releasing_acquiring", test_weakCompareExchange_releasing_acquiring),
    ("test_weakCompareExchange_releasing_sequentiallyConsistent", test_weakCompareExchange_releasing_sequentiallyConsistent),
    ("test_weakCompareExchange_acquiringAndReleasing_relaxed", test_weakCompareExchange_acquiringAndReleasing_relaxed),
    ("test_weakCompareExchange_acquiringAndReleasing_acquiring", test_weakCompareExchange_acquiringAndReleasing_acquiring),
    ("test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent", test_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent),
    ("test_weakCompareExchange_sequentiallyConsistent_relaxed", test_weakCompareExchange_sequentiallyConsistent_relaxed),
    ("test_weakCompareExchange_sequentiallyConsistent_acquiring", test_weakCompareExchange_sequentiallyConsistent_acquiring),
    ("test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent", test_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent),
  ]
}
#endif
