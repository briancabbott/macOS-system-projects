//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift Atomics open source project
//
// Copyright (c) 2020 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//


// #############################################################################
// #                                                                           #
// #            DO NOT EDIT THIS FILE; IT IS AUTOGENERATED.                    #
// #                                                                           #
// #############################################################################


extension UnsafeRawPointer: AtomicValue {
  @frozen
  public struct AtomicRepresentation {
    public typealias Value = UnsafeRawPointer
    @usableFromInline internal typealias Storage = Int.AtomicRepresentation

    @usableFromInline
    internal let _storage: Storage

    @inline(__always) @_alwaysEmitIntoClient
    public init(_ value: Value) {
      self._storage = .init(Self._encode(value))
    }

    @inline(__always) @_alwaysEmitIntoClient
    public func dispose() -> Value {
      Self._decode(_storage.dispose())
    }
  }
}

extension UnsafeRawPointer.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient
  @usableFromInline
  internal static func _extract(
    _ ptr: UnsafeMutablePointer<Self>
  ) -> UnsafeMutablePointer<Storage> {
    // `Self` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: Storage.self)
  }

  @_transparent @_alwaysEmitIntoClient
  internal static func _decode(_ bitPattern: Int) -> Value {
    return UnsafeRawPointer(bitPattern: bitPattern)!
  }

  @_transparent @_alwaysEmitIntoClient
  internal static func _encode(_ value: Value) -> Int {
    return Int(bitPattern: value)
  }
}

extension UnsafeRawPointer.AtomicRepresentation: AtomicStorage {
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicLoad(
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicLoadOrdering
  ) -> Value {
    let encoded = Storage.atomicLoad(at: _extract(pointer), ordering: ordering)
    return _decode(encoded)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicStore(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicStoreOrdering
  ) {
    Storage.atomicStore(_encode(desired), at: _extract(pointer), ordering: ordering)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicExchange(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> Value {
    _decode(Storage.atomicExchange(_encode(desired), at: _extract(pointer), ordering: ordering))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> (exchanged: Bool, original: Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      ordering: ordering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Bool, original: Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicWeakCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Bool, original: Value) {
    let (exchanged, original) = Storage.atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}
extension UnsafeMutableRawPointer: AtomicValue {
  @frozen
  public struct AtomicRepresentation {
    public typealias Value = UnsafeMutableRawPointer
    @usableFromInline internal typealias Storage = Int.AtomicRepresentation

    @usableFromInline
    internal let _storage: Storage

    @inline(__always) @_alwaysEmitIntoClient
    public init(_ value: Value) {
      self._storage = .init(Self._encode(value))
    }

    @inline(__always) @_alwaysEmitIntoClient
    public func dispose() -> Value {
      Self._decode(_storage.dispose())
    }
  }
}

extension UnsafeMutableRawPointer.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient
  @usableFromInline
  internal static func _extract(
    _ ptr: UnsafeMutablePointer<Self>
  ) -> UnsafeMutablePointer<Storage> {
    // `Self` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: Storage.self)
  }

  @_transparent @_alwaysEmitIntoClient
  internal static func _decode(_ bitPattern: Int) -> Value {
    return UnsafeMutableRawPointer(bitPattern: bitPattern)!
  }

  @_transparent @_alwaysEmitIntoClient
  internal static func _encode(_ value: Value) -> Int {
    return Int(bitPattern: value)
  }
}

extension UnsafeMutableRawPointer.AtomicRepresentation: AtomicStorage {
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicLoad(
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicLoadOrdering
  ) -> Value {
    let encoded = Storage.atomicLoad(at: _extract(pointer), ordering: ordering)
    return _decode(encoded)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicStore(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicStoreOrdering
  ) {
    Storage.atomicStore(_encode(desired), at: _extract(pointer), ordering: ordering)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicExchange(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> Value {
    _decode(Storage.atomicExchange(_encode(desired), at: _extract(pointer), ordering: ordering))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> (exchanged: Bool, original: Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      ordering: ordering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Bool, original: Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicWeakCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Bool, original: Value) {
    let (exchanged, original) = Storage.atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}
extension UnsafePointer: AtomicValue {
  @frozen
  public struct AtomicRepresentation {
    public typealias Value = UnsafePointer
    @usableFromInline internal typealias Storage = Int.AtomicRepresentation

    @usableFromInline
    internal let _storage: Storage

    @inline(__always) @_alwaysEmitIntoClient
    public init(_ value: Value) {
      self._storage = .init(Self._encode(value))
    }

    @inline(__always) @_alwaysEmitIntoClient
    public func dispose() -> Value {
      Self._decode(_storage.dispose())
    }
  }
}

extension UnsafePointer.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient
  @usableFromInline
  internal static func _extract(
    _ ptr: UnsafeMutablePointer<Self>
  ) -> UnsafeMutablePointer<Storage> {
    // `Self` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: Storage.self)
  }

  @_transparent @_alwaysEmitIntoClient
  internal static func _decode(_ bitPattern: Int) -> Value {
    return UnsafePointer(bitPattern: bitPattern)!
  }

  @_transparent @_alwaysEmitIntoClient
  internal static func _encode(_ value: Value) -> Int {
    return Int(bitPattern: value)
  }
}

extension UnsafePointer.AtomicRepresentation: AtomicStorage {
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicLoad(
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicLoadOrdering
  ) -> Value {
    let encoded = Storage.atomicLoad(at: _extract(pointer), ordering: ordering)
    return _decode(encoded)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicStore(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicStoreOrdering
  ) {
    Storage.atomicStore(_encode(desired), at: _extract(pointer), ordering: ordering)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicExchange(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> Value {
    _decode(Storage.atomicExchange(_encode(desired), at: _extract(pointer), ordering: ordering))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> (exchanged: Bool, original: Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      ordering: ordering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Bool, original: Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicWeakCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Bool, original: Value) {
    let (exchanged, original) = Storage.atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}
extension UnsafeMutablePointer: AtomicValue {
  @frozen
  public struct AtomicRepresentation {
    public typealias Value = UnsafeMutablePointer
    @usableFromInline internal typealias Storage = Int.AtomicRepresentation

    @usableFromInline
    internal let _storage: Storage

    @inline(__always) @_alwaysEmitIntoClient
    public init(_ value: Value) {
      self._storage = .init(Self._encode(value))
    }

    @inline(__always) @_alwaysEmitIntoClient
    public func dispose() -> Value {
      Self._decode(_storage.dispose())
    }
  }
}

extension UnsafeMutablePointer.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient
  @usableFromInline
  internal static func _extract(
    _ ptr: UnsafeMutablePointer<Self>
  ) -> UnsafeMutablePointer<Storage> {
    // `Self` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: Storage.self)
  }

  @_transparent @_alwaysEmitIntoClient
  internal static func _decode(_ bitPattern: Int) -> Value {
    return UnsafeMutablePointer(bitPattern: bitPattern)!
  }

  @_transparent @_alwaysEmitIntoClient
  internal static func _encode(_ value: Value) -> Int {
    return Int(bitPattern: value)
  }
}

extension UnsafeMutablePointer.AtomicRepresentation: AtomicStorage {
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicLoad(
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicLoadOrdering
  ) -> Value {
    let encoded = Storage.atomicLoad(at: _extract(pointer), ordering: ordering)
    return _decode(encoded)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicStore(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicStoreOrdering
  ) {
    Storage.atomicStore(_encode(desired), at: _extract(pointer), ordering: ordering)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicExchange(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> Value {
    _decode(Storage.atomicExchange(_encode(desired), at: _extract(pointer), ordering: ordering))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> (exchanged: Bool, original: Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      ordering: ordering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Bool, original: Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicWeakCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Bool, original: Value) {
    let (exchanged, original) = Storage.atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}
extension Unmanaged: AtomicValue {
  @frozen
  public struct AtomicRepresentation {
    public typealias Value = Unmanaged
    @usableFromInline internal typealias Storage = Int.AtomicRepresentation

    @usableFromInline
    internal let _storage: Storage

    @inline(__always) @_alwaysEmitIntoClient
    public init(_ value: Value) {
      self._storage = .init(Self._encode(value))
    }

    @inline(__always) @_alwaysEmitIntoClient
    public func dispose() -> Value {
      Self._decode(_storage.dispose())
    }
  }
}

extension Unmanaged.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient
  @usableFromInline
  internal static func _extract(
    _ ptr: UnsafeMutablePointer<Self>
  ) -> UnsafeMutablePointer<Storage> {
    // `Self` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: Storage.self)
  }

  @_transparent @_alwaysEmitIntoClient
  internal static func _decode(_ bitPattern: Int) -> Value {
    return Unmanaged.fromOpaque(UnsafeRawPointer(bitPattern: bitPattern)!)
  }

  @_transparent @_alwaysEmitIntoClient
  internal static func _encode(_ value: Value) -> Int {
    return Int(bitPattern: value.toOpaque())
  }
}

extension Unmanaged.AtomicRepresentation: AtomicStorage {
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicLoad(
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicLoadOrdering
  ) -> Value {
    let encoded = Storage.atomicLoad(at: _extract(pointer), ordering: ordering)
    return _decode(encoded)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicStore(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicStoreOrdering
  ) {
    Storage.atomicStore(_encode(desired), at: _extract(pointer), ordering: ordering)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicExchange(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> Value {
    _decode(Storage.atomicExchange(_encode(desired), at: _extract(pointer), ordering: ordering))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> (exchanged: Bool, original: Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      ordering: ordering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Bool, original: Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicWeakCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Bool, original: Value) {
    let (exchanged, original) = Storage.atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}


extension UnsafeRawPointer: AtomicOptionalWrappable {
  @frozen
  public struct AtomicOptionalRepresentation {
    public typealias Value = UnsafeRawPointer?
    @usableFromInline internal typealias Storage = Int.AtomicRepresentation

    @usableFromInline
    internal let _storage: Storage

    @inline(__always) @_alwaysEmitIntoClient
    public init(_ value: Value) {
      self._storage = .init(Self._encode(value))
    }

    @inline(__always) @_alwaysEmitIntoClient
    public func dispose() -> Value {
      Self._decode(_storage.dispose())
    }
  }
}

extension UnsafeRawPointer.AtomicOptionalRepresentation {
  @_transparent @_alwaysEmitIntoClient
  @usableFromInline
  internal static func _extract(
    _ ptr: UnsafeMutablePointer<Self>
  ) -> UnsafeMutablePointer<Storage> {
    // `Self` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: Storage.self)
  }

  @_transparent @_alwaysEmitIntoClient
  internal static func _decode(_ bitPattern: Int) -> Value {
    return UnsafeRawPointer(bitPattern: bitPattern)
  }

  @_transparent @_alwaysEmitIntoClient
  internal static func _encode(_ value: Value) -> Int {
    guard let value = value else { return 0 }
    return Int(bitPattern: value)
  }
}

extension UnsafeRawPointer.AtomicOptionalRepresentation: AtomicStorage {
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicLoad(
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicLoadOrdering
  ) -> Value {
    let encoded = Storage.atomicLoad(at: _extract(pointer), ordering: ordering)
    return _decode(encoded)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicStore(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicStoreOrdering
  ) {
    Storage.atomicStore(_encode(desired), at: _extract(pointer), ordering: ordering)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicExchange(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> Value {
    _decode(Storage.atomicExchange(_encode(desired), at: _extract(pointer), ordering: ordering))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> (exchanged: Bool, original: Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      ordering: ordering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Bool, original: Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicWeakCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Bool, original: Value) {
    let (exchanged, original) = Storage.atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}
extension UnsafeMutableRawPointer: AtomicOptionalWrappable {
  @frozen
  public struct AtomicOptionalRepresentation {
    public typealias Value = UnsafeMutableRawPointer?
    @usableFromInline internal typealias Storage = Int.AtomicRepresentation

    @usableFromInline
    internal let _storage: Storage

    @inline(__always) @_alwaysEmitIntoClient
    public init(_ value: Value) {
      self._storage = .init(Self._encode(value))
    }

    @inline(__always) @_alwaysEmitIntoClient
    public func dispose() -> Value {
      Self._decode(_storage.dispose())
    }
  }
}

extension UnsafeMutableRawPointer.AtomicOptionalRepresentation {
  @_transparent @_alwaysEmitIntoClient
  @usableFromInline
  internal static func _extract(
    _ ptr: UnsafeMutablePointer<Self>
  ) -> UnsafeMutablePointer<Storage> {
    // `Self` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: Storage.self)
  }

  @_transparent @_alwaysEmitIntoClient
  internal static func _decode(_ bitPattern: Int) -> Value {
    return UnsafeMutableRawPointer(bitPattern: bitPattern)
  }

  @_transparent @_alwaysEmitIntoClient
  internal static func _encode(_ value: Value) -> Int {
    guard let value = value else { return 0 }
    return Int(bitPattern: value)
  }
}

extension UnsafeMutableRawPointer.AtomicOptionalRepresentation: AtomicStorage {
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicLoad(
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicLoadOrdering
  ) -> Value {
    let encoded = Storage.atomicLoad(at: _extract(pointer), ordering: ordering)
    return _decode(encoded)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicStore(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicStoreOrdering
  ) {
    Storage.atomicStore(_encode(desired), at: _extract(pointer), ordering: ordering)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicExchange(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> Value {
    _decode(Storage.atomicExchange(_encode(desired), at: _extract(pointer), ordering: ordering))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> (exchanged: Bool, original: Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      ordering: ordering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Bool, original: Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicWeakCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Bool, original: Value) {
    let (exchanged, original) = Storage.atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}
extension UnsafePointer: AtomicOptionalWrappable {
  @frozen
  public struct AtomicOptionalRepresentation {
    public typealias Value = UnsafePointer?
    @usableFromInline internal typealias Storage = Int.AtomicRepresentation

    @usableFromInline
    internal let _storage: Storage

    @inline(__always) @_alwaysEmitIntoClient
    public init(_ value: Value) {
      self._storage = .init(Self._encode(value))
    }

    @inline(__always) @_alwaysEmitIntoClient
    public func dispose() -> Value {
      Self._decode(_storage.dispose())
    }
  }
}

extension UnsafePointer.AtomicOptionalRepresentation {
  @_transparent @_alwaysEmitIntoClient
  @usableFromInline
  internal static func _extract(
    _ ptr: UnsafeMutablePointer<Self>
  ) -> UnsafeMutablePointer<Storage> {
    // `Self` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: Storage.self)
  }

  @_transparent @_alwaysEmitIntoClient
  internal static func _decode(_ bitPattern: Int) -> Value {
    return UnsafePointer(bitPattern: bitPattern)
  }

  @_transparent @_alwaysEmitIntoClient
  internal static func _encode(_ value: Value) -> Int {
    guard let value = value else { return 0 }
    return Int(bitPattern: value)
  }
}

extension UnsafePointer.AtomicOptionalRepresentation: AtomicStorage {
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicLoad(
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicLoadOrdering
  ) -> Value {
    let encoded = Storage.atomicLoad(at: _extract(pointer), ordering: ordering)
    return _decode(encoded)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicStore(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicStoreOrdering
  ) {
    Storage.atomicStore(_encode(desired), at: _extract(pointer), ordering: ordering)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicExchange(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> Value {
    _decode(Storage.atomicExchange(_encode(desired), at: _extract(pointer), ordering: ordering))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> (exchanged: Bool, original: Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      ordering: ordering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Bool, original: Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicWeakCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Bool, original: Value) {
    let (exchanged, original) = Storage.atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}
extension UnsafeMutablePointer: AtomicOptionalWrappable {
  @frozen
  public struct AtomicOptionalRepresentation {
    public typealias Value = UnsafeMutablePointer?
    @usableFromInline internal typealias Storage = Int.AtomicRepresentation

    @usableFromInline
    internal let _storage: Storage

    @inline(__always) @_alwaysEmitIntoClient
    public init(_ value: Value) {
      self._storage = .init(Self._encode(value))
    }

    @inline(__always) @_alwaysEmitIntoClient
    public func dispose() -> Value {
      Self._decode(_storage.dispose())
    }
  }
}

extension UnsafeMutablePointer.AtomicOptionalRepresentation {
  @_transparent @_alwaysEmitIntoClient
  @usableFromInline
  internal static func _extract(
    _ ptr: UnsafeMutablePointer<Self>
  ) -> UnsafeMutablePointer<Storage> {
    // `Self` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: Storage.self)
  }

  @_transparent @_alwaysEmitIntoClient
  internal static func _decode(_ bitPattern: Int) -> Value {
    return UnsafeMutablePointer(bitPattern: bitPattern)
  }

  @_transparent @_alwaysEmitIntoClient
  internal static func _encode(_ value: Value) -> Int {
    guard let value = value else { return 0 }
    return Int(bitPattern: value)
  }
}

extension UnsafeMutablePointer.AtomicOptionalRepresentation: AtomicStorage {
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicLoad(
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicLoadOrdering
  ) -> Value {
    let encoded = Storage.atomicLoad(at: _extract(pointer), ordering: ordering)
    return _decode(encoded)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicStore(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicStoreOrdering
  ) {
    Storage.atomicStore(_encode(desired), at: _extract(pointer), ordering: ordering)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicExchange(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> Value {
    _decode(Storage.atomicExchange(_encode(desired), at: _extract(pointer), ordering: ordering))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> (exchanged: Bool, original: Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      ordering: ordering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Bool, original: Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicWeakCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Bool, original: Value) {
    let (exchanged, original) = Storage.atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}
extension Unmanaged: AtomicOptionalWrappable {
  @frozen
  public struct AtomicOptionalRepresentation {
    public typealias Value = Unmanaged?
    @usableFromInline internal typealias Storage = Int.AtomicRepresentation

    @usableFromInline
    internal let _storage: Storage

    @inline(__always) @_alwaysEmitIntoClient
    public init(_ value: Value) {
      self._storage = .init(Self._encode(value))
    }

    @inline(__always) @_alwaysEmitIntoClient
    public func dispose() -> Value {
      Self._decode(_storage.dispose())
    }
  }
}

extension Unmanaged.AtomicOptionalRepresentation {
  @_transparent @_alwaysEmitIntoClient
  @usableFromInline
  internal static func _extract(
    _ ptr: UnsafeMutablePointer<Self>
  ) -> UnsafeMutablePointer<Storage> {
    // `Self` is layout-compatible with its only stored property.
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: Storage.self)
  }

  @_transparent @_alwaysEmitIntoClient
  internal static func _decode(_ bitPattern: Int) -> Value {
    guard let opaque = UnsafeRawPointer(bitPattern: bitPattern) else {
      return nil
    }
    return Unmanaged.fromOpaque(opaque)
  }

  @_transparent @_alwaysEmitIntoClient
  internal static func _encode(_ value: Value) -> Int {
    guard let value = value else { return 0 }
    return Int(bitPattern: value.toOpaque())
  }
}

extension Unmanaged.AtomicOptionalRepresentation: AtomicStorage {
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicLoad(
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicLoadOrdering
  ) -> Value {
    let encoded = Storage.atomicLoad(at: _extract(pointer), ordering: ordering)
    return _decode(encoded)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicStore(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicStoreOrdering
  ) {
    Storage.atomicStore(_encode(desired), at: _extract(pointer), ordering: ordering)
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicExchange(
    _ desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> Value {
    _decode(Storage.atomicExchange(_encode(desired), at: _extract(pointer), ordering: ordering))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    ordering: AtomicUpdateOrdering
  ) -> (exchanged: Bool, original: Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      ordering: ordering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Bool, original: Value) {
    let (exchanged, original) = Storage.atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }

  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public static func atomicWeakCompareExchange(
    expected: Value,
    desired: Value,
    at pointer: UnsafeMutablePointer<Self>,
    successOrdering: AtomicUpdateOrdering,
    failureOrdering: AtomicLoadOrdering
  ) -> (exchanged: Bool, original: Value) {
    let (exchanged, original) = Storage.atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}
