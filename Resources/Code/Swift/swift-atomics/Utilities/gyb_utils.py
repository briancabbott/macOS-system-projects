#===-----------------------------------------------------------------------===//
#
# This source file is part of the Swift.org open source project
#
# Copyright (c) 2020 Apple Inc. and the Swift project authors
# Licensed under Apache License v2.0 with Runtime Library Exception
#
# See https://swift.org/LICENSE.txt for license information
# See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
#
#===-----------------------------------------------------------------------===//

def autogenerated_warning():
  return """
// #############################################################################
// #                                                                           #
// #            DO NOT EDIT THIS FILE; IT IS AUTOGENERATED.                    #
// #                                                                           #
// #############################################################################
"""

loadOrderings = [
  # Swift enum case,         C order
  ('relaxed',                'relaxed'),
  ('acquiring',              'acquire'),
  ('sequentiallyConsistent', 'seq_cst'),
]

storeOrderings = [
  # Swift enum case,         C order
  ('relaxed',                'relaxed'),
  ('releasing',              'release'),
  ('sequentiallyConsistent', 'seq_cst'),
]

updateOrderings = [
  # Swift enum case,         C order     fail order
  ('relaxed',                'relaxed',  'relaxed'),
  ('acquiring',              'acquire',  'acquire'),
  ('releasing',              'release',  'relaxed'),
  ('acquiringAndReleasing',  'acq_rel',  'acquire'),
  ('sequentiallyConsistent', 'seq_cst',  'seq_cst'),
]

# stdatomic.h (and LLVM underneath) doesn't support arbitrary ordering
# combinations yet, so for the two-ordering cmpxchg variants we need
# to upgrade the success ordering when necessary so that it is at
# least as "strong" as the failure case. This function implements that
# mapping.
#
# See llvm/Support/AtomicOrdering.h
def shimOrders(success, failure):
  def max(success, failure):
    if failure == "acquire":
      if success == "relaxed":
        return "acquire"
      if success == "release":
        return "acq_rel"
    if failure == "seq_cst":
      return "seq_cst"
    return success
  return max(success, failure) + "_" + failure

integerOperations = [
  # Swift name,         llvm name,  operator, label,  doc
  ('WrappingIncrement', 'add',      '&+',     "by",   "wrapping add"),
  ('WrappingDecrement', 'sub',      '&-',     "by",   "wrapping subtract"),
  ('BitwiseAnd',        'and',      '&',      "with", "bitwise AND"),
  ('BitwiseOr',         'or',       '|',      "with", "bitwise OR"),
  ('BitwiseXor',        'xor',      '^',      "with", "bitwise XOR")
]

boolOperations = [
  # Swift name,         C name,     operator, label,  doc
  ('LogicalAnd',        'and',      '&&',     "with", "logical AND"),
  ('LogicalOr',         'or',       '||',     "with", "logical OR"),
  ('LogicalXor',        'xor',      '!=',     "with", "logical XOR")
]

def lowerFirst(str):
  return str[:1].lower() + str[1:] if str else ""

def argLabel(label):
  return label + ": " if label != "_" else ""

