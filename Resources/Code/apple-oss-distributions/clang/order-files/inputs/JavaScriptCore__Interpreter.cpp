// RUN: %clang_cc1 -triple x86_64-apple-macosx10.11.0 -Wdeprecated-objc-isa-usage -Werror=deprecated-objc-isa-usage -emit-obj -mrelax-all -disable-free -disable-llvm-verifier -main-file-name %s -mrelocation-model pic -pic-level 2 -mthread-model posix -mdisable-fp-elim -masm-verbose -munwind-tables -target-cpu core2 -target-linker-version 253.9 -gdwarf-2 -dwarf-column-info -stdlib=libc++ -O0 -Wnon-modular-include-in-framework-module -Wno-trigraphs -Wno-missing-field-initializers -Wno-missing-prototypes -Wreturn-type -Wunreachable-code -Wdeprecated-objc-isa-usage -Wobjc-root-class -Wno-missing-braces -Wparentheses -Wswitch -Wunused-function -Wno-unused-label -Wno-unused-parameter -Wunused-variable -Wunused-value -Wempty-body -Wconditional-uninitialized -Wno-unknown-pragmas -Wno-shadow -Wno-four-char-constants -Wno-conversion -Wconstant-conversion -Wint-conversion -Wbool-conversion -Wenum-conversion -Wshorten-64-to-32 -Wno-newline-eof -Wdeprecated-declarations -Wno-sign-conversion -Wno-non-virtual-dtor -Wno-overloaded-virtual -Wno-exit-time-destructors -Wno-c++11-extensions -Winvalid-offsetof -Wno-inline-new-delete -Wno-shorten-64-to-32 -fdeprecated-macro -ferror-limit 19 -fmessage-length 0 -stack-protector 1 -mstackrealign -fblocks -fobjc-runtime=macosx-10.11.0 -fencode-extended-block-signature -fcxx-exceptions -fexceptions -fmax-type-align=16 -fdiagnostics-show-option -x c++ %s
// RUN: %clang_cc1 -triple arm64-apple-macosx10.11.0 -Wdeprecated-objc-isa-usage -Werror=deprecated-objc-isa-usage -emit-obj -mrelax-all -disable-free -disable-llvm-verifier -main-file-name %s -mrelocation-model pic -pic-level 2 -mthread-model posix -mdisable-fp-elim -masm-verbose -target-cpu cyclone -target-feature +neon -target-feature +crc -target-feature +crypto -target-feature +zcm -target-feature +zcz -target-abi darwinpcs -target-linker-version 253.9 -gdwarf-2 -dwarf-column-info -stdlib=libc++ -O0 -Wnon-modular-include-in-framework-module -Wno-trigraphs -Wno-missing-field-initializers -Wno-missing-prototypes -Wreturn-type -Wunreachable-code -Wdeprecated-objc-isa-usage -Wobjc-root-class -Wno-missing-braces -Wparentheses -Wswitch -Wunused-function -Wno-unused-label -Wno-unused-parameter -Wunused-variable -Wunused-value -Wempty-body -Wconditional-uninitialized -Wno-unknown-pragmas -Wno-shadow -Wno-four-char-constants -Wno-conversion -Wconstant-conversion -Wint-conversion -Wbool-conversion -Wenum-conversion -Wshorten-64-to-32 -Wno-newline-eof -Wdeprecated-declarations -Wno-sign-conversion -Wno-non-virtual-dtor -Wno-overloaded-virtual -Wno-exit-time-destructors -Wno-c++11-extensions -Winvalid-offsetof -Wno-inline-new-delete -Wno-shorten-64-to-32 -fdeprecated-macro -ferror-limit 19 -fmessage-length 0 -stack-protector 1 -mstackrealign -fallow-half-arguments-and-returns -fblocks -fobjc-runtime=macosx-10.11.0 -fencode-extended-block-signature -fcxx-exceptions -fexceptions -fmax-type-align=16 -fdiagnostics-show-option -x c++ %s
// RUN: %clang_cc1 -triple x86_64-apple-macosx10.11.0 -Wdeprecated-objc-isa-usage -Werror=deprecated-objc-isa-usage -emit-obj -disable-free -disable-llvm-verifier -main-file-name %s -mrelocation-model pic -pic-level 2 -mthread-model posix -mdisable-fp-elim -masm-verbose -munwind-tables -target-cpu core2 -target-linker-version 253.9 -gdwarf-2 -dwarf-column-info -stdlib=libc++ -Os -Wnon-modular-include-in-framework-module -Wno-trigraphs -Wno-missing-field-initializers -Wno-missing-prototypes -Wreturn-type -Wunreachable-code -Wdeprecated-objc-isa-usage -Wobjc-root-class -Wno-missing-braces -Wparentheses -Wswitch -Wunused-function -Wno-unused-label -Wno-unused-parameter -Wunused-variable -Wunused-value -Wempty-body -Wconditional-uninitialized -Wno-unknown-pragmas -Wno-shadow -Wno-four-char-constants -Wno-conversion -Wconstant-conversion -Wint-conversion -Wbool-conversion -Wenum-conversion -Wshorten-64-to-32 -Wno-newline-eof -Wdeprecated-declarations -Wno-sign-conversion -Wno-non-virtual-dtor -Wno-overloaded-virtual -Wno-exit-time-destructors -Wno-c++11-extensions -Winvalid-offsetof -Wno-inline-new-delete -Wno-shorten-64-to-32 -fdeprecated-macro -ferror-limit 19 -fmessage-length 0 -stack-protector 1 -mstackrealign -fblocks -fobjc-runtime=macosx-10.11.0 -fencode-extended-block-signature -fcxx-exceptions -fexceptions -fmax-type-align=16 -fdiagnostics-show-option -vectorize-loops -vectorize-slp -x c++ %s
// RUN: %clang_cc1 -triple arm64-apple-macosx10.11.0 -Wdeprecated-objc-isa-usage -Werror=deprecated-objc-isa-usage -emit-obj -disable-free -disable-llvm-verifier -main-file-name %s -mrelocation-model pic -pic-level 2 -mthread-model posix -mdisable-fp-elim -masm-verbose -target-cpu cyclone -target-feature +neon -target-feature +crc -target-feature +crypto -target-feature +zcm -target-feature +zcz -target-abi darwinpcs -target-linker-version 253.9 -gdwarf-2 -dwarf-column-info -stdlib=libc++ -Os -Wnon-modular-include-in-framework-module -Wno-trigraphs -Wno-missing-field-initializers -Wno-missing-prototypes -Wreturn-type -Wunreachable-code -Wdeprecated-objc-isa-usage -Wobjc-root-class -Wno-missing-braces -Wparentheses -Wswitch -Wunused-function -Wno-unused-label -Wno-unused-parameter -Wunused-variable -Wunused-value -Wempty-body -Wconditional-uninitialized -Wno-unknown-pragmas -Wno-shadow -Wno-four-char-constants -Wno-conversion -Wconstant-conversion -Wint-conversion -Wbool-conversion -Wenum-conversion -Wshorten-64-to-32 -Wno-newline-eof -Wdeprecated-declarations -Wno-sign-conversion -Wno-non-virtual-dtor -Wno-overloaded-virtual -Wno-exit-time-destructors -Wno-c++11-extensions -Winvalid-offsetof -Wno-inline-new-delete -Wno-shorten-64-to-32 -fdeprecated-macro -ferror-limit 19 -fmessage-length 0 -stack-protector 1 -mstackrealign -fallow-half-arguments-and-returns -fblocks -fobjc-runtime=macosx-10.11.0 -fencode-extended-block-signature -fcxx-exceptions -fexceptions -fmax-type-align=16 -fdiagnostics-show-option -vectorize-loops -vectorize-slp -x c++ %s
// RUN: %clang_cc1 -triple x86_64-apple-macosx10.11.0 -Wdeprecated-objc-isa-usage -Werror=deprecated-objc-isa-usage -emit-obj -disable-free -disable-llvm-verifier -main-file-name %s -mrelocation-model pic -pic-level 2 -mthread-model posix -mdisable-fp-elim -masm-verbose -munwind-tables -target-cpu core2 -target-linker-version 253.9 -dwarf-column-info -stdlib=libc++ -O2 -Wnon-modular-include-in-framework-module -Wno-trigraphs -Wno-missing-field-initializers -Wno-missing-prototypes -Wreturn-type -Wunreachable-code -Wdeprecated-objc-isa-usage -Wobjc-root-class -Wno-missing-braces -Wparentheses -Wswitch -Wunused-function -Wno-unused-label -Wno-unused-parameter -Wunused-variable -Wunused-value -Wempty-body -Wconditional-uninitialized -Wno-unknown-pragmas -Wno-shadow -Wno-four-char-constants -Wno-conversion -Wconstant-conversion -Wint-conversion -Wbool-conversion -Wenum-conversion -Wshorten-64-to-32 -Wno-newline-eof -Wdeprecated-declarations -Wno-sign-conversion -Wno-non-virtual-dtor -Wno-overloaded-virtual -Wno-exit-time-destructors -Wno-c++11-extensions -Winvalid-offsetof -Wno-inline-new-delete -Wno-shorten-64-to-32 -fdeprecated-macro -ferror-limit 19 -fmessage-length 0 -stack-protector 1 -mstackrealign -fblocks -fobjc-runtime=macosx-10.11.0 -fencode-extended-block-signature -fcxx-exceptions -fexceptions -fmax-type-align=16 -fdiagnostics-show-option -vectorize-loops -vectorize-slp -x c++ %s
// RUN: %clang_cc1 -triple arm64-apple-macosx10.11.0 -Wdeprecated-objc-isa-usage -Werror=deprecated-objc-isa-usage -emit-obj -disable-free -disable-llvm-verifier -main-file-name %s -mrelocation-model pic -pic-level 2 -mthread-model posix -mdisable-fp-elim -masm-verbose -target-cpu cyclone -target-feature +neon -target-feature +crc -target-feature +crypto -target-feature +zcm -target-feature +zcz -target-abi darwinpcs -target-linker-version 253.9 -dwarf-column-info -stdlib=libc++ -O2 -Wnon-modular-include-in-framework-module -Wno-trigraphs -Wno-missing-field-initializers -Wno-missing-prototypes -Wreturn-type -Wunreachable-code -Wdeprecated-objc-isa-usage -Wobjc-root-class -Wno-missing-braces -Wparentheses -Wswitch -Wunused-function -Wno-unused-label -Wno-unused-parameter -Wunused-variable -Wunused-value -Wempty-body -Wconditional-uninitialized -Wno-unknown-pragmas -Wno-shadow -Wno-four-char-constants -Wno-conversion -Wconstant-conversion -Wint-conversion -Wbool-conversion -Wenum-conversion -Wshorten-64-to-32 -Wno-newline-eof -Wdeprecated-declarations -Wno-sign-conversion -Wno-non-virtual-dtor -Wno-overloaded-virtual -Wno-exit-time-destructors -Wno-c++11-extensions -Winvalid-offsetof -Wno-inline-new-delete -Wno-shorten-64-to-32 -fdeprecated-macro -ferror-limit 19 -fmessage-length 0 -stack-protector 1 -mstackrealign -fallow-half-arguments-and-returns -fblocks -fobjc-runtime=macosx-10.11.0 -fencode-extended-block-signature -fcxx-exceptions -fexceptions -fmax-type-align=16 -fdiagnostics-show-option -vectorize-loops -vectorize-slp -x c++ %s
// RUN: %clang_cc1 -triple x86_64-apple-macosx10.11.0 -Wdeprecated-objc-isa-usage -Werror=deprecated-objc-isa-usage -emit-obj -disable-free -disable-llvm-verifier -main-file-name %s -mrelocation-model pic -pic-level 2 -mthread-model posix -mdisable-fp-elim -masm-verbose -munwind-tables -target-cpu core2 -target-linker-version 253.9 -dwarf-column-info -stdlib=libc++ -O3 -Wnon-modular-include-in-framework-module -Wno-trigraphs -Wno-missing-field-initializers -Wno-missing-prototypes -Wreturn-type -Wunreachable-code -Wdeprecated-objc-isa-usage -Wobjc-root-class -Wno-missing-braces -Wparentheses -Wswitch -Wunused-function -Wno-unused-label -Wno-unused-parameter -Wunused-variable -Wunused-value -Wempty-body -Wconditional-uninitialized -Wno-unknown-pragmas -Wno-shadow -Wno-four-char-constants -Wno-conversion -Wconstant-conversion -Wint-conversion -Wbool-conversion -Wenum-conversion -Wshorten-64-to-32 -Wno-newline-eof -Wdeprecated-declarations -Wno-sign-conversion -Wno-non-virtual-dtor -Wno-overloaded-virtual -Wno-exit-time-destructors -Wno-c++11-extensions -Winvalid-offsetof -Wno-inline-new-delete -Wno-shorten-64-to-32 -fdeprecated-macro -ferror-limit 19 -fmessage-length 0 -stack-protector 1 -mstackrealign -fblocks -fobjc-runtime=macosx-10.11.0 -fencode-extended-block-signature -fcxx-exceptions -fexceptions -fmax-type-align=16 -fdiagnostics-show-option -vectorize-loops -vectorize-slp -x c++ %s
// RUN: %clang_cc1 -triple arm64-apple-macosx10.11.0 -Wdeprecated-objc-isa-usage -Werror=deprecated-objc-isa-usage -emit-obj -disable-free -disable-llvm-verifier -main-file-name %s -mrelocation-model pic -pic-level 2 -mthread-model posix -mdisable-fp-elim -masm-verbose -target-cpu cyclone -target-feature +neon -target-feature +crc -target-feature +crypto -target-feature +zcm -target-feature +zcz -target-abi darwinpcs -target-linker-version 253.9 -dwarf-column-info -stdlib=libc++ -O3 -Wnon-modular-include-in-framework-module -Wno-trigraphs -Wno-missing-field-initializers -Wno-missing-prototypes -Wreturn-type -Wunreachable-code -Wdeprecated-objc-isa-usage -Wobjc-root-class -Wno-missing-braces -Wparentheses -Wswitch -Wunused-function -Wno-unused-label -Wno-unused-parameter -Wunused-variable -Wunused-value -Wempty-body -Wconditional-uninitialized -Wno-unknown-pragmas -Wno-shadow -Wno-four-char-constants -Wno-conversion -Wconstant-conversion -Wint-conversion -Wbool-conversion -Wenum-conversion -Wshorten-64-to-32 -Wno-newline-eof -Wdeprecated-declarations -Wno-sign-conversion -Wno-non-virtual-dtor -Wno-overloaded-virtual -Wno-exit-time-destructors -Wno-c++11-extensions -Winvalid-offsetof -Wno-inline-new-delete -Wno-shorten-64-to-32 -fdeprecated-macro -ferror-limit 19 -fmessage-length 0 -stack-protector 1 -mstackrealign -fallow-half-arguments-and-returns -fblocks -fobjc-runtime=macosx-10.11.0 -fencode-extended-block-signature -fcxx-exceptions -fexceptions -fmax-type-align=16 -fdiagnostics-show-option -vectorize-loops -vectorize-slp -x c++ %s
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Interpreter.cpp"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Interpreter.cpp" 1
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 150 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Interpreter.cpp" 2
# 30 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Interpreter.cpp"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/config.h" 1
# 30 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/config.h"
# 1 "./wtf/Platform.h" 1
# 32 "./wtf/Platform.h"
# 1 "./wtf/Compiler.h" 1
# 33 "./wtf/Platform.h" 2
# 320 "./wtf/Platform.h"
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/AvailabilityMacros.h" 1 3 4
# 321 "./wtf/Platform.h" 2
# 335 "./wtf/Platform.h"
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/TargetConditionals.h" 1 3 4
# 336 "./wtf/Platform.h" 2
# 31 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/config.h" 2
# 107 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/config.h"
# 1 "./wtf/FastMalloc.h" 1
# 25 "./wtf/FastMalloc.h"
# 1 "./wtf/PossiblyNull.h" 1
# 29 "./wtf/PossiblyNull.h"
# 1 "./wtf/Assertions.h" 1
# 47 "./wtf/Assertions.h"
# 1 "/Users/ddunbar/rt/11003353/clang-r152231-t20120307_081803-b13838/Developer/usr/bin/../lib/clang/3.1/include/stddef.h" 1 3 4
# 31 "/Users/ddunbar/rt/11003353/clang-r152231-t20120307_081803-b13838/Developer/usr/bin/../lib/clang/3.1/include/stddef.h" 3 4
typedef __typeof__(((int*)0)-((int*)0)) ptrdiff_t;



typedef __typeof__(sizeof(int)) size_t;
# 48 "./wtf/Assertions.h" 2


# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/inttypes.h" 1 3 4
# 245 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/inttypes.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/cdefs.h" 1 3 4
# 417 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/cdefs.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/_symbol_aliasing.h" 1 3 4
# 418 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/cdefs.h" 2 3 4
# 494 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/cdefs.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/_posix_availability.h" 1 3 4
# 495 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/cdefs.h" 2 3 4
# 246 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/inttypes.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/_types.h" 1 3 4
# 27 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/_types.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/_types.h" 1 3 4
# 33 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/_types.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/machine/_types.h" 1 3 4
# 32 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/machine/_types.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/i386/_types.h" 1 3 4
# 37 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/i386/_types.h" 3 4
typedef signed char __int8_t;



typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long long __int64_t;
typedef unsigned long long __uint64_t;

typedef long __darwin_intptr_t;
typedef unsigned int __darwin_natural_t;
# 70 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/i386/_types.h" 3 4
typedef int __darwin_ct_rune_t;





typedef union {
 char __mbstate8[128];
 long long _mbstateL;
} __mbstate_t;

typedef __mbstate_t __darwin_mbstate_t;


typedef long int __darwin_ptrdiff_t;





typedef long unsigned int __darwin_size_t;





typedef __builtin_va_list __darwin_va_list;





typedef int __darwin_wchar_t;




typedef __darwin_wchar_t __darwin_rune_t;


typedef int __darwin_wint_t;




typedef unsigned long __darwin_clock_t;
typedef __uint32_t __darwin_socklen_t;
typedef long __darwin_ssize_t;
typedef long __darwin_time_t;
# 33 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/machine/_types.h" 2 3 4
# 34 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/_types.h" 2 3 4
# 58 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/_types.h" 3 4
struct __darwin_pthread_handler_rec
{
 void (*__routine)(void *);
 void *__arg;
 struct __darwin_pthread_handler_rec *__next;
};
struct _opaque_pthread_attr_t { long __sig; char __opaque[56]; };
struct _opaque_pthread_cond_t { long __sig; char __opaque[40]; };
struct _opaque_pthread_condattr_t { long __sig; char __opaque[8]; };
struct _opaque_pthread_mutex_t { long __sig; char __opaque[56]; };
struct _opaque_pthread_mutexattr_t { long __sig; char __opaque[8]; };
struct _opaque_pthread_once_t { long __sig; char __opaque[8]; };
struct _opaque_pthread_rwlock_t { long __sig; char __opaque[192]; };
struct _opaque_pthread_rwlockattr_t { long __sig; char __opaque[16]; };
struct _opaque_pthread_t { long __sig; struct __darwin_pthread_handler_rec *__cleanup_stack; char __opaque[1168]; };
# 94 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/_types.h" 3 4
typedef __int64_t __darwin_blkcnt_t;
typedef __int32_t __darwin_blksize_t;
typedef __int32_t __darwin_dev_t;
typedef unsigned int __darwin_fsblkcnt_t;
typedef unsigned int __darwin_fsfilcnt_t;
typedef __uint32_t __darwin_gid_t;
typedef __uint32_t __darwin_id_t;
typedef __uint64_t __darwin_ino64_t;

typedef __darwin_ino64_t __darwin_ino_t;



typedef __darwin_natural_t __darwin_mach_port_name_t;
typedef __darwin_mach_port_name_t __darwin_mach_port_t;
typedef __uint16_t __darwin_mode_t;
typedef __int64_t __darwin_off_t;
typedef __int32_t __darwin_pid_t;
typedef struct _opaque_pthread_attr_t
   __darwin_pthread_attr_t;
typedef struct _opaque_pthread_cond_t
   __darwin_pthread_cond_t;
typedef struct _opaque_pthread_condattr_t
   __darwin_pthread_condattr_t;
typedef unsigned long __darwin_pthread_key_t;
typedef struct _opaque_pthread_mutex_t
   __darwin_pthread_mutex_t;
typedef struct _opaque_pthread_mutexattr_t
   __darwin_pthread_mutexattr_t;
typedef struct _opaque_pthread_once_t
   __darwin_pthread_once_t;
typedef struct _opaque_pthread_rwlock_t
   __darwin_pthread_rwlock_t;
typedef struct _opaque_pthread_rwlockattr_t
   __darwin_pthread_rwlockattr_t;
typedef struct _opaque_pthread_t
   *__darwin_pthread_t;
typedef __uint32_t __darwin_sigset_t;
typedef __int32_t __darwin_suseconds_t;
typedef __uint32_t __darwin_uid_t;
typedef __uint32_t __darwin_useconds_t;
typedef unsigned char __darwin_uuid_t[16];
typedef char __darwin_uuid_string_t[37];
# 28 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/_types.h" 2 3 4
# 39 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/_types.h" 3 4
typedef int __darwin_nl_item;
typedef int __darwin_wctrans_t;

typedef __uint32_t __darwin_wctype_t;
# 247 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/inttypes.h" 2 3 4
# 1 "/Users/ddunbar/rt/11003353/clang-r152231-t20120307_081803-b13838/Developer/usr/bin/../lib/clang/3.1/include/stdint.h" 1 3 4
# 33 "/Users/ddunbar/rt/11003353/clang-r152231-t20120307_081803-b13838/Developer/usr/bin/../lib/clang/3.1/include/stdint.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/stdint.h" 1 3 4
# 20 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/stdint.h" 3 4
typedef signed char int8_t;




typedef short int16_t;




typedef int int32_t;




typedef long long int64_t;




typedef unsigned char uint8_t;




typedef unsigned short uint16_t;




typedef unsigned int uint32_t;




typedef unsigned long long uint64_t;



typedef int8_t int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;
typedef uint8_t uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;



typedef int8_t int_fast8_t;
typedef int16_t int_fast16_t;
typedef int32_t int_fast32_t;
typedef int64_t int_fast64_t;
typedef uint8_t uint_fast8_t;
typedef uint16_t uint_fast16_t;
typedef uint32_t uint_fast32_t;
typedef uint64_t uint_fast64_t;






typedef long intptr_t;




typedef unsigned long uintptr_t;







typedef long int intmax_t;
# 106 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/stdint.h" 3 4
typedef long unsigned int uintmax_t;
# 34 "/Users/ddunbar/rt/11003353/clang-r152231-t20120307_081803-b13838/Developer/usr/bin/../lib/clang/3.1/include/stdint.h" 2 3 4
# 248 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/inttypes.h" 2 3 4
# 257 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/inttypes.h" 3 4
extern "C" {


  extern intmax_t imaxabs(intmax_t j);


  typedef struct {
        intmax_t quot;
        intmax_t rem;
  } imaxdiv_t;

  extern imaxdiv_t imaxdiv(intmax_t numer, intmax_t denom);


  extern intmax_t strtoimax(const char * nptr, char ** endptr, int base);
  extern uintmax_t strtoumax(const char * nptr, char ** endptr, int base);
# 282 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/inttypes.h" 3 4
  extern intmax_t wcstoimax(const wchar_t * nptr, wchar_t ** endptr, int base);
  extern uintmax_t wcstoumax(const wchar_t * nptr, wchar_t ** endptr, int base);






}
# 51 "./wtf/Assertions.h" 2
# 128 "./wtf/Assertions.h"
extern "C" {


typedef enum { WTFLogChannelOff, WTFLogChannelOn } WTFLogChannelState;

typedef struct {
    unsigned mask;
    const char *defaultName;
    WTFLogChannelState state;
} WTFLogChannel;

                   void WTFReportAssertionFailure(const char* file, int line, const char* function, const char* assertion);
                   void WTFReportAssertionFailureWithMessage(const char* file, int line, const char* function, const char* assertion, const char* format, ...) __attribute__((__format__(printf, 5, 6)));
                   void WTFReportArgumentAssertionFailure(const char* file, int line, const char* function, const char* argName, const char* assertion);
                   void WTFReportFatalError(const char* file, int line, const char* function, const char* format, ...) __attribute__((__format__(printf, 4, 5)));
                   void WTFReportError(const char* file, int line, const char* function, const char* format, ...) __attribute__((__format__(printf, 4, 5)));
                   void WTFLog(WTFLogChannel*, const char* format, ...) __attribute__((__format__(printf, 2, 3)));
                   void WTFLogVerbose(const char* file, int line, const char* function, WTFLogChannel*, const char* format, ...) __attribute__((__format__(printf, 5, 6)));

                   void WTFGetBacktrace(void** stack, int* size);
                   void WTFReportBacktrace();


}
# 30 "./wtf/PossiblyNull.h" 2

namespace WTF {

template <typename T> struct PossiblyNull {
    PossiblyNull(T data)
        : m_data(data)
    {
    }
    PossiblyNull(const PossiblyNull<T>& source)
        : m_data(source.m_data)
    {
        source.m_data = 0;
    }
    ~PossiblyNull() { ((void)0); }
    bool getValue(T& out) __attribute__ ((warn_unused_result));
private:
    mutable T m_data;
};

template <typename T> bool PossiblyNull<T>::getValue(T& out)
{
    out = m_data;
    bool result = !!m_data;
    m_data = 0;
    return result;
}

}
# 26 "./wtf/FastMalloc.h" 2
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/stdlib.h" 1 3 4
# 61 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/stdlib.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/Availability.h" 1 3 4
# 141 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/Availability.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/AvailabilityInternal.h" 1 3 4
# 142 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/Availability.h" 2 3 4
# 62 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/stdlib.h" 2 3 4



# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/wait.h" 1 3 4
# 79 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/wait.h" 3 4
typedef enum {
 P_ALL,
 P_PID,
 P_PGID
} idtype_t;






typedef __darwin_pid_t pid_t;




typedef __darwin_id_t id_t;
# 116 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/wait.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/signal.h" 1 3 4
# 73 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/signal.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/appleapiopts.h" 1 3 4
# 74 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/signal.h" 2 3 4







# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/machine/signal.h" 1 3 4
# 32 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/machine/signal.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/i386/signal.h" 1 3 4
# 39 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/i386/signal.h" 3 4
typedef int sig_atomic_t;
# 55 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/i386/signal.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/i386/_structs.h" 1 3 4
# 56 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/i386/signal.h" 2 3 4
# 33 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/machine/signal.h" 2 3 4
# 82 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/signal.h" 2 3 4
# 148 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/signal.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/_structs.h" 1 3 4
# 57 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/_structs.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/machine/_structs.h" 1 3 4
# 29 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/machine/_structs.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/i386/_structs.h" 1 3 4
# 38 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/i386/_structs.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 1 3 4
# 43 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_i386_thread_state
{
    unsigned int __eax;
    unsigned int __ebx;
    unsigned int __ecx;
    unsigned int __edx;
    unsigned int __edi;
    unsigned int __esi;
    unsigned int __ebp;
    unsigned int __esp;
    unsigned int __ss;
    unsigned int __eflags;
    unsigned int __eip;
    unsigned int __cs;
    unsigned int __ds;
    unsigned int __es;
    unsigned int __fs;
    unsigned int __gs;
};
# 89 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_fp_control
{
    unsigned short __invalid :1,
        __denorm :1,
    __zdiv :1,
    __ovrfl :1,
    __undfl :1,
    __precis :1,
      :2,
    __pc :2,





    __rc :2,






             :1,
      :3;
};
typedef struct __darwin_fp_control __darwin_fp_control_t;
# 147 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_fp_status
{
    unsigned short __invalid :1,
        __denorm :1,
    __zdiv :1,
    __ovrfl :1,
    __undfl :1,
    __precis :1,
    __stkflt :1,
    __errsumm :1,
    __c0 :1,
    __c1 :1,
    __c2 :1,
    __tos :3,
    __c3 :1,
    __busy :1;
};
typedef struct __darwin_fp_status __darwin_fp_status_t;
# 191 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_mmst_reg
{
 char __mmst_reg[10];
 char __mmst_rsrv[6];
};
# 210 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_xmm_reg
{
 char __xmm_reg[16];
};
# 232 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_i386_float_state
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 char __fpu_rsrv4[14*16];
 int __fpu_reserved1;
};


struct __darwin_i386_avx_state
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 char __fpu_rsrv4[14*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
};
# 402 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_i386_exception_state
{
 __uint16_t __trapno;
 __uint16_t __cpu;
 __uint32_t __err;
 __uint32_t __faultvaddr;
};
# 422 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_debug_state32
{
 unsigned int __dr0;
 unsigned int __dr1;
 unsigned int __dr2;
 unsigned int __dr3;
 unsigned int __dr4;
 unsigned int __dr5;
 unsigned int __dr6;
 unsigned int __dr7;
};
# 454 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_thread_state64
{
 __uint64_t __rax;
 __uint64_t __rbx;
 __uint64_t __rcx;
 __uint64_t __rdx;
 __uint64_t __rdi;
 __uint64_t __rsi;
 __uint64_t __rbp;
 __uint64_t __rsp;
 __uint64_t __r8;
 __uint64_t __r9;
 __uint64_t __r10;
 __uint64_t __r11;
 __uint64_t __r12;
 __uint64_t __r13;
 __uint64_t __r14;
 __uint64_t __r15;
 __uint64_t __rip;
 __uint64_t __rflags;
 __uint64_t __cs;
 __uint64_t __fs;
 __uint64_t __gs;
};
# 509 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_float_state64
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;


 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;

 __uint16_t __fpu_rsrv2;


 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;

 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 struct __darwin_xmm_reg __fpu_xmm8;
 struct __darwin_xmm_reg __fpu_xmm9;
 struct __darwin_xmm_reg __fpu_xmm10;
 struct __darwin_xmm_reg __fpu_xmm11;
 struct __darwin_xmm_reg __fpu_xmm12;
 struct __darwin_xmm_reg __fpu_xmm13;
 struct __darwin_xmm_reg __fpu_xmm14;
 struct __darwin_xmm_reg __fpu_xmm15;
 char __fpu_rsrv4[6*16];
 int __fpu_reserved1;
};


struct __darwin_x86_avx_state64
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;


 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;

 __uint16_t __fpu_rsrv2;


 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;

 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 struct __darwin_xmm_reg __fpu_xmm8;
 struct __darwin_xmm_reg __fpu_xmm9;
 struct __darwin_xmm_reg __fpu_xmm10;
 struct __darwin_xmm_reg __fpu_xmm11;
 struct __darwin_xmm_reg __fpu_xmm12;
 struct __darwin_xmm_reg __fpu_xmm13;
 struct __darwin_xmm_reg __fpu_xmm14;
 struct __darwin_xmm_reg __fpu_xmm15;
 char __fpu_rsrv4[6*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
 struct __darwin_xmm_reg __fpu_ymmh8;
 struct __darwin_xmm_reg __fpu_ymmh9;
 struct __darwin_xmm_reg __fpu_ymmh10;
 struct __darwin_xmm_reg __fpu_ymmh11;
 struct __darwin_xmm_reg __fpu_ymmh12;
 struct __darwin_xmm_reg __fpu_ymmh13;
 struct __darwin_xmm_reg __fpu_ymmh14;
 struct __darwin_xmm_reg __fpu_ymmh15;
};
# 751 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_exception_state64
{
    __uint16_t __trapno;
    __uint16_t __cpu;
    __uint32_t __err;
    __uint64_t __faultvaddr;
};
# 771 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_debug_state64
{
 __uint64_t __dr0;
 __uint64_t __dr1;
 __uint64_t __dr2;
 __uint64_t __dr3;
 __uint64_t __dr4;
 __uint64_t __dr5;
 __uint64_t __dr6;
 __uint64_t __dr7;
};
# 39 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/i386/_structs.h" 2 3 4
# 48 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/i386/_structs.h" 3 4
struct __darwin_mcontext32
{
 struct __darwin_i386_exception_state __es;
 struct __darwin_i386_thread_state __ss;
 struct __darwin_i386_float_state __fs;
};


struct __darwin_mcontext_avx32
{
 struct __darwin_i386_exception_state __es;
 struct __darwin_i386_thread_state __ss;
 struct __darwin_i386_avx_state __fs;
};
# 86 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/i386/_structs.h" 3 4
struct __darwin_mcontext64
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_state64 __ss;
 struct __darwin_x86_float_state64 __fs;
};


struct __darwin_mcontext_avx64
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_state64 __ss;
 struct __darwin_x86_avx_state64 __fs;
};
# 127 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/i386/_structs.h" 3 4
typedef struct __darwin_mcontext64 *mcontext_t;
# 30 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/machine/_structs.h" 2 3 4
# 58 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/_structs.h" 2 3 4
# 75 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/_structs.h" 3 4
struct __darwin_sigaltstack
{
 void *ss_sp;
 __darwin_size_t ss_size;
 int ss_flags;
};
# 128 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/_structs.h" 3 4
struct __darwin_ucontext
{
 int uc_onstack;
 __darwin_sigset_t uc_sigmask;
 struct __darwin_sigaltstack uc_stack;
 struct __darwin_ucontext *uc_link;
 __darwin_size_t uc_mcsize;
 struct __darwin_mcontext64 *uc_mcontext;



};
# 218 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/_structs.h" 3 4
typedef struct __darwin_sigaltstack stack_t;
# 227 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/_structs.h" 3 4
typedef struct __darwin_ucontext ucontext_t;
# 149 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/signal.h" 2 3 4








typedef __darwin_pthread_attr_t pthread_attr_t;




typedef __darwin_sigset_t sigset_t;
# 172 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/signal.h" 3 4
typedef __darwin_uid_t uid_t;


union sigval {

 int sival_int;
 void *sival_ptr;
};





struct sigevent {
 int sigev_notify;
 int sigev_signo;
 union sigval sigev_value;
 void (*sigev_notify_function)(union sigval);
 pthread_attr_t *sigev_notify_attributes;
};


typedef struct __siginfo {
 int si_signo;
 int si_errno;
 int si_code;
 pid_t si_pid;
 uid_t si_uid;
 int si_status;
 void *si_addr;
 union sigval si_value;
 long si_band;
 unsigned long __pad[7];
} siginfo_t;
# 286 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/signal.h" 3 4
union __sigaction_u {
 void (*__sa_handler)(int);
 void (*__sa_sigaction)(int, struct __siginfo *,
         void *);
};


struct __sigaction {
 union __sigaction_u __sigaction_u;
 void (*sa_tramp)(void *, int, int, siginfo_t *, void *);
 sigset_t sa_mask;
 int sa_flags;
};




struct sigaction {
 union __sigaction_u __sigaction_u;
 sigset_t sa_mask;
 int sa_flags;
};
# 348 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/signal.h" 3 4
typedef void (*sig_t)(int);
# 365 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/signal.h" 3 4
struct sigvec {
 void (*sv_handler)(int);
 int sv_mask;
 int sv_flags;
};
# 384 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/signal.h" 3 4
struct sigstack {
 char *ss_sp;
 int ss_onstack;
};
# 406 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/signal.h" 3 4
extern "C" {
void (*signal(int, void (*)(int)))(int);
}
# 117 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/wait.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/resource.h" 1 3 4
# 77 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/resource.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/_structs.h" 1 3 4
# 100 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/_structs.h" 3 4
struct timeval
{
 __darwin_time_t tv_sec;
 __darwin_suseconds_t tv_usec;
};
# 78 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/resource.h" 2 3 4
# 89 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/resource.h" 3 4
typedef __uint64_t rlim_t;
# 151 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/resource.h" 3 4
struct rusage {
 struct timeval ru_utime;
 struct timeval ru_stime;
# 162 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/resource.h" 3 4
 long ru_maxrss;

 long ru_ixrss;
 long ru_idrss;
 long ru_isrss;
 long ru_minflt;
 long ru_majflt;
 long ru_nswap;
 long ru_inblock;
 long ru_oublock;
 long ru_msgsnd;
 long ru_msgrcv;
 long ru_nsignals;
 long ru_nvcsw;
 long ru_nivcsw;


};
# 222 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/resource.h" 3 4
struct rlimit {
 rlim_t rlim_cur;
 rlim_t rlim_max;
};
# 244 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/resource.h" 3 4
extern "C" {
int getpriority(int, id_t);

int getiopolicy_np(int, int) __attribute__((visibility("default")));

int getrlimit(int, struct rlimit *) __asm("_" "getrlimit" );
int getrusage(int, struct rusage *);
int setpriority(int, id_t, int);

int setiopolicy_np(int, int, int) __attribute__((visibility("default")));

int setrlimit(int, const struct rlimit *) __asm("_" "setrlimit" );
}
# 118 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/wait.h" 2 3 4
# 193 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/wait.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/machine/endian.h" 1 3 4
# 35 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/machine/endian.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/i386/endian.h" 1 3 4
# 99 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/i386/endian.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/_endian.h" 1 3 4
# 124 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/_endian.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/_OSByteOrder.h" 1 3 4
# 66 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/_OSByteOrder.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/i386/_OSByteOrder.h" 1 3 4
# 44 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/i386/_OSByteOrder.h" 3 4
static inline
__uint16_t
_OSSwapInt16(
    __uint16_t _data
)
{
    return ((_data << 8) | (_data >> 8));
}

static inline
__uint32_t
_OSSwapInt32(
    __uint32_t _data
)
{

    return __builtin_bswap32(_data);




}


static inline
__uint64_t
_OSSwapInt64(
    __uint64_t _data
)
{
    return __builtin_bswap64(_data);
}
# 67 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/_OSByteOrder.h" 2 3 4
# 125 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/_endian.h" 2 3 4
# 100 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/i386/endian.h" 2 3 4
# 36 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/machine/endian.h" 2 3 4
# 194 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/wait.h" 2 3 4







union wait {
 int w_status;



 struct {

  unsigned int w_Termsig:7,
    w_Coredump:1,
    w_Retcode:8,
    w_Filler:16;







 } w_T;





 struct {

  unsigned int w_Stopval:8,
    w_Stopsig:8,
    w_Filler:16;






 } w_S;
};
# 254 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/wait.h" 3 4
extern "C" {
pid_t wait(int *) __asm("_" "wait" );
pid_t waitpid(pid_t, int *, int) __asm("_" "waitpid" );

int waitid(idtype_t, id_t, siginfo_t *, int) __asm("_" "waitid" );


pid_t wait3(int *, int, struct rusage *);
pid_t wait4(pid_t, int *, int, struct rusage *);

}
# 66 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/stdlib.h" 2 3 4

# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/alloca.h" 1 3 4
# 35 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/alloca.h" 3 4
extern "C" {
void *alloca(size_t);
}
# 68 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/stdlib.h" 2 3 4
# 81 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/stdlib.h" 3 4
typedef __darwin_ct_rune_t ct_rune_t;




typedef __darwin_rune_t rune_t;
# 97 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/stdlib.h" 3 4
typedef struct {
 int quot;
 int rem;
} div_t;

typedef struct {
 long quot;
 long rem;
} ldiv_t;


typedef struct {
 long long quot;
 long long rem;
} lldiv_t;
# 134 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/stdlib.h" 3 4
extern int __mb_cur_max;
# 144 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/stdlib.h" 3 4
extern "C" {
void abort(void) __attribute__((__noreturn__));
int abs(int) __attribute__((__const__));
int atexit(void (*)(void));
double atof(const char *);
int atoi(const char *);
long atol(const char *);

long long
  atoll(const char *);

void *bsearch(const void *, const void *, size_t,
     size_t, int (*)(const void *, const void *));
void *calloc(size_t, size_t);
div_t div(int, int) __attribute__((__const__));
void exit(int) __attribute__((__noreturn__));
void free(void *);
char *getenv(const char *);
long labs(long) __attribute__((__const__));
ldiv_t ldiv(long, long) __attribute__((__const__));

long long
  llabs(long long);
lldiv_t lldiv(long long, long long);

void *malloc(size_t);
int mblen(const char *, size_t);
size_t mbstowcs(wchar_t * , const char * , size_t);
int mbtowc(wchar_t * , const char * , size_t);
int posix_memalign(void **, size_t, size_t) __attribute__((visibility("default")));
void qsort(void *, size_t, size_t,
     int (*)(const void *, const void *));
int rand(void);
void *realloc(void *, size_t);
void srand(unsigned);
double strtod(const char *, char **) __asm("_" "strtod" );
float strtof(const char *, char **) __asm("_" "strtof" );
long strtol(const char *, char **, int);
long double
  strtold(const char *, char **) ;

long long
  strtoll(const char *, char **, int);

unsigned long
  strtoul(const char *, char **, int);

unsigned long long
  strtoull(const char *, char **, int);

int system(const char *) __asm("_" "system" );
size_t wcstombs(char * , const wchar_t * , size_t);
int wctomb(char *, wchar_t);


void _Exit(int) __attribute__((__noreturn__));
long a64l(const char *);
double drand48(void);
char *ecvt(double, int, int *, int *);
double erand48(unsigned short[3]);
char *fcvt(double, int, int *, int *);
char *gcvt(double, int, char *);
int getsubopt(char **, char * const *, char **);
int grantpt(int);

char *initstate(unsigned, char *, size_t);



long jrand48(unsigned short[3]);
char *l64a(long);
void lcong48(unsigned short[7]);
long lrand48(void);
char *mktemp(char *);
int mkstemp(char *);
long mrand48(void);
long nrand48(unsigned short[3]);
int posix_openpt(int);
char *ptsname(int);
int putenv(char *) __asm("_" "putenv" );
long random(void);
int rand_r(unsigned *);

char *realpath(const char * , char * ) __asm("_" "realpath" "$DARWIN_EXTSN");



unsigned short
 *seed48(unsigned short[3]);
int setenv(const char *, const char *, int) __asm("_" "setenv" );

void setkey(const char *) __asm("_" "setkey" );



char *setstate(const char *);
void srand48(long);

void srandom(unsigned);



int unlockpt(int);

int unsetenv(const char *) __asm("_" "unsetenv" );







# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/machine/types.h" 1 3 4
# 35 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/machine/types.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/i386/types.h" 1 3 4
# 80 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/i386/types.h" 3 4
typedef unsigned char u_int8_t;




typedef unsigned short u_int16_t;




typedef unsigned int u_int32_t;




typedef unsigned long long u_int64_t;


typedef int64_t register_t;
# 114 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/i386/types.h" 3 4
typedef u_int64_t user_addr_t;
typedef u_int64_t user_size_t;
typedef int64_t user_ssize_t;
typedef int64_t user_long_t;
typedef u_int64_t user_ulong_t;
typedef int64_t user_time_t;
typedef int64_t user_off_t;







typedef u_int64_t syscall_arg_t;
# 36 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/machine/types.h" 2 3 4
# 256 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/stdlib.h" 2 3 4


typedef __darwin_dev_t dev_t;




typedef __darwin_mode_t mode_t;



u_int32_t
  arc4random(void);
void arc4random_addrandom(unsigned char * , int );
void arc4random_buf(void * , size_t ) __attribute__((visibility("default")));
void arc4random_stir(void);
u_int32_t
  arc4random_uniform(u_int32_t ) __attribute__((visibility("default")));

int atexit_b(void (^)(void)) __attribute__((visibility("default")));
void *bsearch_b(const void *, const void *, size_t,
     size_t, int (^)(const void *, const void *)) __attribute__((visibility("default")));



char *cgetcap(char *, const char *, int);
int cgetclose(void);
int cgetent(char **, char **, const char *);
int cgetfirst(char **, char **);
int cgetmatch(const char *, const char *);
int cgetnext(char **, char **);
int cgetnum(char *, const char *, long *);
int cgetset(const char *);
int cgetstr(char *, const char *, char **);
int cgetustr(char *, const char *, char **);

int daemon(int, int) __asm("_" "daemon" "$1050") __attribute__((deprecated,visibility("default")));
char *devname(dev_t, mode_t);
char *devname_r(dev_t, mode_t, char *buf, int len);
char *getbsize(int *, long *);
int getloadavg(double [], int);
const char
 *getprogname(void);

int heapsort(void *, size_t, size_t,
     int (*)(const void *, const void *));

int heapsort_b(void *, size_t, size_t,
     int (^)(const void *, const void *)) __attribute__((visibility("default")));

int mergesort(void *, size_t, size_t,
     int (*)(const void *, const void *));

int mergesort_b(void *, size_t, size_t,
     int (^)(const void *, const void *)) __attribute__((visibility("default")));

void psort(void *, size_t, size_t,
     int (*)(const void *, const void *)) __attribute__((visibility("default")));

void psort_b(void *, size_t, size_t,
     int (^)(const void *, const void *)) __attribute__((visibility("default")));

void psort_r(void *, size_t, size_t, void *,
     int (*)(void *, const void *, const void *)) __attribute__((visibility("default")));

void qsort_b(void *, size_t, size_t,
     int (^)(const void *, const void *)) __attribute__((visibility("default")));

void qsort_r(void *, size_t, size_t, void *,
     int (*)(void *, const void *, const void *));
int radixsort(const unsigned char **, int, const unsigned char *,
     unsigned);
void setprogname(const char *);
int sradixsort(const unsigned char **, int, const unsigned char *,
     unsigned);
void sranddev(void);
void srandomdev(void);
void *reallocf(void *, size_t);

long long
  strtoq(const char *, char **, int);
unsigned long long
  strtouq(const char *, char **, int);

extern char *suboptarg;
void *valloc(size_t);






}
# 27 "./wtf/FastMalloc.h" 2
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/new" 1 3
# 44 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/new" 3
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cstddef" 1 3
# 48 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cstddef" 3
# 48 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cstddef" 3

# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/c++config.h" 1 3
# 41 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/c++config.h" 3
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/os_defines.h" 1 3
# 61 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/os_defines.h" 3
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/unistd.h" 1 3 4
# 72 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/unistd.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/unistd.h" 1 3 4
# 138 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/unistd.h" 3 4
struct accessx_descriptor {
 unsigned int ad_name_offset;
 int ad_flags;
 int ad_pad[2];
};
# 73 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/unistd.h" 2 3 4




typedef __darwin_gid_t gid_t;
# 87 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/unistd.h" 3 4
typedef __darwin_off_t off_t;
# 104 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/unistd.h" 3 4
typedef __darwin_ssize_t ssize_t;
# 114 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/unistd.h" 3 4
typedef __darwin_useconds_t useconds_t;
# 468 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/unistd.h" 3 4
extern "C" {
void _exit(int) __attribute__((__noreturn__));
int access(const char *, int);
unsigned int
  alarm(unsigned int);
int chdir(const char *);
int chown(const char *, uid_t, gid_t);

int close(int) __asm("_" "close" );

int dup(int);
int dup2(int, int);
int execl(const char *, const char *, ...);
int execle(const char *, const char *, ...);
int execlp(const char *, const char *, ...);
int execv(const char *, char * const *);
int execve(const char *, char * const *, char * const *);
int execvp(const char *, char * const *);
pid_t fork(void);
long fpathconf(int, int);
char *getcwd(char *, size_t);
gid_t getegid(void);
uid_t geteuid(void);
gid_t getgid(void);



int getgroups(int, gid_t []);

char *getlogin(void);
pid_t getpgrp(void);
pid_t getpid(void);
pid_t getppid(void);
uid_t getuid(void);
int isatty(int);
int link(const char *, const char *);
off_t lseek(int, off_t, int);
long pathconf(const char *, int);

int pause(void) __asm("_" "pause" );

int pipe(int [2]);

ssize_t read(int, void *, size_t) __asm("_" "read" );

int rmdir(const char *);
int setgid(gid_t);
int setpgid(pid_t, pid_t);
pid_t setsid(void);
int setuid(uid_t);

unsigned int
  sleep(unsigned int) __asm("_" "sleep" );

long sysconf(int);
pid_t tcgetpgrp(int);
int tcsetpgrp(int, pid_t);
char *ttyname(int);


int ttyname_r(int, char *, size_t) __asm("_" "ttyname_r" );




int unlink(const char *);

ssize_t write(int, const void *, size_t) __asm("_" "write" );
}
# 545 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/unistd.h" 3 4
extern "C" {
size_t confstr(int, char *, size_t) __asm("_" "confstr" );

int getopt(int, char * const [], const char *) __asm("_" "getopt" );

extern char *optarg;
extern int optind, opterr, optopt;
}
# 570 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/unistd.h" 3 4
 extern "C" {




void *brk(const void *);
int chroot(const char *) ;


char *crypt(const char *, const char *);



char *ctermid(char *);


void encrypt(char *, int) __asm("_" "encrypt" );



int fchdir(int);
long gethostid(void);
pid_t getpgid(pid_t);
pid_t getsid(pid_t);



int getdtablesize(void) ;
int getpagesize(void) __attribute__((__const__)) ;
char *getpass(const char *) ;




char *getwd(char *) ;


int lchown(const char *, uid_t, gid_t) __asm("_" "lchown" );

int lockf(int, int, off_t) __asm("_" "lockf" );

int nice(int) __asm("_" "nice" );

ssize_t pread(int, void *, size_t, off_t) __asm("_" "pread" );

ssize_t pwrite(int, const void *, size_t, off_t) __asm("_" "pwrite" );





void *sbrk(int);



pid_t setpgrp(void) __asm("_" "setpgrp" );




int setregid(gid_t, gid_t) __asm("_" "setregid" );

int setreuid(uid_t, uid_t) __asm("_" "setreuid" );

void swab(const void * , void * , ssize_t);
void sync(void);
int truncate(const char *, off_t);
useconds_t ualarm(useconds_t, useconds_t);
int usleep(useconds_t) __asm("_" "usleep" );
pid_t vfork(void);


int fsync(int) __asm("_" "fsync" );

int ftruncate(int, off_t);
int getlogin_r(char *, size_t);
}
# 657 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/unistd.h" 3 4
extern "C" {
int fchown(int, uid_t, gid_t);
int gethostname(char *, size_t);
ssize_t readlink(const char * , char * , size_t);
int setegid(gid_t);
int seteuid(uid_t);
int symlink(const char *, const char *);
}








# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/select.h" 1 3 4
# 78 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/select.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/_structs.h" 1 3 4
# 88 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/_structs.h" 3 4
struct timespec
{
 __darwin_time_t tv_sec;
 long tv_nsec;
};
# 183 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/_structs.h" 3 4
extern "C" {
typedef struct fd_set {
 __int32_t fds_bits[((((1024) % ((sizeof(__int32_t) * 8))) == 0) ? ((1024) / ((sizeof(__int32_t) * 8))) : (((1024) / ((sizeof(__int32_t) * 8))) + 1))];
} fd_set;
}


static inline int
__darwin_fd_isset(int _n, const struct fd_set *_p)
{
 return (_p->fds_bits[_n/(sizeof(__int32_t) * 8)] & (1<<(_n % (sizeof(__int32_t) * 8))));
}
# 79 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/select.h" 2 3 4








typedef __darwin_time_t time_t;




typedef __darwin_suseconds_t suseconds_t;
# 134 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/select.h" 3 4
extern "C" {


int pselect(int, fd_set * , fd_set * ,
  fd_set * , const struct timespec * ,
  const sigset_t * )




  __asm("_" "pselect" "$1050")




  ;



# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/_select.h" 1 3 4
# 39 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/_select.h" 3 4
int select(int, fd_set * , fd_set * ,
  fd_set * , struct timeval * )




  __asm("_" "select" "$1050")




  ;
# 153 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/select.h" 2 3 4

}
# 673 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/unistd.h" 2 3 4
# 686 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/unistd.h" 3 4
typedef __darwin_uuid_t uuid_t;


extern "C" {
void _Exit(int) __attribute__((__noreturn__));
int accessx_np(const struct accessx_descriptor *, size_t, int *, uid_t);
int acct(const char *);
int add_profil(char *, size_t, unsigned long, unsigned int);
void endusershell(void);
int execvP(const char *, const char *, char * const *);
char *fflagstostr(unsigned long);
int getdomainname(char *, int);
int getgrouplist(const char *, int, int *, int *);
int gethostuuid(uuid_t, const struct timespec *) __attribute__((visibility("default")));
mode_t getmode(const void *, mode_t);
int getpeereid(int, uid_t *, gid_t *);
int getsgroups_np(int *, uuid_t);
char *getusershell(void);
int getwgroups_np(int *, uuid_t);
int initgroups(const char *, int);
int iruserok(unsigned long, int, const char *, const char *);
int iruserok_sa(const void *, int, int, const char *, const char *);
int issetugid(void);
char *mkdtemp(char *);
int mknod(const char *, mode_t, dev_t);
int mkstemp(char *);
int mkstemps(char *, int);
char *mktemp(char *);
int nfssvc(int, void *);
int profil(char *, size_t, unsigned long, unsigned int);
int pthread_setugid_np(uid_t, gid_t);
int pthread_getugid_np( uid_t *, gid_t *);
int rcmd(char **, int, const char *, const char *, const char *, int *);
int rcmd_af(char **, int, const char *, const char *, const char *, int *,
  int);
int reboot(int);
int revoke(const char *);
int rresvport(int *);
int rresvport_af(int *, int);
int ruserok(const char *, int, const char *, const char *);
int setdomainname(const char *, int);
int setgroups(int, const gid_t *);
void sethostid(long);
int sethostname(const char *, int);

void setkey(const char *) __asm("_" "setkey" );



int setlogin(const char *);
void *setmode(const char *) __asm("_" "setmode" );
int setrgid(gid_t);
int setruid(uid_t);
int setsgroups_np(int, const uuid_t);
void setusershell(void);
int setwgroups_np(int, const uuid_t);
int strtofflags(char **, unsigned long *, unsigned long *);
int swapon(const char *);
int syscall(int, ...);
int ttyslot(void);
int undelete(const char *);
int unwhiteout(const char *);
void *valloc(size_t);

extern char *suboptarg;
int getsubopt(char **, char * const *, char **);



int fgetattrlist(int,void*,void*,size_t,unsigned int) __attribute__((visibility("default")));
int fsetattrlist(int,void*,void*,size_t,unsigned int) __attribute__((visibility("default")));
int getattrlist(const char*,void*,void*,size_t,unsigned int) __asm("_" "getattrlist" );
int setattrlist(const char*,void*,void*,size_t,unsigned int) __asm("_" "setattrlist" );
int exchangedata(const char*,const char*,unsigned int);
int getdirentriesattr(int,void*,void*,size_t,unsigned int*,unsigned int*,unsigned int*,unsigned int);
# 772 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/unistd.h" 3 4
struct fssearchblock;
struct searchstate;

int searchfs(const char *, struct fssearchblock *, unsigned long *, unsigned int, unsigned int, struct searchstate *);
int fsctl(const char *,unsigned long,void*,unsigned int);
int ffsctl(int,unsigned long,void*,unsigned int) __attribute__((visibility("default")));

extern int optreset;

}
# 62 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/os_defines.h" 2 3


extern "C" {
# 89 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/os_defines.h" 3
extern void __dtrace_probe$cxa_runtime$cxa_exception_rethrow$v1(void);
extern int __dtrace_isenabled$cxa_runtime$cxa_exception_rethrow$v1(void);
extern void __dtrace_probe$cxa_runtime$cxa_exception_throw$v1$766f6964202a(void *);
extern int __dtrace_isenabled$cxa_runtime$cxa_exception_throw$v1(void);


}
# 42 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/c++config.h" 2 3


# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/cpu_defines.h" 1 3
# 45 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/c++config.h" 2 3
# 153 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/c++config.h" 3
namespace std {
# 165 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/c++config.h" 3
}
# 50 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cstddef" 2 3
# 1 "/Users/ddunbar/rt/11003353/clang-r152231-t20120307_081803-b13838/Developer/usr/bin/../lib/clang/3.1/include/stddef.h" 1 3 4
# 51 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cstddef" 2 3

namespace std {

  using ::ptrdiff_t;
  using ::size_t;

}
# 45 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/new" 2 3
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/exception" 1 3
# 40 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/exception" 3
#pragma GCC visibility push(default)



extern "C++" {

namespace std
{
# 56 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/exception" 3
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();



    virtual const char* what() const throw();
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }



    virtual ~bad_exception() throw();


    virtual const char* what() const throw();
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) throw();



  void terminate() __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) throw();



  void unexpected() __attribute__ ((__noreturn__));
# 112 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/exception" 3
  bool uncaught_exception() throw();
}

namespace __gnu_cxx {
# 127 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/exception" 3
  void __verbose_terminate_handler ();

}

}

#pragma GCC visibility pop
# 46 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{





  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };

  struct nothrow_t { };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();
}
# 95 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/new" 3
void* operator new(std::size_t) throw (std::bad_alloc);
void* operator new[](std::size_t) throw (std::bad_alloc);
void operator delete(void*) throw();
void operator delete[](void*) throw();
void* operator new(std::size_t, const std::nothrow_t&) throw();
void* operator new[](std::size_t, const std::nothrow_t&) throw();
void operator delete(void*, const std::nothrow_t&) throw();
void operator delete[](void*, const std::nothrow_t&) throw();


inline void* operator new(std::size_t, void* __p) throw() { return __p; }
inline void* operator new[](std::size_t, void* __p) throw() { return __p; }


inline void operator delete (void*, void*) throw() { }
inline void operator delete[](void*, void*) throw() { }

}

#pragma GCC visibility pop
# 28 "./wtf/FastMalloc.h" 2

namespace WTF {


    void* fastMalloc(size_t);
    void* fastZeroedMalloc(size_t);
    void* fastCalloc(size_t numElements, size_t elementSize);
    void* fastRealloc(void*, size_t);
    char* fastStrDup(const char*);
    size_t fastMallocSize(const void*);

    struct TryMallocReturnValue {
        TryMallocReturnValue(void* data)
            : m_data(data)
        {
        }
        TryMallocReturnValue(const TryMallocReturnValue& source)
            : m_data(source.m_data)
        {
            source.m_data = 0;
        }
        ~TryMallocReturnValue() { ((void)0); }
        template <typename T> bool getValue(T& data) __attribute__ ((warn_unused_result));
        template <typename T> operator PossiblyNull<T>()
        {
            T value;
            getValue(value);
            return PossiblyNull<T>(value);
        }
    private:
        mutable void* m_data;
    };

    template <typename T> bool TryMallocReturnValue::getValue(T& data)
    {
        union u { void* data; T target; } res;
        res.data = m_data;
        data = res.target;
        bool returnValue = !!m_data;
        m_data = 0;
        return returnValue;
    }

    TryMallocReturnValue tryFastMalloc(size_t n);
    TryMallocReturnValue tryFastZeroedMalloc(size_t n);
    TryMallocReturnValue tryFastCalloc(size_t n_elements, size_t element_size);
    TryMallocReturnValue tryFastRealloc(void* p, size_t n);

    void fastFree(void*);






    void releaseFastMallocFreeMemory();

    struct FastMallocStatistics {
        size_t reservedVMBytes;
        size_t committedVMBytes;
        size_t freeListBytes;
    };
    FastMallocStatistics fastMallocStatistics();



    typedef unsigned long long AllocAlignmentInteger;

    namespace Internal {
        enum AllocType {
            AllocTypeMalloc = 0x375d6750,
            AllocTypeClassNew,
            AllocTypeClassNewArray,
            AllocTypeFastNew,
            AllocTypeFastNewArray,
            AllocTypeNew,
            AllocTypeNewArray
        };

        enum {
            ValidationPrefix = 0xf00df00d,
            ValidationSuffix = 0x0badf00d
        };

        typedef unsigned ValidationTag;

        struct ValidationHeader {
            AllocType m_type;
            unsigned m_size;
            ValidationTag m_prefix;
            unsigned m_alignment;
        };

        static const int ValidationBufferSize = sizeof(ValidationHeader) + sizeof(ValidationTag);
    }
# 211 "./wtf/FastMalloc.h"
    inline void fastMallocMatchValidateMalloc(void*, Internal::AllocType)
    {
    }

    inline void fastMallocMatchValidateFree(void*, Internal::AllocType)
    {
    }



}

using WTF::fastCalloc;
using WTF::fastFree;
using WTF::fastMalloc;
using WTF::fastMallocSize;
using WTF::fastRealloc;
using WTF::fastStrDup;
using WTF::fastZeroedMalloc;
using WTF::tryFastCalloc;
using WTF::tryFastMalloc;
using WTF::tryFastRealloc;
using WTF::tryFastZeroedMalloc;
# 265 "./wtf/FastMalloc.h"
extern inline __attribute__((always_inline)) void* operator new(size_t size) throw (std::bad_alloc) { return fastMalloc(size); }
extern inline __attribute__((always_inline)) void* operator new(size_t size, const std::nothrow_t&) throw() { return fastMalloc(size); }
extern inline __attribute__((always_inline)) void operator delete(void* p) throw() { fastFree(p); }
extern inline __attribute__((always_inline)) void operator delete(void* p, const std::nothrow_t&) throw() { fastFree(p); }
extern inline __attribute__((always_inline)) void* operator new[](size_t size) throw (std::bad_alloc) { return fastMalloc(size); }
extern inline __attribute__((always_inline)) void* operator new[](size_t size, const std::nothrow_t&) throw() { return fastMalloc(size); }
extern inline __attribute__((always_inline)) void operator delete[](void* p) throw() { fastFree(p); }
extern inline __attribute__((always_inline)) void operator delete[](void* p, const std::nothrow_t&) throw() { fastFree(p); }
# 108 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/config.h" 2






# 1 "./wtf/DisallowCType.h" 1
# 38 "./wtf/DisallowCType.h"
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/ctype.h" 1 3 4
# 69 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/ctype.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/runetype.h" 1 3 4
# 70 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/runetype.h" 3 4
typedef __darwin_wint_t wint_t;
# 81 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/runetype.h" 3 4
typedef struct {
 __darwin_rune_t __min;
 __darwin_rune_t __max;
 __darwin_rune_t __map;
 __uint32_t *__types;
} _RuneEntry;

typedef struct {
 int __nranges;
 _RuneEntry *__ranges;
} _RuneRange;

typedef struct {
 char __name[14];
 __uint32_t __mask;
} _RuneCharClass;

typedef struct {
 char __magic[8];
 char __encoding[32];

 __darwin_rune_t (*__sgetrune)(const char *, __darwin_size_t, char const **);
 int (*__sputrune)(__darwin_rune_t, char *, __darwin_size_t, char **);
 __darwin_rune_t __invalid_rune;

 __uint32_t __runetype[(1 <<8 )];
 __darwin_rune_t __maplower[(1 <<8 )];
 __darwin_rune_t __mapupper[(1 <<8 )];






 _RuneRange __runetype_ext;
 _RuneRange __maplower_ext;
 _RuneRange __mapupper_ext;

 void *__variable;
 int __variable_len;




 int __ncharclasses;
 _RuneCharClass *__charclasses;
} _RuneLocale;



extern "C" {
extern _RuneLocale _DefaultRuneLocale;
extern _RuneLocale *_CurrentRuneLocale;
}
# 70 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/ctype.h" 2 3 4
# 145 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/ctype.h" 3 4
extern "C" {
unsigned long ___runetype(__darwin_ct_rune_t);
__darwin_ct_rune_t ___tolower(__darwin_ct_rune_t);
__darwin_ct_rune_t ___toupper(__darwin_ct_rune_t);
}

static inline int
isascii(int _c)
{
 return ((_c & ~0x7F) == 0);
}
# 164 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/ctype.h" 3 4
extern "C" {
int __maskrune(__darwin_ct_rune_t, unsigned long);
}


static inline int
__istype(__darwin_ct_rune_t _c, unsigned long _f)
{



 return (isascii(_c) ? !!(_DefaultRuneLocale.__runetype[_c] & _f)
  : !!__maskrune(_c, _f));

}

static inline __darwin_ct_rune_t
__isctype(__darwin_ct_rune_t _c, unsigned long _f)
{



 return (_c < 0 || _c >= (1 <<8 )) ? 0 :
  !!(_DefaultRuneLocale.__runetype[_c] & _f);

}
# 204 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/ctype.h" 3 4
extern "C" {
__darwin_ct_rune_t __toupper(__darwin_ct_rune_t);
__darwin_ct_rune_t __tolower(__darwin_ct_rune_t);
}


static inline int
__wcwidth(__darwin_ct_rune_t _c)
{
 unsigned int _x;

 if (_c == 0)
  return (0);
 _x = (unsigned int)__maskrune(_c, 0xe0000000L|0x00040000L);
 if ((_x & 0xe0000000L) != 0)
  return ((_x & 0xe0000000L) >> 30);
 return ((_x & 0x00040000L) != 0 ? 1 : -1);
}






static inline int
isalnum(int _c)
{
 return (__istype(_c, 0x00000100L|0x00000400L));
}

static inline int
isalpha(int _c)
{
 return (__istype(_c, 0x00000100L));
}

static inline int
isblank(int _c)
{
 return (__istype(_c, 0x00020000L));
}

static inline int
iscntrl(int _c)
{
 return (__istype(_c, 0x00000200L));
}


static inline int
isdigit(int _c)
{
 return (__isctype(_c, 0x00000400L));
}

static inline int
isgraph(int _c)
{
 return (__istype(_c, 0x00000800L));
}

static inline int
islower(int _c)
{
 return (__istype(_c, 0x00001000L));
}

static inline int
isprint(int _c)
{
 return (__istype(_c, 0x00040000L));
}

static inline int
ispunct(int _c)
{
 return (__istype(_c, 0x00002000L));
}

static inline int
isspace(int _c)
{
 return (__istype(_c, 0x00004000L));
}

static inline int
isupper(int _c)
{
 return (__istype(_c, 0x00008000L));
}


static inline int
isxdigit(int _c)
{
 return (__isctype(_c, 0x00010000L));
}

static inline int
toascii(int _c)
{
 return (_c & 0x7F);
}

static inline int
tolower(int _c)
{
        return (__tolower(_c));
}

static inline int
toupper(int _c)
{
        return (__toupper(_c));
}


static inline int
digittoint(int _c)
{
 return (__maskrune(_c, 0x0F));
}

static inline int
ishexnumber(int _c)
{
 return (__istype(_c, 0x00010000L));
}

static inline int
isideogram(int _c)
{
 return (__istype(_c, 0x00080000L));
}

static inline int
isnumber(int _c)
{
 return (__istype(_c, 0x00000400L));
}

static inline int
isphonogram(int _c)
{
 return (__istype(_c, 0x00200000L));
}

static inline int
isrune(int _c)
{
 return (__istype(_c, 0xFFFFFFF0L));
}

static inline int
isspecial(int _c)
{
 return (__istype(_c, 0x00100000L));
}
# 39 "./wtf/DisallowCType.h" 2
# 115 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/config.h" 2
# 31 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Interpreter.cpp" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Interpreter.h" 1
# 32 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Interpreter.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/ArgList.h" 1
# 25 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/ArgList.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/CallFrame.h" 1
# 26 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/CallFrame.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSGlobalData.h" 1
# 32 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSGlobalData.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/CachedTranscendentalFunction.h" 1
# 29 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/CachedTranscendentalFunction.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSValue.h" 1
# 26 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSValue.h"
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/math.h" 1 3 4
# 28 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/math.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/architecture/i386/math.h" 1 3 4
# 36 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/architecture/i386/math.h" 3 4
extern "C" {
# 49 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/architecture/i386/math.h" 3 4
 typedef float float_t;
 typedef double double_t;
# 108 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/architecture/i386/math.h" 3 4
extern int __math_errhandling ( void );
# 128 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/architecture/i386/math.h" 3 4
extern int __fpclassifyf(float );
extern int __fpclassifyd(double );
extern int __fpclassify (long double);
# 163 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/architecture/i386/math.h" 3 4
 static __inline__ int __inline_isfinitef (float ) __attribute__ ((always_inline));
 static __inline__ int __inline_isfinited (double ) __attribute__ ((always_inline));
 static __inline__ int __inline_isfinite (long double) __attribute__ ((always_inline));
 static __inline__ int __inline_isinff (float ) __attribute__ ((always_inline));
 static __inline__ int __inline_isinfd (double ) __attribute__ ((always_inline));
 static __inline__ int __inline_isinf (long double) __attribute__ ((always_inline));
 static __inline__ int __inline_isnanf (float ) __attribute__ ((always_inline));
 static __inline__ int __inline_isnand (double ) __attribute__ ((always_inline));
 static __inline__ int __inline_isnan (long double) __attribute__ ((always_inline));
 static __inline__ int __inline_isnormalf (float ) __attribute__ ((always_inline));
 static __inline__ int __inline_isnormald (double ) __attribute__ ((always_inline));
 static __inline__ int __inline_isnormal (long double) __attribute__ ((always_inline));
 static __inline__ int __inline_signbitf (float ) __attribute__ ((always_inline));
 static __inline__ int __inline_signbitd (double ) __attribute__ ((always_inline));
 static __inline__ int __inline_signbit (long double) __attribute__ ((always_inline));

 static __inline__ int __inline_isinff( float __x ) { return __builtin_fabsf(__x) == __builtin_inff(); }
 static __inline__ int __inline_isinfd( double __x ) { return __builtin_fabs(__x) == __builtin_inf(); }
 static __inline__ int __inline_isinf( long double __x ) { return __builtin_fabsl(__x) == __builtin_infl(); }
 static __inline__ int __inline_isfinitef( float __x ) { return __x == __x && __builtin_fabsf(__x) != __builtin_inff(); }
 static __inline__ int __inline_isfinited( double __x ) { return __x == __x && __builtin_fabs(__x) != __builtin_inf(); }
 static __inline__ int __inline_isfinite( long double __x ) { return __x == __x && __builtin_fabsl(__x) != __builtin_infl(); }
 static __inline__ int __inline_isnanf( float __x ) { return __x != __x; }
 static __inline__ int __inline_isnand( double __x ) { return __x != __x; }
 static __inline__ int __inline_isnan( long double __x ) { return __x != __x; }
 static __inline__ int __inline_signbitf( float __x ) { union{ float __f; unsigned int __u; }__u; __u.__f = __x; return (int)(__u.__u >> 31); }
 static __inline__ int __inline_signbitd( double __x ) { union{ double __f; unsigned int __u[2]; }__u; __u.__f = __x; return (int)(__u.__u[1] >> 31); }
 static __inline__ int __inline_signbit( long double __x ){ union{ long double __ld; struct{ unsigned int __m[2]; short __sexp; }__p; }__u; __u.__ld = __x; return (int) (((unsigned short) __u.__p.__sexp) >> 15); }
 static __inline__ int __inline_isnormalf( float __x ) { float fabsf = __builtin_fabsf(__x); if( __x != __x ) return 0; return fabsf < __builtin_inff() && fabsf >= 1.17549435e-38F; }
 static __inline__ int __inline_isnormald( double __x ) { double fabsf = __builtin_fabs(__x); if( __x != __x ) return 0; return fabsf < __builtin_inf() && fabsf >= 2.2250738585072014e-308; }
 static __inline__ int __inline_isnormal( long double __x ) { long double fabsf = __builtin_fabsl(__x); if( __x != __x ) return 0; return fabsf < __builtin_infl() && fabsf >= 3.36210314311209350626e-4932L; }
# 253 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/architecture/i386/math.h" 3 4
extern double acos( double );
extern float acosf( float );

extern double asin( double );
extern float asinf( float );

extern double atan( double );
extern float atanf( float );

extern double atan2( double, double );
extern float atan2f( float, float );

extern double cos( double );
extern float cosf( float );

extern double sin( double );
extern float sinf( float );

extern double tan( double );
extern float tanf( float );

extern double acosh( double );
extern float acoshf( float );

extern double asinh( double );
extern float asinhf( float );

extern double atanh( double );
extern float atanhf( float );

extern double cosh( double );
extern float coshf( float );

extern double sinh( double );
extern float sinhf( float );

extern double tanh( double );
extern float tanhf( float );

extern double exp ( double );
extern float expf ( float );

extern double exp2 ( double );
extern float exp2f ( float );

extern double expm1 ( double );
extern float expm1f ( float );

extern double log ( double );
extern float logf ( float );

extern double log10 ( double );
extern float log10f ( float );

extern double log2 ( double );
extern float log2f ( float );

extern double log1p ( double );
extern float log1pf ( float );

extern double logb ( double );
extern float logbf ( float );

extern double modf ( double, double * );
extern float modff ( float, float * );

extern double ldexp ( double, int );
extern float ldexpf ( float, int );

extern double frexp ( double, int * );
extern float frexpf ( float, int * );

extern int ilogb ( double );
extern int ilogbf ( float );

extern double scalbn ( double, int );
extern float scalbnf ( float, int );

extern double scalbln ( double, long int );
extern float scalblnf ( float, long int );

extern double fabs( double );
extern float fabsf( float );

extern double cbrt( double );
extern float cbrtf( float );

extern double hypot ( double, double );
extern float hypotf ( float, float );

extern double pow ( double, double );
extern float powf ( float, float );

extern double sqrt( double );
extern float sqrtf( float );

extern double erf( double );
extern float erff( float );

extern double erfc( double );
extern float erfcf( float );






extern double lgamma( double );
extern float lgammaf( float );

extern double tgamma( double );
extern float tgammaf( float );

extern double ceil ( double );
extern float ceilf ( float );

extern double floor ( double );
extern float floorf ( float );

extern double nearbyint ( double );
extern float nearbyintf ( float );

extern double rint ( double );
extern float rintf ( float );

extern long int lrint ( double );
extern long int lrintf ( float );

extern double round ( double );
extern float roundf ( float );

extern long int lround ( double );
extern long int lroundf ( float );



    extern long long int llrint ( double );
    extern long long int llrintf ( float );
    extern long long int llround ( double );
    extern long long int llroundf ( float );


extern double trunc ( double );
extern float truncf ( float );

extern double fmod ( double, double );
extern float fmodf ( float, float );

extern double remainder ( double, double );
extern float remainderf ( float, float );

extern double remquo ( double, double, int * );
extern float remquof ( float, float, int * );

extern double copysign ( double, double );
extern float copysignf ( float, float );

extern double nan( const char * );
extern float nanf( const char * );

extern double nextafter ( double, double );
extern float nextafterf ( float, float );

extern double fdim ( double, double );
extern float fdimf ( float, float );

extern double fmax ( double, double );
extern float fmaxf ( float, float );

extern double fmin ( double, double );
extern float fminf ( float, float );

extern double fma ( double, double, double );
extern float fmaf ( float, float, float );

extern long double acosl(long double);
extern long double asinl(long double);
extern long double atanl(long double);
extern long double atan2l(long double, long double);
extern long double cosl(long double);
extern long double sinl(long double);
extern long double tanl(long double);
extern long double acoshl(long double);
extern long double asinhl(long double);
extern long double atanhl(long double);
extern long double coshl(long double);
extern long double sinhl(long double);
extern long double tanhl(long double);
extern long double expl(long double);
extern long double exp2l(long double);
extern long double expm1l(long double);
extern long double logl(long double);
extern long double log10l(long double);
extern long double log2l(long double);
extern long double log1pl(long double);
extern long double logbl(long double);
extern long double modfl(long double, long double *);
extern long double ldexpl(long double, int);
extern long double frexpl(long double, int *);
extern int ilogbl(long double);
extern long double scalbnl(long double, int);
extern long double scalblnl(long double, long int);
extern long double fabsl(long double);
extern long double cbrtl(long double);
extern long double hypotl(long double, long double);
extern long double powl(long double, long double);
extern long double sqrtl(long double);
extern long double erfl(long double);
extern long double erfcl(long double);






extern long double lgammal(long double);

extern long double tgammal(long double);
extern long double ceill(long double);
extern long double floorl(long double);
extern long double nearbyintl(long double);
extern long double rintl(long double);
extern long int lrintl(long double);
extern long double roundl(long double);
extern long int lroundl(long double);



    extern long long int llrintl(long double);
    extern long long int llroundl(long double);


extern long double truncl(long double);
extern long double fmodl(long double, long double);
extern long double remainderl(long double, long double);
extern long double remquol(long double, long double, int *);
extern long double copysignl(long double, long double);
extern long double nanl(const char *);
extern long double nextafterl(long double, long double);
extern double nexttoward(double, long double);
extern float nexttowardf(float, long double);
extern long double nexttowardl(long double, long double);
extern long double fdiml(long double, long double);
extern long double fmaxl(long double, long double);
extern long double fminl(long double, long double);
extern long double fmal(long double, long double, long double);
# 507 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/architecture/i386/math.h" 3 4
extern double __inf( void );
extern float __inff( void );
extern long double __infl( void );
extern float __nan( void );


extern double j0 ( double );

extern double j1 ( double );

extern double jn ( int, double );

extern double y0 ( double );

extern double y1 ( double );

extern double yn ( int, double );

extern double scalb ( double, double );
# 543 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/architecture/i386/math.h" 3 4
extern int signgam;
# 558 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/architecture/i386/math.h" 3 4
extern long int rinttol ( double );


extern long int roundtol ( double );
# 601 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/architecture/i386/math.h" 3 4
extern int finite ( double );


extern double gamma ( double );
# 615 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/architecture/i386/math.h" 3 4
extern double significand ( double );






extern double drem ( double, double );
# 643 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/architecture/i386/math.h" 3 4
}
# 29 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/math.h" 2 3 4
# 27 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSValue.h" 2
# 1 "/Users/ddunbar/rt/11003353/clang-r152231-t20120307_081803-b13838/Developer/usr/bin/../lib/clang/3.1/include/stddef.h" 1 3 4
# 28 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSValue.h" 2

# 1 "./wtf/AlwaysInline.h" 1
# 30 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSValue.h" 2

# 1 "./wtf/HashMap.h" 1
# 24 "./wtf/HashMap.h"
# 1 "./wtf/HashTable.h" 1
# 26 "./wtf/HashTable.h"
# 1 "./wtf/HashTraits.h" 1
# 24 "./wtf/HashTraits.h"
# 1 "./wtf/HashFunctions.h" 1
# 24 "./wtf/HashFunctions.h"
# 1 "./wtf/RefPtr.h" 1
# 26 "./wtf/RefPtr.h"
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/algorithm" 1 3
# 63 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/algorithm" 3
# 63 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/algorithm" 3

# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algobase.h" 1 3
# 66 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algobase.h" 3
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cstring" 1 3
# 48 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cstring" 3
# 48 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cstring" 3



# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/string.h" 1 3 4
# 79 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/string.h" 3 4
extern "C" {
void *memchr(const void *, int, size_t);
int memcmp(const void *, const void *, size_t);
void *memcpy(void *, const void *, size_t);
void *memmove(void *, const void *, size_t);
void *memset(void *, int, size_t);
char *strcat(char *, const char *);
char *strchr(const char *, int);
int strcmp(const char *, const char *);
int strcoll(const char *, const char *);
char *strcpy(char *, const char *);
size_t strcspn(const char *, const char *);
char *strerror(int) __asm("_" "strerror" );
size_t strlen(const char *);
char *strncat(char *, const char *, size_t);
int strncmp(const char *, const char *, size_t);
char *strncpy(char *, const char *, size_t);
char *strpbrk(const char *, const char *);
char *strrchr(const char *, int);
size_t strspn(const char *, const char *);
char *strstr(const char *, const char *);
char *strtok(char *, const char *);
size_t strxfrm(char *, const char *, size_t);
}
# 113 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/string.h" 3 4
extern "C" {
char *strtok_r(char *, const char *, char **);
}
# 125 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/string.h" 3 4
extern "C" {
int strerror_r(int, char *, size_t);
char *strdup(const char *);
void *memccpy(void *, const void *, int, size_t);
}
# 139 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/string.h" 3 4
extern "C" {
char *stpcpy(char *, const char *);
char *stpncpy(char *, const char *, size_t) __attribute__((visibility("default")));
char *strndup(const char *, size_t) __attribute__((visibility("default")));
size_t strnlen(const char *, size_t) __attribute__((visibility("default")));
char *strsignal(int sig);
}
# 158 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/string.h" 3 4
extern "C" {
void *memmem(const void *, size_t, const void *, size_t) __attribute__((visibility("default")));
void memset_pattern4(void *, const void *, size_t) __attribute__((visibility("default")));
void memset_pattern8(void *, const void *, size_t) __attribute__((visibility("default")));
void memset_pattern16(void *, const void *, size_t) __attribute__((visibility("default")));

char *strcasestr(const char *, const char *);
char *strnstr(const char *, const char *, size_t);
size_t strlcat(char *, const char *, size_t);
size_t strlcpy(char *, const char *, size_t);
void strmode(int, char *);
char *strsep(char **, const char *);


void swab(const void * , void * , ssize_t);
}







# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/strings.h" 1 3 4
# 71 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/strings.h" 3 4
extern "C" {


int bcmp(const void *, const void *, size_t) ;
void bcopy(const void *, void *, size_t) ;
void bzero(void *, size_t) ;
char *index(const char *, int) ;
char *rindex(const char *, int) ;


int ffs(int);
int strcasecmp(const char *, const char *);
int strncasecmp(const char *, const char *, size_t);
}



extern "C" {
int ffsl(long) __attribute__((visibility("default")));
int fls(int) __attribute__((visibility("default")));
int flsl(long) __attribute__((visibility("default")));
}


# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/string.h" 1 3 4
# 95 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/strings.h" 2 3 4
# 181 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/string.h" 2 3 4
# 52 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cstring" 2 3
# 77 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cstring" 3
namespace std {

  using ::memcpy;
  using ::memmove;
  using ::strcpy;
  using ::strncpy;
  using ::strcat;
  using ::strncat;
  using ::memcmp;
  using ::strcmp;
  using ::strcoll;
  using ::strncmp;
  using ::strxfrm;
  using ::strcspn;
  using ::strspn;
  using ::strtok;
  using ::memset;
  using ::strerror;
  using ::strlen;

  using ::memchr;

  inline void*
  memchr(void* __p, int __c, size_t __n)
  { return memchr(const_cast<const void*>(__p), __c, __n); }

  using ::strchr;

  inline char*
  strchr(char* __s1, int __n)
  { return __builtin_strchr(const_cast<const char*>(__s1), __n); }

  using ::strpbrk;

  inline char*
  strpbrk(char* __s1, const char* __s2)
  { return __builtin_strpbrk(const_cast<const char*>(__s1), __s2); }

  using ::strrchr;

  inline char*
  strrchr(char* __s1, int __n)
  { return __builtin_strrchr(const_cast<const char*>(__s1), __n); }

  using ::strstr;

  inline char*
  strstr(char* __s1, const char* __s2)
  { return __builtin_strstr(const_cast<const char*>(__s1), __s2); }

}
# 67 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/climits" 1 3
# 48 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/climits" 3
# 48 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/climits" 3

# 1 "/Users/ddunbar/rt/11003353/clang-r152231-t20120307_081803-b13838/Developer/usr/bin/../lib/clang/3.1/include/limits.h" 1 3 4
# 38 "/Users/ddunbar/rt/11003353/clang-r152231-t20120307_081803-b13838/Developer/usr/bin/../lib/clang/3.1/include/limits.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/limits.h" 1 3 4
# 64 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/limits.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/machine/limits.h" 1 3 4





# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/i386/limits.h" 1 3 4
# 40 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/i386/limits.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/i386/_limits.h" 1 3 4
# 41 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/i386/limits.h" 2 3 4
# 7 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/machine/limits.h" 2 3 4
# 65 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/limits.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/syslimits.h" 1 3 4
# 66 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/limits.h" 2 3 4
# 39 "/Users/ddunbar/rt/11003353/clang-r152231-t20120307_081803-b13838/Developer/usr/bin/../lib/clang/3.1/include/limits.h" 2 3 4
# 50 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/climits" 2 3
# 68 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cstdlib" 1 3
# 48 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cstdlib" 3
# 48 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cstdlib" 3
# 103 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cstdlib" 3
namespace std {

  using ::div_t;
  using ::ldiv_t;

  using ::abort;
  using ::abs;
  using ::atexit;
  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;
  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;


  inline long
  abs(long __i) { return labs(__i); }

  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }

}
# 160 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cstdlib" 3
namespace __gnu_cxx {


  using ::lldiv_t;





  using ::_Exit;


  inline long long
  abs(long long __x) { return __x >= 0 ? __x : -__x; }


  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 193 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;

}

namespace std {


  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;
  using ::__gnu_cxx::abs;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;

}
# 69 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3

# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/iosfwd" 1 3
# 42 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/iosfwd" 3
# 42 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/iosfwd" 3


# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/c++locale.h" 1 3
# 45 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/c++locale.h" 3
# 45 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/c++locale.h" 3

# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/clocale" 1 3
# 48 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/clocale" 3
# 48 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/clocale" 3


# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/locale.h" 1 3 4
# 40 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/locale.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/_locale.h" 1 3 4
# 43 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/_locale.h" 3 4
struct lconv {
 char *decimal_point;
 char *thousands_sep;
 char *grouping;
 char *int_curr_symbol;
 char *currency_symbol;
 char *mon_decimal_point;
 char *mon_thousands_sep;
 char *mon_grouping;
 char *positive_sign;
 char *negative_sign;
 char int_frac_digits;
 char frac_digits;
 char p_cs_precedes;
 char p_sep_by_space;
 char n_cs_precedes;
 char n_sep_by_space;
 char p_sign_posn;
 char n_sign_posn;
 char int_p_cs_precedes;
 char int_n_cs_precedes;
 char int_p_sep_by_space;
 char int_n_sep_by_space;
 char int_p_sign_posn;
 char int_n_sign_posn;
};





extern "C" {
struct lconv *localeconv(void);
}
# 41 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/locale.h" 2 3 4
# 52 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/locale.h" 3 4
extern "C" {
char *setlocale(int, const char *);
}
# 51 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/clocale" 2 3





namespace std {

  using ::lconv;
  using ::setlocale;
  using ::localeconv;

}
# 47 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/c++locale.h" 2 3

# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cstdio" 1 3
# 48 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cstdio" 3
# 48 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cstdio" 3




# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/stdio.h" 1 3 4
# 73 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/stdio.h" 3 4
typedef __darwin_va_list va_list;
# 85 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/stdio.h" 3 4
typedef __darwin_off_t fpos_t;
# 96 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/stdio.h" 3 4
struct __sbuf {
 unsigned char *_base;
 int _size;
};


struct __sFILEX;
# 130 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/stdio.h" 3 4
typedef struct __sFILE {
 unsigned char *_p;
 int _r;
 int _w;
 short _flags;
 short _file;
 struct __sbuf _bf;
 int _lbfsize;


 void *_cookie;
 int (*_close)(void *);
 int (*_read) (void *, char *, int);
 fpos_t (*_seek) (void *, fpos_t, int);
 int (*_write)(void *, const char *, int);


 struct __sbuf _ub;
 struct __sFILEX *_extra;
 int _ur;


 unsigned char _ubuf[3];
 unsigned char _nbuf[1];


 struct __sbuf _lb;


 int _blksize;
 fpos_t _offset;
} FILE;

extern "C" {
extern FILE *__stdinp;
extern FILE *__stdoutp;
extern FILE *__stderrp;
}
# 238 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/stdio.h" 3 4
extern "C" {
void clearerr(FILE *);
int fclose(FILE *);
int feof(FILE *);
int ferror(FILE *);
int fflush(FILE *);
int fgetc(FILE *);
int fgetpos(FILE * , fpos_t *);
char *fgets(char * , int, FILE *);



FILE *fopen(const char * , const char * ) __asm("_" "fopen" );

int fprintf(FILE * , const char * , ...) __attribute__((__format__ (__printf__, 2, 3)));
int fputc(int, FILE *);
int fputs(const char * , FILE * ) __asm("_" "fputs" );
size_t fread(void * , size_t, size_t, FILE * );
FILE *freopen(const char * , const char * ,
                 FILE * ) __asm("_" "freopen" );
int fscanf(FILE * , const char * , ...) __attribute__((__format__ (__scanf__, 2, 3)));
int fseek(FILE *, long, int);
int fsetpos(FILE *, const fpos_t *);
long ftell(FILE *);
size_t fwrite(const void * , size_t, size_t, FILE * ) __asm("_" "fwrite" );
int getc(FILE *);
int getchar(void);
char *gets(char *);
void perror(const char *);
int printf(const char * , ...) __attribute__((__format__ (__printf__, 1, 2)));
int putc(int, FILE *);
int putchar(int);
int puts(const char *);
int remove(const char *);
int rename (const char *, const char *);
void rewind(FILE *);
int scanf(const char * , ...) __attribute__((__format__ (__scanf__, 1, 2)));
void setbuf(FILE * , char * );
int setvbuf(FILE * , char * , int, size_t);
int sprintf(char * , const char * , ...) __attribute__((__format__ (__printf__, 2, 3)));
int sscanf(const char * , const char * , ...) __attribute__((__format__ (__scanf__, 2, 3)));
FILE *tmpfile(void);
char *tmpnam(char *);
int ungetc(int, FILE *);
int vfprintf(FILE * , const char * , va_list) __attribute__((__format__ (__printf__, 2, 0)));
int vprintf(const char * , va_list) __attribute__((__format__ (__printf__, 1, 0)));
int vsprintf(char * , const char * , va_list) __attribute__((__format__ (__printf__, 2, 0)));
}
# 296 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/stdio.h" 3 4
extern "C" {
# 306 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/stdio.h" 3 4
FILE *fdopen(int, const char *) __asm("_" "fdopen" );

int fileno(FILE *);
}
# 318 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/stdio.h" 3 4
extern "C" {
int pclose(FILE *);



FILE *popen(const char *, const char *) __asm("_" "popen" );

}
# 340 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/stdio.h" 3 4
extern "C" {
int __srget(FILE *);
int __svfscanf(FILE *, const char *, va_list) __attribute__((__format__ (__scanf__, 2, 0)));
int __swbuf(int, FILE *);
}







static inline int __sputc(int _c, FILE *_p) {
 if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
  return (*_p->_p++ = _c);
 else
  return (__swbuf(_c, _p));
}
# 377 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/stdio.h" 3 4
extern "C" {
void flockfile(FILE *);
int ftrylockfile(FILE *);
void funlockfile(FILE *);
int getc_unlocked(FILE *);
int getchar_unlocked(void);
int putc_unlocked(int, FILE *);
int putchar_unlocked(int);



int getw(FILE *);
int putw(int, FILE *);


char *tempnam(const char *, const char *) __asm("_" "tempnam" );
}
# 417 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/stdio.h" 3 4
extern "C" {
int fseeko(FILE *, off_t, int);
off_t ftello(FILE *);
}



extern "C" {
int snprintf(char * , size_t, const char * , ...) __attribute__((__format__ (__printf__, 3, 4)));
int vfscanf(FILE * , const char * , va_list) __attribute__((__format__ (__scanf__, 2, 0)));
int vscanf(const char * , va_list) __attribute__((__format__ (__scanf__, 1, 0)));
int vsnprintf(char * , size_t, const char * , va_list) __attribute__((__format__ (__printf__, 3, 0)));
int vsscanf(const char * , const char * , va_list) __attribute__((__format__ (__scanf__, 2, 0)));
}
# 445 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/stdio.h" 3 4
extern "C" {
int dprintf(int, const char * , ...) __attribute__((__format__ (__printf__, 2, 3))) __attribute__((visibility("default")));
int vdprintf(int, const char * , va_list) __attribute__((__format__ (__printf__, 2, 0))) __attribute__((visibility("default")));
ssize_t getdelim(char ** , size_t * , int, FILE * ) __attribute__((visibility("default")));
ssize_t getline(char ** , size_t * , FILE * ) __attribute__((visibility("default")));
}







extern "C" {
extern const int sys_nerr;
extern const char *const sys_errlist[];

int asprintf(char **, const char *, ...) __attribute__((__format__ (__printf__, 2, 3)));
char *ctermid_r(char *);
char *fgetln(FILE *, size_t *);
const char *fmtcheck(const char *, const char *);
int fpurge(FILE *);
void setbuffer(FILE *, char *, int);
int setlinebuf(FILE *);
int vasprintf(char **, const char *, va_list) __attribute__((__format__ (__printf__, 2, 0)));
FILE *zopen(const char *, const char *, int);





FILE *funopen(const void *,
                 int (*)(void *, char *, int),
                 int (*)(void *, const char *, int),
                 fpos_t (*)(void *, fpos_t, int),
                 int (*)(void *));
}
# 53 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cstdio" 2 3
# 97 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cstdio" 3
namespace std {

  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;
  using ::gets;
  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;
  using ::tmpnam;
  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;

}
# 154 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cstdio" 3
namespace __gnu_cxx {
# 169 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;


}

namespace std {

  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;

}
# 49 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/c++locale.h" 2 3
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cstdarg" 1 3
# 48 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cstdarg" 3
# 48 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cstdarg" 3


# 1 "/Users/ddunbar/rt/11003353/clang-r152231-t20120307_081803-b13838/Developer/usr/bin/../lib/clang/3.1/include/stdarg.h" 1 3 4
# 48 "/Users/ddunbar/rt/11003353/clang-r152231-t20120307_081803-b13838/Developer/usr/bin/../lib/clang/3.1/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 51 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cstdarg" 2 3






namespace std {

  using ::va_list;

}
# 50 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/c++locale.h" 2 3



namespace std {

  typedef int* __c_locale;





  inline int
  __convert_from_v(const __c_locale&, char* __out,
     const int __size __attribute__((__unused__)),
     const char* __fmt, ...)
  {
    char* __old = std::setlocale(4, __null);
    char* __sav = __null;
    if (std::strcmp(__old, "C"))
      {
 __sav = new char[std::strlen(__old) + 1];
 std::strcpy(__sav, __old);
 std::setlocale(4, "C");
      }

    va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = std::vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);

    if (__sav)
      {
 std::setlocale(4, __sav);
 delete [] __sav;
      }
    return __ret;
  }

}
# 45 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/iosfwd" 2 3
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/c++io.h" 1 3
# 43 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/c++io.h" 3
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/gthr.h" 1 3
# 33 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/gthr.h" 3
#pragma GCC visibility push(default)
# 114 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/gthr.h" 3
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/gthr-default.h" 1 3
# 43 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/gthr-default.h" 3
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/pthread.h" 1 3 4
# 57 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/pthread.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/pthread_impl.h" 1 3 4
# 58 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/pthread.h" 2 3 4

# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sched.h" 1 3 4
# 30 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sched.h" 3 4
extern "C" {




struct sched_param { int sched_priority; char __opaque[4]; };


extern int sched_yield(void);
extern int sched_get_priority_min(int);
extern int sched_get_priority_max(int);
}
# 60 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/time.h" 1 3 4
# 69 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/time.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/_structs.h" 1 3 4
# 24 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/_structs.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/_structs.h" 1 3 4
# 25 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/_structs.h" 2 3 4
# 70 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/time.h" 2 3 4







typedef __darwin_clock_t clock_t;
# 90 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/time.h" 3 4
struct tm {
 int tm_sec;
 int tm_min;
 int tm_hour;
 int tm_mday;
 int tm_mon;
 int tm_year;
 int tm_wday;
 int tm_yday;
 int tm_isdst;
 long tm_gmtoff;
 char *tm_zone;
};
# 113 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/time.h" 3 4
extern char *tzname[];


extern int getdate_err;

extern long timezone __asm("_" "timezone" );

extern int daylight;

extern "C" {
char *asctime(const struct tm *);
clock_t clock(void) __asm("_" "clock" );
char *ctime(const time_t *);
double difftime(time_t, time_t);
struct tm *getdate(const char *);
struct tm *gmtime(const time_t *);
struct tm *localtime(const time_t *);
time_t mktime(struct tm *) __asm("_" "mktime" );
size_t strftime(char * , size_t, const char * , const struct tm * ) __asm("_" "strftime" );
char *strptime(const char * , const char * , struct tm * ) __asm("_" "strptime" );
time_t time(time_t *);


void tzset(void);



char *asctime_r(const struct tm * , char * );
char *ctime_r(const time_t *, char *);
struct tm *gmtime_r(const time_t * , struct tm * );
struct tm *localtime_r(const time_t * , struct tm * );


time_t posix2time(time_t);



void tzsetwall(void);
time_t time2posix(time_t);
time_t timelocal(struct tm * const);
time_t timegm(struct tm * const);



int nanosleep(const struct timespec *, struct timespec *) __asm("_" "nanosleep" );

}
# 61 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/pthread.h" 2 3 4








typedef __darwin_pthread_cond_t pthread_cond_t;




typedef __darwin_pthread_condattr_t pthread_condattr_t;




typedef __darwin_pthread_key_t pthread_key_t;




typedef __darwin_pthread_mutex_t pthread_mutex_t;




typedef __darwin_pthread_mutexattr_t pthread_mutexattr_t;




typedef __darwin_pthread_once_t pthread_once_t;




typedef __darwin_pthread_rwlock_t pthread_rwlock_t;




typedef __darwin_pthread_rwlockattr_t pthread_rwlockattr_t;




typedef __darwin_pthread_t pthread_t;






typedef __darwin_mach_port_t mach_port_t;
# 149 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/pthread.h" 3 4
extern "C" {
# 250 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/pthread.h" 3 4
int pthread_atfork(void (*)(void), void (*)(void),
                      void (*)(void));
int pthread_attr_destroy(pthread_attr_t *);
int pthread_attr_getdetachstate(const pthread_attr_t *,
          int *);
int pthread_attr_getguardsize(const pthread_attr_t * ,
                                      size_t * );
int pthread_attr_getinheritsched(const pthread_attr_t * ,
           int * );
int pthread_attr_getschedparam(const pthread_attr_t * ,
                                     struct sched_param * );
int pthread_attr_getschedpolicy(const pthread_attr_t * ,
          int * );
int pthread_attr_getscope(const pthread_attr_t * , int * );
int pthread_attr_getstack(const pthread_attr_t * ,
                                      void ** , size_t * );
int pthread_attr_getstackaddr(const pthread_attr_t * ,
                                      void ** );
int pthread_attr_getstacksize(const pthread_attr_t * ,
                                      size_t * );
int pthread_attr_init(pthread_attr_t *);
int pthread_attr_setdetachstate(pthread_attr_t *,
          int );
int pthread_attr_setguardsize(pthread_attr_t *, size_t );
int pthread_attr_setinheritsched(pthread_attr_t *,
           int );
int pthread_attr_setschedparam(pthread_attr_t * ,
                                     const struct sched_param * );
int pthread_attr_setschedpolicy(pthread_attr_t *,
          int );
int pthread_attr_setscope(pthread_attr_t *, int);
int pthread_attr_setstack(pthread_attr_t *,
                                      void *, size_t );
int pthread_attr_setstackaddr(pthread_attr_t *,
                                      void *);
int pthread_attr_setstacksize(pthread_attr_t *, size_t );
int pthread_cancel(pthread_t ) __asm("_" "pthread_cancel" );

int pthread_cond_broadcast(pthread_cond_t *);
int pthread_cond_destroy(pthread_cond_t *);
int pthread_cond_init(pthread_cond_t * ,
                            const pthread_condattr_t * ) __asm("_" "pthread_cond_init" );
int pthread_cond_signal(pthread_cond_t *);
int pthread_cond_timedwait(pthread_cond_t * ,
     pthread_mutex_t * ,
     const struct timespec * ) __asm("_" "pthread_cond_timedwait" );
int pthread_cond_wait(pthread_cond_t * ,
       pthread_mutex_t * ) __asm("_" "pthread_cond_wait" );
int pthread_condattr_destroy(pthread_condattr_t *);
int pthread_condattr_init(pthread_condattr_t *);
int pthread_condattr_getpshared(const pthread_condattr_t * ,
   int * );
int pthread_condattr_setpshared(pthread_condattr_t *,
   int );
int pthread_create(pthread_t * ,
                         const pthread_attr_t * ,
                         void *(*)(void *),
                         void * );
int pthread_detach(pthread_t );
int pthread_equal(pthread_t ,
   pthread_t );
void pthread_exit(void *) __attribute__((__noreturn__));
int pthread_getconcurrency(void);
int pthread_getschedparam(pthread_t , int * , struct sched_param * );
void *pthread_getspecific(pthread_key_t );
int pthread_join(pthread_t , void **) __asm("_" "pthread_join" );
int pthread_key_create(pthread_key_t *, void (*)(void *));
int pthread_key_delete(pthread_key_t );
int pthread_mutex_destroy(pthread_mutex_t *);
int pthread_mutex_getprioceiling(const pthread_mutex_t * , int * );
int pthread_mutex_init(pthread_mutex_t * , const pthread_mutexattr_t * );
int pthread_mutex_lock(pthread_mutex_t *);
int pthread_mutex_setprioceiling(pthread_mutex_t * , int, int * );
int pthread_mutex_trylock(pthread_mutex_t *);
int pthread_mutex_unlock(pthread_mutex_t *);
int pthread_mutexattr_destroy(pthread_mutexattr_t *) __asm("_" "pthread_mutexattr_destroy" );
int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t * , int * );
int pthread_mutexattr_getprotocol(const pthread_mutexattr_t * , int * );
int pthread_mutexattr_getpshared(const pthread_mutexattr_t * , int * );
int pthread_mutexattr_gettype(const pthread_mutexattr_t * , int * );
int pthread_mutexattr_init(pthread_mutexattr_t *);
int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int);
int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int);
int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int );
int pthread_mutexattr_settype(pthread_mutexattr_t *, int);
int pthread_once(pthread_once_t *, void (*)(void));
int pthread_rwlock_destroy(pthread_rwlock_t * ) __asm("_" "pthread_rwlock_destroy" );
int pthread_rwlock_init(pthread_rwlock_t * , const pthread_rwlockattr_t * ) __asm("_" "pthread_rwlock_init" );
int pthread_rwlock_rdlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_rdlock" );
int pthread_rwlock_tryrdlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_tryrdlock" );
int pthread_rwlock_trywrlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_trywrlock" );
int pthread_rwlock_wrlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_wrlock" );
int pthread_rwlock_unlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_unlock" );
int pthread_rwlockattr_destroy(pthread_rwlockattr_t *);
int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t * ,
   int * );
int pthread_rwlockattr_init(pthread_rwlockattr_t *);
int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *,
   int );
pthread_t pthread_self(void);

int pthread_setcancelstate(int , int *) __asm("_" "pthread_setcancelstate" );
int pthread_setcanceltype(int , int *) __asm("_" "pthread_setcanceltype" );
int pthread_setconcurrency(int);
int pthread_setschedparam(pthread_t ,
    int ,
                                const struct sched_param *);
int pthread_setspecific(pthread_key_t ,
         const void *);
void pthread_testcancel(void) __asm("_" "pthread_testcancel" );



int pthread_is_threaded_np(void);

int pthread_threadid_np(pthread_t,__uint64_t*) __attribute__((visibility("default")));

int pthread_rwlock_longrdlock_np(pthread_rwlock_t *) __attribute__((visibility("default")));
int pthread_rwlock_yieldwrlock_np(pthread_rwlock_t *) __attribute__((visibility("default")));
int pthread_rwlock_downgrade_np(pthread_rwlock_t *);
int pthread_rwlock_upgrade_np(pthread_rwlock_t *);
int pthread_rwlock_tryupgrade_np(pthread_rwlock_t *);
int pthread_rwlock_held_np(pthread_rwlock_t *);
int pthread_rwlock_rdheld_np(pthread_rwlock_t *);
int pthread_rwlock_wrheld_np(pthread_rwlock_t *);


int pthread_getname_np(pthread_t,char*,size_t) __attribute__((visibility("default")));
int pthread_setname_np(const char*) __attribute__((visibility("default")));

int pthread_main_np(void);


mach_port_t pthread_mach_thread_np(pthread_t);
size_t pthread_get_stacksize_np(pthread_t);
void * pthread_get_stackaddr_np(pthread_t);


int pthread_cond_signal_thread_np(pthread_cond_t *, pthread_t);


int pthread_cond_timedwait_relative_np(pthread_cond_t *,
     pthread_mutex_t *,
     const struct timespec *);


int pthread_create_suspended_np(pthread_t *,
                         const pthread_attr_t *,
                         void *(*)(void *),
                         void *);
int pthread_kill(pthread_t, int);

pthread_t pthread_from_mach_thread_np(mach_port_t) __attribute__((visibility("default")));

int pthread_sigmask(int, const sigset_t *, sigset_t *) __asm("_" "pthread_sigmask" );
void pthread_yield_np(void);

}
# 44 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/gthr-default.h" 2 3


typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
# 214 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  return 1;
}
# 571 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/gthr-default.h" 3
static inline int
__gthread_once (__gthread_once_t *once, void (*func) (void))
{
  if (__gthread_active_p ())
    return pthread_once (once, func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))
{
  return pthread_key_create (key, dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t key)
{
  return pthread_key_delete (key);
}

static inline void *
__gthread_getspecific (__gthread_key_t key)
{
  return pthread_getspecific (key);
}

static inline int
__gthread_setspecific (__gthread_key_t key, const void *ptr)
{
  return pthread_setspecific (key, ptr);
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_lock (mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_trylock (mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_unlock (__gthread_mutex_t *mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_unlock (mutex);
  else
    return 0;
}


static inline int
__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *mutex)
{
  if (__gthread_active_p ())
    {
      pthread_mutexattr_t attr;
      int r;

      r = pthread_mutexattr_init (&attr);
      if (!r)
 r = pthread_mutexattr_settype (&attr, 2);
      if (!r)
 r = pthread_mutex_init (mutex, &attr);
      if (!r)
 r = pthread_mutexattr_destroy (&attr);
      return r;
    }
  return 0;
}


static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex)
{
  return __gthread_mutex_lock (mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex)
{
  return __gthread_mutex_trylock (mutex);
}

static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)
{
  return __gthread_mutex_unlock (mutex);
}
# 115 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/gthr.h" 2 3







#pragma GCC visibility pop
# 44 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/c++io.h" 2 3

namespace std {

  typedef __gthread_mutex_t __c_lock;


  typedef FILE __c_file;

}
# 46 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/iosfwd" 2 3
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cctype" 1 3
# 48 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cctype" 3
# 48 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cctype" 3
# 67 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cctype" 3
namespace std {

  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;

}
# 47 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/iosfwd" 2 3
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stringfwd.h" 1 3
# 42 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stringfwd.h" 3
# 42 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stringfwd.h" 3



namespace std {

  template<typename _Alloc>
    class allocator;

  template<class _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;

  template<> struct char_traits<char>;

  typedef basic_string<char> string;


  template<> struct char_traits<wchar_t>;

  typedef basic_string<wchar_t> wstring;


}
# 48 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/iosfwd" 2 3
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/postypes.h" 1 3
# 44 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/postypes.h" 3
# 44 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/postypes.h" 3

# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cwchar" 1 3
# 48 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cwchar" 3
# 48 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cwchar" 3



# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/ctime" 1 3
# 48 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/ctime" 3
# 48 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/ctime" 3
# 63 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/ctime" 3
namespace std {

  using ::clock_t;
  using ::time_t;
  using ::tm;

  using ::clock;
  using ::difftime;
  using ::mktime;
  using ::time;
  using ::asctime;
  using ::ctime;
  using ::gmtime;
  using ::localtime;
  using ::strftime;

}
# 52 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cwchar" 2 3


# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/wchar.h" 1 3 4
# 85 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/wchar.h" 3 4
typedef __darwin_mbstate_t mbstate_t;
# 116 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/wchar.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/_wctype.h" 1 3 4
# 52 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/_wctype.h" 3 4
typedef __darwin_wctype_t wctype_t;
# 71 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/_wctype.h" 3 4
static inline int
iswalnum(wint_t _wc)
{
 return (__istype(_wc, 0x00000100L|0x00000400L));
}

static inline int
iswalpha(wint_t _wc)
{
 return (__istype(_wc, 0x00000100L));
}

static inline int
iswcntrl(wint_t _wc)
{
 return (__istype(_wc, 0x00000200L));
}

static inline int
iswctype(wint_t _wc, wctype_t _charclass)
{
 return (__istype(_wc, _charclass));
}

static inline int
iswdigit(wint_t _wc)
{
 return (__isctype(_wc, 0x00000400L));
}

static inline int
iswgraph(wint_t _wc)
{
 return (__istype(_wc, 0x00000800L));
}

static inline int
iswlower(wint_t _wc)
{
 return (__istype(_wc, 0x00001000L));
}

static inline int
iswprint(wint_t _wc)
{
 return (__istype(_wc, 0x00040000L));
}

static inline int
iswpunct(wint_t _wc)
{
 return (__istype(_wc, 0x00002000L));
}

static inline int
iswspace(wint_t _wc)
{
 return (__istype(_wc, 0x00004000L));
}

static inline int
iswupper(wint_t _wc)
{
 return (__istype(_wc, 0x00008000L));
}

static inline int
iswxdigit(wint_t _wc)
{
 return (__isctype(_wc, 0x00010000L));
}

static inline wint_t
towlower(wint_t _wc)
{
        return (__tolower(_wc));
}

static inline wint_t
towupper(wint_t _wc)
{
        return (__toupper(_wc));
}
# 176 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/_wctype.h" 3 4
extern "C" {
wctype_t
 wctype(const char *);
}
# 117 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/wchar.h" 2 3 4



extern "C" {
wint_t btowc(int);
wint_t fgetwc(FILE *);
wchar_t *fgetws(wchar_t * , int, FILE * );
wint_t fputwc(wchar_t, FILE *);
int fputws(const wchar_t * , FILE * );
int fwide(FILE *, int);
int fwprintf(FILE * , const wchar_t * , ...) ;
int fwscanf(FILE * , const wchar_t * , ...) ;
wint_t getwc(FILE *);
wint_t getwchar(void);
size_t mbrlen(const char * , size_t, mbstate_t * );
size_t mbrtowc(wchar_t * , const char * , size_t,
     mbstate_t * );
int mbsinit(const mbstate_t *);
size_t mbsrtowcs(wchar_t * , const char ** , size_t,
     mbstate_t * );
wint_t putwc(wchar_t, FILE *);
wint_t putwchar(wchar_t);
int swprintf(wchar_t * , size_t, const wchar_t * ,
     ...) ;
int swscanf(const wchar_t * , const wchar_t * , ...) ;
wint_t ungetwc(wint_t, FILE *);
int vfwprintf(FILE * , const wchar_t * ,
     __darwin_va_list) ;
int vswprintf(wchar_t * , size_t, const wchar_t * ,
     __darwin_va_list) ;
int vwprintf(const wchar_t * , __darwin_va_list) ;
size_t wcrtomb(char * , wchar_t, mbstate_t * );
wchar_t *wcscat(wchar_t * , const wchar_t * );
wchar_t *wcschr(const wchar_t *, wchar_t);
int wcscmp(const wchar_t *, const wchar_t *);
int wcscoll(const wchar_t *, const wchar_t *);
wchar_t *wcscpy(wchar_t * , const wchar_t * );
size_t wcscspn(const wchar_t *, const wchar_t *);
size_t wcsftime(wchar_t * , size_t, const wchar_t * ,
     const struct tm * ) __asm("_" "wcsftime" );
size_t wcslen(const wchar_t *);
wchar_t *wcsncat(wchar_t * , const wchar_t * , size_t);
int wcsncmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wcsncpy(wchar_t * , const wchar_t * , size_t);
wchar_t *wcspbrk(const wchar_t *, const wchar_t *);
wchar_t *wcsrchr(const wchar_t *, wchar_t);
size_t wcsrtombs(char * , const wchar_t ** , size_t,
     mbstate_t * );
size_t wcsspn(const wchar_t *, const wchar_t *);
wchar_t *wcsstr(const wchar_t * , const wchar_t * );
size_t wcsxfrm(wchar_t * , const wchar_t * , size_t);
int wctob(wint_t);
double wcstod(const wchar_t * , wchar_t ** );
wchar_t *wcstok(wchar_t * , const wchar_t * ,
     wchar_t ** );
long wcstol(const wchar_t * , wchar_t ** , int);
unsigned long
  wcstoul(const wchar_t * , wchar_t ** , int);
wchar_t *wmemchr(const wchar_t *, wchar_t, size_t);
int wmemcmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wmemcpy(wchar_t * , const wchar_t * , size_t);
wchar_t *wmemmove(wchar_t *, const wchar_t *, size_t);
wchar_t *wmemset(wchar_t *, wchar_t, size_t);
int wprintf(const wchar_t * , ...) ;
int wscanf(const wchar_t * , ...) ;
int wcswidth(const wchar_t *, size_t);
int wcwidth(wchar_t);
}
# 194 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/wchar.h" 3 4
extern "C" {
int vfwscanf(FILE * , const wchar_t * ,
     __darwin_va_list) ;
int vswscanf(const wchar_t * , const wchar_t * ,
     __darwin_va_list) ;
int vwscanf(const wchar_t * , __darwin_va_list) ;
float wcstof(const wchar_t * , wchar_t ** );
long double
 wcstold(const wchar_t * , wchar_t ** ) ;

long long
 wcstoll(const wchar_t * , wchar_t ** , int);
unsigned long long
 wcstoull(const wchar_t * , wchar_t ** , int);

}
# 219 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/wchar.h" 3 4
extern "C" {
size_t mbsnrtowcs(wchar_t * , const char ** , size_t,
            size_t, mbstate_t * );
wchar_t *wcpcpy(wchar_t * , const wchar_t * ) __attribute__((visibility("default")));
wchar_t *wcpncpy(wchar_t * , const wchar_t * , size_t) __attribute__((visibility("default")));
wchar_t *wcsdup(const wchar_t *) __attribute__((visibility("default")));
int wcscasecmp(const wchar_t *, const wchar_t *) __attribute__((visibility("default")));
int wcsncasecmp(const wchar_t *, const wchar_t *, size_t n) __attribute__((visibility("default")));
size_t wcsnlen(const wchar_t *, size_t) __attribute__((visibility("default")));
size_t wcsnrtombs(char * , const wchar_t ** , size_t,
            size_t, mbstate_t * );
}







extern "C" {
wchar_t *fgetwln(FILE * , size_t *) __attribute__((visibility("default")));
size_t wcslcat(wchar_t *, const wchar_t *, size_t);
size_t wcslcpy(wchar_t *, const wchar_t *, size_t);
}
# 55 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cwchar" 2 3
# 69 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cwchar" 3
namespace std {

  using ::mbstate_t;

}
# 143 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cwchar" 3
namespace std {

  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;
  using ::swprintf;
  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;

  using ::vswprintf;

  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;

  using ::wcschr;

  inline wchar_t*
  wcschr(wchar_t* __p, wchar_t __c)
  { return wcschr(const_cast<const wchar_t*>(__p), __c); }

  using ::wcspbrk;

  inline wchar_t*
  wcspbrk(wchar_t* __s1, const wchar_t* __s2)
  { return wcspbrk(const_cast<const wchar_t*>(__s1), __s2); }

  using ::wcsrchr;

  inline wchar_t*
  wcsrchr(wchar_t* __p, wchar_t __c)
  { return wcsrchr(const_cast<const wchar_t*>(__p), __c); }

  using ::wcsstr;

  inline wchar_t*
  wcsstr(wchar_t* __s1, const wchar_t* __s2)
  { return wcsstr(const_cast<const wchar_t*>(__s1), __s2); }

  using ::wmemchr;

  inline wchar_t*
  wmemchr(wchar_t* __p, wchar_t __c, size_t __n)
  { return wmemchr(const_cast<const wchar_t*>(__p), __c, __n); }

}







namespace __gnu_cxx {






  using ::wcstold;
# 261 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;


}

namespace std {

  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;

}
# 46 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/postypes.h" 2 3





namespace std {
# 71 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/postypes.h" 3
  typedef int64_t streamoff;





  typedef ptrdiff_t streamsize;

  template<typename _StateT>
    class fpos;
# 93 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 115 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;

}
# 49 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/iosfwd" 2 3
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/functexcept.h" 1 3
# 42 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/functexcept.h" 3
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/exception_defines.h" 1 3
# 43 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/functexcept.h" 2 3

namespace std {


  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

}
# 50 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/iosfwd" 2 3

namespace std {

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  class ios_base;
# 134 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/iosfwd" 3
  typedef basic_ios<char> ios;
  typedef basic_streambuf<char> streambuf;
  typedef basic_istream<char> istream;
  typedef basic_ostream<char> ostream;
  typedef basic_iostream<char> iostream;
  typedef basic_stringbuf<char> stringbuf;
  typedef basic_istringstream<char> istringstream;
  typedef basic_ostringstream<char> ostringstream;
  typedef basic_stringstream<char> stringstream;
  typedef basic_filebuf<char> filebuf;
  typedef basic_ifstream<char> ifstream;
  typedef basic_ofstream<char> ofstream;
  typedef basic_fstream<char> fstream;


  typedef basic_ios<wchar_t> wios;
  typedef basic_streambuf<wchar_t> wstreambuf;
  typedef basic_istream<wchar_t> wistream;
  typedef basic_ostream<wchar_t> wostream;
  typedef basic_iostream<wchar_t> wiostream;
  typedef basic_stringbuf<wchar_t> wstringbuf;
  typedef basic_istringstream<wchar_t> wistringstream;
  typedef basic_ostringstream<wchar_t> wostringstream;
  typedef basic_stringstream<wchar_t> wstringstream;
  typedef basic_filebuf<wchar_t> wfilebuf;
  typedef basic_ifstream<wchar_t> wifstream;
  typedef basic_ofstream<wchar_t> wofstream;
  typedef basic_fstream<wchar_t> wfstream;



}
# 71 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_pair.h" 1 3
# 64 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_pair.h" 3
namespace std {


  template<class _T1, class _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;





      pair()
      : first(), second() { }


      pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }


      template<class _U1, class _U2>
        pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }
    };


  template<class _T1, class _T2>
    inline bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<class _T1, class _T2>
    inline bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<class _T1, class _T2>
    inline bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<class _T1, class _T2>
    inline bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<class _T1, class _T2>
    inline bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<class _T1, class _T2>
    inline bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }
# 142 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    inline pair<_T1, _T2>
    make_pair(_T1 __x, _T2 __y)
    { return pair<_T1, _T2>(__x, __y); }

}
# 72 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/cpp_type_traits.h" 1 3
# 41 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/cpp_type_traits.h" 3
# 41 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/cpp_type_traits.h" 3
# 73 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/cpp_type_traits.h" 3
namespace __gnu_cxx {

  template<typename _Iterator, typename _Container>
    class __normal_iterator;

}

namespace std {

namespace __detail
{


  typedef char __one;
  typedef char __two[2];

  template<typename _Tp>
  __one __test_type(int _Tp::*);
  template<typename _Tp>
  __two& __test_type(...);
}


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };




  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_normal_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Iterator, typename _Container>
    struct __is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,
             _Container> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_fundamental
    : public __traitor<__is_void<_Tp>, __is_arithmetic<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };


  template<typename _Tp>
    struct __is_pod
    {
      enum
 {
   __value = (sizeof(__detail::__test_type<_Tp>(0))
       != sizeof(__detail::__one))
 };
    };




  template<typename _Tp>
    struct __is_empty
    {
    private:
      template<typename>
        struct __first { };
      template<typename _Up>
        struct __second
        : public _Up { };

    public:
      enum
 {
   __value = sizeof(__first<_Tp>) == sizeof(__second<_Tp>)
 };
    };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


}
# 73 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/ext/type_traits.h" 1 3
# 38 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/ext/type_traits.h" 3
# 38 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/ext/type_traits.h" 3


# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/utility" 1 3
# 63 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/utility" 3
# 63 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/utility" 3


# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_relops.h" 1 3
# 74 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_relops.h" 3
namespace std {

  namespace rel_ops
  {
# 90 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
# 103 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
# 116 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
# 129 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }

  }

}
# 66 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/utility" 2 3
# 41 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/ext/type_traits.h" 2 3


namespace __gnu_cxx {


  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;

}
# 74 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_iterator_base_types.h" 1 3
# 67 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_iterator_base_types.h" 3
# 67 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_iterator_base_types.h" 3

namespace std {
# 79 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag {};

  struct output_iterator_tag {};

  struct forward_iterator_tag : public input_iterator_tag {};


  struct bidirectional_iterator_tag : public forward_iterator_tag {};


  struct random_access_iterator_tag : public bidirectional_iterator_tag {};
# 103 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };







  template<typename _Iterator>
    struct iterator_traits
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };

  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };

  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };







  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }

}
# 75 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_iterator_base_funcs.h" 1 3
# 68 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_iterator_base_funcs.h" 3
# 68 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_iterator_base_funcs.h" 3
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/concept_check.h" 1 3
# 38 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/concept_check.h" 3
# 38 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/concept_check.h" 3
# 69 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_iterator_base_funcs.h" 2 3

namespace std {

  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {



      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {



      return __last - __first;
    }
# 112 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {


      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {



      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {



      __i += __n;
    }
# 170 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }

}
# 76 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_iterator.h" 1 3
# 72 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_iterator.h" 3
namespace std {
# 93 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

    public:
      typedef _Iterator iterator_type;
      typedef typename iterator_traits<_Iterator>::difference_type
              difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

    public:






      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }






      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const
      { return &(operator*()); }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }






      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }






      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
# 280 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline typename reverse_iterator<_IteratorL>::difference_type
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() - __x.base(); }
# 384 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }
# 410 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_back(__value);
 return *this;
      }


      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 444 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 459 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
# 484 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_front(__value);
 return *this;
      }


      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 518 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 537 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x), iter(__i) {}
# 579 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(const typename _Container::const_reference __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }


      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 614 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }

}

namespace __gnu_cxx {
# 633 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

    public:
      typedef typename iterator_traits<_Iterator>::iterator_category
                                                             iterator_category;
      typedef typename iterator_traits<_Iterator>::value_type value_type;
      typedef typename iterator_traits<_Iterator>::difference_type
                                                             difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }


      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i)
        : _M_current(__i.base()) { }


      reference
      operator*() const
      { return *_M_current; }

      pointer
      operator->() const
      { return _M_current; }

      __normal_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int)
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int)
      { return __normal_iterator(_M_current--); }


      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const
      { return _M_current; }
    };
# 730 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline typename __normal_iterator<_IteratorL, _Container>::difference_type
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }

}
# 77 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3

# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/debug/debug.h" 1 3
# 47 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}

namespace __gnu_cxx
{
  namespace __debug { };
}

namespace __gnu_debug
{
  using namespace std::__debug;
  using namespace __gnu_cxx::__debug;
}
# 79 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algobase.h" 2 3

namespace std {
# 91 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)
    {



      _Tp __tmp = __a;
      __a = __b;
      __b = __tmp;
    }




  template<bool _BoolType>
    struct __iter_swap
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          typedef typename iterator_traits<_ForwardIterator1>::value_type
            _ValueType1;
          _ValueType1 __tmp = *__a;
          *__a = *__b;
          *__b = __tmp;
 }
    };

  template<>
    struct __iter_swap<true>
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          swap(*__a, *__b);
        }
    };
# 141 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {
      typedef typename iterator_traits<_ForwardIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator2>::value_type
 _ValueType2;
# 160 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algobase.h" 3
      typedef typename iterator_traits<_ForwardIterator1>::reference
 _ReferenceType1;
      typedef typename iterator_traits<_ForwardIterator2>::reference
 _ReferenceType2;
      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value &&
 __are_same<_ValueType1 &, _ReferenceType1>::__value &&
 __are_same<_ValueType2 &, _ReferenceType2>::__value>::
 iter_swap(__a, __b);
    }
# 180 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {



      if (__b < __a)
 return __b;
      return __a;
    }
# 202 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {



      if (__a < __b)
 return __b;
      return __a;
    }
# 224 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 244 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }







  template<bool, typename>
    struct __copy
    {
      template<typename _II, typename _OI>
        static _OI
        copy(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = *__first;
   return __result;
 }
    };

  template<bool _BoolType>
    struct __copy<_BoolType, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        copy(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };

  template<>
    struct __copy<true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        copy(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   std::memmove(__result, __first, sizeof(_Tp) * (__last - __first));
   return __result + (__last - __first);
 }
    };

  template<typename _II, typename _OI>
    inline _OI
    __copy_aux(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_scalar<_ValueTypeI>::__value
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy<__simple, _Category>::copy(__first, __last, __result);
    }


  template<typename _CharT>
  typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT> >::__type
    __copy_aux(_CharT*, _CharT*, ostreambuf_iterator<_CharT>);

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_aux(const _CharT*, const _CharT*, ostreambuf_iterator<_CharT>);

  template<typename _CharT>
  typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, _CharT*>::__type
    __copy_aux(istreambuf_iterator<_CharT>, istreambuf_iterator<_CharT>,
        _CharT*);

  template<bool, bool>
    struct __copy_normal
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_n(_II __first, _II __last, _OI __result)
        { return std::__copy_aux(__first, __last, __result); }
    };

  template<>
    struct __copy_normal<true, false>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_n(_II __first, _II __last, _OI __result)
        { return std::__copy_aux(__first.base(), __last.base(), __result); }
    };

  template<>
    struct __copy_normal<false, true>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_n(_II __first, _II __last, _OI __result)
        { return _OI(std::__copy_aux(__first, __last, __result.base())); }
    };

  template<>
    struct __copy_normal<true, true>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_n(_II __first, _II __last, _OI __result)
        { return _OI(std::__copy_aux(__first.base(), __last.base(),
         __result.base())); }
    };
# 387 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {




                                                     ;

       const bool __in = __is_normal_iterator<_InputIterator>::__value;
       const bool __out = __is_normal_iterator<_OutputIterator>::__value;
       return std::__copy_normal<__in, __out>::__copy_n(__first, __last,
       __result);
    }


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                 ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT>, istreambuf_iterator<_CharT>,
  ostreambuf_iterator<_CharT>);

  template<bool, typename>
    struct __copy_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };

  template<bool _BoolType>
    struct __copy_backward<_BoolType, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };

  template<>
    struct __copy_backward<true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   std::memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<typename _BI1, typename _BI2>
    inline _BI2
    __copy_backward_aux(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_scalar<_ValueType1>::__value
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_backward<__simple, _Category>::__copy_b(__first,
         __last,
         __result);
    }

  template<bool, bool>
    struct __copy_backward_normal
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_b_n(_BI1 __first, _BI1 __last, _BI2 __result)
        { return std::__copy_backward_aux(__first, __last, __result); }
    };

  template<>
    struct __copy_backward_normal<true, false>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_b_n(_BI1 __first, _BI1 __last, _BI2 __result)
        { return std::__copy_backward_aux(__first.base(), __last.base(),
       __result); }
    };

  template<>
    struct __copy_backward_normal<false, true>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_b_n(_BI1 __first, _BI1 __last, _BI2 __result)
        { return _BI2(std::__copy_backward_aux(__first, __last,
            __result.base())); }
    };

  template<>
    struct __copy_backward_normal<true, true>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_b_n(_BI1 __first, _BI1 __last, _BI2 __result)
        { return _BI2(std::__copy_backward_aux(__first.base(), __last.base(),
            __result.base())); }
    };
# 524 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template <typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {






                                                     ;

      const bool __bi1 = __is_normal_iterator<_BI1>::__value;
      const bool __bi2 = __is_normal_iterator<_BI2>::__value;
      return std::__copy_backward_normal<__bi1, __bi2>::__copy_b_n(__first,
           __last,
           __result);
    }

  template<bool>
    struct __fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        fill(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
        {
   for (; __first != __last; ++__first)
     *__first = __value;
 }
    };

  template<>
    struct __fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        fill(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
        {
   const _Tp __tmp = __value;
   for (; __first != __last; ++__first)
     *__first = __tmp;
 }
    };
# 581 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {



                                                     ;

      const bool __scalar = __is_scalar<_Tp>::__value;
      std::__fill<__scalar>::fill(__first, __last, __value);
    }


  inline void
  fill(unsigned char* __first, unsigned char* __last, const unsigned char& __c)
  {
                                                   ;
    const unsigned char __tmp = __c;
    std::memset(__first, __tmp, __last - __first);
  }

  inline void
  fill(signed char* __first, signed char* __last, const signed char& __c)
  {
                                                   ;
    const signed char __tmp = __c;
    std::memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
  }

  inline void
  fill(char* __first, char* __last, const char& __c)
  {
                                                   ;
    const char __tmp = __c;
    std::memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
  }

  template<bool>
    struct __fill_n
    {
      template<typename _OutputIterator, typename _Size, typename _Tp>
        static _OutputIterator
        fill_n(_OutputIterator __first, _Size __n, const _Tp& __value)
        {
   for (; __n > 0; --__n, ++__first)
     *__first = __value;
   return __first;
 }
    };

  template<>
    struct __fill_n<true>
    {
      template<typename _OutputIterator, typename _Size, typename _Tp>
        static _OutputIterator
        fill_n(_OutputIterator __first, _Size __n, const _Tp& __value)
        {
   const _Tp __tmp = __value;
   for (; __n > 0; --__n, ++__first)
     *__first = __tmp;
   return __first;
 }
    };
# 657 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _OutputIterator, typename _Size, typename _Tp>
    _OutputIterator
    fill_n(_OutputIterator __first, _Size __n, const _Tp& __value)
    {



      const bool __scalar = __is_scalar<_Tp>::__value;
      return std::__fill_n<__scalar>::fill_n(__first, __n, __value);
    }

  template<typename _Size>
    inline unsigned char*
    fill_n(unsigned char* __first, _Size __n, const unsigned char& __c)
    {
      std::fill(__first, __first + __n, __c);
      return __first + __n;
    }

  template<typename _Size>
    inline signed char*
    fill_n(signed char* __first, _Size __n, const signed char& __c)
    {
      std::fill(__first, __first + __n, __c);
      return __first + __n;
    }

  template<typename _Size>
    inline char*
    fill_n(char* __first, _Size __n, const char& __c)
    {
      std::fill(__first, __first + __n, __c);
      return __first + __n;
    }
# 704 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {






                                                       ;

      while (__first1 != __last1 && *__first1 == *__first2)
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 739 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {



                                                       ;

      while (__first1 != __last1 && __binary_pred(*__first1, *__first2))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 769 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline bool
    equal(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2)
    {






                                                       ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!(*__first1 == *__first2))
   return false;
      return true;
    }
# 801 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    inline bool
    equal(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2,
   _BinaryPredicate __binary_pred)
    {



                                                       ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!__binary_pred(*__first1, *__first2))
   return false;
      return true;
    }
# 833 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    bool
    lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2)
    {
# 847 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algobase.h" 3
                                                       ;
                                                       ;

      for (; __first1 != __last1 && __first2 != __last2;
    ++__first1, ++__first2)
 {
   if (*__first1 < *__first2)
     return true;
   if (*__first2 < *__first1)
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }
# 873 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _Compare __comp)
    {



                                                       ;
                                                       ;

      for (; __first1 != __last1 && __first2 != __last2;
    ++__first1, ++__first2)
 {
   if (__comp(*__first1, *__first2))
     return true;
   if (__comp(*__first2, *__first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }

  inline bool
  lexicographical_compare(const unsigned char* __first1,
     const unsigned char* __last1,
     const unsigned char* __first2,
     const unsigned char* __last2)
  {
                                                     ;
                                                     ;

    const size_t __len1 = __last1 - __first1;
    const size_t __len2 = __last2 - __first2;
    const int __result = std::memcmp(__first1, __first2,
         std::min(__len1, __len2));
    return __result != 0 ? __result < 0 : __len1 < __len2;
  }

  inline bool
  lexicographical_compare(const char* __first1, const char* __last1,
     const char* __first2, const char* __last2)
  {
                                                     ;
                                                     ;


    return std::lexicographical_compare((const signed char*) __first1,
     (const signed char*) __last1,
     (const signed char*) __first2,
     (const signed char*) __last2);






  }

}
# 65 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/algorithm" 2 3
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_construct.h" 1 3
# 67 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_construct.h" 3
namespace std {







  template<typename _T1, typename _T2>
    inline void
    _Construct(_T1* __p, const _T2& __value)
    {


      ::new(static_cast<void*>(__p)) _T1(__value);
    }







  template<typename _T1>
    inline void
    _Construct(_T1* __p)
    {


      ::new(static_cast<void*>(__p)) _T1();
    }






  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }
# 116 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_construct.h" 3
  template<typename _ForwardIterator>
    inline void
    __destroy_aux(_ForwardIterator __first, _ForwardIterator __last,
    __false_type)
    {
      for (; __first != __last; ++__first)
 std::_Destroy(&*__first);
    }
# 134 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_construct.h" 3
  template<typename _ForwardIterator>
    inline void
    __destroy_aux(_ForwardIterator, _ForwardIterator, __true_type)
    { }
# 146 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_construct.h" 3
  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;
      typedef typename std::__is_scalar<_Value_type>::__type
                _Has_trivial_destructor;

      std::__destroy_aux(__first, __last, _Has_trivial_destructor());
    }
# 166 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_construct.h" 3
  template <typename _Tp> class allocator;

  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator __alloc)
    {
      for (; __first != __last; ++__first)
 __alloc.destroy(&*__first);
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>)
    {
      _Destroy(__first, __last);
    }

}
# 66 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/algorithm" 2 3
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_uninitialized.h" 1 3
# 67 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_uninitialized.h" 3
namespace std {


  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_aux(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result,
        __true_type)
    { return std::copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_aux(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result,
        __false_type)
    {
      _ForwardIterator __cur = __result;
      if (true)
 {
   for (; __first != __last; ++__first, ++__cur)
     std::_Construct(&*__cur, *__first);
   return __cur;
 }
      if (false)
 {
   std::_Destroy(__result, __cur);
                          ;
 }
    }
# 106 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
      typedef typename std::__is_scalar<_ValueType>::__type _Is_POD;
      return std::__uninitialized_copy_aux(__first, __last, __result,
        _Is_POD());
    }

  inline char*
  uninitialized_copy(const char* __first, const char* __last, char* __result)
  {
    std::memmove(__result, __first, __last - __first);
    return __result + (__last - __first);
  }

  inline wchar_t*
  uninitialized_copy(const wchar_t* __first, const wchar_t* __last,
       wchar_t* __result)
  {
    std::memmove(__result, __first, sizeof(wchar_t) * (__last - __first));
    return __result + (__last - __first);
  }



  template<typename _ForwardIterator, typename _Tp>
    inline void
    __uninitialized_fill_aux(_ForwardIterator __first,
        _ForwardIterator __last,
        const _Tp& __x, __true_type)
    { std::fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Tp>
    void
    __uninitialized_fill_aux(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x, __false_type)
    {
      _ForwardIterator __cur = __first;
      if (true)
 {
   for (; __cur != __last; ++__cur)
     std::_Construct(&*__cur, __x);
 }
      if (false)
 {
   std::_Destroy(__first, __cur);
                          ;
 }
    }
# 168 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
      typedef typename std::__is_scalar<_ValueType>::__type _Is_POD;
      std::__uninitialized_fill_aux(__first, __last, __x, _Is_POD());
    }



  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline void
    __uninitialized_fill_n_aux(_ForwardIterator __first, _Size __n,
          const _Tp& __x, __true_type)
    { std::fill_n(__first, __n, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp>
    void
    __uninitialized_fill_n_aux(_ForwardIterator __first, _Size __n,
          const _Tp& __x, __false_type)
    {
      _ForwardIterator __cur = __first;
      if (true)
 {
   for (; __n > 0; --__n, ++__cur)
     std::_Construct(&*__cur, __x);
 }
      if (false)
 {
   std::_Destroy(__first, __cur);
                          ;
 }
    }
# 213 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline void
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
      typedef typename std::__is_scalar<_ValueType>::__type _Is_POD;
      std::__uninitialized_fill_n_aux(__first, __n, __x, _Is_POD());
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result,
      _Allocator __alloc)
    {
      _ForwardIterator __cur = __result;
      if (true)
 {
   for (; __first != __last; ++__first, ++__cur)
     __alloc.construct(&*__cur, *__first);
   return __cur;
 }
      if (false)
 {
   std::_Destroy(__result, __cur, __alloc);
                          ;
 }
    }

  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result,
      allocator<_Tp>)
    { return std::uninitialized_copy(__first, __last, __result); }

  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator __alloc)
    {
      _ForwardIterator __cur = __first;
      if (true)
 {
   for (; __cur != __last; ++__cur)
     __alloc.construct(&*__cur, __x);
 }
      if (false)
 {
   std::_Destroy(__first, __cur, __alloc);
                          ;
 }
    }

  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>)
    { std::uninitialized_fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x,
        _Allocator __alloc)
    {
      _ForwardIterator __cur = __first;
      if (true)
 {
   for (; __n > 0; --__n, ++__cur)
     __alloc.construct(&*__cur, __x);
 }
      if (false)
 {
   std::_Destroy(__first, __cur, __alloc);
                          ;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    inline void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x,
        allocator<_Tp2>)
    { std::uninitialized_fill_n(__first, __n, __x); }
# 318 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_uninitialized.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      if (true)
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      if (false)
 {
   std::_Destroy(__result, __mid, __alloc);
                          ;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_copy(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last,
         _Allocator __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      if (true)
 {
   return std::__uninitialized_copy_a(__first, __last, __mid, __alloc);
 }
      if (false)
 {
   std::_Destroy(__result, __mid, __alloc);
                          ;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_copy_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_copy_a(__first1, __last1,
           __first2,
           __alloc);
      if (true)
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      if (false)
 {
   std::_Destroy(__first2, __mid2, __alloc);
                          ;
 }
    }

}
# 67 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/algorithm" 2 3
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 1 3
# 65 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_heap.h" 1 3
# 65 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_heap.h" 3
namespace std {




  template<typename _RandomAccessIterator, typename _Distance>
    bool
    __is_heap(_RandomAccessIterator __first, _Distance __n)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__first[__parent] < __first[__child])
     return false;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return true;
    }

  template<typename _RandomAccessIterator, typename _Distance,
           typename _StrictWeakOrdering>
    bool
    __is_heap(_RandomAccessIterator __first, _StrictWeakOrdering __comp,
       _Distance __n)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__comp(__first[__parent], __first[__child]))
     return false;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return true;
    }

  template<typename _RandomAccessIterator>
    bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::__is_heap(__first, std::distance(__first, __last)); }

  template<typename _RandomAccessIterator, typename _StrictWeakOrdering>
    bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _StrictWeakOrdering __comp)
    { return std::__is_heap(__first, __comp, std::distance(__first, __last)); }



  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __push_heap(_RandomAccessIterator __first,
  _Distance __holeIndex, _Distance __topIndex, _Tp __value)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && *(__first + __parent) < __value)
 {
   *(__first + __holeIndex) = *(__first + __parent);
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = __value;
    }
# 139 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;





                                                     ;


      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), _ValueType(*(__last - 1)));
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,
     typename _Compare>
    void
    __push_heap(_RandomAccessIterator __first, _Distance __holeIndex,
  _Distance __topIndex, _Tp __value, _Compare __comp)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex
      && __comp(*(__first + __parent), __value))
 {
   *(__first + __holeIndex) = *(__first + __parent);
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = __value;
    }
# 187 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;




                                                     ;
                                                               ;

      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), _ValueType(*(__last - 1)), __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = 2 * __holeIndex + 2;
      while (__secondChild < __len)
 {
   if (*(__first + __secondChild) < *(__first + (__secondChild - 1)))
     __secondChild--;
   *(__first + __holeIndex) = *(__first + __secondChild);
   __holeIndex = __secondChild;
   __secondChild = 2 * (__secondChild + 1);
 }
      if (__secondChild == __len)
 {
   *(__first + __holeIndex) = *(__first + (__secondChild - 1));
   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex, __value);
    }

  template<typename _RandomAccessIterator, typename _Tp>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Tp __value)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      *__result = *__first;
      std::__adjust_heap(__first, _Distance(0), _Distance(__last - __first),
    __value);
    }
# 251 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;





                                                     ;
                                              ;

      std::__pop_heap(__first, __last - 1, __last - 1,
        _ValueType(*(__last - 1)));
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Tp, typename _Compare>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value, _Compare __comp)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = 2 * __holeIndex + 2;
      while (__secondChild < __len)
 {
   if (__comp(*(__first + __secondChild),
       *(__first + (__secondChild - 1))))
     __secondChild--;
   *(__first + __holeIndex) = *(__first + __secondChild);
   __holeIndex = __secondChild;
   __secondChild = 2 * (__secondChild + 1);
 }
      if (__secondChild == __len)
 {
   *(__first + __holeIndex) = *(__first + (__secondChild - 1));
   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex, __value, __comp);
    }

  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Tp __value, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      *__result = *__first;
      std::__adjust_heap(__first, _Distance(0), _Distance(__last - __first),
    __value, __comp);
    }
# 317 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    pop_heap(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {



                                                     ;
                                                           ;

      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      std::__pop_heap(__first, __last - 1, __last - 1,
        _ValueType(*(__last - 1)), __comp);
    }
# 342 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;





                                                     ;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   std::__adjust_heap(__first, __parent, __len,
        _ValueType(*(__first + __parent)));
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 382 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;




                                                     ;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   std::__adjust_heap(__first, __parent, __len,
        _ValueType(*(__first + __parent)), __comp);
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 420 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {





                                                     ;


      while (__last - __first > 1)
 std::pop_heap(__first, _RandomAccessIterator(__last--));
    }
# 446 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {



                                                     ;
                                                           ;

      while (__last - __first > 1)
 std::pop_heap(__first, _RandomAccessIterator(__last--), __comp);
    }

}
# 66 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 2 3
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_tempbuf.h" 1 3
# 65 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_tempbuf.h" 3
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/memory" 1 3
# 51 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/memory" 3
# 51 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/memory" 3


# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/allocator.h" 1 3
# 53 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/allocator.h" 3
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/c++allocator.h" 1 3
# 39 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/c++allocator.h" 3
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/ext/new_allocator.h" 1 3
# 40 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/ext/new_allocator.h" 3
namespace __gnu_cxx {

  using std::size_t;
  using std::ptrdiff_t;
# 52 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };

      new_allocator() throw() { }

      new_allocator(const new_allocator&) throw() { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) throw() { }

      ~new_allocator() throw() { }

      pointer
      address(reference __x) const { return &__x; }

      const_pointer
      address(const_reference __x) const { return &__x; }



      pointer
      allocate(size_type __n, const void* = 0)
      {
 if (__builtin_expect(__n > this->max_size(), false))
   std::__throw_bad_alloc();

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const throw()
      { return size_t(-1) / sizeof(_Tp); }



      void
      construct(pointer __p, const _Tp& __val)
      { ::new(__p) _Tp(__val); }

      void
      destroy(pointer __p) { __p->~_Tp(); }
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }

}
# 40 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/c++allocator.h" 2 3
# 54 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/allocator.h" 2 3



namespace std {

  template<typename _Tp>
    class allocator;


  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };
    };







  template<typename _Tp>
    class allocator: public __gnu_cxx::new_allocator<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };

      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __gnu_cxx::new_allocator<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    { return false; }





  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = std::__is_empty<_Alloc>::__value>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two)
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };

}
# 54 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/memory" 2 3



# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_raw_storage_iter.h" 1 3
# 64 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_raw_storage_iter.h" 3
namespace std {





  template <class _ForwardIterator, class _Tp>
    class raw_storage_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _ForwardIterator _M_iter;

    public:
      explicit
      raw_storage_iterator(_ForwardIterator __x)
      : _M_iter(__x) {}

      raw_storage_iterator&
      operator*() { return *this; }

      raw_storage_iterator&
      operator=(const _Tp& __element)
      {
 std::_Construct(&*_M_iter, __element);
 return *this;
      }

      raw_storage_iterator<_ForwardIterator, _Tp>&
      operator++()
      {
 ++_M_iter;
 return *this;
      }

      raw_storage_iterator<_ForwardIterator, _Tp>
      operator++(int)
      {
 raw_storage_iterator<_ForwardIterator, _Tp> __tmp = *this;
 ++_M_iter;
 return __tmp;
      }
    };

}
# 58 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/memory" 2 3

# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/limits" 1 3
# 46 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/limits" 3
# 46 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/limits" 3
# 149 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/limits" 3
namespace std {






  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 191 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/limits" 3
  struct __numeric_limits_base
  {


    static const bool is_specialized = false;




    static const int digits = 0;

    static const int digits10 = 0;

    static const bool is_signed = false;





    static const bool is_integer = false;




    static const bool is_exact = false;


    static const int radix = 0;



    static const int min_exponent = 0;


    static const int min_exponent10 = 0;



    static const int max_exponent = 0;


    static const int max_exponent10 = 0;


    static const bool has_infinity = false;


    static const bool has_quiet_NaN = false;


    static const bool has_signaling_NaN = false;

    static const float_denorm_style has_denorm = denorm_absent;


    static const bool has_denorm_loss = false;



    static const bool is_iec559 = false;



    static const bool is_bounded = false;




    static const bool is_modulo = false;


    static const bool traps = false;

    static const bool tinyness_before = false;



    static const float_round_style round_style = round_toward_zero;
  };
# 284 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static _Tp min() throw() { return static_cast<_Tp>(0); }

      static _Tp max() throw() { return static_cast<_Tp>(0); }


      static _Tp epsilon() throw() { return static_cast<_Tp>(0); }

      static _Tp round_error() throw() { return static_cast<_Tp>(0); }

      static _Tp infinity() throw() { return static_cast<_Tp>(0); }

      static _Tp quiet_NaN() throw() { return static_cast<_Tp>(0); }


      static _Tp signaling_NaN() throw() { return static_cast<_Tp>(0); }



      static _Tp denorm_min() throw() { return static_cast<_Tp>(0); }
    };





  template<>
    struct numeric_limits<bool>
    {
      static const bool is_specialized = true;

      static bool min() throw()
      { return false; }
      static bool max() throw()
      { return true; }

      static const int digits = 1;
      static const int digits10 = 0;
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static bool epsilon() throw()
      { return false; }
      static bool round_error() throw()
      { return false; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static bool infinity() throw()
      { return false; }
      static bool quiet_NaN() throw()
      { return false; }
      static bool signaling_NaN() throw()
      { return false; }
      static bool denorm_min() throw()
      { return false; }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;




      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static const bool is_specialized = true;

      static char min() throw()
      { return (((char)(-1) < 0) ? (char)1 << (sizeof(char) * 8 - ((char)(-1) < 0)) : (char)0); }
      static char max() throw()
      { return (((char)(-1) < 0) ? ((char)1 << (sizeof(char) * 8 - ((char)(-1) < 0))) - 1 : ~(char)0); }

      static const int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static const int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = ((char)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static char epsilon() throw()
      { return 0; }
      static char round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static char infinity() throw()
      { return char(); }
      static char quiet_NaN() throw()
      { return char(); }
      static char signaling_NaN() throw()
      { return char(); }
      static char denorm_min() throw()
      { return static_cast<char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static const bool is_specialized = true;

      static signed char min() throw()
      { return -127 - 1; }
      static signed char max() throw()
      { return 127; }

      static const int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static const int digits10 = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static signed char epsilon() throw()
      { return 0; }
      static signed char round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static signed char infinity() throw()
      { return static_cast<signed char>(0); }
      static signed char quiet_NaN() throw()
      { return static_cast<signed char>(0); }
      static signed char signaling_NaN() throw()
      { return static_cast<signed char>(0); }
      static signed char denorm_min() throw()
      { return static_cast<signed char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static const bool is_specialized = true;

      static unsigned char min() throw()
      { return 0; }
      static unsigned char max() throw()
      { return 127 * 2U + 1; }

      static const int digits = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned char epsilon() throw()
      { return 0; }
      static unsigned char round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned char infinity() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char quiet_NaN() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char signaling_NaN() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char denorm_min() throw()
      { return static_cast<unsigned char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static const bool is_specialized = true;

      static wchar_t min() throw()
      { return (((wchar_t)(-1) < 0) ? (wchar_t)1 << (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) : (wchar_t)0); }
      static wchar_t max() throw()
      { return (((wchar_t)(-1) < 0) ? ((wchar_t)1 << (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0))) - 1 : ~(wchar_t)0); }

      static const int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static const int digits10 = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = ((wchar_t)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static wchar_t epsilon() throw()
      { return 0; }
      static wchar_t round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static wchar_t infinity() throw()
      { return wchar_t(); }
      static wchar_t quiet_NaN() throw()
      { return wchar_t(); }
      static wchar_t signaling_NaN() throw()
      { return wchar_t(); }
      static wchar_t denorm_min() throw()
      { return wchar_t(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<short>
    {
      static const bool is_specialized = true;

      static short min() throw()
      { return -32767 - 1; }
      static short max() throw()
      { return 32767; }

      static const int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static const int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static short epsilon() throw()
      { return 0; }
      static short round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static short infinity() throw()
      { return short(); }
      static short quiet_NaN() throw()
      { return short(); }
      static short signaling_NaN() throw()
      { return short(); }
      static short denorm_min() throw()
      { return short(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static const bool is_specialized = true;

      static unsigned short min() throw()
      { return 0; }
      static unsigned short max() throw()
      { return 32767 * 2U + 1; }

      static const int digits = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned short epsilon() throw()
      { return 0; }
      static unsigned short round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned short infinity() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short quiet_NaN() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short signaling_NaN() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short denorm_min() throw()
      { return static_cast<unsigned short>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static const bool is_specialized = true;

      static int min() throw()
      { return -2147483647 - 1; }
      static int max() throw()
      { return 2147483647; }

      static const int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static const int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static int epsilon() throw()
      { return 0; }
      static int round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static int infinity() throw()
      { return static_cast<int>(0); }
      static int quiet_NaN() throw()
      { return static_cast<int>(0); }
      static int signaling_NaN() throw()
      { return static_cast<int>(0); }
      static int denorm_min() throw()
      { return static_cast<int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static const bool is_specialized = true;

      static unsigned int min() throw()
      { return 0; }
      static unsigned int max() throw()
      { return 2147483647 * 2U + 1; }

      static const int digits = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned int epsilon() throw()
      { return 0; }
      static unsigned int round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned int infinity() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int quiet_NaN() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int signaling_NaN() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int denorm_min() throw()
      { return static_cast<unsigned int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static const bool is_specialized = true;

      static long min() throw()
      { return -9223372036854775807L - 1; }
      static long max() throw()
      { return 9223372036854775807L; }

      static const int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static const int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static long epsilon() throw()
      { return 0; }
      static long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static long infinity() throw()
      { return static_cast<long>(0); }
      static long quiet_NaN() throw()
      { return static_cast<long>(0); }
      static long signaling_NaN() throw()
      { return static_cast<long>(0); }
      static long denorm_min() throw()
      { return static_cast<long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static const bool is_specialized = true;

      static unsigned long min() throw()
      { return 0; }
      static unsigned long max() throw()
      { return 9223372036854775807L * 2UL + 1; }

      static const int digits = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned long epsilon() throw()
      { return 0; }
      static unsigned long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long infinity() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long quiet_NaN() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long signaling_NaN() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long denorm_min() throw()
      { return static_cast<unsigned long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static const bool is_specialized = true;

      static long long min() throw()
      { return -9223372036854775807LL - 1; }
      static long long max() throw()
      { return 9223372036854775807LL; }

      static const int digits = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static const int digits10 = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static long long epsilon() throw()
      { return 0; }
      static long long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static long long infinity() throw()
      { return static_cast<long long>(0); }
      static long long quiet_NaN() throw()
      { return static_cast<long long>(0); }
      static long long signaling_NaN() throw()
      { return static_cast<long long>(0); }
      static long long denorm_min() throw()
      { return static_cast<long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static const bool is_specialized = true;

      static unsigned long long min() throw()
      { return 0; }
      static unsigned long long max() throw()
      { return 9223372036854775807LL * 2ULL + 1; }

      static const int digits = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned long long epsilon() throw()
      { return 0; }
      static unsigned long long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long long infinity() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long quiet_NaN() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long signaling_NaN() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long denorm_min() throw()
      { return static_cast<unsigned long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<float>
    {
      static const bool is_specialized = true;

      static float min() throw()
      { return 1.17549435e-38F; }
      static float max() throw()
      { return 3.40282347e+38F; }

      static const int digits = 24;
      static const int digits10 = 6;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static float epsilon() throw()
      { return 1.19209290e-7F; }
      static float round_error() throw()
      { return 0.5F; }

      static const int min_exponent = (-125);
      static const int min_exponent10 = (-37);
      static const int max_exponent = 128;
      static const int max_exponent10 = 38;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss = false;

      static float infinity() throw()
      { return __builtin_huge_valf (); }
      static float quiet_NaN() throw()
      { return __builtin_nanf (""); }
      static float signaling_NaN() throw()
      { return __builtin_nansf (""); }
      static float denorm_min() throw()
      { return 1.40129846e-45F; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static const bool is_specialized = true;

      static double min() throw()
      { return 2.2250738585072014e-308; }
      static double max() throw()
      { return 1.7976931348623157e+308; }

      static const int digits = 53;
      static const int digits10 = 15;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static double epsilon() throw()
      { return 2.2204460492503131e-16; }
      static double round_error() throw()
      { return 0.5; }

      static const int min_exponent = (-1021);
      static const int min_exponent10 = (-307);
      static const int max_exponent = 1024;
      static const int max_exponent10 = 308;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss = false;

      static double infinity() throw()
      { return __builtin_huge_val(); }
      static double quiet_NaN() throw()
      { return __builtin_nan (""); }
      static double signaling_NaN() throw()
      { return __builtin_nans (""); }
      static double denorm_min() throw()
      { return 4.9406564584124654e-324; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static const bool is_specialized = true;

      static long double min() throw()
      { return 3.36210314311209350626e-4932L; }
      static long double max() throw()
      { return 1.18973149535723176502e+4932L; }

      static const int digits = 64;
      static const int digits10 = 18;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static long double epsilon() throw()
      { return 1.08420217248550443401e-19L; }
      static long double round_error() throw()
      { return 0.5L; }

      static const int min_exponent = (-16381);
      static const int min_exponent10 = (-4931);
      static const int max_exponent = 16384;
      static const int max_exponent10 = 4932;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
 = false;

      static long double infinity() throw()
      { return __builtin_huge_vall (); }
      static long double quiet_NaN() throw()
      { return __builtin_nanl (""); }
      static long double signaling_NaN() throw()
      { return __builtin_nansl (""); }
      static long double denorm_min() throw()
      { return 3.64519953188247460253e-4951L; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };





}
# 60 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/memory" 2 3

namespace std {
# 71 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/memory" 3
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    __get_temporary_buffer(ptrdiff_t __len, _Tp*)
    {
      const ptrdiff_t __max = numeric_limits<ptrdiff_t>::max() / sizeof(_Tp);
      if (__len > __max)
 __len = __max;

      while (__len > 0)
 {
   _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp),
       nothrow));
   if (__tmp != 0)
     return pair<_Tp*, ptrdiff_t>(__tmp, __len);
   __len /= 2;
 }
      return pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);
    }
# 107 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/memory" 3
  template<typename _Tp>
    inline pair<_Tp*, ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len)
    { return std::__get_temporary_buffer(__len, static_cast<_Tp*>(0)); }
# 119 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/memory" 3
  template<typename _Tp>
    void
    return_temporary_buffer(_Tp* __p)
    { ::operator delete(__p, nothrow); }
# 131 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/memory" 3
  template<typename _Tp1>
    struct auto_ptr_ref
    {
      _Tp1* _M_ptr;

      explicit
      auto_ptr_ref(_Tp1* __p): _M_ptr(__p) { }
    };
# 172 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/memory" 3
  template<typename _Tp>
    class auto_ptr
    {
    private:
      _Tp* _M_ptr;

    public:

      typedef _Tp element_type;







      explicit
      auto_ptr(element_type* __p = 0) throw() : _M_ptr(__p) { }
# 198 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/memory" 3
      auto_ptr(auto_ptr& __a) throw() : _M_ptr(__a.release()) { }
# 210 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/memory" 3
      template<typename _Tp1>
        auto_ptr(auto_ptr<_Tp1>& __a) throw() : _M_ptr(__a.release()) { }
# 221 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/memory" 3
      auto_ptr&
      operator=(auto_ptr& __a) throw()
      {
 reset(__a.release());
 return *this;
      }
# 238 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/memory" 3
      template<typename _Tp1>
        auto_ptr&
        operator=(auto_ptr<_Tp1>& __a) throw()
        {
   reset(__a.release());
   return *this;
 }
# 258 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/memory" 3
      ~auto_ptr() { delete _M_ptr; }
# 268 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/memory" 3
      element_type&
      operator*() const throw()
      {
                                   ;
 return *_M_ptr;
      }







      element_type*
      operator->() const throw()
      {
                                   ;
 return _M_ptr;
      }
# 298 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/memory" 3
      element_type*
      get() const throw() { return _M_ptr; }
# 312 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/memory" 3
      element_type*
      release() throw()
      {
 element_type* __tmp = _M_ptr;
 _M_ptr = 0;
 return __tmp;
      }
# 327 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/memory" 3
      void
      reset(element_type* __p = 0) throw()
      {
 if (__p != _M_ptr)
   {
     delete _M_ptr;
     _M_ptr = __p;
   }
      }
# 348 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/memory" 3
      auto_ptr(auto_ptr_ref<element_type> __ref) throw()
      : _M_ptr(__ref._M_ptr) { }

      auto_ptr&
      operator=(auto_ptr_ref<element_type> __ref) throw()
      {
 if (__ref._M_ptr != this->get())
   {
     delete _M_ptr;
     _M_ptr = __ref._M_ptr;
   }
 return *this;
      }

      template<typename _Tp1>
        operator auto_ptr_ref<_Tp1>() throw()
        { return auto_ptr_ref<_Tp1>(this->release()); }

      template<typename _Tp1>
        operator auto_ptr<_Tp1>() throw()
        { return auto_ptr<_Tp1>(this->release()); }
  };

}
# 66 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_tempbuf.h" 2 3

namespace std {
# 76 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_tempbuf.h" 3
  template<typename _ForwardIterator, typename _Tp>
    class _Temporary_buffer
    {



    public:
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef pointer iterator;
      typedef ptrdiff_t size_type;

    protected:
      size_type _M_original_len;
      size_type _M_len;
      pointer _M_buffer;

      void
      _M_initialize_buffer(const _Tp&, __true_type) { }

      void
      _M_initialize_buffer(const _Tp& __val, __false_type)
      { std::uninitialized_fill_n(_M_buffer, _M_len, __val); }

    public:

      size_type
      size() const
      { return _M_len; }


      size_type
      requested_size() const
      { return _M_original_len; }


      iterator
      begin()
      { return _M_buffer; }


      iterator
      end()
      { return _M_buffer + _M_len; }





      _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);

      ~_Temporary_buffer()
      {
 std::_Destroy(_M_buffer, _M_buffer + _M_len);
 std::return_temporary_buffer(_M_buffer);
      }

    private:

      _Temporary_buffer(const _Temporary_buffer&);

      void
      operator=(const _Temporary_buffer&);
    };


  template<typename _ForwardIterator, typename _Tp>
    _Temporary_buffer<_ForwardIterator, _Tp>::
    _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _M_original_len(std::distance(__first, __last)),
      _M_len(0), _M_buffer(0)
    {

      typedef typename std::__is_scalar<_Tp>::__type _Trivial;

      if (true)
 {
   pair<pointer, size_type> __p(get_temporary_buffer<
           value_type>(_M_original_len));
   _M_buffer = __p.first;
   _M_len = __p.second;
   if (_M_len > 0)
     _M_initialize_buffer(*__first, _Trivial());
 }
      if (false)
 {
   std::return_temporary_buffer(_M_buffer);
   _M_buffer = 0;
   _M_len = 0;
                          ;
 }
    }

}
# 67 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 2 3




namespace std {
# 85 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _Tp>
    inline const _Tp&
    __median(const _Tp& __a, const _Tp& __b, const _Tp& __c)
    {


      if (__a < __b)
 if (__b < __c)
   return __b;
 else if (__a < __c)
   return __c;
 else
   return __a;
      else if (__a < __c)
 return __a;
      else if (__b < __c)
 return __c;
      else
 return __b;
    }
# 119 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    __median(const _Tp& __a, const _Tp& __b, const _Tp& __c, _Compare __comp)
    {


      if (__comp(__a, __b))
 if (__comp(__b, __c))
   return __b;
 else if (__comp(__a, __c))
   return __c;
 else
   return __a;
      else if (__comp(__a, __c))
 return __a;
      else if (__comp(__b, __c))
 return __c;
      else
 return __b;
    }
# 151 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Function>
    _Function
    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
    {


                                                     ;
      for ( ; __first != __last; ++__first)
 __f(*__first);
      return __f;
    }






  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    __find(_InputIterator __first, _InputIterator __last,
    const _Tp& __val, input_iterator_tag)
    {
      while (__first != __last && !(*__first == __val))
 ++__first;
      return __first;
    }






  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !__pred(*__first))
 ++__first;
      return __first;
    }






  template<typename _RandomAccessIterator, typename _Tp>
    _RandomAccessIterator
    __find(_RandomAccessIterator __first, _RandomAccessIterator __last,
    const _Tp& __val, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for ( ; __trip_count > 0 ; --__trip_count)
 {
   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (*__first == __val)
     return __first;
   ++__first;
 case 2:
   if (*__first == __val)
     return __first;
   ++__first;
 case 1:
   if (*__first == __val)
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }






  template<typename _RandomAccessIterator, typename _Predicate>
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for ( ; __trip_count > 0 ; --__trip_count)
 {
   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 2:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 1:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }






  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT>, istreambuf_iterator<_CharT>,
  const _CharT&);
# 316 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
  const _Tp& __val)
    {




                                                     ;
      return std::__find(__first, __last, __val,
           std::__iterator_category(__first));
    }
# 338 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {




                                                     ;
      return std::__find_if(__first, __last, __pred,
       std::__iterator_category(__first));
    }
# 360 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while(++__next != __last)
 {
   if (*__first == *__next)
     return __first;
   __first = __next;
 }
      return __last;
    }
# 391 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {





                                                     ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while(++__next != __last)
 {
   if (__binary_pred(*__first, *__next))
     return __first;
   __first = __next;
 }
      return __last;
    }
# 422 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
    {




                                                     ;
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for ( ; __first != __last; ++__first)
 if (*__first == __value)
   ++__n;
      return __n;
    }
# 446 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {




                                                     ;
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for ( ; __first != __last; ++__first)
 if (__pred(*__first))
   ++__n;
      return __n;
    }
# 485 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {






                                                       ;
                                                       ;

      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __tmp(__first2);
      ++__tmp;
      if (__tmp == __last2)
 return std::find(__first1, __last1, *__first2);


      _ForwardIterator2 __p1, __p;
      __p1 = __first2; ++__p1;
      _ForwardIterator1 __current = __first1;

      while (__first1 != __last1)
 {
   __first1 = std::find(__first1, __last1, *__first2);
   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (*__current == *__p)
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }
# 556 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __predicate)
    {






                                                       ;
                                                       ;


      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __tmp(__first2);
      ++__tmp;
      if (__tmp == __last2)
 {
   while (__first1 != __last1 && !__predicate(*__first1, *__first2))
     ++__first1;
   return __first1;
 }


      _ForwardIterator2 __p1, __p;
      __p1 = __first2; ++__p1;
      _ForwardIterator1 __current = __first1;

      while (__first1 != __last1)
 {
   while (__first1 != __last1)
     {
       if (__predicate(*__first1, *__first2))
  break;
       ++__first1;
     }
   while (__first1 != __last1 && !__predicate(*__first1, *__first2))
     ++__first1;
   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (__predicate(*__current, *__p))
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }
# 628 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count, const _Tp& __val,
        std::forward_iterator_tag)
    {
      __first = std::find(__first, __last, __val);
      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && *__i == __val)
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = std::find(++__i, __last, __val);
 }
      return __last;
    }
# 662 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIter, typename _Integer, typename _Tp>
    _RandomAccessIter
    __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
        _Integer __count, const _Tp& __val,
        std::random_access_iterator_tag)
    {

      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      const _DistanceType __pattSize = __count;

      if (__tailSize < __pattSize)
        return __last;

      const _DistanceType __skipOffset = __pattSize - 1;
      _RandomAccessIter __lookAhead = __first + __skipOffset;
      __tailSize -= __pattSize;

      while (1)
 {


   while (!(*__lookAhead == __val))
     {
       if (__tailSize < __pattSize)
  return __last;
       __lookAhead += __pattSize;
       __tailSize -= __pattSize;
     }
   _DistanceType __remainder = __skipOffset;
   for (_RandomAccessIter __backTrack = __lookAhead - 1;
        *__backTrack == __val; --__backTrack)
     {
       if (--__remainder == 0)
  return (__lookAhead - __skipOffset);
     }
   if (__remainder > __tailSize)
     return __last;
   __lookAhead += __remainder;
   __tailSize -= __remainder;
 }
    }
# 720 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val)
    {




                                                     ;

      if (__count <= 0)
 return __first;
      if (__count == 1)
 return std::find(__first, __last, __val);
      return std::__search_n(__first, __last, __count, __val,
        std::__iterator_category(__first));
    }
# 747 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
           typename _BinaryPredicate>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count, const _Tp& __val,
        _BinaryPredicate __binary_pred, std::forward_iterator_tag)
    {
      while (__first != __last && !__binary_pred(*__first, __val))
        ++__first;

      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && __binary_pred(*__i, __val))
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = ++__i;
   while (__first != __last && !__binary_pred(*__first, __val))
     ++__first;
 }
      return __last;
    }
# 787 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIter, typename _Integer, typename _Tp,
    typename _BinaryPredicate>
    _RandomAccessIter
    __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
        _Integer __count, const _Tp& __val,
        _BinaryPredicate __binary_pred, std::random_access_iterator_tag)
    {

      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      const _DistanceType __pattSize = __count;

      if (__tailSize < __pattSize)
        return __last;

      const _DistanceType __skipOffset = __pattSize - 1;
      _RandomAccessIter __lookAhead = __first + __skipOffset;
      __tailSize -= __pattSize;

      while (1)
 {


   while (!__binary_pred(*__lookAhead, __val))
     {
       if (__tailSize < __pattSize)
  return __last;
       __lookAhead += __pattSize;
       __tailSize -= __pattSize;
     }
   _DistanceType __remainder = __skipOffset;
   for (_RandomAccessIter __backTrack = __lookAhead - 1;
        __binary_pred(*__backTrack, __val); --__backTrack)
     {
       if (--__remainder == 0)
  return (__lookAhead - __skipOffset);
     }
   if (__remainder > __tailSize)
     return __last;
   __lookAhead += __remainder;
   __tailSize -= __remainder;
 }
    }
# 848 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
           typename _BinaryPredicate>
    _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val,
      _BinaryPredicate __binary_pred)
    {




                                                     ;

      if (__count <= 0)
 return __first;
      if (__count == 1)
 {
   while (__first != __last && !__binary_pred(*__first, __val))
     ++__first;
   return __first;
 }
      return std::__search_n(__first, __last, __count, __val, __binary_pred,
        std::__iterator_category(__first));
    }
# 884 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {
# 900 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                       ;

      for ( ; __first1 != __last1; ++__first1, ++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 922 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _UnaryOperation>
    _OutputIterator
    transform(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _UnaryOperation __unary_op)
    {





                                                     ;

      for ( ; __first != __last; ++__first, ++__result)
 *__result = __unary_op(*__first);
      return __result;
    }
# 957 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _BinaryOperation>
    _OutputIterator
    transform(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _OutputIterator __result,
       _BinaryOperation __binary_op)
    {






                                                       ;

      for ( ; __first1 != __last1; ++__first1, ++__first2, ++__result)
 *__result = __binary_op(*__first1, *__first2);
      return __result;
    }
# 989 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    void
    replace(_ForwardIterator __first, _ForwardIterator __last,
     const _Tp& __old_value, const _Tp& __new_value)
    {







                                                     ;

      for ( ; __first != __last; ++__first)
 if (*__first == __old_value)
   *__first = __new_value;
    }
# 1020 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
    void
    replace_if(_ForwardIterator __first, _ForwardIterator __last,
        _Predicate __pred, const _Tp& __new_value)
    {







                                                     ;

      for ( ; __first != __last; ++__first)
 if (__pred(*__first))
   *__first = __new_value;
    }
# 1053 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    _OutputIterator
    replace_copy(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result,
   const _Tp& __old_value, const _Tp& __new_value)
    {






                                                     ;

      for ( ; __first != __last; ++__first, ++__result)
 if (*__first == __old_value)
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
# 1089 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    _OutputIterator
    replace_copy_if(_InputIterator __first, _InputIterator __last,
      _OutputIterator __result,
      _Predicate __pred, const _Tp& __new_value)
    {






                                                     ;

      for ( ; __first != __last; ++__first, ++__result)
 if (__pred(*__first))
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
# 1123 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Generator>
    void
    generate(_ForwardIterator __first, _ForwardIterator __last,
      _Generator __gen)
    {




                                                     ;

      for ( ; __first != __last; ++__first)
 *__first = __gen();
    }
# 1149 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _OutputIterator, typename _Size, typename _Generator>
    _OutputIterator
    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
    {





      for ( ; __n > 0; --__n, ++__first)
 *__first = __gen();
      return __first;
    }
# 1176 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    _OutputIterator
    remove_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, const _Tp& __value)
    {






                                                     ;

      for ( ; __first != __last; ++__first)
 if (!(*__first == __value))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 1212 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    remove_copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {






                                                     ;

      for ( ; __first != __last; ++__first)
 if (!__pred(*__first))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 1251 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    remove(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __value)
    {





                                                     ;

      __first = std::find(__first, __last, __value);
      _ForwardIterator __i = __first;
      return __first == __last ? __first
          : std::remove_copy(++__i, __last,
        __first, __value);
    }
# 1286 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    remove_if(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





                                                     ;

      __first = std::find_if(__first, __last, __pred);
      _ForwardIterator __i = __first;
      return __first == __last ? __first
          : std::remove_copy_if(++__i, __last,
           __first, __pred);
    }
# 1312 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _OutputIterator>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result,
    forward_iterator_tag, output_iterator_tag)
    {

      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!(*__first == *__next))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }
# 1337 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result,
    input_iterator_tag, output_iterator_tag)
    {

      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
 if (!(__value == *__first))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }
# 1362 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result,
    input_iterator_tag, forward_iterator_tag)
    {

      *__result = *__first;
      while (++__first != __last)
 if (!(*__result == *__first))
   *++__result = *__first;
      return ++__result;
    }
# 1384 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    forward_iterator_tag, output_iterator_tag)
    {





      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!__binary_pred(*__first, *__next))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }
# 1415 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, output_iterator_tag)
    {





      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
 if (!__binary_pred(__value, *__first))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }
# 1446 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, forward_iterator_tag)
    {





      *__result = *__first;
      while (++__first != __last)
 if (!__binary_pred(*__result, *__first))
   *++__result = *__first;
      return ++__result;
    }
# 1487 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {






                                                     ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 1527 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result,
  _BinaryPredicate __binary_pred)
    {




                                                     ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result, __binary_pred,
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 1560 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last)
    {





                                                     ;


      __first = std::adjacent_find(__first, __last);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!(*__dest == *__first))
   *++__dest = *__first;
      return ++__dest;
    }
# 1599 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last,
           _BinaryPredicate __binary_pred)
    {






                                                     ;


      __first = std::adjacent_find(__first, __last, __binary_pred);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!__binary_pred(*__dest, *__first))
   *++__dest = *__first;
      return ++__dest;
    }
# 1633 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    void
    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {
      while (true)
 if (__first == __last || __first == --__last)
   return;
 else
   {
     std::iter_swap(__first, __last);
     ++__first;
   }
    }
# 1655 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    void
    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
       random_access_iterator_tag)
    {
      if (__first == __last)
 return;
      --__last;
      while (__first < __last)
 {
   std::iter_swap(__first, __last);
   ++__first;
   --__last;
 }
    }
# 1682 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline void
    reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
    {



                                                     ;
      std::__reverse(__first, __last, std::__iterator_category(__first));
    }
# 1708 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _OutputIterator>
    _OutputIterator
    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
        _OutputIterator __result)
    {





                                                     ;

      while (__first != __last)
 {
   --__last;
   *__result = *__last;
   ++__result;
 }
      return __result;
    }
# 1736 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _EuclideanRingElement>
    _EuclideanRingElement
    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
    {
      while (__n != 0)
 {
   _EuclideanRingElement __t = __m % __n;
   __m = __n;
   __n = __t;
 }
      return __m;
    }






  template<typename _ForwardIterator>
    void
    __rotate(_ForwardIterator __first,
      _ForwardIterator __middle,
      _ForwardIterator __last,
      forward_iterator_tag)
    {
      if (__first == __middle || __last == __middle)
 return;

      _ForwardIterator __first2 = __middle;
      do
 {
   swap(*__first, *__first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
 }
      while (__first2 != __last);

      __first2 = __middle;

      while (__first2 != __last)
 {
   swap(*__first, *__first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
   else if (__first2 == __last)
     __first2 = __middle;
 }
    }






  template<typename _BidirectionalIterator>
    void
    __rotate(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {




      if (__first == __middle || __last == __middle)
 return;

      std::__reverse(__first, __middle, bidirectional_iterator_tag());
      std::__reverse(__middle, __last, bidirectional_iterator_tag());

      while (__first != __middle && __middle != __last)
 {
   swap(*__first, *--__last);
   ++__first;
 }

      if (__first == __middle)
 std::__reverse(__middle, __last, bidirectional_iterator_tag());
      else
 std::__reverse(__first, __middle, bidirectional_iterator_tag());
    }






  template<typename _RandomAccessIterator>
    void
    __rotate(_RandomAccessIterator __first,
      _RandomAccessIterator __middle,
      _RandomAccessIterator __last,
      random_access_iterator_tag)
    {




      if (__first == __middle || __last == __middle)
 return;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      const _Distance __n = __last - __first;
      const _Distance __k = __middle - __first;
      const _Distance __l = __n - __k;

      if (__k == __l)
 {
   std::swap_ranges(__first, __middle, __middle);
   return;
 }

      const _Distance __d = __gcd(__n, __k);

      for (_Distance __i = 0; __i < __d; __i++)
 {
   _ValueType __tmp = *__first;
   _RandomAccessIterator __p = __first;

   if (__k < __l)
     {
       for (_Distance __j = 0; __j < __l / __d; __j++)
  {
    if (__p > __first + __l)
      {
        *__p = *(__p - __l);
        __p -= __l;
      }

    *__p = *(__p + __k);
    __p += __k;
  }
     }
   else
     {
       for (_Distance __j = 0; __j < __k / __d - 1; __j ++)
  {
    if (__p < __last - __k)
      {
        *__p = *(__p + __k);
        __p += __k;
      }
    *__p = * (__p - __l);
    __p -= __l;
  }
     }

   *__p = __tmp;
   ++__first;
 }
    }
# 1915 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline void
    rotate(_ForwardIterator __first, _ForwardIterator __middle,
    _ForwardIterator __last)
    {



                                                       ;
                                                      ;

      typedef typename iterator_traits<_ForwardIterator>::iterator_category
 _IterType;
      std::__rotate(__first, __middle, __last, _IterType());
    }
# 1948 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _OutputIterator>
    _OutputIterator
    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
                _ForwardIterator __last, _OutputIterator __result)
    {




                                                       ;
                                                      ;

      return std::copy(__first, __middle,
                       std::copy(__middle, __last, __result));
    }
# 1974 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {



                                                     ;

      if (__first != __last)
 for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
   std::iter_swap(__i, __first + (std::rand() % ((__i - __first) + 1)));
    }
# 2001 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
    void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _RandomNumberGenerator& __rand)
    {



                                                     ;

      if (__first == __last)
 return;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 std::iter_swap(__i, __first + __rand((__i - __first) + 1));
    }







  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __partition(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred,
  forward_iterator_tag)
    {
      if (__first == __last)
 return __first;

      while (__pred(*__first))
 if (++__first == __last)
   return __first;

      _ForwardIterator __next = __first;

      while (++__next != __last)
 if (__pred(*__next))
   {
     swap(*__first, *__next);
     ++__first;
   }

      return __first;
    }






  template<typename _BidirectionalIterator, typename _Predicate>
    _BidirectionalIterator
    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
  _Predicate __pred,
  bidirectional_iterator_tag)
    {
      while (true)
 {
   while (true)
     if (__first == __last)
       return __first;
     else if (__pred(*__first))
       ++__first;
     else
       break;
   --__last;
   while (true)
     if (__first == __last)
       return __first;
     else if (!__pred(*__last))
       --__last;
     else
       break;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }
# 2095 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





                                                     ;

      return std::__partition(__first, __last, __pred,
         std::__iterator_category(__first));
    }







  template<typename _ForwardIterator, typename _Predicate, typename _Distance>
    _ForwardIterator
    __inplace_stable_partition(_ForwardIterator __first,
          _ForwardIterator __last,
          _Predicate __pred, _Distance __len)
    {
      if (__len == 1)
 return __pred(*__first) ? __last : __first;
      _ForwardIterator __middle = __first;
      std::advance(__middle, __len / 2);
      _ForwardIterator __begin = std::__inplace_stable_partition(__first,
         __middle,
         __pred,
         __len / 2);
      _ForwardIterator __end = std::__inplace_stable_partition(__middle, __last,
              __pred,
              __len
              - __len / 2);
      std::rotate(__begin, __middle, __end);
      std::advance(__begin, std::distance(__middle, __end));
      return __begin;
    }






  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
    typename _Distance>
    _ForwardIterator
    __stable_partition_adaptive(_ForwardIterator __first,
    _ForwardIterator __last,
    _Predicate __pred, _Distance __len,
    _Pointer __buffer,
    _Distance __buffer_size)
    {
      if (__len <= __buffer_size)
 {
   _ForwardIterator __result1 = __first;
   _Pointer __result2 = __buffer;
   for ( ; __first != __last ; ++__first)
     if (__pred(*__first))
       {
  *__result1 = *__first;
  ++__result1;
       }
     else
       {
  *__result2 = *__first;
  ++__result2;
       }
   std::copy(__buffer, __result2, __result1);
   return __result1;
 }
      else
 {
   _ForwardIterator __middle = __first;
   std::advance(__middle, __len / 2);
   _ForwardIterator __begin =
     std::__stable_partition_adaptive(__first, __middle, __pred,
          __len / 2, __buffer,
          __buffer_size);
   _ForwardIterator __end =
     std::__stable_partition_adaptive(__middle, __last, __pred,
          __len - __len / 2,
          __buffer, __buffer_size);
   std::rotate(__begin, __middle, __end);
   std::advance(__begin, std::distance(__middle, __end));
   return __begin;
 }
    }
# 2206 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    stable_partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





                                                     ;

      if (__first == __last)
 return __first;
      else
 {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;
   typedef typename iterator_traits<_ForwardIterator>::difference_type
     _DistanceType;

   _Temporary_buffer<_ForwardIterator, _ValueType> __buf(__first,
        __last);
 if (__buf.size() > 0)
   return
     std::__stable_partition_adaptive(__first, __last, __pred,
       _DistanceType(__buf.requested_size()),
       __buf.begin(), __buf.size());
 else
   return
     std::__inplace_stable_partition(__first, __last, __pred,
      _DistanceType(__buf.requested_size()));
 }
    }






  template<typename _RandomAccessIterator, typename _Tp>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Tp __pivot)
    {
      while (true)
 {
   while (*__first < __pivot)
     ++__first;
   --__last;
   while (__pivot < *__last)
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }






  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last,
     _Tp __pivot, _Compare __comp)
    {
      while (true)
 {
   while (__comp(*__first, __pivot))
     ++__first;
   --__last;
   while (__comp(__pivot, *__last))
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }







  enum { _S_threshold = 16 };






  template<typename _RandomAccessIterator, typename _Tp>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last, _Tp __val)
    {
      _RandomAccessIterator __next = __last;
      --__next;
      while (__val < *__next)
 {
   *__last = *__next;
   __last = __next;
   --__next;
 }
      *__last = __val;
    }






  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last, _Tp __val,
         _Compare __comp)
    {
      _RandomAccessIterator __next = __last;
      --__next;
      while (__comp(__val, *__next))
 {
   *__last = *__next;
   __last = __next;
   --__next;
 }
      *__last = __val;
    }






  template<typename _RandomAccessIterator>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last)
    {
      if (__first == __last)
 return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   typename iterator_traits<_RandomAccessIterator>::value_type
     __val = *__i;
   if (__val < *__first)
     {
       std::copy_backward(__first, __i, __i + 1);
       *__first = __val;
     }
   else
     std::__unguarded_linear_insert(__i, __val);
 }
    }






  template<typename _RandomAccessIterator, typename _Compare>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last, _Compare __comp)
    {
      if (__first == __last) return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   typename iterator_traits<_RandomAccessIterator>::value_type
     __val = *__i;
   if (__comp(__val, *__first))
     {
       std::copy_backward(__first, __i, __i + 1);
       *__first = __val;
     }
   else
     std::__unguarded_linear_insert(__i, __val, __comp);
 }
    }






  template<typename _RandomAccessIterator>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i, _ValueType(*__i));
    }






  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i, _ValueType(*__i), __comp);
    }






  template<typename _RandomAccessIterator>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold));
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last);
 }
      else
 std::__insertion_sort(__first, __last);
    }






  template<typename _RandomAccessIterator, typename _Compare>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
       __comp);
 }
      else
 std::__insertion_sort(__first, __last, __comp);
    }






  template<typename _RandomAccessIterator>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      std::make_heap(__first, __middle);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (*__i < *__first)
   std::__pop_heap(__first, __middle, __i, _ValueType(*__i));
    }






  template<typename _RandomAccessIterator, typename _Compare>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      std::make_heap(__first, __middle, __comp);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (__comp(*__i, *__first))
   std::__pop_heap(__first, __middle, __i, _ValueType(*__i), __comp);
    }






  template<typename _Size>
    inline _Size
    __lg(_Size __n)
    {
      _Size __k;
      for (__k = 0; __n != 1; __n >>= 1)
 ++__k;
      return __k;
    }
# 2535 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;





                                                       ;
                                                      ;

      std::__heap_select(__first, __middle, __last);
      std::sort_heap(__first, __middle);
    }
# 2573 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last,
   _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;






                                                       ;
                                                      ;

      std::__heap_select(__first, __middle, __last, __comp);
      std::sort_heap(__first, __middle, __comp);
    }
# 2612 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator>
    _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;
# 2632 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                     ;
                                                                   ;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }
      std::make_heap(__result_first, __result_real_last);
      while (__first != __last)
 {
   if (*__first < *__result_first)
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first));
   ++__first;
 }
      std::sort_heap(__result_first, __result_real_last);
      return __result_real_last;
    }
# 2677 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator, typename _Compare>
    _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last,
        _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;
# 2701 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                     ;
                                                                   ;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }
      std::make_heap(__result_first, __result_real_last, __comp);
      while (__first != __last)
 {
   if (__comp(*__first, *__result_first))
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first),
          __comp);
   ++__first;
 }
      std::sort_heap(__result_first, __result_real_last, __comp);
      return __result_real_last;
    }






  template<typename _RandomAccessIterator, typename _Size>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::partial_sort(__first, __last, __last);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last
          - 1))));
   std::__introsort_loop(__cut, __last, __depth_limit);
   __last = __cut;
 }
    }






  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::partial_sort(__first, __last, __last, __comp);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last - 1),
        __comp)),
           __comp);
   std::__introsort_loop(__cut, __last, __depth_limit, __comp);
   __last = __cut;
 }
    }
# 2814 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;





                                                     ;

      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2);
   std::__final_insertion_sort(__first, __last);
 }
    }
# 2849 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;






                                                     ;

      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2, __comp);
   std::__final_insertion_sort(__first, __last, __comp);
 }
    }
# 2882 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;




                                                            ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 2932 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;





                                                                         ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(*__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 2979 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;




                                                            ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__val < *__middle)
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
# 3029 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;





                                                                         ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__val, *__middle))
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }






  template<typename _BidirectionalIterator, typename _Distance>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2)
    {
      if (__len1 == 0 || __len2 == 0)
 return;
      if (__len1 + __len2 == 2)
 {
   if (*__middle < *__first)
     std::iter_swap(__first, __middle);
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut = std::lower_bound(__middle, __last, *__first_cut);
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut = std::upper_bound(__first, __middle, *__second_cut);
   __len11 = std::distance(__first, __first_cut);
 }
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22);
    }






  template<typename _BidirectionalIterator, typename _Distance,
    typename _Compare>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
                           _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2,
      _Compare __comp)
    {
      if (__len1 == 0 || __len2 == 0)
 return;
      if (__len1 + __len2 == 2)
 {
   if (__comp(*__middle, *__first))
     std::iter_swap(__first, __middle);
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut = std::lower_bound(__middle, __last, *__first_cut,
       __comp);
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut = std::upper_bound(__first, __middle, *__second_cut,
      __comp);
   __len11 = std::distance(__first, __first_cut);
 }
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22, __comp);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22, __comp);
    }






  template<typename _RandomAccessIterator>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle);
      std::__inplace_stable_sort(__middle, __last);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle);
    }






  template<typename _RandomAccessIterator, typename _Compare>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last, __comp);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle, __comp);
      std::__inplace_stable_sort(__middle, __last, __comp);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle,
      __comp);
    }
# 3227 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 3247 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                  ;
                                                  ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first2 < *__first1)
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 3288 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 3309 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                               ;
                                                               ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first2, *__first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result,
        _Distance __step_size)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::merge(__first, __first + __step_size,
    __first + __step_size, __first + __two_step,
    __result);
   __first += __two_step;
 }

      __step_size = std::min(_Distance(__last - __first), __step_size);
      std::merge(__first, __first + __step_size, __first + __step_size, __last,
   __result);
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance, typename _Compare>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result, _Distance __step_size,
        _Compare __comp)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::merge(__first, __first + __step_size,
    __first + __step_size, __first + __two_step,
    __result,
    __comp);
   __first += __two_step;
 }
      __step_size = std::min(_Distance(__last - __first), __step_size);

      std::merge(__first, __first + __step_size,
   __first + __step_size, __last,
   __result,
   __comp);
    }

  enum { _S_chunk_size = 7 };

  template<typename _RandomAccessIterator, typename _Distance>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last);
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Compare>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size, _Compare __comp)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size, __comp);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last, __comp);
    }

  template<typename _RandomAccessIterator, typename _Pointer>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer, __step_size);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first, __step_size);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer,
     __step_size, __comp);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first,
     __step_size, __comp);
   __step_size *= 2;
 }
    }






  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3>
    _BidirectionalIterator3
    __merge_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result)
    {
      if (__first1 == __last1)
 return std::copy_backward(__first2, __last2, __result);
      if (__first2 == __last2)
 return std::copy_backward(__first1, __last1, __result);
      --__last1;
      --__last2;
      while (true)
 {
   if (*__last2 < *__last1)
     {
       *--__result = *__last1;
       if (__first1 == __last1)
  return std::copy_backward(__first2, ++__last2, __result);
       --__last1;
     }
   else
     {
       *--__result = *__last2;
       if (__first2 == __last2)
  return std::copy_backward(__first1, ++__last1, __result);
       --__last2;
     }
 }
    }






  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3, typename _Compare>
    _BidirectionalIterator3
    __merge_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result,
       _Compare __comp)
    {
      if (__first1 == __last1)
 return std::copy_backward(__first2, __last2, __result);
      if (__first2 == __last2)
 return std::copy_backward(__first1, __last1, __result);
      --__last1;
      --__last2;
      while (true)
 {
   if (__comp(*__last2, *__last1))
     {
       *--__result = *__last1;
       if (__first1 == __last1)
  return std::copy_backward(__first2, ++__last2, __result);
       --__last1;
     }
   else
     {
       *--__result = *__last2;
       if (__first2 == __last2)
  return std::copy_backward(__first1, ++__last1, __result);
       --__last2;
     }
 }
    }






  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _Distance>
    _BidirectionalIterator1
    __rotate_adaptive(_BidirectionalIterator1 __first,
        _BidirectionalIterator1 __middle,
        _BidirectionalIterator1 __last,
        _Distance __len1, _Distance __len2,
        _BidirectionalIterator2 __buffer,
        _Distance __buffer_size)
    {
      _BidirectionalIterator2 __buffer_end;
      if (__len1 > __len2 && __len2 <= __buffer_size)
 {
   __buffer_end = std::copy(__middle, __last, __buffer);
   std::copy_backward(__first, __middle, __last);
   return std::copy(__buffer, __buffer_end, __first);
 }
      else if (__len1 <= __buffer_size)
 {
   __buffer_end = std::copy(__first, __middle, __buffer);
   std::copy(__middle, __last, __first);
   return std::copy_backward(__buffer, __buffer_end, __last);
 }
      else
 {
   std::rotate(__first, __middle, __last);
   std::advance(__first, std::distance(__middle, __last));
   return __first;
 }
    }






  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__first, __middle, __buffer);
   std::merge(__buffer, __buffer_end, __middle, __last, __first);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__middle, __last, __buffer);
   std::__merge_backward(__first, __middle, __buffer,
    __buffer_end, __last);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut = std::lower_bound(__middle, __last,
           *__first_cut);
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut = std::upper_bound(__first, __middle,
          *__second_cut);
       __len11 = std::distance(__first, __first_cut);
     }
   _BidirectionalIterator __new_middle =
     std::__rotate_adaptive(__first_cut, __middle, __second_cut,
       __len1 - __len11, __len22, __buffer,
       __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer, __buffer_size);
 }
    }






  template<typename _BidirectionalIterator, typename _Distance, typename _Pointer,
    typename _Compare>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size,
       _Compare __comp)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__first, __middle, __buffer);
   std::merge(__buffer, __buffer_end, __middle, __last, __first, __comp);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__middle, __last, __buffer);
   std::__merge_backward(__first, __middle, __buffer, __buffer_end,
    __last, __comp);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut = std::lower_bound(__middle, __last, *__first_cut,
           __comp);
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut = std::upper_bound(__first, __middle, *__second_cut,
          __comp);
       __len11 = std::distance(__first, __first_cut);
     }
   _BidirectionalIterator __new_middle =
     std::__rotate_adaptive(__first_cut, __middle, __second_cut,
       __len1 - __len11, __len22, __buffer,
       __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size, __comp);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer,
    __buffer_size, __comp);
 }
    }
# 3711 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;





                                                  ;
                                                 ;

      if (__first == __middle || __middle == __last)
 return;

      _DistanceType __len1 = std::distance(__first, __middle);
      _DistanceType __len2 = std::distance(__middle, __last);

      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
          __last);
      if (__buf.begin() == 0)
 std::__merge_without_buffer(__first, __middle, __last, __len1, __len2);
      else
 std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
         __buf.begin(), _DistanceType(__buf.size()));
    }
# 3765 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare __comp)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;






                                                               ;
                                                              ;

      if (__first == __middle || __middle == __last)
 return;

      const _DistanceType __len1 = std::distance(__first, __middle);
      const _DistanceType __len2 = std::distance(__middle, __last);

      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
          __last);
      if (__buf.begin() == 0)
 std::__merge_without_buffer(__first, __middle, __last, __len1,
        __len2, __comp);
      else
 std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
         __buf.begin(), _DistanceType(__buf.size()),
         __comp);
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle,
          __buffer, __buffer_size);
   std::__stable_sort_adaptive(__middle, __last,
          __buffer, __buffer_size);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer);
   std::__merge_sort_with_buffer(__middle, __last, __buffer);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size);
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance, typename _Compare>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size,
                           _Compare __comp)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle, __buffer,
          __buffer_size, __comp);
   std::__stable_sort_adaptive(__middle, __last, __buffer,
          __buffer_size, __comp);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
   std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size,
       __comp);
    }
# 3874 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;





                                                     ;

      _Temporary_buffer<_RandomAccessIterator, _ValueType> __buf(__first,
         __last);
      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()));
    }
# 3915 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;







                                                     ;

      _Temporary_buffer<_RandomAccessIterator, _ValueType> __buf(__first,
         __last);
      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last, __comp);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()), __comp);
    }


  template<typename _RandomAccessIterator, typename _Size>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last);

       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last
          - 1))));
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last);
    }

  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit,
    _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last, __comp);

       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last - 1),
        __comp)),
           __comp);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last, __comp);
    }
# 4030 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;





                                                    ;
                                                   ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2);
    }
# 4068 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;






                                                    ;
                                                   ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2, __comp);
    }
# 4107 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;





                                                            ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle, __left, __right;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__val < *__middle)
     __len = __half;
   else
     {
       __left = std::lower_bound(__first, __middle, __val);
       std::advance(__first, __len);
       __right = std::upper_bound(++__middle, __first, __val);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 4168 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val,
  _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;







                                                                         ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle, __left, __right;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(*__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__comp(__val, *__middle))
     __len = __half;
   else
     {
       __left = std::lower_bound(__first, __middle, __val, __comp);
       std::advance(__first, __len);
       __right = std::upper_bound(++__middle, __first, __val, __comp);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 4226 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;




                                                            ;

      _ForwardIterator __i = std::lower_bound(__first, __last, __val);
      return __i != __last && !(__val < *__i);
    }
# 4258 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;





                                                                         ;

      _ForwardIterator __i = std::lower_bound(__first, __last, __val, __comp);
      return __i != __last && !__comp(__val, *__i);
    }
# 4297 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;






                                                  ;
                                                  ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first2 < *__first1)
   return false;
 else if(*__first1 < *__first2)
   ++__first1;
 else
   ++__first1, ++__first2;

      return __first2 == __last2;
    }
# 4345 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 4363 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                               ;
                                                               ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first2, *__first1))
   return false;
 else if(__comp(*__first1, *__first2))
   ++__first1;
 else
   ++__first1, ++__first2;

      return __first2 == __last2;
    }
# 4394 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 4415 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                  ;
                                                  ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first1 < *__first2)
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (*__first2 < *__first1)
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 4460 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 4483 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                               ;
                                                               ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first1, *__first2))
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (__comp(*__first2, *__first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 4526 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 4545 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                  ;
                                                  ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   ++__first1;
 else if (*__first2 < *__first1)
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 4582 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 4603 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                               ;
                                                               ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   ++__first1;
 else if (__comp(*__first2, *__first1))
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 4639 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 4658 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                  ;
                                                  ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (*__first2 < *__first1)
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 4699 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 4720 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                               ;
                                                               ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(*__first2, *__first1))
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 4756 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 4777 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                  ;
                                                  ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (*__first2 < *__first1)
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2, std::copy(__first1,
          __last1, __result));
    }
# 4821 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result,
        _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 4845 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
                                                               ;
                                                               ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(*__first2, *__first1))
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2, std::copy(__first1,
          __last1, __result));
    }
# 4879 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (*__result < *__first)
   __result = __first;
      return __result;
    }
# 4906 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {





                                                     ;

      if (__first == __last) return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(*__result, *__first)) __result = __first;
      return __result;
    }







  template<typename _ForwardIterator>
    _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (*__first < *__result)
   __result = __first;
      return __result;
    }
# 4958 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {





                                                     ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(*__first, *__result))
   __result = __first;
      return __result;
    }
# 4993 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {





                                                     ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (*__i < *__ii)
     {
       _BidirectionalIterator __j = __last;
       while (!(*__i < *--__j))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 5049 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {






                                                     ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(*__i, *__ii))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(*__i, *--__j))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 5104 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {





                                                     ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (*__ii < *__i)
     {
       _BidirectionalIterator __j = __last;
       while (!(*--__j < *__i))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 5160 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {






                                                     ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(*__ii, *__i))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(*--__j, *__i))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 5219 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2)
    {






                                                       ;
                                                       ;

      for ( ; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (*__first1 == *__iter)
     return __first1;
      return __last1;
    }
# 5255 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2,
    _BinaryPredicate __comp)
    {






                                                       ;
                                                       ;

      for ( ; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (__comp(*__first1, *__iter))
     return __first1;
      return __last1;
    }
# 5285 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag)
    {
      if (__first2 == __last2)
 return __last1;
      else
 {
   _ForwardIterator1 __result = __last1;
   while (1)
     {
       _ForwardIterator1 __new_result
  = std::search(__first1, __last1, __first2, __last2);
       if (__new_result == __last1)
  return __result;
       else
  {
    __result = __new_result;
    __first1 = __new_result;
    ++__first1;
  }
     }
 }
    }

  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag,
        _BinaryPredicate __comp)
    {
      if (__first2 == __last2)
 return __last1;
      else
 {
   _ForwardIterator1 __result = __last1;
   while (1)
     {
       _ForwardIterator1 __new_result
  = std::search(__first1, __last1, __first2, __last2, __comp);
       if (__new_result == __last1)
  return __result;
       else
  {
    __result = __new_result;
    __first1 = __new_result;
    ++__first1;
  }
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag)
    {






      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::search(_RevIterator1(__last1), __rlast1,
         _RevIterator2(__last2), __rlast2);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }

  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BinaryPredicate>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag,
        _BinaryPredicate __comp)
    {






      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::search(_RevIterator1(__last1), __rlast1,
         _RevIterator2(__last2), __rlast2,
         __comp);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }
# 5435 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {






                                                       ;
                                                       ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2));
    }
# 5480 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __comp)
    {






                                                       ;
                                                       ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __comp);
    }

}
# 68 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/algorithm" 2 3
# 27 "./wtf/RefPtr.h" 2
# 1 "./wtf/FastAllocBase.h" 1
# 93 "./wtf/FastAllocBase.h"
# 1 "./wtf/TypeTraits.h" 1
# 34 "./wtf/TypeTraits.h"
namespace WTF {
# 52 "./wtf/TypeTraits.h"
    template<typename T> struct IsInteger { static const bool value = false; };
    template<> struct IsInteger<bool> { static const bool value = true; };
    template<> struct IsInteger<char> { static const bool value = true; };
    template<> struct IsInteger<signed char> { static const bool value = true; };
    template<> struct IsInteger<unsigned char> { static const bool value = true; };
    template<> struct IsInteger<short> { static const bool value = true; };
    template<> struct IsInteger<unsigned short> { static const bool value = true; };
    template<> struct IsInteger<int> { static const bool value = true; };
    template<> struct IsInteger<unsigned int> { static const bool value = true; };
    template<> struct IsInteger<long> { static const bool value = true; };
    template<> struct IsInteger<unsigned long> { static const bool value = true; };
    template<> struct IsInteger<long long> { static const bool value = true; };
    template<> struct IsInteger<unsigned long long> { static const bool value = true; };

    template<> struct IsInteger<wchar_t> { static const bool value = true; };


    template<typename T> struct IsFloatingPoint { static const bool value = false; };
    template<> struct IsFloatingPoint<float> { static const bool value = true; };
    template<> struct IsFloatingPoint<double> { static const bool value = true; };
    template<> struct IsFloatingPoint<long double> { static const bool value = true; };

    template<typename T> struct IsArithmetic { static const bool value = IsInteger<T>::value || IsFloatingPoint<T>::value; };



    template <typename T> struct IsPod { static const bool value = IsArithmetic<T>::value; };
    template <typename P> struct IsPod<P*> { static const bool value = true; };

    template<typename T> class IsConvertibleToInteger {


        template<bool performCheck, typename U> class IsConvertibleToDouble;
        template<typename U> class IsConvertibleToDouble<false, U> {
        public:
            static const bool value = false;
        };

        template<typename U> class IsConvertibleToDouble<true, U> {
            typedef char YesType;
            struct NoType {
                char padding[8];
            };

            static YesType floatCheck(long double);
            static NoType floatCheck(...);
            static T& t;
        public:
            static const bool value = sizeof(floatCheck(t)) == sizeof(YesType);
        };

    public:
        static const bool value = IsInteger<T>::value || IsConvertibleToDouble<!IsInteger<T>::value, T>::value;
    };

    template <typename T, typename U> struct IsSameType {
        static const bool value = false;
    };

    template <typename T> struct IsSameType<T, T> {
        static const bool value = true;
    };

    template <typename T, typename U> class IsSubclass {
        typedef char YesType;
        struct NoType {
            char padding[8];
        };

        static YesType subclassCheck(U*);
        static NoType subclassCheck(...);
        static T* t;
    public:
        static const bool value = sizeof(subclassCheck(t)) == sizeof(YesType);
    };

    template <typename T, template<class V> class U> class IsSubclassOfTemplate {
        typedef char YesType;
        struct NoType {
            char padding[8];
        };

        template<typename W> static YesType subclassCheck(U<W>*);
        static NoType subclassCheck(...);
        static T* t;
    public:
        static const bool value = sizeof(subclassCheck(t)) == sizeof(YesType);
    };

    template <typename T, template <class V> class OuterTemplate> struct RemoveTemplate {
        typedef T Type;
    };

    template <typename T, template <class V> class OuterTemplate> struct RemoveTemplate<OuterTemplate<T>, OuterTemplate> {
        typedef T Type;
    };

    template <typename T> struct RemoveConst {
        typedef T Type;
    };

    template <typename T> struct RemoveConst<const T> {
        typedef T Type;
    };

    template <typename T> struct RemoveVolatile {
        typedef T Type;
    };

    template <typename T> struct RemoveVolatile<volatile T> {
        typedef T Type;
    };

    template <typename T> struct RemoveConstVolatile {
        typedef typename RemoveVolatile<typename RemoveConst<T>::Type>::Type Type;
    };

    template <typename T> struct RemovePointer {
        typedef T Type;
    };

    template <typename T> struct RemovePointer<T*> {
        typedef T Type;
    };

    template <typename T> struct RemoveReference {
        typedef T Type;
    };

    template <typename T> struct RemoveReference<T&> {
        typedef T Type;
    };
# 198 "./wtf/TypeTraits.h"
    template <typename T, T v>
    struct IntegralConstant {
        static const T value = v;
        typedef T value_type;
        typedef IntegralConstant<T, v> type;
    };

    typedef IntegralConstant<bool, true> true_type;
    typedef IntegralConstant<bool, false> false_type;







    template <typename T> struct HasTrivialConstructor : public false_type{ };
    template <typename T> struct HasTrivialDestructor : public false_type{ };


    template <typename T> struct HasTrivialConstructor<T*> : public true_type{ };
    template <typename T> struct HasTrivialDestructor<T*> : public true_type{ };

    template <> struct HasTrivialConstructor<float> : public true_type{ };
    template <> struct HasTrivialConstructor<const float> : public true_type{ };
    template <> struct HasTrivialConstructor<volatile float> : public true_type{ };
    template <> struct HasTrivialConstructor<const volatile float> : public true_type{ };

    template <> struct HasTrivialConstructor<double> : public true_type{ };
    template <> struct HasTrivialConstructor<const double> : public true_type{ };
    template <> struct HasTrivialConstructor<volatile double> : public true_type{ };
    template <> struct HasTrivialConstructor<const volatile double> : public true_type{ };

    template <> struct HasTrivialConstructor<long double> : public true_type{ };
    template <> struct HasTrivialConstructor<const long double> : public true_type{ };
    template <> struct HasTrivialConstructor<volatile long double> : public true_type{ };
    template <> struct HasTrivialConstructor<const volatile long double> : public true_type{ };

    template <> struct HasTrivialConstructor<unsigned char> : public true_type{ };
    template <> struct HasTrivialConstructor<const unsigned char> : public true_type{ };
    template <> struct HasTrivialConstructor<volatile unsigned char> : public true_type{ };
    template <> struct HasTrivialConstructor<const volatile unsigned char> : public true_type{ };

    template <> struct HasTrivialConstructor<unsigned short> : public true_type{ };
    template <> struct HasTrivialConstructor<const unsigned short> : public true_type{ };
    template <> struct HasTrivialConstructor<volatile unsigned short> : public true_type{ };
    template <> struct HasTrivialConstructor<const volatile unsigned short> : public true_type{ };

    template <> struct HasTrivialConstructor<unsigned int> : public true_type{ };
    template <> struct HasTrivialConstructor<const unsigned int> : public true_type{ };
    template <> struct HasTrivialConstructor<volatile unsigned int> : public true_type{ };
    template <> struct HasTrivialConstructor<const volatile unsigned int> : public true_type{ };

    template <> struct HasTrivialConstructor<unsigned long> : public true_type{ };
    template <> struct HasTrivialConstructor<const unsigned long> : public true_type{ };
    template <> struct HasTrivialConstructor<volatile unsigned long> : public true_type{ };
    template <> struct HasTrivialConstructor<const volatile unsigned long> : public true_type{ };

    template <> struct HasTrivialConstructor<unsigned long long> : public true_type{ };
    template <> struct HasTrivialConstructor<const unsigned long long> : public true_type{ };
    template <> struct HasTrivialConstructor<volatile unsigned long long> : public true_type{ };
    template <> struct HasTrivialConstructor<const volatile unsigned long long> : public true_type{ };

    template <> struct HasTrivialConstructor<signed char> : public true_type{ };
    template <> struct HasTrivialConstructor<const signed char> : public true_type{ };
    template <> struct HasTrivialConstructor<volatile signed char> : public true_type{ };
    template <> struct HasTrivialConstructor<const volatile signed char> : public true_type{ };

    template <> struct HasTrivialConstructor<signed short> : public true_type{ };
    template <> struct HasTrivialConstructor<const signed short> : public true_type{ };
    template <> struct HasTrivialConstructor<volatile signed short> : public true_type{ };
    template <> struct HasTrivialConstructor<const volatile signed short> : public true_type{ };

    template <> struct HasTrivialConstructor<signed int> : public true_type{ };
    template <> struct HasTrivialConstructor<const signed int> : public true_type{ };
    template <> struct HasTrivialConstructor<volatile signed int> : public true_type{ };
    template <> struct HasTrivialConstructor<const volatile signed int> : public true_type{ };

    template <> struct HasTrivialConstructor<signed long> : public true_type{ };
    template <> struct HasTrivialConstructor<const signed long> : public true_type{ };
    template <> struct HasTrivialConstructor<volatile signed long> : public true_type{ };
    template <> struct HasTrivialConstructor<const volatile signed long> : public true_type{ };

    template <> struct HasTrivialConstructor<signed long long> : public true_type{ };
    template <> struct HasTrivialConstructor<const signed long long> : public true_type{ };
    template <> struct HasTrivialConstructor<volatile signed long long> : public true_type{ };
    template <> struct HasTrivialConstructor<const volatile signed long long> : public true_type{ };

    template <> struct HasTrivialConstructor<bool> : public true_type{ };
    template <> struct HasTrivialConstructor<const bool> : public true_type{ };
    template <> struct HasTrivialConstructor<volatile bool> : public true_type{ };
    template <> struct HasTrivialConstructor<const volatile bool> : public true_type{ };

    template <> struct HasTrivialConstructor<char> : public true_type{ };
    template <> struct HasTrivialConstructor<const char> : public true_type{ };
    template <> struct HasTrivialConstructor<volatile char> : public true_type{ };
    template <> struct HasTrivialConstructor<const volatile char> : public true_type{ };


        template <> struct HasTrivialConstructor<wchar_t> : public true_type{ };
        template <> struct HasTrivialConstructor<const wchar_t> : public true_type{ };
        template <> struct HasTrivialConstructor<volatile wchar_t> : public true_type{ };
        template <> struct HasTrivialConstructor<const volatile wchar_t> : public true_type{ };


    template <> struct HasTrivialDestructor<float> : public true_type{ };
    template <> struct HasTrivialDestructor<const float> : public true_type{ };
    template <> struct HasTrivialDestructor<volatile float> : public true_type{ };
    template <> struct HasTrivialDestructor<const volatile float> : public true_type{ };

    template <> struct HasTrivialDestructor<double> : public true_type{ };
    template <> struct HasTrivialDestructor<const double> : public true_type{ };
    template <> struct HasTrivialDestructor<volatile double> : public true_type{ };
    template <> struct HasTrivialDestructor<const volatile double> : public true_type{ };

    template <> struct HasTrivialDestructor<long double> : public true_type{ };
    template <> struct HasTrivialDestructor<const long double> : public true_type{ };
    template <> struct HasTrivialDestructor<volatile long double> : public true_type{ };
    template <> struct HasTrivialDestructor<const volatile long double> : public true_type{ };

    template <> struct HasTrivialDestructor<unsigned char> : public true_type{ };
    template <> struct HasTrivialDestructor<const unsigned char> : public true_type{ };
    template <> struct HasTrivialDestructor<volatile unsigned char> : public true_type{ };
    template <> struct HasTrivialDestructor<const volatile unsigned char> : public true_type{ };

    template <> struct HasTrivialDestructor<unsigned short> : public true_type{ };
    template <> struct HasTrivialDestructor<const unsigned short> : public true_type{ };
    template <> struct HasTrivialDestructor<volatile unsigned short> : public true_type{ };
    template <> struct HasTrivialDestructor<const volatile unsigned short> : public true_type{ };

    template <> struct HasTrivialDestructor<unsigned int> : public true_type{ };
    template <> struct HasTrivialDestructor<const unsigned int> : public true_type{ };
    template <> struct HasTrivialDestructor<volatile unsigned int> : public true_type{ };
    template <> struct HasTrivialDestructor<const volatile unsigned int> : public true_type{ };

    template <> struct HasTrivialDestructor<unsigned long> : public true_type{ };
    template <> struct HasTrivialDestructor<const unsigned long> : public true_type{ };
    template <> struct HasTrivialDestructor<volatile unsigned long> : public true_type{ };
    template <> struct HasTrivialDestructor<const volatile unsigned long> : public true_type{ };

    template <> struct HasTrivialDestructor<unsigned long long> : public true_type{ };
    template <> struct HasTrivialDestructor<const unsigned long long> : public true_type{ };
    template <> struct HasTrivialDestructor<volatile unsigned long long> : public true_type{ };
    template <> struct HasTrivialDestructor<const volatile unsigned long long> : public true_type{ };

    template <> struct HasTrivialDestructor<signed char> : public true_type{ };
    template <> struct HasTrivialDestructor<const signed char> : public true_type{ };
    template <> struct HasTrivialDestructor<volatile signed char> : public true_type{ };
    template <> struct HasTrivialDestructor<const volatile signed char> : public true_type{ };

    template <> struct HasTrivialDestructor<signed short> : public true_type{ };
    template <> struct HasTrivialDestructor<const signed short> : public true_type{ };
    template <> struct HasTrivialDestructor<volatile signed short> : public true_type{ };
    template <> struct HasTrivialDestructor<const volatile signed short> : public true_type{ };

    template <> struct HasTrivialDestructor<signed int> : public true_type{ };
    template <> struct HasTrivialDestructor<const signed int> : public true_type{ };
    template <> struct HasTrivialDestructor<volatile signed int> : public true_type{ };
    template <> struct HasTrivialDestructor<const volatile signed int> : public true_type{ };

    template <> struct HasTrivialDestructor<signed long> : public true_type{ };
    template <> struct HasTrivialDestructor<const signed long> : public true_type{ };
    template <> struct HasTrivialDestructor<volatile signed long> : public true_type{ };
    template <> struct HasTrivialDestructor<const volatile signed long> : public true_type{ };

    template <> struct HasTrivialDestructor<signed long long> : public true_type{ };
    template <> struct HasTrivialDestructor<const signed long long> : public true_type{ };
    template <> struct HasTrivialDestructor<volatile signed long long> : public true_type{ };
    template <> struct HasTrivialDestructor<const volatile signed long long> : public true_type{ };

    template <> struct HasTrivialDestructor<bool> : public true_type{ };
    template <> struct HasTrivialDestructor<const bool> : public true_type{ };
    template <> struct HasTrivialDestructor<volatile bool> : public true_type{ };
    template <> struct HasTrivialDestructor<const volatile bool> : public true_type{ };

    template <> struct HasTrivialDestructor<char> : public true_type{ };
    template <> struct HasTrivialDestructor<const char> : public true_type{ };
    template <> struct HasTrivialDestructor<volatile char> : public true_type{ };
    template <> struct HasTrivialDestructor<const volatile char> : public true_type{ };


        template <> struct HasTrivialDestructor<wchar_t> : public true_type{ };
        template <> struct HasTrivialDestructor<const wchar_t> : public true_type{ };
        template <> struct HasTrivialDestructor<volatile wchar_t> : public true_type{ };
        template <> struct HasTrivialDestructor<const volatile wchar_t> : public true_type{ };




}
# 94 "./wtf/FastAllocBase.h" 2
# 128 "./wtf/FastAllocBase.h"
namespace WTF {



    template <typename T>
    inline T* fastNew()
    {
        void* p = fastMalloc(sizeof(T));

        if (!p)
            return 0;

        fastMallocMatchValidateMalloc(p, Internal::AllocTypeFastNew);
        return ::new(p) T;
    }

    template <typename T, typename Arg1>
    inline T* fastNew(Arg1 arg1)
    {
        void* p = fastMalloc(sizeof(T));

        if (!p)
            return 0;

        fastMallocMatchValidateMalloc(p, Internal::AllocTypeFastNew);
        return ::new(p) T(arg1);
    }

    template <typename T, typename Arg1, typename Arg2>
    inline T* fastNew(Arg1 arg1, Arg2 arg2)
    {
        void* p = fastMalloc(sizeof(T));

        if (!p)
            return 0;

        fastMallocMatchValidateMalloc(p, Internal::AllocTypeFastNew);
        return ::new(p) T(arg1, arg2);
    }

    template <typename T, typename Arg1, typename Arg2, typename Arg3>
    inline T* fastNew(Arg1 arg1, Arg2 arg2, Arg3 arg3)
    {
        void* p = fastMalloc(sizeof(T));

        if (!p)
            return 0;

        fastMallocMatchValidateMalloc(p, Internal::AllocTypeFastNew);
        return ::new(p) T(arg1, arg2, arg3);
    }

    template <typename T, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
    inline T* fastNew(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4)
    {
        void* p = fastMalloc(sizeof(T));

        if (!p)
            return 0;

        fastMallocMatchValidateMalloc(p, Internal::AllocTypeFastNew);
        return ::new(p) T(arg1, arg2, arg3, arg4);
    }

    template <typename T, typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
    inline T* fastNew(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5)
    {
        void* p = fastMalloc(sizeof(T));

        if (!p)
            return 0;

        fastMallocMatchValidateMalloc(p, Internal::AllocTypeFastNew);
        return ::new(p) T(arg1, arg2, arg3, arg4, arg5);
    }

    namespace Internal {
# 215 "./wtf/FastAllocBase.h"
        template <typename T>
        union ArraySize {
            AllocAlignmentInteger* size;
            T* t;
        };



        template <typename T, bool trivialCtor, bool trivialDtor>
        struct NewArrayImpl {
            static T* fastNewArray(size_t count)
            {
                T* p = static_cast<T*>(fastMalloc(sizeof(T) * count));
                fastMallocMatchValidateMalloc(p, Internal::AllocTypeFastNewArray);
                return p;
            }
        };



        template <typename T>
        struct NewArrayImpl<T, false, true> {
            static T* fastNewArray(size_t count)
            {
                T* p = static_cast<T*>(fastMalloc(sizeof(T) * count));

                if (!p)
                    return 0;

                fastMallocMatchValidateMalloc(p, Internal::AllocTypeFastNewArray);

                for (T* pObject = p, *pObjectEnd = pObject + count; pObject != pObjectEnd; ++pObject)
                    ::new(pObject) T;

                return p;
            }
        };



        template <typename T>
        struct NewArrayImpl<T, true, false> {
            static T* fastNewArray(size_t count)
            {
                void* p = fastMalloc(sizeof(AllocAlignmentInteger) + (sizeof(T) * count));
                ArraySize<T> a = { static_cast<AllocAlignmentInteger*>(p) };

                if (!p)
                    return 0;

                fastMallocMatchValidateMalloc(p, Internal::AllocTypeFastNewArray);
                *a.size++ = count;


                return a.t;
            }
        };



        template <typename T>
        struct NewArrayImpl<T, false, false> {
            static T* fastNewArray(size_t count)
            {
                void* p = fastMalloc(sizeof(AllocAlignmentInteger) + (sizeof(T) * count));
                ArraySize<T> a = { static_cast<AllocAlignmentInteger*>(p) };

                if (!p)
                    return 0;

                fastMallocMatchValidateMalloc(p, Internal::AllocTypeFastNewArray);
                *a.size++ = count;

                for (T* pT = a.t, *pTEnd = pT + count; pT != pTEnd; ++pT)
                    ::new(pT) T;

                return a.t;
            }
        };
    }

    template <typename T>
    inline T* fastNewArray(size_t count)
    {
        return Internal::NewArrayImpl<T, WTF::HasTrivialConstructor<T>::value, WTF::HasTrivialDestructor<T>::value>::fastNewArray(count);
    }

    template <typename T>
    inline void fastDelete(T* p)
    {
        if (!p)
            return;

        fastMallocMatchValidateFree(p, Internal::AllocTypeFastNew);
        p->~T();
        fastFree(p);
    }

    template <typename T>
    inline void fastDeleteSkippingDestructor(T* p)
    {
        if (!p)
            return;

        fastMallocMatchValidateFree(p, Internal::AllocTypeFastNew);
        fastFree(p);
    }

    namespace Internal {


        template <typename T, bool trivialDtor>
        struct DeleteArrayImpl {
            static void fastDeleteArray(void* p)
            {


                fastMallocMatchValidateFree(p, Internal::AllocTypeFastNewArray);
                fastFree(p);
            }
        };



        template <typename T>
        struct DeleteArrayImpl<T, false> {
            static void fastDeleteArray(T* p)
            {
                if (!p)
                    return;

                ArraySize<T> a;
                a.t = p;
                a.size--;

                T* pEnd = p + *a.size;
                while (pEnd-- != p)
                    pEnd->~T();

                fastMallocMatchValidateFree(a.size, Internal::AllocTypeFastNewArray);
                fastFree(a.size);
            }
        };

    }

    template <typename T>
    void fastDeleteArray(T* p)
    {
        Internal::DeleteArrayImpl<T, WTF::HasTrivialDestructor<T>::value>::fastDeleteArray(p);
    }


    template <typename T>
    inline void fastNonNullDelete(T* p)
    {
        fastMallocMatchValidateFree(p, Internal::AllocTypeFastNew);
        p->~T();
        fastFree(p);
    }

    namespace Internal {


        template <typename T, bool trivialDtor>
        struct NonNullDeleteArrayImpl {
            static void fastNonNullDeleteArray(void* p)
            {
                fastMallocMatchValidateFree(p, Internal::AllocTypeFastNewArray);

                fastFree(p);
            }
        };



        template <typename T>
        struct NonNullDeleteArrayImpl<T, false> {
            static void fastNonNullDeleteArray(T* p)
            {
                ArraySize<T> a;
                a.t = p;
                a.size--;

                T* pEnd = p + *a.size;
                while (pEnd-- != p)
                    pEnd->~T();

                fastMallocMatchValidateFree(a.size, Internal::AllocTypeFastNewArray);
                fastFree(a.size);
            }
        };

    }

    template <typename T>
    void fastNonNullDeleteArray(T* p)
    {
        Internal::NonNullDeleteArrayImpl<T, WTF::HasTrivialDestructor<T>::value>::fastNonNullDeleteArray(p);
    }


}

using WTF::fastDeleteSkippingDestructor;
# 28 "./wtf/RefPtr.h" 2
# 1 "./wtf/PassRefPtr.h" 1
# 24 "./wtf/PassRefPtr.h"
# 1 "./wtf/AlwaysInline.h" 1
# 25 "./wtf/PassRefPtr.h" 2
# 1 "./wtf/NullPtr.h" 1
# 46 "./wtf/NullPtr.h"
namespace std {
    class nullptr_t { };
}

extern std::nullptr_t nullptr;
# 26 "./wtf/PassRefPtr.h" 2

namespace WTF {

    template<typename T> class RefPtr;
    template<typename T> class PassRefPtr;
    template<typename T> PassRefPtr<T> adoptRef(T*);

    inline void adopted(const void*) { }
# 50 "./wtf/PassRefPtr.h"
    template<typename T> inline __attribute__((__always_inline__)) void refIfNotNull(T* ptr)
    {
        if (__builtin_expect((ptr != 0), 1))
            ptr->ref();
    }

    template<typename T> inline __attribute__((__always_inline__)) void derefIfNotNull(T* ptr)
    {
        if (__builtin_expect((ptr != 0), 1))
            ptr->deref();
    }



    template<typename T> class PassRefPtr {
    public:
        PassRefPtr() : m_ptr(0) { }
        PassRefPtr(T* ptr) : m_ptr(ptr) { refIfNotNull(ptr); }



        PassRefPtr(const PassRefPtr& o) : m_ptr(o.leakRef()) { }
        template<typename U> PassRefPtr(const PassRefPtr<U>& o) : m_ptr(o.leakRef()) { }

        inline __attribute__((__always_inline__)) ~PassRefPtr() { derefIfNotNull(m_ptr); }

        template<typename U> PassRefPtr(const RefPtr<U>&);

        T* get() const { return m_ptr; }

        T* leakRef() const __attribute__ ((warn_unused_result));

        T& operator*() const { return *m_ptr; }
        T* operator->() const { return m_ptr; }

        bool operator!() const { return !m_ptr; }


        typedef T* (PassRefPtr::*UnspecifiedBoolType);
        operator UnspecifiedBoolType() const { return m_ptr ? &PassRefPtr::m_ptr : 0; }

        PassRefPtr& operator=(const PassRefPtr&) { typedef int dummyPassRefPtr_should_never_be_assigned_to [(!sizeof(T*)) ? 1 : -1]; return *this; }

        friend PassRefPtr adoptRef<T>(T*);


        T* releaseRef() const __attribute__ ((warn_unused_result)) { return leakRef(); }

    private:

        PassRefPtr(T* ptr, bool) : m_ptr(ptr) { }

        mutable T* m_ptr;
    };
# 113 "./wtf/PassRefPtr.h"
    template<typename T> class NonNullPassRefPtr {
    public:
        NonNullPassRefPtr(T* ptr)
            : m_ptr(ptr)
        {
            ((void)0);
            m_ptr->ref();
        }

        template<typename U> NonNullPassRefPtr(const RefPtr<U>& o)
            : m_ptr(o.get())
        {
            ((void)0);
            m_ptr->ref();
        }

        NonNullPassRefPtr(const NonNullPassRefPtr& o)
            : m_ptr(o.leakRef())
        {
            ((void)0);
        }

        template<typename U> NonNullPassRefPtr(const NonNullPassRefPtr<U>& o)
            : m_ptr(o.leakRef())
        {
            ((void)0);
        }

        template<typename U> NonNullPassRefPtr(const PassRefPtr<U>& o)
            : m_ptr(o.leakRef())
        {
            ((void)0);
        }

        inline __attribute__((__always_inline__)) ~NonNullPassRefPtr() { derefIfNotNull(m_ptr); }

        T* get() const { return m_ptr; }

        T* leakRef() const __attribute__ ((warn_unused_result)) { T* tmp = m_ptr; m_ptr = 0; return tmp; }

        T& operator*() const { return *m_ptr; }
        T* operator->() const { return m_ptr; }

        NonNullPassRefPtr& operator=(const NonNullPassRefPtr&) { typedef int dummyNonNullPassRefPtr_should_never_be_assigned_to [(!sizeof(T*)) ? 1 : -1]; return *this; }


        T* releaseRef() const __attribute__ ((warn_unused_result)) { return leakRef(); }

    private:
        mutable T* m_ptr;
    };

    template<typename T> template<typename U> inline PassRefPtr<T>::PassRefPtr(const RefPtr<U>& o)
        : m_ptr(o.get())
    {
        T* ptr = m_ptr;
        refIfNotNull(ptr);
    }

    template<typename T> inline T* PassRefPtr<T>::leakRef() const
    {
        T* ptr = m_ptr;
        m_ptr = 0;
        return ptr;
    }

    template<typename T, typename U> inline bool operator==(const PassRefPtr<T>& a, const PassRefPtr<U>& b)
    {
        return a.get() == b.get();
    }

    template<typename T, typename U> inline bool operator==(const PassRefPtr<T>& a, const RefPtr<U>& b)
    {
        return a.get() == b.get();
    }

    template<typename T, typename U> inline bool operator==(const RefPtr<T>& a, const PassRefPtr<U>& b)
    {
        return a.get() == b.get();
    }

    template<typename T, typename U> inline bool operator==(const PassRefPtr<T>& a, U* b)
    {
        return a.get() == b;
    }

    template<typename T, typename U> inline bool operator==(T* a, const PassRefPtr<U>& b)
    {
        return a == b.get();
    }

    template<typename T, typename U> inline bool operator!=(const PassRefPtr<T>& a, const PassRefPtr<U>& b)
    {
        return a.get() != b.get();
    }

    template<typename T, typename U> inline bool operator!=(const PassRefPtr<T>& a, const RefPtr<U>& b)
    {
        return a.get() != b.get();
    }

    template<typename T, typename U> inline bool operator!=(const RefPtr<T>& a, const PassRefPtr<U>& b)
    {
        return a.get() != b.get();
    }

    template<typename T, typename U> inline bool operator!=(const PassRefPtr<T>& a, U* b)
    {
        return a.get() != b;
    }

    template<typename T, typename U> inline bool operator!=(T* a, const PassRefPtr<U>& b)
    {
        return a != b.get();
    }

    template<typename T> inline PassRefPtr<T> adoptRef(T* p)
    {
        adopted(p);
        return PassRefPtr<T>(p, true);
    }

    template<typename T, typename U> inline PassRefPtr<T> static_pointer_cast(const PassRefPtr<U>& p)
    {
        return adoptRef(static_cast<T*>(p.leakRef()));
    }

    template<typename T, typename U> inline PassRefPtr<T> const_pointer_cast(const PassRefPtr<U>& p)
    {
        return adoptRef(const_cast<T*>(p.leakRef()));
    }

    template<typename T> inline T* getPtr(const PassRefPtr<T>& p)
    {
        return p.get();
    }

}

using WTF::PassRefPtr;
using WTF::NonNullPassRefPtr;
using WTF::adoptRef;
using WTF::static_pointer_cast;
using WTF::const_pointer_cast;
# 29 "./wtf/RefPtr.h" 2

namespace WTF {

    enum PlacementNewAdoptType { PlacementNewAdopt };

    template<typename T> class PassRefPtr;
    template<typename T> class NonNullPassRefPtr;

    enum HashTableDeletedValueType { HashTableDeletedValue };

    template<typename T> class RefPtr {
        public: void* operator new(size_t, void* p) { return p; } void* operator new[](size_t, void* p) { return p; } void* operator new(size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNew); return p; } void operator delete(void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNew); ::WTF::fastFree(p); } void* operator new[](size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNewArray); return p; } void operator delete[](void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNewArray); ::WTF::fastFree(p); } private: typedef int ThisIsHereToForceASemicolonAfterThisMacro;
    public:
        inline __attribute__((__always_inline__)) RefPtr() : m_ptr(0) { }
        inline __attribute__((__always_inline__)) RefPtr(T* ptr) : m_ptr(ptr) { refIfNotNull(ptr); }
        inline __attribute__((__always_inline__)) RefPtr(const RefPtr& o) : m_ptr(o.m_ptr) { refIfNotNull(m_ptr); }
        template<typename U> RefPtr(const RefPtr<U>& o) : m_ptr(o.get()) { refIfNotNull(m_ptr); }


        template<typename U> RefPtr(const PassRefPtr<U>&);
        template<typename U> RefPtr(const NonNullPassRefPtr<U>&);


        inline __attribute__((__always_inline__)) RefPtr(PlacementNewAdoptType) { }


        RefPtr(HashTableDeletedValueType) : m_ptr(hashTableDeletedValue()) { }
        bool isHashTableDeletedValue() const { return m_ptr == hashTableDeletedValue(); }

        inline __attribute__((__always_inline__)) ~RefPtr() { derefIfNotNull(m_ptr); }

        T* get() const { return m_ptr; }

        void clear();
        PassRefPtr<T> release() { PassRefPtr<T> tmp = adoptRef(m_ptr); m_ptr = 0; return tmp; }

        T& operator*() const { return *m_ptr; }
        inline __attribute__((__always_inline__)) T* operator->() const { return m_ptr; }

        bool operator!() const { return !m_ptr; }


        typedef T* (RefPtr::*UnspecifiedBoolType);
        operator UnspecifiedBoolType() const { return m_ptr ? &RefPtr::m_ptr : 0; }

        RefPtr& operator=(const RefPtr&);
        RefPtr& operator=(T*);
        RefPtr& operator=(const PassRefPtr<T>&);
        RefPtr& operator=(const NonNullPassRefPtr<T>&);

        RefPtr& operator=(std::nullptr_t) { clear(); return *this; }

        template<typename U> RefPtr& operator=(const RefPtr<U>&);
        template<typename U> RefPtr& operator=(const PassRefPtr<U>&);
        template<typename U> RefPtr& operator=(const NonNullPassRefPtr<U>&);

        void swap(RefPtr&);

        static T* hashTableDeletedValue() { return reinterpret_cast<T*>(-1); }

    private:
        T* m_ptr;
    };

    template<typename T> template<typename U> inline RefPtr<T>::RefPtr(const PassRefPtr<U>& o)
        : m_ptr(o.leakRef())
    {
    }

    template<typename T> template<typename U> inline RefPtr<T>::RefPtr(const NonNullPassRefPtr<U>& o)
        : m_ptr(o.leakRef())
    {
    }

    template<typename T> inline void RefPtr<T>::clear()
    {
        T* ptr = m_ptr;
        m_ptr = 0;
        derefIfNotNull(ptr);
    }

    template<typename T> inline RefPtr<T>& RefPtr<T>::operator=(const RefPtr<T>& o)
    {
        T* optr = o.get();
        refIfNotNull(optr);
        T* ptr = m_ptr;
        m_ptr = optr;
        derefIfNotNull(ptr);
        return *this;
    }

    template<typename T> template<typename U> inline RefPtr<T>& RefPtr<T>::operator=(const RefPtr<U>& o)
    {
        T* optr = o.get();
        refIfNotNull(optr);
        T* ptr = m_ptr;
        m_ptr = optr;
        derefIfNotNull(ptr);
        return *this;
    }

    template<typename T> inline RefPtr<T>& RefPtr<T>::operator=(T* optr)
    {
        refIfNotNull(optr);
        T* ptr = m_ptr;
        m_ptr = optr;
        derefIfNotNull(ptr);
        return *this;
    }

    template<typename T> inline RefPtr<T>& RefPtr<T>::operator=(const PassRefPtr<T>& o)
    {
        T* ptr = m_ptr;
        m_ptr = o.leakRef();
        derefIfNotNull(ptr);
        return *this;
    }

    template<typename T> inline RefPtr<T>& RefPtr<T>::operator=(const NonNullPassRefPtr<T>& o)
    {
        T* ptr = m_ptr;
        m_ptr = o.leakRef();
        derefIfNotNull(ptr);
        return *this;
    }

    template<typename T> template<typename U> inline RefPtr<T>& RefPtr<T>::operator=(const PassRefPtr<U>& o)
    {
        T* ptr = m_ptr;
        m_ptr = o.leakRef();
        derefIfNotNull(ptr);
        return *this;
    }

    template<typename T> template<typename U> inline RefPtr<T>& RefPtr<T>::operator=(const NonNullPassRefPtr<U>& o)
    {
        T* ptr = m_ptr;
        m_ptr = o.leakRef();
        derefIfNotNull(ptr);
        return *this;
    }

    template<class T> inline void RefPtr<T>::swap(RefPtr<T>& o)
    {
        std::swap(m_ptr, o.m_ptr);
    }

    template<class T> inline void swap(RefPtr<T>& a, RefPtr<T>& b)
    {
        a.swap(b);
    }

    template<typename T, typename U> inline bool operator==(const RefPtr<T>& a, const RefPtr<U>& b)
    {
        return a.get() == b.get();
    }

    template<typename T, typename U> inline bool operator==(const RefPtr<T>& a, U* b)
    {
        return a.get() == b;
    }

    template<typename T, typename U> inline bool operator==(T* a, const RefPtr<U>& b)
    {
        return a == b.get();
    }

    template<typename T, typename U> inline bool operator!=(const RefPtr<T>& a, const RefPtr<U>& b)
    {
        return a.get() != b.get();
    }

    template<typename T, typename U> inline bool operator!=(const RefPtr<T>& a, U* b)
    {
        return a.get() != b;
    }

    template<typename T, typename U> inline bool operator!=(T* a, const RefPtr<U>& b)
    {
        return a != b.get();
    }

    template<typename T, typename U> inline RefPtr<T> static_pointer_cast(const RefPtr<U>& p)
    {
        return RefPtr<T>(static_cast<T*>(p.get()));
    }

    template<typename T, typename U> inline RefPtr<T> const_pointer_cast(const RefPtr<U>& p)
    {
        return RefPtr<T>(const_cast<T*>(p.get()));
    }

    template<typename T> inline T* getPtr(const RefPtr<T>& p)
    {
        return p.get();
    }

}

using WTF::RefPtr;
using WTF::static_pointer_cast;
using WTF::const_pointer_cast;
# 25 "./wtf/HashFunctions.h" 2


namespace WTF {

    template<size_t size> struct IntTypes;
    template<> struct IntTypes<1> { typedef int8_t SignedType; typedef uint8_t UnsignedType; };
    template<> struct IntTypes<2> { typedef int16_t SignedType; typedef uint16_t UnsignedType; };
    template<> struct IntTypes<4> { typedef int32_t SignedType; typedef uint32_t UnsignedType; };
    template<> struct IntTypes<8> { typedef int64_t SignedType; typedef uint64_t UnsignedType; };




    inline unsigned intHash(uint8_t key8)
    {
        unsigned key = key8;
        key += ~(key << 15);
        key ^= (key >> 10);
        key += (key << 3);
        key ^= (key >> 6);
        key += ~(key << 11);
        key ^= (key >> 16);
        return key;
    }


    inline unsigned intHash(uint16_t key16)
    {
        unsigned key = key16;
        key += ~(key << 15);
        key ^= (key >> 10);
        key += (key << 3);
        key ^= (key >> 6);
        key += ~(key << 11);
        key ^= (key >> 16);
        return key;
    }


    inline unsigned intHash(uint32_t key)
    {
        key += ~(key << 15);
        key ^= (key >> 10);
        key += (key << 3);
        key ^= (key >> 6);
        key += ~(key << 11);
        key ^= (key >> 16);
        return key;
    }


    inline unsigned intHash(uint64_t key)
    {
        key += ~(key << 32);
        key ^= (key >> 22);
        key += ~(key << 13);
        key ^= (key >> 8);
        key += (key << 3);
        key ^= (key >> 15);
        key += ~(key << 27);
        key ^= (key >> 31);
        return static_cast<unsigned>(key);
    }

    template<typename T> struct IntHash {
        static unsigned hash(T key) { return intHash(static_cast<typename IntTypes<sizeof(T)>::UnsignedType>(key)); }
        static bool equal(T a, T b) { return a == b; }
        static const bool safeToCompareToEmptyOrDeleted = true;
    };

    template<typename T> struct FloatHash {
        static unsigned hash(T key)
        {
            union {
                T key;
                typename IntTypes<sizeof(T)>::UnsignedType bits;
            } u;
            u.key = key;
            return intHash(u.bits);
        }
        static bool equal(T a, T b) { return a == b; }
        static const bool safeToCompareToEmptyOrDeleted = true;
    };



    template<typename T> struct PtrHash {
        static unsigned hash(T key)
        {




            return IntHash<uintptr_t>::hash(reinterpret_cast<uintptr_t>(key));



        }
        static bool equal(T a, T b) { return a == b; }
        static const bool safeToCompareToEmptyOrDeleted = true;
    };
    template<typename P> struct PtrHash<RefPtr<P> > : PtrHash<P*> {
        using PtrHash<P*>::hash;
        static unsigned hash(const RefPtr<P>& key) { return hash(key.get()); }
        using PtrHash<P*>::equal;
        static bool equal(const RefPtr<P>& a, const RefPtr<P>& b) { return a == b; }
        static bool equal(P* a, const RefPtr<P>& b) { return a == b; }
        static bool equal(const RefPtr<P>& a, P* b) { return a == b; }
    };



    template<typename T> struct DefaultHash;

    template<typename T, typename U> struct PairHash {
        static unsigned hash(const std::pair<T, U>& p)
        {
            return intHash((static_cast<uint64_t>(DefaultHash<T>::Hash::hash(p.first)) << 32 | DefaultHash<U>::Hash::hash(p.second)));
        }
        static bool equal(const std::pair<T, U>& a, const std::pair<T, U>& b)
        {
            return DefaultHash<T>::Hash::equal(a.first, b.first) && DefaultHash<U>::Hash::equal(a.second, b.second);
        }
        static const bool safeToCompareToEmptyOrDeleted = DefaultHash<T>::Hash::safeToCompareToEmptyOrDeleted
                                                            && DefaultHash<U>::Hash::safeToCompareToEmptyOrDeleted;
    };



    template<> struct DefaultHash<short> { typedef IntHash<unsigned> Hash; };
    template<> struct DefaultHash<unsigned short> { typedef IntHash<unsigned> Hash; };
    template<> struct DefaultHash<int> { typedef IntHash<unsigned> Hash; };
    template<> struct DefaultHash<unsigned> { typedef IntHash<unsigned> Hash; };
    template<> struct DefaultHash<long> { typedef IntHash<unsigned long> Hash; };
    template<> struct DefaultHash<unsigned long> { typedef IntHash<unsigned long> Hash; };
    template<> struct DefaultHash<long long> { typedef IntHash<unsigned long long> Hash; };
    template<> struct DefaultHash<unsigned long long> { typedef IntHash<unsigned long long> Hash; };


    template<> struct DefaultHash<wchar_t> { typedef IntHash<wchar_t> Hash; };


    template<> struct DefaultHash<float> { typedef FloatHash<float> Hash; };
    template<> struct DefaultHash<double> { typedef FloatHash<double> Hash; };



    template<typename P> struct DefaultHash<P*> { typedef PtrHash<P*> Hash; };
    template<typename P> struct DefaultHash<RefPtr<P> > { typedef PtrHash<RefPtr<P> > Hash; };

    template<typename T, typename U> struct DefaultHash<std::pair<T, U> > { typedef PairHash<T, U> Hash; };

}

using WTF::DefaultHash;
using WTF::IntHash;
using WTF::PtrHash;
# 25 "./wtf/HashTraits.h" 2




namespace WTF {

    class String;

    using std::pair;
    using std::make_pair;

    template<typename T> struct HashTraits;

    template<bool isInteger, typename T> struct GenericHashTraitsBase;

    template<typename T> struct GenericHashTraitsBase<false, T> {
        static const bool emptyValueIsZero = false;
        static const bool needsDestruction = true;
        static const int minimumTableSize = 64;
    };


    template<typename T> struct GenericHashTraitsBase<true, T> : GenericHashTraitsBase<false, T> {
        static const bool emptyValueIsZero = true;
        static const bool needsDestruction = false;
        static void constructDeletedValue(T& slot) { slot = static_cast<T>(-1); }
        static bool isDeletedValue(T value) { return value == static_cast<T>(-1); }
    };

    template<typename T> struct GenericHashTraits : GenericHashTraitsBase<IsInteger<T>::value, T> {
        typedef T TraitType;
        static T emptyValue() { return T(); }
    };

    template<typename T> struct HashTraits : GenericHashTraits<T> { };

    template<typename T> struct FloatHashTraits : GenericHashTraits<T> {
        static const bool needsDestruction = false;
        static T emptyValue() { return std::numeric_limits<T>::infinity(); }
        static void constructDeletedValue(T& slot) { slot = -std::numeric_limits<T>::infinity(); }
        static bool isDeletedValue(T value) { return value == -std::numeric_limits<T>::infinity(); }
    };

    template<> struct HashTraits<float> : FloatHashTraits<float> { };
    template<> struct HashTraits<double> : FloatHashTraits<double> { };


    template<typename T> struct UnsignedWithZeroKeyHashTraits : GenericHashTraits<T> {
        static const bool emptyValueIsZero = false;
        static const bool needsDestruction = false;
        static T emptyValue() { return std::numeric_limits<T>::max(); }
        static void constructDeletedValue(T& slot) { slot = std::numeric_limits<T>::max() - 1; }
        static bool isDeletedValue(T value) { return value == std::numeric_limits<T>::max() - 1; }
    };

    template<typename P> struct HashTraits<P*> : GenericHashTraits<P*> {
        static const bool emptyValueIsZero = true;
        static const bool needsDestruction = false;
        static void constructDeletedValue(P*& slot) { slot = reinterpret_cast<P*>(-1); }
        static bool isDeletedValue(P* value) { return value == reinterpret_cast<P*>(-1); }
    };

    template<typename T> struct SimpleClassHashTraits : GenericHashTraits<T> {
        static const bool emptyValueIsZero = true;
        static void constructDeletedValue(T& slot) { new (&slot) T(HashTableDeletedValue); }
        static bool isDeletedValue(const T& value) { return value.isHashTableDeletedValue(); }
    };

    template<typename P> struct HashTraits<RefPtr<P> > : SimpleClassHashTraits<RefPtr<P> > { };
    template<> struct HashTraits<String> : SimpleClassHashTraits<String> { };



    template<typename FirstTraitsArg, typename SecondTraitsArg>
    struct PairHashTraits : GenericHashTraits<pair<typename FirstTraitsArg::TraitType, typename SecondTraitsArg::TraitType> > {
        typedef FirstTraitsArg FirstTraits;
        typedef SecondTraitsArg SecondTraits;
        typedef pair<typename FirstTraits::TraitType, typename SecondTraits::TraitType> TraitType;

        static const bool emptyValueIsZero = FirstTraits::emptyValueIsZero && SecondTraits::emptyValueIsZero;
        static TraitType emptyValue() { return make_pair(FirstTraits::emptyValue(), SecondTraits::emptyValue()); }

        static const bool needsDestruction = FirstTraits::needsDestruction || SecondTraits::needsDestruction;

        static const int minimumTableSize = FirstTraits::minimumTableSize;

        static void constructDeletedValue(TraitType& slot) { FirstTraits::constructDeletedValue(slot.first); }
        static bool isDeletedValue(const TraitType& value) { return FirstTraits::isDeletedValue(value.first); }
    };

    template<typename First, typename Second>
    struct HashTraits<pair<First, Second> > : public PairHashTraits<HashTraits<First>, HashTraits<Second> > { };

}

using WTF::HashTraits;
using WTF::PairHashTraits;
# 27 "./wtf/HashTable.h" 2
# 1 "./wtf/ValueCheck.h" 1
# 31 "./wtf/ValueCheck.h"
namespace WTF {

template<typename T> struct ValueCheck {
    typedef T TraitType;
    static void checkConsistency(const T&) { }
};
# 51 "./wtf/ValueCheck.h"
}
# 28 "./wtf/HashTable.h" 2

# 1 "./wtf/Threading.h" 1
# 66 "./wtf/Threading.h"
# 1 "./wtf/Atomics.h" 1
# 67 "./wtf/Atomics.h"
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 1 3 4
# 27 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
# 1 "/Users/ddunbar/rt/11003353/clang-r152231-t20120307_081803-b13838/Developer/usr/bin/../lib/clang/3.1/include/stddef.h" 1 3 4
# 28 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 2 3 4


# 1 "/Users/ddunbar/rt/11003353/clang-r152231-t20120307_081803-b13838/Developer/usr/bin/../lib/clang/3.1/include/stdbool.h" 1 3 4
# 31 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 2 3 4
# 76 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
extern "C" {
# 90 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
int32_t OSAtomicAdd32( int32_t __theAmount, volatile int32_t *__theValue );
# 103 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
int32_t OSAtomicAdd32Barrier( int32_t __theAmount, volatile int32_t *__theValue );




inline static
int32_t OSAtomicIncrement32( volatile int32_t *__theValue )
            { return OSAtomicAdd32( 1, __theValue); }
# 119 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
inline static
int32_t OSAtomicIncrement32Barrier( volatile int32_t *__theValue )
            { return OSAtomicAdd32Barrier( 1, __theValue); }


inline static
int32_t OSAtomicDecrement32( volatile int32_t *__theValue )
            { return OSAtomicAdd32( -1, __theValue); }







inline static
int32_t OSAtomicDecrement32Barrier( volatile int32_t *__theValue )
            { return OSAtomicAdd32Barrier( -1, __theValue); }
# 147 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
int64_t OSAtomicAdd64( int64_t __theAmount, volatile int64_t *__theValue );
# 160 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
int64_t OSAtomicAdd64Barrier( int64_t __theAmount, volatile int64_t *__theValue ) __attribute__((visibility("default")));



inline static
int64_t OSAtomicIncrement64( volatile int64_t *__theValue )
            { return OSAtomicAdd64( 1, __theValue); }







inline static
int64_t OSAtomicIncrement64Barrier( volatile int64_t *__theValue )
            { return OSAtomicAdd64Barrier( 1, __theValue); }
# 185 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
inline static
int64_t OSAtomicDecrement64( volatile int64_t *__theValue )
            { return OSAtomicAdd64( -1, __theValue); }
# 196 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
inline static
int64_t OSAtomicDecrement64Barrier( volatile int64_t *__theValue )
            { return OSAtomicAdd64Barrier( -1, __theValue); }
# 222 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
int32_t OSAtomicOr32( uint32_t __theMask, volatile uint32_t *__theValue );
# 235 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
int32_t OSAtomicOr32Barrier( uint32_t __theMask, volatile uint32_t *__theValue );
# 245 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
int32_t OSAtomicOr32Orig( uint32_t __theMask, volatile uint32_t *__theValue ) __attribute__((visibility("default")));
# 258 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
int32_t OSAtomicOr32OrigBarrier( uint32_t __theMask, volatile uint32_t *__theValue ) __attribute__((visibility("default")));
# 270 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
int32_t OSAtomicAnd32( uint32_t __theMask, volatile uint32_t *__theValue );
# 283 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
int32_t OSAtomicAnd32Barrier( uint32_t __theMask, volatile uint32_t *__theValue );
# 293 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
int32_t OSAtomicAnd32Orig( uint32_t __theMask, volatile uint32_t *__theValue ) __attribute__((visibility("default")));
# 306 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
int32_t OSAtomicAnd32OrigBarrier( uint32_t __theMask, volatile uint32_t *__theValue ) __attribute__((visibility("default")));
# 318 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
int32_t OSAtomicXor32( uint32_t __theMask, volatile uint32_t *__theValue );
# 331 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
int32_t OSAtomicXor32Barrier( uint32_t __theMask, volatile uint32_t *__theValue );
# 341 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
int32_t OSAtomicXor32Orig( uint32_t __theMask, volatile uint32_t *__theValue ) __attribute__((visibility("default")));
# 354 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
int32_t OSAtomicXor32OrigBarrier( uint32_t __theMask, volatile uint32_t *__theValue ) __attribute__((visibility("default")));
# 371 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
bool OSAtomicCompareAndSwap32( int32_t __oldValue, int32_t __newValue, volatile int32_t *__theValue );
# 385 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
bool OSAtomicCompareAndSwap32Barrier( int32_t __oldValue, int32_t __newValue, volatile int32_t *__theValue );
# 396 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
bool OSAtomicCompareAndSwapPtr( void *__oldValue, void *__newValue, void * volatile *__theValue ) __attribute__((visibility("default")));
# 410 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
bool OSAtomicCompareAndSwapPtrBarrier( void *__oldValue, void *__newValue, void * volatile *__theValue ) __attribute__((visibility("default")));
# 423 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
bool OSAtomicCompareAndSwapInt( int __oldValue, int __newValue, volatile int *__theValue ) __attribute__((visibility("default")));
# 439 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
bool OSAtomicCompareAndSwapIntBarrier( int __oldValue, int __newValue, volatile int *__theValue ) __attribute__((visibility("default")));
# 453 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
bool OSAtomicCompareAndSwapLong( long __oldValue, long __newValue, volatile long *__theValue ) __attribute__((visibility("default")));
# 470 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
bool OSAtomicCompareAndSwapLongBarrier( long __oldValue, long __newValue, volatile long *__theValue ) __attribute__((visibility("default")));
# 483 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
bool OSAtomicCompareAndSwap64( int64_t __oldValue, int64_t __newValue, volatile int64_t *__theValue );
# 497 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
bool OSAtomicCompareAndSwap64Barrier( int64_t __oldValue, int64_t __newValue, volatile int64_t *__theValue ) __attribute__((visibility("default")));
# 517 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
bool OSAtomicTestAndSet( uint32_t __n, volatile void *__theAddress );
# 536 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
bool OSAtomicTestAndSetBarrier( uint32_t __n, volatile void *__theAddress );
# 552 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
bool OSAtomicTestAndClear( uint32_t __n, volatile void *__theAddress );
# 570 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
bool OSAtomicTestAndClearBarrier( uint32_t __n, volatile void *__theAddress );
# 590 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
typedef int32_t OSSpinLock;







bool OSSpinLockTry( volatile OSSpinLock *__lock );
# 607 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
void OSSpinLockLock( volatile OSSpinLock *__lock );



void OSSpinLockUnlock( volatile OSSpinLock *__lock );
# 625 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
typedef volatile struct {
 void *opaque1;
 long opaque2;
} __attribute__ ((aligned (16))) OSQueueHead;
# 660 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
void OSAtomicEnqueue( OSQueueHead *__list, void *__new, size_t __offset) __attribute__((visibility("default")));
# 682 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
void* OSAtomicDequeue( OSQueueHead *__list, size_t __offset) __attribute__((visibility("default")));
# 697 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
typedef volatile struct {
 void *opaque1;
 void *opaque2;
 int opaque3;
} __attribute__ ((aligned (16))) OSFifoQueueHead;
# 734 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
void OSAtomicFifoEnqueue( OSFifoQueueHead *__list, void *__new, size_t __offset) __attribute__((visibility("default")));
# 755 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
void* OSAtomicFifoDequeue( OSFifoQueueHead *__list, size_t __offset) __attribute__((visibility("default")));
# 765 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSAtomic.h" 3 4
void OSMemoryBarrier( void );

}
# 68 "./wtf/Atomics.h" 2
# 80 "./wtf/Atomics.h"
namespace WTF {
# 96 "./wtf/Atomics.h"
inline int atomicIncrement(int volatile* addend) { return OSAtomicIncrement32Barrier(const_cast<int*>(addend)); }
inline int atomicDecrement(int volatile* addend) { return OSAtomicDecrement32Barrier(const_cast<int*>(addend)); }
# 119 "./wtf/Atomics.h"
}


using WTF::atomicDecrement;
using WTF::atomicIncrement;
# 67 "./wtf/Threading.h" 2
# 1 "./wtf/Locker.h" 1
# 31 "./wtf/Locker.h"
# 1 "./wtf/Noncopyable.h" 1
# 32 "./wtf/Locker.h" 2

namespace WTF {

template <typename T> class Locker {
    private: Locker(const Locker&); Locker& operator=(const Locker&);
public:
    Locker(T& lockable) : m_lockable(lockable) { m_lockable.lock(); }
    ~Locker() { m_lockable.unlock(); }
private:
    T& m_lockable;
};

}

using WTF::Locker;
# 68 "./wtf/Threading.h" 2

# 1 "./wtf/ThreadSafeRefCounted.h" 1
# 65 "./wtf/ThreadSafeRefCounted.h"
# 1 "./wtf/DynamicAnnotations.h" 1
# 66 "./wtf/ThreadSafeRefCounted.h" 2
# 1 "./wtf/ThreadingPrimitives.h" 1
# 57 "./wtf/ThreadingPrimitives.h"
namespace WTF {


typedef pthread_mutex_t PlatformMutex;

typedef pthread_rwlock_t PlatformReadWriteLock;



typedef pthread_cond_t PlatformCondition;
# 94 "./wtf/ThreadingPrimitives.h"
class Mutex {
    private: Mutex(const Mutex&); Mutex& operator=(const Mutex&); public: void* operator new(size_t, void* p) { return p; } void* operator new[](size_t, void* p) { return p; } void* operator new(size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNew); return p; } void operator delete(void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNew); ::WTF::fastFree(p); } void* operator new[](size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNewArray); return p; } void operator delete[](void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNewArray); ::WTF::fastFree(p); } private: typedef int ThisIsHereToForceASemicolonAfterThisMacro;
public:
    Mutex();
    ~Mutex();

    void lock();
    bool tryLock();
    void unlock();

public:
    PlatformMutex& impl() { return m_mutex; }
private:
    PlatformMutex m_mutex;
};

typedef Locker<Mutex> MutexLocker;

class ReadWriteLock {
    private: ReadWriteLock(const ReadWriteLock&); ReadWriteLock& operator=(const ReadWriteLock&);
public:
    ReadWriteLock();
    ~ReadWriteLock();

    void readLock();
    bool tryReadLock();

    void writeLock();
    bool tryWriteLock();

    void unlock();

private:
    PlatformReadWriteLock m_readWriteLock;
};

class ThreadCondition {
    private: ThreadCondition(const ThreadCondition&); ThreadCondition& operator=(const ThreadCondition&);
public:
    ThreadCondition();
    ~ThreadCondition();

    void wait(Mutex& mutex);


    bool timedWait(Mutex&, double absoluteTime);
    void signal();
    void broadcast();

private:
    PlatformCondition m_condition;
};







}

using WTF::Mutex;
using WTF::MutexLocker;
using WTF::ThreadCondition;
# 67 "./wtf/ThreadSafeRefCounted.h" 2

namespace WTF {

class ThreadSafeRefCountedBase {
    private: ThreadSafeRefCountedBase(const ThreadSafeRefCountedBase&); ThreadSafeRefCountedBase& operator=(const ThreadSafeRefCountedBase&);
    public: void* operator new(size_t, void* p) { return p; } void* operator new[](size_t, void* p) { return p; } void* operator new(size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNew); return p; } void operator delete(void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNew); ::WTF::fastFree(p); } void* operator new[](size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNewArray); return p; } void operator delete[](void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNewArray); ::WTF::fastFree(p); } private: typedef int ThisIsHereToForceASemicolonAfterThisMacro;
public:
    ThreadSafeRefCountedBase(int initialRefCount = 1)
        : m_refCount(initialRefCount)
    {
    }

    void ref()
    {

        atomicIncrement(&m_refCount);




    }

    bool hasOneRef()
    {
        return refCount() == 1;
    }

    int refCount() const
    {



        return static_cast<int const volatile &>(m_refCount);
    }

protected:

    bool derefBase()
    {

                                                ;
        if (atomicDecrement(&m_refCount) <= 0) {
                                                   ;
            return true;
        }
# 122 "./wtf/ThreadSafeRefCounted.h"
        return false;
    }

private:
    int m_refCount;



};

template<class T> class ThreadSafeRefCounted : public ThreadSafeRefCountedBase {
public:
    void deref()
    {
        if (derefBase())
            delete static_cast<T*>(this);
    }

protected:
    ThreadSafeRefCounted()
    {
    }
};

}

using WTF::ThreadSafeRefCounted;
# 70 "./wtf/Threading.h" 2








namespace WTF {

typedef uint32_t ThreadIdentifier;
typedef void* (*ThreadFunction)(void* argument);




void initializeThreading();



ThreadIdentifier createThread(ThreadFunction, void*, const char* threadName);


ThreadIdentifier createThreadInternal(ThreadFunction, void*, const char* threadName);



void initializeCurrentThreadInternal(const char* threadName);

ThreadIdentifier currentThread();
int waitForThreadCompletion(ThreadIdentifier, void**);
void detachThread(ThreadIdentifier);

void yield();

void lockAtomicallyInitializedStaticMutex();
void unlockAtomicallyInitializedStaticMutex();

}

using WTF::ThreadIdentifier;
using WTF::createThread;
using WTF::currentThread;
using WTF::detachThread;
using WTF::waitForThreadCompletion;
using WTF::yield;
# 30 "./wtf/HashTable.h" 2

namespace WTF {
# 67 "./wtf/HashTable.h"
    template<typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits>
    class HashTable;
    template<typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits>
    class HashTableIterator;
    template<typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits>
    class HashTableConstIterator;

    template<typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits>
    void addIterator(const HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>*,
        HashTableConstIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>*);

    template<typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits>
    void removeIterator(HashTableConstIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>*);



    template<typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits>
    inline void addIterator(const HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>*,
        HashTableConstIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>*) { }

    template<typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits>
    inline void removeIterator(HashTableConstIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>*) { }



    typedef enum { HashItemKnownGood } HashItemKnownGoodTag;

    template<typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits>
    class HashTableConstIterator {
    private:
        typedef HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits> HashTableType;
        typedef HashTableIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits> iterator;
        typedef HashTableConstIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits> const_iterator;
        typedef Value ValueType;
        typedef const ValueType& ReferenceType;
        typedef const ValueType* PointerType;

        friend class HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>;
        friend class HashTableIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>;

        void skipEmptyBuckets()
        {
            while (m_position != m_endPosition && HashTableType::isEmptyOrDeletedBucket(*m_position))
                ++m_position;
        }

        HashTableConstIterator(const HashTableType* table, PointerType position, PointerType endPosition)
            : m_position(position), m_endPosition(endPosition)
        {
            addIterator(table, this);
            skipEmptyBuckets();
        }

        HashTableConstIterator(const HashTableType* table, PointerType position, PointerType endPosition, HashItemKnownGoodTag)
            : m_position(position), m_endPosition(endPosition)
        {
            addIterator(table, this);
        }

    public:
        HashTableConstIterator()
        {
            addIterator(static_cast<const HashTableType*>(0), this);
        }
# 158 "./wtf/HashTable.h"
        PointerType get() const
        {
            checkValidity();
            return m_position;
        }
        ReferenceType operator*() const { return *get(); }
        PointerType operator->() const { return get(); }

        const_iterator& operator++()
        {
            checkValidity();
            ((void)0);
            ++m_position;
            skipEmptyBuckets();
            return *this;
        }




        bool operator==(const const_iterator& other) const
        {
            checkValidity(other);
            return m_position == other.m_position;
        }
        bool operator!=(const const_iterator& other) const
        {
            checkValidity(other);
            return m_position != other.m_position;
        }

    private:
        void checkValidity() const
        {



        }
# 206 "./wtf/HashTable.h"
        void checkValidity(const const_iterator&) const { }


        PointerType m_position;
        PointerType m_endPosition;
# 220 "./wtf/HashTable.h"
    };

    template<typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits>
    class HashTableIterator {
    private:
        typedef HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits> HashTableType;
        typedef HashTableIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits> iterator;
        typedef HashTableConstIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits> const_iterator;
        typedef Value ValueType;
        typedef ValueType& ReferenceType;
        typedef ValueType* PointerType;

        friend class HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>;

        HashTableIterator(HashTableType* table, PointerType pos, PointerType end) : m_iterator(table, pos, end) { }
        HashTableIterator(HashTableType* table, PointerType pos, PointerType end, HashItemKnownGoodTag tag) : m_iterator(table, pos, end, tag) { }

    public:
        HashTableIterator() { }



        PointerType get() const { return const_cast<PointerType>(m_iterator.get()); }
        ReferenceType operator*() const { return *get(); }
        PointerType operator->() const { return get(); }

        iterator& operator++() { ++m_iterator; return *this; }




        bool operator==(const iterator& other) const { return m_iterator == other.m_iterator; }
        bool operator!=(const iterator& other) const { return m_iterator != other.m_iterator; }

        operator const_iterator() const { return m_iterator; }

    private:
        const_iterator m_iterator;
    };

    using std::swap;


    template<typename T> inline void hashTableSwap(T& a, T& b)
    {
        swap(a, b);
    }


    template<typename T, typename U> inline void hashTableSwap(pair<T, U>& a, pair<T, U>& b)
    {
        swap(a.first, b.first);
        swap(a.second, b.second);
    }

    template<typename T, bool useSwap> struct Mover;
    template<typename T> struct Mover<T, true> { static void move(T& from, T& to) { hashTableSwap(from, to); } };
    template<typename T> struct Mover<T, false> { static void move(T& from, T& to) { to = from; } };

    template<typename Key, typename Value, typename HashFunctions> class IdentityHashTranslator {
    public:
        static unsigned hash(const Key& key) { return HashFunctions::hash(key); }
        static bool equal(const Key& a, const Key& b) { return HashFunctions::equal(a, b); }
        static void translate(Value& location, const Key&, const Value& value) { location = value; }
    };

    template<typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits>
    class HashTable {
    public:
        typedef HashTableIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits> iterator;
        typedef HashTableConstIterator<Key, Value, Extractor, HashFunctions, Traits, KeyTraits> const_iterator;
        typedef Traits ValueTraits;
        typedef Key KeyType;
        typedef Value ValueType;
        typedef IdentityHashTranslator<Key, Value, HashFunctions> IdentityTranslatorType;

        HashTable();
        ~HashTable()
        {
            invalidateIterators();
            deallocateTable(m_table, m_tableSize);



        }

        HashTable(const HashTable&);
        void swap(HashTable&);
        HashTable& operator=(const HashTable&);

        iterator begin() { return makeIterator(m_table); }
        iterator end() { return makeKnownGoodIterator(m_table + m_tableSize); }
        const_iterator begin() const { return makeConstIterator(m_table); }
        const_iterator end() const { return makeKnownGoodConstIterator(m_table + m_tableSize); }

        int size() const { return m_keyCount; }
        int capacity() const { return m_tableSize; }
        bool isEmpty() const { return !m_keyCount; }

        pair<iterator, bool> add(const ValueType& value) { return add<KeyType, ValueType, IdentityTranslatorType>(Extractor::extract(value), value); }




        template<typename T, typename Extra, typename HashTranslator> pair<iterator, bool> add(const T& key, const Extra&);
        template<typename T, typename Extra, typename HashTranslator> pair<iterator, bool> addPassingHashCode(const T& key, const Extra&);

        iterator find(const KeyType& key) { return find<KeyType, IdentityTranslatorType>(key); }
        const_iterator find(const KeyType& key) const { return find<KeyType, IdentityTranslatorType>(key); }
        bool contains(const KeyType& key) const { return contains<KeyType, IdentityTranslatorType>(key); }

        template <typename T, typename HashTranslator> iterator find(const T&);
        template <typename T, typename HashTranslator> const_iterator find(const T&) const;
        template <typename T, typename HashTranslator> bool contains(const T&) const;

        void remove(const KeyType&);
        void remove(iterator);
        void removeWithoutEntryConsistencyCheck(iterator);
        void removeWithoutEntryConsistencyCheck(const_iterator);
        void clear();

        static bool isEmptyBucket(const ValueType& value) { return Extractor::extract(value) == KeyTraits::emptyValue(); }
        static bool isDeletedBucket(const ValueType& value) { return KeyTraits::isDeletedValue(Extractor::extract(value)); }
        static bool isEmptyOrDeletedBucket(const ValueType& value) { return isEmptyBucket(value) || isDeletedBucket(value); }

        ValueType* lookup(const Key& key) { return lookup<Key, IdentityTranslatorType>(key); }
        template<typename T, typename HashTranslator> ValueType* lookup(const T&);




        static void checkTableConsistency() { }





        static void internalCheckTableConsistencyExceptSize() { }
        static void internalCheckTableConsistency() { }


    private:
        static ValueType* allocateTable(int size);
        static void deallocateTable(ValueType* table, int size);

        typedef pair<ValueType*, bool> LookupType;
        typedef pair<LookupType, unsigned> FullLookupType;

        LookupType lookupForWriting(const Key& key) { return lookupForWriting<Key, IdentityTranslatorType>(key); };
        template<typename T, typename HashTranslator> FullLookupType fullLookupForWriting(const T&);
        template<typename T, typename HashTranslator> LookupType lookupForWriting(const T&);

        template<typename T, typename HashTranslator> void checkKey(const T&);

        void removeAndInvalidateWithoutEntryConsistencyCheck(ValueType*);
        void removeAndInvalidate(ValueType*);
        void remove(ValueType*);

        bool shouldExpand() const { return (m_keyCount + m_deletedCount) * m_maxLoad >= m_tableSize; }
        bool mustRehashInPlace() const { return m_keyCount * m_minLoad < m_tableSize * 2; }
        bool shouldShrink() const { return m_keyCount * m_minLoad < m_tableSize && m_tableSize > KeyTraits::minimumTableSize; }
        void expand();
        void shrink() { rehash(m_tableSize / 2); }

        void rehash(int newTableSize);
        void reinsert(ValueType&);

        static void initializeBucket(ValueType& bucket) { new (&bucket) ValueType(Traits::emptyValue()); }
        static void deleteBucket(ValueType& bucket) { bucket.~ValueType(); Traits::constructDeletedValue(bucket); }

        FullLookupType makeLookupResult(ValueType* position, bool found, unsigned hash)
            { return FullLookupType(LookupType(position, found), hash); }

        iterator makeIterator(ValueType* pos) { return iterator(this, pos, m_table + m_tableSize); }
        const_iterator makeConstIterator(ValueType* pos) const { return const_iterator(this, pos, m_table + m_tableSize); }
        iterator makeKnownGoodIterator(ValueType* pos) { return iterator(this, pos, m_table + m_tableSize, HashItemKnownGood); }
        const_iterator makeKnownGoodConstIterator(ValueType* pos) const { return const_iterator(this, pos, m_table + m_tableSize, HashItemKnownGood); }




        static void checkTableConsistencyExceptSize() { }





        static void invalidateIterators() { }


        static const int m_maxLoad = 2;
        static const int m_minLoad = 6;

        ValueType* m_table;
        int m_tableSize;
        int m_tableSizeMask;
        int m_keyCount;
        int m_deletedCount;







    };

    template<typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits>
    inline HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::HashTable()
        : m_table(0)
        , m_tableSize(0)
        , m_tableSizeMask(0)
        , m_keyCount(0)
        , m_deletedCount(0)



    {
    }

    static inline unsigned doubleHash(unsigned key)
    {
        key = ~key + (key >> 23);
        key ^= (key << 12);
        key ^= (key >> 7);
        key ^= (key << 2);
        key ^= (key >> 20);
        return key;
    }



    template<typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits>
    template<typename T, typename HashTranslator>
    inline void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::checkKey(const T&)
    {
    }
# 476 "./wtf/HashTable.h"
    template<typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits>
    template<typename T, typename HashTranslator>
    inline Value* HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::lookup(const T& key)
    {
        checkKey<T, HashTranslator>(key);

        int k = 0;
        int sizeMask = m_tableSizeMask;
        ValueType* table = m_table;
        unsigned h = HashTranslator::hash(key);
        int i = h & sizeMask;

        if (!table)
            return 0;






        while (1) {
            ValueType* entry = table + i;


            if (HashFunctions::safeToCompareToEmptyOrDeleted) {
                if (HashTranslator::equal(Extractor::extract(*entry), key))
                    return entry;

                if (isEmptyBucket(*entry))
                    return 0;
            } else {
                if (isEmptyBucket(*entry))
                    return 0;

                if (!isDeletedBucket(*entry) && HashTranslator::equal(Extractor::extract(*entry), key))
                    return entry;
            }




            if (k == 0)
                k = 1 | doubleHash(h);
            i = (i + k) & sizeMask;
        }
    }

    template<typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits>
    template<typename T, typename HashTranslator>
    inline typename HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::LookupType HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::lookupForWriting(const T& key)
    {
        ((void)0);
        checkKey<T, HashTranslator>(key);

        int k = 0;
        ValueType* table = m_table;
        int sizeMask = m_tableSizeMask;
        unsigned h = HashTranslator::hash(key);
        int i = h & sizeMask;






        ValueType* deletedEntry = 0;

        while (1) {
            ValueType* entry = table + i;


            if (HashFunctions::safeToCompareToEmptyOrDeleted) {
                if (isEmptyBucket(*entry))
                    return LookupType(deletedEntry ? deletedEntry : entry, false);

                if (HashTranslator::equal(Extractor::extract(*entry), key))
                    return LookupType(entry, true);

                if (isDeletedBucket(*entry))
                    deletedEntry = entry;
            } else {
                if (isEmptyBucket(*entry))
                    return LookupType(deletedEntry ? deletedEntry : entry, false);

                if (isDeletedBucket(*entry))
                    deletedEntry = entry;
                else if (HashTranslator::equal(Extractor::extract(*entry), key))
                    return LookupType(entry, true);
            }




            if (k == 0)
                k = 1 | doubleHash(h);
            i = (i + k) & sizeMask;
        }
    }

    template<typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits>
    template<typename T, typename HashTranslator>
    inline typename HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::FullLookupType HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::fullLookupForWriting(const T& key)
    {
        ((void)0);
        checkKey<T, HashTranslator>(key);

        int k = 0;
        ValueType* table = m_table;
        int sizeMask = m_tableSizeMask;
        unsigned h = HashTranslator::hash(key);
        int i = h & sizeMask;






        ValueType* deletedEntry = 0;

        while (1) {
            ValueType* entry = table + i;


            if (HashFunctions::safeToCompareToEmptyOrDeleted) {
                if (isEmptyBucket(*entry))
                    return makeLookupResult(deletedEntry ? deletedEntry : entry, false, h);

                if (HashTranslator::equal(Extractor::extract(*entry), key))
                    return makeLookupResult(entry, true, h);

                if (isDeletedBucket(*entry))
                    deletedEntry = entry;
            } else {
                if (isEmptyBucket(*entry))
                    return makeLookupResult(deletedEntry ? deletedEntry : entry, false, h);

                if (isDeletedBucket(*entry))
                    deletedEntry = entry;
                else if (HashTranslator::equal(Extractor::extract(*entry), key))
                    return makeLookupResult(entry, true, h);
            }




            if (k == 0)
                k = 1 | doubleHash(h);
            i = (i + k) & sizeMask;
        }
    }

    template<typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits>
    template<typename T, typename Extra, typename HashTranslator>
    inline pair<typename HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::iterator, bool> HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::add(const T& key, const Extra& extra)
    {
        checkKey<T, HashTranslator>(key);

        invalidateIterators();

        if (!m_table)
            expand();

        internalCheckTableConsistency();

        ((void)0);

        int k = 0;
        ValueType* table = m_table;
        int sizeMask = m_tableSizeMask;
        unsigned h = HashTranslator::hash(key);
        int i = h & sizeMask;






        ValueType* deletedEntry = 0;
        ValueType* entry;
        while (1) {
            entry = table + i;


            if (HashFunctions::safeToCompareToEmptyOrDeleted) {
                if (isEmptyBucket(*entry))
                    break;

                if (HashTranslator::equal(Extractor::extract(*entry), key))
                    return std::make_pair(makeKnownGoodIterator(entry), false);

                if (isDeletedBucket(*entry))
                    deletedEntry = entry;
            } else {
                if (isEmptyBucket(*entry))
                    break;

                if (isDeletedBucket(*entry))
                    deletedEntry = entry;
                else if (HashTranslator::equal(Extractor::extract(*entry), key))
                    return std::make_pair(makeKnownGoodIterator(entry), false);
            }




            if (k == 0)
                k = 1 | doubleHash(h);
            i = (i + k) & sizeMask;
        }

        if (deletedEntry) {
            initializeBucket(*deletedEntry);
            entry = deletedEntry;
            --m_deletedCount;
        }

        HashTranslator::translate(*entry, key, extra);

        ++m_keyCount;

        if (shouldExpand()) {



            KeyType enteredKey = Extractor::extract(*entry);
            expand();
            pair<iterator, bool> p = std::make_pair(find(enteredKey), true);
            ((void)0);
            return p;
        }

        internalCheckTableConsistency();

        return std::make_pair(makeKnownGoodIterator(entry), true);
    }

    template<typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits>
    template<typename T, typename Extra, typename HashTranslator>
    inline pair<typename HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::iterator, bool> HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::addPassingHashCode(const T& key, const Extra& extra)
    {
        checkKey<T, HashTranslator>(key);

        invalidateIterators();

        if (!m_table)
            expand();

        internalCheckTableConsistency();

        FullLookupType lookupResult = fullLookupForWriting<T, HashTranslator>(key);

        ValueType* entry = lookupResult.first.first;
        bool found = lookupResult.first.second;
        unsigned h = lookupResult.second;

        if (found)
            return std::make_pair(makeKnownGoodIterator(entry), false);

        if (isDeletedBucket(*entry)) {
            initializeBucket(*entry);
            --m_deletedCount;
        }

        HashTranslator::translate(*entry, key, extra, h);
        ++m_keyCount;
        if (shouldExpand()) {



            KeyType enteredKey = Extractor::extract(*entry);
            expand();
            pair<iterator, bool> p = std::make_pair(find(enteredKey), true);
            ((void)0);
            return p;
        }

        internalCheckTableConsistency();

        return std::make_pair(makeKnownGoodIterator(entry), true);
    }

    template<typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits>
    inline void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::reinsert(ValueType& entry)
    {
        ((void)0);
        ((void)0);
        ((void)0);




        Mover<ValueType, Traits::needsDestruction>::move(entry, *lookupForWriting(Extractor::extract(entry)).first);
    }

    template<typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits>
    template <typename T, typename HashTranslator>
    typename HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::iterator HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::find(const T& key)
    {
        if (!m_table)
            return end();

        ValueType* entry = lookup<T, HashTranslator>(key);
        if (!entry)
            return end();

        return makeKnownGoodIterator(entry);
    }

    template<typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits>
    template <typename T, typename HashTranslator>
    typename HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::const_iterator HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::find(const T& key) const
    {
        if (!m_table)
            return end();

        ValueType* entry = const_cast<HashTable*>(this)->lookup<T, HashTranslator>(key);
        if (!entry)
            return end();

        return makeKnownGoodConstIterator(entry);
    }

    template<typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits>
    template <typename T, typename HashTranslator>
    bool HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::contains(const T& key) const
    {
        if (!m_table)
            return false;

        return const_cast<HashTable*>(this)->lookup<T, HashTranslator>(key);
    }

    template<typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits>
    void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::removeAndInvalidateWithoutEntryConsistencyCheck(ValueType* pos)
    {
        invalidateIterators();
        remove(pos);
    }

    template<typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits>
    void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::removeAndInvalidate(ValueType* pos)
    {
        invalidateIterators();
        internalCheckTableConsistency();
        remove(pos);
    }

    template<typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits>
    void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::remove(ValueType* pos)
    {




        deleteBucket(*pos);
        ++m_deletedCount;
        --m_keyCount;

        if (shouldShrink())
            shrink();

        internalCheckTableConsistency();
    }

    template<typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits>
    inline void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::remove(iterator it)
    {
        if (it == end())
            return;

        removeAndInvalidate(const_cast<ValueType*>(it.m_iterator.m_position));
    }

    template<typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits>
    inline void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::removeWithoutEntryConsistencyCheck(iterator it)
    {
        if (it == end())
            return;

        removeAndInvalidateWithoutEntryConsistencyCheck(const_cast<ValueType*>(it.m_iterator.m_position));
    }

    template<typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits>
    inline void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::removeWithoutEntryConsistencyCheck(const_iterator it)
    {
        if (it == end())
            return;

        removeAndInvalidateWithoutEntryConsistencyCheck(const_cast<ValueType*>(it.m_position));
    }

    template<typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits>
    inline void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::remove(const KeyType& key)
    {
        remove(find(key));
    }

    template<typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits>
    Value* HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::allocateTable(int size)
    {


        if (Traits::emptyValueIsZero)
            return static_cast<ValueType*>(fastZeroedMalloc(size * sizeof(ValueType)));
        ValueType* result = static_cast<ValueType*>(fastMalloc(size * sizeof(ValueType)));
        for (int i = 0; i < size; i++)
            initializeBucket(result[i]);
        return result;
    }

    template<typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits>
    void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::deallocateTable(ValueType* table, int size)
    {
        if (Traits::needsDestruction) {
            for (int i = 0; i < size; ++i) {
                if (!isDeletedBucket(table[i]))
                    table[i].~ValueType();
            }
        }
        fastFree(table);
    }

    template<typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits>
    void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::expand()
    {
        int newSize;
        if (m_tableSize == 0)
            newSize = KeyTraits::minimumTableSize;
        else if (mustRehashInPlace())
            newSize = m_tableSize;
        else
            newSize = m_tableSize * 2;

        rehash(newSize);
    }

    template<typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits>
    void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::rehash(int newTableSize)
    {
        internalCheckTableConsistencyExceptSize();

        int oldTableSize = m_tableSize;
        ValueType* oldTable = m_table;






        m_tableSize = newTableSize;
        m_tableSizeMask = newTableSize - 1;
        m_table = allocateTable(newTableSize);

        for (int i = 0; i != oldTableSize; ++i)
            if (!isEmptyOrDeletedBucket(oldTable[i]))
                reinsert(oldTable[i]);

        m_deletedCount = 0;

        deallocateTable(oldTable, oldTableSize);

        internalCheckTableConsistency();
    }

    template<typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits>
    void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::clear()
    {
        invalidateIterators();
        deallocateTable(m_table, m_tableSize);
        m_table = 0;
        m_tableSize = 0;
        m_tableSizeMask = 0;
        m_keyCount = 0;
    }

    template<typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits>
    HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::HashTable(const HashTable& other)
        : m_table(0)
        , m_tableSize(0)
        , m_tableSizeMask(0)
        , m_keyCount(0)
        , m_deletedCount(0)



    {


        const_iterator end = other.end();
        for (const_iterator it = other.begin(); it != end; ++it)
            add(*it);
    }

    template<typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits>
    void HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::swap(HashTable& other)
    {
        invalidateIterators();
        other.invalidateIterators();

        ValueType* tmp_table = m_table;
        m_table = other.m_table;
        other.m_table = tmp_table;

        int tmp_tableSize = m_tableSize;
        m_tableSize = other.m_tableSize;
        other.m_tableSize = tmp_tableSize;

        int tmp_tableSizeMask = m_tableSizeMask;
        m_tableSizeMask = other.m_tableSizeMask;
        other.m_tableSizeMask = tmp_tableSizeMask;

        int tmp_keyCount = m_keyCount;
        m_keyCount = other.m_keyCount;
        other.m_keyCount = tmp_keyCount;

        int tmp_deletedCount = m_deletedCount;
        m_deletedCount = other.m_deletedCount;
        other.m_deletedCount = tmp_deletedCount;
    }

    template<typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits>
    HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>& HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits>::operator=(const HashTable& other)
    {
        HashTable tmp(other);
        swap(tmp);
        return *this;
    }
# 1121 "./wtf/HashTable.h"
    template<typename HashTableType, typename ValueType> struct HashTableConstIteratorAdapter {
        HashTableConstIteratorAdapter() {}
        HashTableConstIteratorAdapter(const typename HashTableType::const_iterator& impl) : m_impl(impl) {}

        const ValueType* get() const { return (const ValueType*)m_impl.get(); }
        const ValueType& operator*() const { return *get(); }
        const ValueType* operator->() const { return get(); }

        HashTableConstIteratorAdapter& operator++() { ++m_impl; return *this; }


        typename HashTableType::const_iterator m_impl;
    };

    template<typename HashTableType, typename ValueType> struct HashTableIteratorAdapter {
        HashTableIteratorAdapter() {}
        HashTableIteratorAdapter(const typename HashTableType::iterator& impl) : m_impl(impl) {}

        ValueType* get() const { return (ValueType*)m_impl.get(); }
        ValueType& operator*() const { return *get(); }
        ValueType* operator->() const { return get(); }

        HashTableIteratorAdapter& operator++() { ++m_impl; return *this; }


        operator HashTableConstIteratorAdapter<HashTableType, ValueType>() {
            typename HashTableType::const_iterator i = m_impl;
            return i;
        }

        typename HashTableType::iterator m_impl;
    };

    template<typename T, typename U>
    inline bool operator==(const HashTableConstIteratorAdapter<T, U>& a, const HashTableConstIteratorAdapter<T, U>& b)
    {
        return a.m_impl == b.m_impl;
    }

    template<typename T, typename U>
    inline bool operator!=(const HashTableConstIteratorAdapter<T, U>& a, const HashTableConstIteratorAdapter<T, U>& b)
    {
        return a.m_impl != b.m_impl;
    }

    template<typename T, typename U>
    inline bool operator==(const HashTableIteratorAdapter<T, U>& a, const HashTableIteratorAdapter<T, U>& b)
    {
        return a.m_impl == b.m_impl;
    }

    template<typename T, typename U>
    inline bool operator!=(const HashTableIteratorAdapter<T, U>& a, const HashTableIteratorAdapter<T, U>& b)
    {
        return a.m_impl != b.m_impl;
    }

}


# 1 "./wtf/HashIterators.h" 1
# 29 "./wtf/HashIterators.h"
namespace WTF {

    template<typename HashTableType, typename KeyType, typename MappedType> struct HashTableConstKeysIterator;
    template<typename HashTableType, typename KeyType, typename MappedType> struct HashTableConstValuesIterator;
    template<typename HashTableType, typename KeyType, typename MappedType> struct HashTableKeysIterator;
    template<typename HashTableType, typename KeyType, typename MappedType> struct HashTableValuesIterator;

    template<typename HashTableType, typename KeyType, typename MappedType> struct HashTableConstIteratorAdapter<HashTableType, std::pair<KeyType, MappedType> > {
    private:
        typedef std::pair<KeyType, MappedType> ValueType;
    public:
        typedef HashTableConstKeysIterator<HashTableType, KeyType, MappedType> Keys;
        typedef HashTableConstValuesIterator<HashTableType, KeyType, MappedType> Values;

        HashTableConstIteratorAdapter() {}
        HashTableConstIteratorAdapter(const typename HashTableType::const_iterator& impl) : m_impl(impl) {}

        const ValueType* get() const { return (const ValueType*)m_impl.get(); }
        const ValueType& operator*() const { return *get(); }
        const ValueType* operator->() const { return get(); }

        HashTableConstIteratorAdapter& operator++() { ++m_impl; return *this; }


        Keys keys() { return Keys(*this); }
        Values values() { return Values(*this); }

        typename HashTableType::const_iterator m_impl;
    };

    template<typename HashTableType, typename KeyType, typename MappedType> struct HashTableIteratorAdapter<HashTableType, std::pair<KeyType, MappedType> > {
    private:
        typedef std::pair<KeyType, MappedType> ValueType;
    public:
        typedef HashTableKeysIterator<HashTableType, KeyType, MappedType> Keys;
        typedef HashTableValuesIterator<HashTableType, KeyType, MappedType> Values;

        HashTableIteratorAdapter() {}
        HashTableIteratorAdapter(const typename HashTableType::iterator& impl) : m_impl(impl) {}

        ValueType* get() const { return (ValueType*)m_impl.get(); }
        ValueType& operator*() const { return *get(); }
        ValueType* operator->() const { return get(); }

        HashTableIteratorAdapter& operator++() { ++m_impl; return *this; }


        operator HashTableConstIteratorAdapter<HashTableType, ValueType>() {
            typename HashTableType::const_iterator i = m_impl;
            return i;
        }

        Keys keys() { return Keys(*this); }
        Values values() { return Values(*this); }

        typename HashTableType::iterator m_impl;
    };

    template<typename HashTableType, typename KeyType, typename MappedType> struct HashTableConstKeysIterator {
    private:
        typedef HashTableConstIteratorAdapter<HashTableType, std::pair<KeyType, MappedType> > ConstIterator;

    public:
        HashTableConstKeysIterator(const ConstIterator& impl) : m_impl(impl) {}

        const KeyType* get() const { return &(m_impl.get()->first); }
        const KeyType& operator*() const { return *get(); }
        const KeyType* operator->() const { return get(); }

        HashTableConstKeysIterator& operator++() { ++m_impl; return *this; }


        ConstIterator m_impl;
    };

    template<typename HashTableType, typename KeyType, typename MappedType> struct HashTableConstValuesIterator {
    private:
        typedef HashTableConstIteratorAdapter<HashTableType, std::pair<KeyType, MappedType> > ConstIterator;

    public:
        HashTableConstValuesIterator(const ConstIterator& impl) : m_impl(impl) {}

        const MappedType* get() const { return &(m_impl.get()->second); }
        const MappedType& operator*() const { return *get(); }
        const MappedType* operator->() const { return get(); }

        HashTableConstValuesIterator& operator++() { ++m_impl; return *this; }


        ConstIterator m_impl;
    };

    template<typename HashTableType, typename KeyType, typename MappedType> struct HashTableKeysIterator {
    private:
        typedef HashTableIteratorAdapter<HashTableType, std::pair<KeyType, MappedType> > Iterator;
        typedef HashTableConstIteratorAdapter<HashTableType, std::pair<KeyType, MappedType> > ConstIterator;

    public:
        HashTableKeysIterator(const Iterator& impl) : m_impl(impl) {}

        KeyType* get() const { return &(m_impl.get()->first); }
        KeyType& operator*() const { return *get(); }
        KeyType* operator->() const { return get(); }

        HashTableKeysIterator& operator++() { ++m_impl; return *this; }


        operator HashTableConstKeysIterator<HashTableType, KeyType, MappedType>() {
            ConstIterator i = m_impl;
            return i;
        }

        Iterator m_impl;
    };

    template<typename HashTableType, typename KeyType, typename MappedType> struct HashTableValuesIterator {
    private:
        typedef HashTableIteratorAdapter<HashTableType, std::pair<KeyType, MappedType> > Iterator;
        typedef HashTableConstIteratorAdapter<HashTableType, std::pair<KeyType, MappedType> > ConstIterator;

    public:
        HashTableValuesIterator(const Iterator& impl) : m_impl(impl) {}

        MappedType* get() const { return &(m_impl.get()->second); }
        MappedType& operator*() const { return *get(); }
        MappedType* operator->() const { return get(); }

        HashTableValuesIterator& operator++() { ++m_impl; return *this; }


        operator HashTableConstValuesIterator<HashTableType, KeyType, MappedType>() {
            ConstIterator i = m_impl;
            return i;
        }

        Iterator m_impl;
    };

    template<typename T, typename U, typename V>
        inline bool operator==(const HashTableConstKeysIterator<T, U, V>& a, const HashTableConstKeysIterator<T, U, V>& b)
    {
        return a.m_impl == b.m_impl;
    }

    template<typename T, typename U, typename V>
        inline bool operator!=(const HashTableConstKeysIterator<T, U, V>& a, const HashTableConstKeysIterator<T, U, V>& b)
    {
        return a.m_impl != b.m_impl;
    }

    template<typename T, typename U, typename V>
        inline bool operator==(const HashTableConstValuesIterator<T, U, V>& a, const HashTableConstValuesIterator<T, U, V>& b)
    {
        return a.m_impl == b.m_impl;
    }

    template<typename T, typename U, typename V>
        inline bool operator!=(const HashTableConstValuesIterator<T, U, V>& a, const HashTableConstValuesIterator<T, U, V>& b)
    {
        return a.m_impl != b.m_impl;
    }

    template<typename T, typename U, typename V>
        inline bool operator==(const HashTableKeysIterator<T, U, V>& a, const HashTableKeysIterator<T, U, V>& b)
    {
        return a.m_impl == b.m_impl;
    }

    template<typename T, typename U, typename V>
        inline bool operator!=(const HashTableKeysIterator<T, U, V>& a, const HashTableKeysIterator<T, U, V>& b)
    {
        return a.m_impl != b.m_impl;
    }

    template<typename T, typename U, typename V>
        inline bool operator==(const HashTableValuesIterator<T, U, V>& a, const HashTableValuesIterator<T, U, V>& b)
    {
        return a.m_impl == b.m_impl;
    }

    template<typename T, typename U, typename V>
        inline bool operator!=(const HashTableValuesIterator<T, U, V>& a, const HashTableValuesIterator<T, U, V>& b)
    {
        return a.m_impl != b.m_impl;
    }


}
# 1181 "./wtf/HashTable.h" 2
# 25 "./wtf/HashMap.h" 2

namespace WTF {

    template<typename PairType> struct PairFirstExtractor;

    template<typename KeyArg, typename MappedArg, typename HashArg = typename DefaultHash<KeyArg>::Hash,
        typename KeyTraitsArg = HashTraits<KeyArg>, typename MappedTraitsArg = HashTraits<MappedArg> >
    class HashMap {
        public: void* operator new(size_t, void* p) { return p; } void* operator new[](size_t, void* p) { return p; } void* operator new(size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNew); return p; } void operator delete(void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNew); ::WTF::fastFree(p); } void* operator new[](size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNewArray); return p; } void operator delete[](void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNewArray); ::WTF::fastFree(p); } private: typedef int ThisIsHereToForceASemicolonAfterThisMacro;
    private:
        typedef KeyTraitsArg KeyTraits;
        typedef MappedTraitsArg MappedTraits;
        typedef PairHashTraits<KeyTraits, MappedTraits> ValueTraits;

    public:
        typedef typename KeyTraits::TraitType KeyType;
        typedef typename MappedTraits::TraitType MappedType;
        typedef typename ValueTraits::TraitType ValueType;

    private:
        typedef HashArg HashFunctions;

        typedef HashTable<KeyType, ValueType, PairFirstExtractor<ValueType>,
            HashFunctions, ValueTraits, KeyTraits> HashTableType;

    public:
        typedef HashTableIteratorAdapter<HashTableType, ValueType> iterator;
        typedef HashTableConstIteratorAdapter<HashTableType, ValueType> const_iterator;

        void swap(HashMap&);

        int size() const;
        int capacity() const;
        bool isEmpty() const;


        iterator begin();
        iterator end();
        const_iterator begin() const;
        const_iterator end() const;

        iterator find(const KeyType&);
        const_iterator find(const KeyType&) const;
        bool contains(const KeyType&) const;
        MappedType get(const KeyType&) const;




        pair<iterator, bool> set(const KeyType&, const MappedType&);




        pair<iterator, bool> add(const KeyType&, const MappedType&);

        void remove(const KeyType&);
        void remove(iterator);
        void clear();

        MappedType take(const KeyType&);






        template<typename T, typename HashTranslator> iterator find(const T&);
        template<typename T, typename HashTranslator> const_iterator find(const T&) const;
        template<typename T, typename HashTranslator> bool contains(const T&) const;







        template<typename T, typename HashTranslator> pair<iterator, bool> add(const T&, const MappedType&);

        void checkConsistency() const;

    private:
        pair<iterator, bool> inlineAdd(const KeyType&, const MappedType&);

        HashTableType m_impl;
    };

    template<typename PairType> struct PairFirstExtractor {
        static const typename PairType::first_type& extract(const PairType& p) { return p.first; }
    };

    template<typename ValueType, typename ValueTraits, typename HashFunctions>
    struct HashMapTranslator {
        typedef typename ValueType::first_type KeyType;
        typedef typename ValueType::second_type MappedType;

        static unsigned hash(const KeyType& key) { return HashFunctions::hash(key); }
        static bool equal(const KeyType& a, const KeyType& b) { return HashFunctions::equal(a, b); }
        static void translate(ValueType& location, const KeyType& key, const MappedType& mapped)
        {
            location.first = key;
            location.second = mapped;
        }
    };

    template<typename ValueType, typename ValueTraits, typename T, typename Translator>
    struct HashMapTranslatorAdapter {
        typedef typename ValueType::first_type KeyType;
        typedef typename ValueType::second_type MappedType;

        static unsigned hash(const T& key) { return Translator::hash(key); }
        static bool equal(const KeyType& a, const T& b) { return Translator::equal(a, b); }
        static void translate(ValueType& location, const T& key, const MappedType& mapped, unsigned hashCode)
        {
            Translator::translate(location.first, key, hashCode);
            location.second = mapped;
        }
    };

    template<typename T, typename U, typename V, typename W, typename X>
    inline void HashMap<T, U, V, W, X>::swap(HashMap& other)
    {
        m_impl.swap(other.m_impl);
    }

    template<typename T, typename U, typename V, typename W, typename X>
    inline int HashMap<T, U, V, W, X>::size() const
    {
        return m_impl.size();
    }

    template<typename T, typename U, typename V, typename W, typename X>
    inline int HashMap<T, U, V, W, X>::capacity() const
    {
        return m_impl.capacity();
    }

    template<typename T, typename U, typename V, typename W, typename X>
    inline bool HashMap<T, U, V, W, X>::isEmpty() const
    {
        return m_impl.isEmpty();
    }

    template<typename T, typename U, typename V, typename W, typename X>
    inline typename HashMap<T, U, V, W, X>::iterator HashMap<T, U, V, W, X>::begin()
    {
        return m_impl.begin();
    }

    template<typename T, typename U, typename V, typename W, typename X>
    inline typename HashMap<T, U, V, W, X>::iterator HashMap<T, U, V, W, X>::end()
    {
        return m_impl.end();
    }

    template<typename T, typename U, typename V, typename W, typename X>
    inline typename HashMap<T, U, V, W, X>::const_iterator HashMap<T, U, V, W, X>::begin() const
    {
        return m_impl.begin();
    }

    template<typename T, typename U, typename V, typename W, typename X>
    inline typename HashMap<T, U, V, W, X>::const_iterator HashMap<T, U, V, W, X>::end() const
    {
        return m_impl.end();
    }

    template<typename T, typename U, typename V, typename W, typename X>
    inline typename HashMap<T, U, V, W, X>::iterator HashMap<T, U, V, W, X>::find(const KeyType& key)
    {
        return m_impl.find(key);
    }

    template<typename T, typename U, typename V, typename W, typename X>
    inline typename HashMap<T, U, V, W, X>::const_iterator HashMap<T, U, V, W, X>::find(const KeyType& key) const
    {
        return m_impl.find(key);
    }

    template<typename T, typename U, typename V, typename W, typename X>
    inline bool HashMap<T, U, V, W, X>::contains(const KeyType& key) const
    {
        return m_impl.contains(key);
    }

    template<typename T, typename U, typename V, typename W, typename X>
    template<typename TYPE, typename HashTranslator>
    inline typename HashMap<T, U, V, W, X>::iterator
    HashMap<T, U, V, W, X>::find(const TYPE& value)
    {
        typedef HashMapTranslatorAdapter<ValueType, ValueTraits, TYPE, HashTranslator> Adapter;
        return m_impl.template find<TYPE, Adapter>(value);
    }

    template<typename T, typename U, typename V, typename W, typename X>
    template<typename TYPE, typename HashTranslator>
    inline typename HashMap<T, U, V, W, X>::const_iterator
    HashMap<T, U, V, W, X>::find(const TYPE& value) const
    {
        typedef HashMapTranslatorAdapter<ValueType, ValueTraits, TYPE, HashTranslator> Adapter;
        return m_impl.template find<TYPE, Adapter>(value);
    }

    template<typename T, typename U, typename V, typename W, typename X>
    template<typename TYPE, typename HashTranslator>
    inline bool
    HashMap<T, U, V, W, X>::contains(const TYPE& value) const
    {
        typedef HashMapTranslatorAdapter<ValueType, ValueTraits, TYPE, HashTranslator> Adapter;
        return m_impl.template contains<TYPE, Adapter>(value);
    }

    template<typename T, typename U, typename V, typename W, typename X>
    inline pair<typename HashMap<T, U, V, W, X>::iterator, bool>
    HashMap<T, U, V, W, X>::inlineAdd(const KeyType& key, const MappedType& mapped)
    {
        typedef HashMapTranslator<ValueType, ValueTraits, HashFunctions> TranslatorType;
        return m_impl.template add<KeyType, MappedType, TranslatorType>(key, mapped);
    }

    template<typename T, typename U, typename V, typename W, typename X>
    pair<typename HashMap<T, U, V, W, X>::iterator, bool>
    HashMap<T, U, V, W, X>::set(const KeyType& key, const MappedType& mapped)
    {
        pair<iterator, bool> result = inlineAdd(key, mapped);
        if (!result.second) {

            result.first->second = mapped;
        }
        return result;
    }

    template<typename T, typename U, typename V, typename W, typename X>
    template<typename TYPE, typename HashTranslator>
    pair<typename HashMap<T, U, V, W, X>::iterator, bool>
    HashMap<T, U, V, W, X>::add(const TYPE& key, const MappedType& value)
    {
        typedef HashMapTranslatorAdapter<ValueType, ValueTraits, TYPE, HashTranslator> Adapter;
        return m_impl.template addPassingHashCode<TYPE, MappedType, Adapter>(key, value);
    }

    template<typename T, typename U, typename V, typename W, typename X>
    pair<typename HashMap<T, U, V, W, X>::iterator, bool>
    HashMap<T, U, V, W, X>::add(const KeyType& key, const MappedType& mapped)
    {
        return inlineAdd(key, mapped);
    }

    template<typename T, typename U, typename V, typename W, typename MappedTraits>
    typename HashMap<T, U, V, W, MappedTraits>::MappedType
    HashMap<T, U, V, W, MappedTraits>::get(const KeyType& key) const
    {
        ValueType* entry = const_cast<HashTableType&>(m_impl).lookup(key);
        if (!entry)
            return MappedTraits::emptyValue();
        return entry->second;
    }

    template<typename T, typename U, typename V, typename W, typename X>
    inline void HashMap<T, U, V, W, X>::remove(iterator it)
    {
        if (it.m_impl == m_impl.end())
            return;
        m_impl.internalCheckTableConsistency();
        m_impl.removeWithoutEntryConsistencyCheck(it.m_impl);
    }

    template<typename T, typename U, typename V, typename W, typename X>
    inline void HashMap<T, U, V, W, X>::remove(const KeyType& key)
    {
        remove(find(key));
    }

    template<typename T, typename U, typename V, typename W, typename X>
    inline void HashMap<T, U, V, W, X>::clear()
    {
        m_impl.clear();
    }

    template<typename T, typename U, typename V, typename W, typename MappedTraits>
    typename HashMap<T, U, V, W, MappedTraits>::MappedType
    HashMap<T, U, V, W, MappedTraits>::take(const KeyType& key)
    {

        iterator it = find(key);
        if (it == end())
            return MappedTraits::emptyValue();
        typename HashMap<T, U, V, W, MappedTraits>::MappedType result = it->second;
        remove(it);
        return result;
    }

    template<typename T, typename U, typename V, typename W, typename X>
    inline void HashMap<T, U, V, W, X>::checkConsistency() const
    {
        m_impl.checkTableConsistency();
    }


    template<typename T, typename U, typename V, typename W, typename X>
    bool operator==(const HashMap<T, U, V, W, X>& a, const HashMap<T, U, V, W, X>& b)
    {
        if (a.size() != b.size())
            return false;

        typedef typename HashMap<T, U, V, W, X>::const_iterator const_iterator;

        const_iterator end = a.end();
        const_iterator notFound = b.end();
        for (const_iterator it = a.begin(); it != end; ++it) {
            const_iterator bPos = b.find(it->first);
            if (bPos == notFound || it->second != bPos->second)
                return false;
        }

        return true;
    }

    template<typename T, typename U, typename V, typename W, typename X>
    inline bool operator!=(const HashMap<T, U, V, W, X>& a, const HashMap<T, U, V, W, X>& b)
    {
        return !(a == b);
    }

    template<typename MappedType, typename HashTableType>
    void deleteAllPairSeconds(HashTableType& collection)
    {
        typedef typename HashTableType::const_iterator iterator;
        iterator end = collection.end();
        for (iterator it = collection.begin(); it != end; ++it)
            delete it->second;
    }

    template<typename T, typename U, typename V, typename W, typename X>
    inline void deleteAllValues(const HashMap<T, U, V, W, X>& collection)
    {
        deleteAllPairSeconds<typename HashMap<T, U, V, W, X>::MappedType>(collection);
    }

    template<typename KeyType, typename HashTableType>
    void deleteAllPairFirsts(HashTableType& collection)
    {
        typedef typename HashTableType::const_iterator iterator;
        iterator end = collection.end();
        for (iterator it = collection.begin(); it != end; ++it)
            delete it->first;
    }

    template<typename T, typename U, typename V, typename W, typename X>
    inline void deleteAllKeys(const HashMap<T, U, V, W, X>& collection)
    {
        deleteAllPairFirsts<typename HashMap<T, U, V, W, X>::KeyType>(collection);
    }

    template<typename T, typename U, typename V, typename W, typename X, typename Y>
    inline void copyKeysToVector(const HashMap<T, U, V, W, X>& collection, Y& vector)
    {
        typedef typename HashMap<T, U, V, W, X>::const_iterator::Keys iterator;

        vector.resize(collection.size());

        iterator it = collection.begin().keys();
        iterator end = collection.end().keys();
        for (unsigned i = 0; it != end; ++it, ++i)
            vector[i] = *it;
    }

    template<typename T, typename U, typename V, typename W, typename X, typename Y>
    inline void copyValuesToVector(const HashMap<T, U, V, W, X>& collection, Y& vector)
    {
        typedef typename HashMap<T, U, V, W, X>::const_iterator::Values iterator;

        vector.resize(collection.size());

        iterator it = collection.begin().values();
        iterator end = collection.end().values();
        for (unsigned i = 0; it != end; ++it, ++i)
            vector[i] = *it;
    }

}

using WTF::HashMap;


# 1 "./wtf/RefPtrHashMap.h" 1
# 24 "./wtf/RefPtrHashMap.h"
namespace WTF {






    template<typename RawKeyType, typename ValueType, typename ValueTraits, typename HashFunctions>
    struct RefPtrHashMapRawKeyTranslator {
        typedef typename ValueType::first_type KeyType;
        typedef typename ValueType::second_type MappedType;
        typedef typename ValueTraits::FirstTraits KeyTraits;
        typedef typename ValueTraits::SecondTraits MappedTraits;

        static unsigned hash(RawKeyType key) { return HashFunctions::hash(key); }
        static bool equal(const KeyType& a, RawKeyType b) { return HashFunctions::equal(a, b); }
        static void translate(ValueType& location, RawKeyType key, const MappedType& mapped)
        {
            location.first = key;
            location.second = mapped;
        }
    };

    template<typename T, typename MappedArg, typename HashArg, typename KeyTraitsArg, typename MappedTraitsArg>
    class HashMap<RefPtr<T>, MappedArg, HashArg, KeyTraitsArg, MappedTraitsArg> {
        public: void* operator new(size_t, void* p) { return p; } void* operator new[](size_t, void* p) { return p; } void* operator new(size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNew); return p; } void operator delete(void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNew); ::WTF::fastFree(p); } void* operator new[](size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNewArray); return p; } void operator delete[](void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNewArray); ::WTF::fastFree(p); } private: typedef int ThisIsHereToForceASemicolonAfterThisMacro;
    private:
        typedef KeyTraitsArg KeyTraits;
        typedef MappedTraitsArg MappedTraits;
        typedef PairHashTraits<KeyTraits, MappedTraits> ValueTraits;

    public:
        typedef typename KeyTraits::TraitType KeyType;
        typedef T* RawKeyType;
        typedef typename MappedTraits::TraitType MappedType;
        typedef typename ValueTraits::TraitType ValueType;

    private:
        typedef HashArg HashFunctions;

        typedef HashTable<KeyType, ValueType, PairFirstExtractor<ValueType>,
            HashFunctions, ValueTraits, KeyTraits> HashTableType;

        typedef RefPtrHashMapRawKeyTranslator<RawKeyType, ValueType, ValueTraits, HashFunctions>
            RawKeyTranslator;

    public:
        typedef HashTableIteratorAdapter<HashTableType, ValueType> iterator;
        typedef HashTableConstIteratorAdapter<HashTableType, ValueType> const_iterator;

        void swap(HashMap&);

        int size() const;
        int capacity() const;
        bool isEmpty() const;


        iterator begin();
        iterator end();
        const_iterator begin() const;
        const_iterator end() const;

        iterator find(const KeyType&);
        iterator find(RawKeyType);
        const_iterator find(const KeyType&) const;
        const_iterator find(RawKeyType) const;
        bool contains(const KeyType&) const;
        bool contains(RawKeyType) const;
        MappedType get(const KeyType&) const;
        MappedType get(RawKeyType) const;
        MappedType inlineGet(RawKeyType) const;




        pair<iterator, bool> set(const KeyType&, const MappedType&);
        pair<iterator, bool> set(RawKeyType, const MappedType&);




        pair<iterator, bool> add(const KeyType&, const MappedType&);
        pair<iterator, bool> add(RawKeyType, const MappedType&);

        void remove(const KeyType&);
        void remove(RawKeyType);
        void remove(iterator);
        void clear();

        MappedType take(const KeyType&);
        MappedType take(RawKeyType);

    private:
        pair<iterator, bool> inlineAdd(const KeyType&, const MappedType&);
        pair<iterator, bool> inlineAdd(RawKeyType, const MappedType&);

        HashTableType m_impl;
    };

    template<typename T, typename U, typename V, typename W, typename X>
    inline void HashMap<RefPtr<T>, U, V, W, X>::swap(HashMap& other)
    {
        m_impl.swap(other.m_impl);
    }

    template<typename T, typename U, typename V, typename W, typename X>
    inline int HashMap<RefPtr<T>, U, V, W, X>::size() const
    {
        return m_impl.size();
    }

    template<typename T, typename U, typename V, typename W, typename X>
    inline int HashMap<RefPtr<T>, U, V, W, X>::capacity() const
    {
        return m_impl.capacity();
    }

    template<typename T, typename U, typename V, typename W, typename X>
    inline bool HashMap<RefPtr<T>, U, V, W, X>::isEmpty() const
    {
        return m_impl.isEmpty();
    }

    template<typename T, typename U, typename V, typename W, typename X>
    inline typename HashMap<RefPtr<T>, U, V, W, X>::iterator HashMap<RefPtr<T>, U, V, W, X>::begin()
    {
        return m_impl.begin();
    }

    template<typename T, typename U, typename V, typename W, typename X>
    inline typename HashMap<RefPtr<T>, U, V, W, X>::iterator HashMap<RefPtr<T>, U, V, W, X>::end()
    {
        return m_impl.end();
    }

    template<typename T, typename U, typename V, typename W, typename X>
    inline typename HashMap<RefPtr<T>, U, V, W, X>::const_iterator HashMap<RefPtr<T>, U, V, W, X>::begin() const
    {
        return m_impl.begin();
    }

    template<typename T, typename U, typename V, typename W, typename X>
    inline typename HashMap<RefPtr<T>, U, V, W, X>::const_iterator HashMap<RefPtr<T>, U, V, W, X>::end() const
    {
        return m_impl.end();
    }

    template<typename T, typename U, typename V, typename W, typename X>
    inline typename HashMap<RefPtr<T>, U, V, W, X>::iterator HashMap<RefPtr<T>, U, V, W, X>::find(const KeyType& key)
    {
        return m_impl.find(key);
    }

    template<typename T, typename U, typename V, typename W, typename X>
    inline typename HashMap<RefPtr<T>, U, V, W, X>::iterator HashMap<RefPtr<T>, U, V, W, X>::find(RawKeyType key)
    {
        return m_impl.template find<RawKeyType, RawKeyTranslator>(key);
    }

    template<typename T, typename U, typename V, typename W, typename X>
    inline typename HashMap<RefPtr<T>, U, V, W, X>::const_iterator HashMap<RefPtr<T>, U, V, W, X>::find(const KeyType& key) const
    {
        return m_impl.find(key);
    }

    template<typename T, typename U, typename V, typename W, typename X>
    inline typename HashMap<RefPtr<T>, U, V, W, X>::const_iterator HashMap<RefPtr<T>, U, V, W, X>::find(RawKeyType key) const
    {
        return m_impl.template find<RawKeyType, RawKeyTranslator>(key);
    }

    template<typename T, typename U, typename V, typename W, typename X>
    inline bool HashMap<RefPtr<T>, U, V, W, X>::contains(const KeyType& key) const
    {
        return m_impl.contains(key);
    }

    template<typename T, typename U, typename V, typename W, typename X>
    inline bool HashMap<RefPtr<T>, U, V, W, X>::contains(RawKeyType key) const
    {
        return m_impl.template contains<RawKeyType, RawKeyTranslator>(key);
    }

    template<typename T, typename U, typename V, typename W, typename X>
    inline pair<typename HashMap<RefPtr<T>, U, V, W, X>::iterator, bool>
    HashMap<RefPtr<T>, U, V, W, X>::inlineAdd(const KeyType& key, const MappedType& mapped)
    {
        typedef HashMapTranslator<ValueType, ValueTraits, HashFunctions> TranslatorType;
        return m_impl.template add<KeyType, MappedType, TranslatorType>(key, mapped);
    }

    template<typename T, typename U, typename V, typename W, typename X>
    inline pair<typename HashMap<RefPtr<T>, U, V, W, X>::iterator, bool>
    HashMap<RefPtr<T>, U, V, W, X>::inlineAdd(RawKeyType key, const MappedType& mapped)
    {
        return m_impl.template add<RawKeyType, MappedType, RawKeyTranslator>(key, mapped);
    }

    template<typename T, typename U, typename V, typename W, typename X>
    pair<typename HashMap<RefPtr<T>, U, V, W, X>::iterator, bool>
    HashMap<RefPtr<T>, U, V, W, X>::set(const KeyType& key, const MappedType& mapped)
    {
        pair<iterator, bool> result = inlineAdd(key, mapped);
        if (!result.second) {

            result.first->second = mapped;
        }
        return result;
    }

    template<typename T, typename U, typename V, typename W, typename X>
    pair<typename HashMap<RefPtr<T>, U, V, W, X>::iterator, bool>
    HashMap<RefPtr<T>, U, V, W, X>::set(RawKeyType key, const MappedType& mapped)
    {
        pair<iterator, bool> result = inlineAdd(key, mapped);
        if (!result.second) {

            result.first->second = mapped;
        }
        return result;
    }

    template<typename T, typename U, typename V, typename W, typename X>
    pair<typename HashMap<RefPtr<T>, U, V, W, X>::iterator, bool>
    HashMap<RefPtr<T>, U, V, W, X>::add(const KeyType& key, const MappedType& mapped)
    {
        return inlineAdd(key, mapped);
    }

    template<typename T, typename U, typename V, typename W, typename X>
    pair<typename HashMap<RefPtr<T>, U, V, W, X>::iterator, bool>
    HashMap<RefPtr<T>, U, V, W, X>::add(RawKeyType key, const MappedType& mapped)
    {
        return inlineAdd(key, mapped);
    }

    template<typename T, typename U, typename V, typename W, typename MappedTraits>
    typename HashMap<RefPtr<T>, U, V, W, MappedTraits>::MappedType
    HashMap<RefPtr<T>, U, V, W, MappedTraits>::get(const KeyType& key) const
    {
        ValueType* entry = const_cast<HashTableType&>(m_impl).lookup(key);
        if (!entry)
            return MappedTraits::emptyValue();
        return entry->second;
    }

    template<typename T, typename U, typename V, typename W, typename MappedTraits>
    typename HashMap<RefPtr<T>, U, V, W, MappedTraits>::MappedType
    inline HashMap<RefPtr<T>, U, V, W, MappedTraits>::inlineGet(RawKeyType key) const
    {
        ValueType* entry = const_cast<HashTableType&>(m_impl).template lookup<RawKeyType, RawKeyTranslator>(key);
        if (!entry)
            return MappedTraits::emptyValue();
        return entry->second;
    }

    template<typename T, typename U, typename V, typename W, typename MappedTraits>
    typename HashMap<RefPtr<T>, U, V, W, MappedTraits>::MappedType
    HashMap<RefPtr<T>, U, V, W, MappedTraits>::get(RawKeyType key) const
    {
        return inlineGet(key);
    }

    template<typename T, typename U, typename V, typename W, typename X>
    inline void HashMap<RefPtr<T>, U, V, W, X>::remove(iterator it)
    {
        if (it.m_impl == m_impl.end())
            return;
        m_impl.internalCheckTableConsistency();
        m_impl.removeWithoutEntryConsistencyCheck(it.m_impl);
    }

    template<typename T, typename U, typename V, typename W, typename X>
    inline void HashMap<RefPtr<T>, U, V, W, X>::remove(const KeyType& key)
    {
        remove(find(key));
    }

    template<typename T, typename U, typename V, typename W, typename X>
    inline void HashMap<RefPtr<T>, U, V, W, X>::remove(RawKeyType key)
    {
        remove(find(key));
    }

    template<typename T, typename U, typename V, typename W, typename X>
    inline void HashMap<RefPtr<T>, U, V, W, X>::clear()
    {
        m_impl.clear();
    }

    template<typename T, typename U, typename V, typename W, typename MappedTraits>
    typename HashMap<RefPtr<T>, U, V, W, MappedTraits>::MappedType
    HashMap<RefPtr<T>, U, V, W, MappedTraits>::take(const KeyType& key)
    {

        iterator it = find(key);
        if (it == end())
            return MappedTraits::emptyValue();
        typename HashMap<RefPtr<T>, U, V, W, MappedTraits>::MappedType result = it->second;
        remove(it);
        return result;
    }

    template<typename T, typename U, typename V, typename W, typename MappedTraits>
    typename HashMap<RefPtr<T>, U, V, W, MappedTraits>::MappedType
    HashMap<RefPtr<T>, U, V, W, MappedTraits>::take(RawKeyType key)
    {

        iterator it = find(key);
        if (it == end())
            return MappedTraits::emptyValue();
        typename HashMap<RefPtr<T>, U, V, W, MappedTraits>::MappedType result = it->second;
        remove(it);
        return result;
    }

}
# 410 "./wtf/HashMap.h" 2
# 32 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSValue.h" 2

# 1 "./wtf/MathExtras.h" 1
# 30 "./wtf/MathExtras.h"
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cmath" 1 3
# 48 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cmath" 3
# 48 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cmath" 3
# 81 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cmath" 3
namespace std {



  template<typename _Tp> _Tp __cmath_power(_Tp, unsigned int);

  inline double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }

  using ::acos;

  inline float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline long double
  acos(long double __x)
  { return __builtin_acosl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;

  inline float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline long double
  asin(long double __x)
  { return __builtin_asinl(__x); }

  template<typename _Tp>
  inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
      double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;

  inline float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline long double
  atan(long double __x)
  { return __builtin_atanl(__x); }

  template<typename _Tp>
  inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
      double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;

  inline float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }

  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value
            && __is_integer<_Up>::__value,
        double>::__type
    atan2(_Tp __y, _Up __x)
    { return __builtin_atan2(__y, __x); }

  using ::ceil;

  inline float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;

  inline float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline long double
  cos(long double __x)
  { return __builtin_cosl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;

  inline float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;

  inline float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline long double
  exp(long double __x)
  { return __builtin_expl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;

  inline float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;

  inline float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline long double
  floor(long double __x)
  { return __builtin_floorl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;

  inline float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }

  using ::frexp;

  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;

  inline float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
  ldexp(_Tp __x, int __exp)
  { return __builtin_ldexp(__x, __exp); }

  using ::log;

  inline float
  log(float __x)
  { return __builtin_logf(__x); }

  inline long double
  log(long double __x)
  { return __builtin_logl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;

  inline float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline long double
  log10(long double __x)
  { return __builtin_log10l(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;

  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }

  template<typename _Tp>
    inline _Tp
    __pow_helper(_Tp __x, int __n)
    {
      return __n < 0
        ? _Tp(1)/__cmath_power(__x, -__n)
        : __cmath_power(__x, __n);
    }

  using ::pow;

  inline float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }

  inline double
  pow(double __x, int __i)
  { return __builtin_powi(__x, __i); }

  inline float
  pow(float __x, int __n)
  { return __builtin_powif(__x, __n); }

  inline long double
  pow(long double __x, int __n)
  { return __builtin_powil(__x, __n); }

  using ::sin;

  inline float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline long double
  sin(long double __x)
  { return __builtin_sinl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;

  inline float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;

  inline float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;

  inline float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline long double
  tan(long double __x)
  { return __builtin_tanl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;

  inline float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }

}







namespace __gnu_cxx {

  template<typename _Tp>
    inline int
    __capture_fpclassify(_Tp __f) { return ( sizeof (__f) == sizeof(float ) ? __fpclassifyf((float)(__f)) : sizeof (__f) == sizeof(double) ? __fpclassifyd((double)(__f)) : __fpclassify ((long double)(__f))); }

  template<typename _Tp>
    inline int
    __capture_isfinite(_Tp __f) { return ( sizeof (__f) == sizeof(float ) ? __inline_isfinitef((float)(__f)) : sizeof (__f) == sizeof(double) ? __inline_isfinited((double)(__f)) : __inline_isfinite ((long double)(__f))); }

  template<typename _Tp>
    inline int
    __capture_isinf(_Tp __f) { return ( sizeof (__f) == sizeof(float ) ? __inline_isinff((float)(__f)) : sizeof (__f) == sizeof(double) ? __inline_isinfd((double)(__f)) : __inline_isinf ((long double)(__f))); }

  template<typename _Tp>
    inline int
    __capture_isnan(_Tp __f) { return ( sizeof (__f) == sizeof(float ) ? __inline_isnanf((float)(__f)) : sizeof (__f) == sizeof(double) ? __inline_isnand((double)(__f)) : __inline_isnan ((long double)(__f))); }

  template<typename _Tp>
    inline int
    __capture_isnormal(_Tp __f) { return ( sizeof (__f) == sizeof(float ) ? __inline_isnormalf((float)(__f)) : sizeof (__f) == sizeof(double) ? __inline_isnormald((double)(__f)) : __inline_isnormal ((long double)(__f))); }

  template<typename _Tp>
    inline int
    __capture_signbit(_Tp __f) { return ( sizeof (__f) == sizeof(float ) ? __inline_signbitf((float)(__f)) : sizeof (__f) == sizeof(double) ? __inline_signbitd((double)(__f)) : __inline_signbit((long double)(__f))); }

  template<typename _Tp>
    inline int
    __capture_isgreater(_Tp __f1, _Tp __f2)
    { return __builtin_isgreater ((__f1),(__f2)); }

  template<typename _Tp>
    inline int
    __capture_isgreaterequal(_Tp __f1, _Tp __f2)
    { return __builtin_isgreaterequal ((__f1),(__f2)); }

  template<typename _Tp>
    inline int
    __capture_isless(_Tp __f1, _Tp __f2) { return __builtin_isless ((__f1),(__f2)); }

  template<typename _Tp>
    inline int
    __capture_islessequal(_Tp __f1, _Tp __f2)
    { return __builtin_islessequal ((__f1),(__f2)); }

  template<typename _Tp>
    inline int
    __capture_islessgreater(_Tp __f1, _Tp __f2)
    { return __builtin_islessgreater ((__f1),(__f2)); }

  template<typename _Tp>
    inline int
    __capture_isunordered(_Tp __f1, _Tp __f2)
    { return __builtin_isunordered ((__f1),(__f2)); }

}
# 534 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cmath" 3
namespace std {

  template<typename _Tp>
    inline int
    fpclassify(_Tp __f) { return ::__gnu_cxx::__capture_fpclassify(__f); }

  template<typename _Tp>
    inline int
    isfinite(_Tp __f) { return ::__gnu_cxx::__capture_isfinite(__f); }

  template<typename _Tp>
    inline int
    isinf(_Tp __f) { return ::__gnu_cxx::__capture_isinf(__f); }

  template<typename _Tp>
    inline int
    isnan(_Tp __f) { return ::__gnu_cxx::__capture_isnan(__f); }

  template<typename _Tp>
    inline int
    isnormal(_Tp __f) { return ::__gnu_cxx::__capture_isnormal(__f); }

  template<typename _Tp>
    inline int
    signbit(_Tp __f) { return ::__gnu_cxx::__capture_signbit(__f); }

  template<typename _Tp>
    inline int
    isgreater(_Tp __f1, _Tp __f2)
    { return ::__gnu_cxx::__capture_isgreater(__f1, __f2); }

  template<typename _Tp>
    inline int
    isgreaterequal(_Tp __f1, _Tp __f2)
    { return ::__gnu_cxx::__capture_isgreaterequal(__f1, __f2); }

  template<typename _Tp>
    inline int
    isless(_Tp __f1, _Tp __f2)
    { return ::__gnu_cxx::__capture_isless(__f1, __f2); }

  template<typename _Tp>
    inline int
    islessequal(_Tp __f1, _Tp __f2)
    { return ::__gnu_cxx::__capture_islessequal(__f1, __f2); }

  template<typename _Tp>
    inline int
    islessgreater(_Tp __f1, _Tp __f2)
    { return ::__gnu_cxx::__capture_islessgreater(__f1, __f2); }

  template<typename _Tp>
    inline int
    isunordered(_Tp __f1, _Tp __f2)
    { return ::__gnu_cxx::__capture_isunordered(__f1, __f2); }

}






# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/cmath.tcc" 1 3
# 39 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/bits/cmath.tcc" 3
namespace std {

  template<typename _Tp>
    inline _Tp
    __cmath_power(_Tp __x, unsigned int __n)
    {
      _Tp __y = __n % 2 ? __x : 1;

      while (__n >>= 1)
        {
          __x = __x * __x;
          if (__n % 2)
            __y = __y * __x;
        }

      return __y;
    }

}
# 597 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/c++/4.2.1/cmath" 2 3
# 31 "./wtf/MathExtras.h" 2
# 1 "/Users/ddunbar/rt/11003353/clang-r152231-t20120307_081803-b13838/Developer/usr/bin/../lib/clang/3.1/include/float.h" 1 3 4
# 32 "./wtf/MathExtras.h" 2



# 1 "./wtf/StdLibExtras.h" 1
# 29 "./wtf/StdLibExtras.h"
# 1 "./wtf/CheckedArithmetic.h" 1
# 67 "./wtf/CheckedArithmetic.h"
namespace WTF {

class CrashOnOverflow {
protected:
    __attribute((__noreturn__)) void overflowed()
    {
        do { WTFReportBacktrace(); *(int *)(uintptr_t)0xbbadbeef = 0; __builtin_trap(); } while (false);
    }

    void clearOverflow() { }

public:
    bool hasOverflowed() const { return false; }
};

class RecordOverflow {
protected:
    RecordOverflow()
        : m_overflowed(false)
    {
    }

    void overflowed()
    {
        m_overflowed = true;
    }

    void clearOverflow()
    {
        m_overflowed = false;
    }

public:
    bool hasOverflowed() const { return m_overflowed; }

private:
    unsigned char m_overflowed;
};

template <typename T, class OverflowHandler = CrashOnOverflow> class Checked;
template <typename T> struct RemoveChecked;
template <typename T> struct RemoveChecked<Checked<T> >;

template <typename Target, typename Source, bool targetSigned = std::numeric_limits<Target>::is_signed, bool sourceSigned = std::numeric_limits<Source>::is_signed> struct BoundsChecker;
template <typename Target, typename Source> struct BoundsChecker<Target, Source, false, false> {
    static bool inBounds(Source value)
    {


        return value <= std::numeric_limits<Target>::max();
    }
};

template <typename Target, typename Source> struct BoundsChecker<Target, Source, true, true> {
    static bool inBounds(Source value)
    {


        return std::numeric_limits<Target>::min() <= value && value <= std::numeric_limits<Target>::max();
    }
};

template <typename Target, typename Source> struct BoundsChecker<Target, Source, false, true> {
    static bool inBounds(Source value)
    {

        if (value < 0)
            return false;


        if (sizeof(Target) >= sizeof(Source))
            return static_cast<Target>(value) <= std::numeric_limits<Target>::max();


        return value <= static_cast<Source>(std::numeric_limits<Target>::max());
    }
};

template <typename Target, typename Source> struct BoundsChecker<Target, Source, true, false> {
    static bool inBounds(Source value)
    {

        if (sizeof(Target) <= sizeof(Source))
            return value <= static_cast<Source>(std::numeric_limits<Target>::max());


        return true;
    }
};

template <typename Target, typename Source, bool SameType = IsSameType<Target, Source>::value> struct BoundsCheckElider;
template <typename Target, typename Source> struct BoundsCheckElider<Target, Source, true> {
    static bool inBounds(Source) { return true; }
};
template <typename Target, typename Source> struct BoundsCheckElider<Target, Source, false> : public BoundsChecker<Target, Source> {
};

template <typename Target, typename Source> static inline bool isInBounds(Source value)
{
    return BoundsCheckElider<Target, Source>::inBounds(value);
}

template <typename T> struct RemoveChecked {
    typedef T CleanType;
    static const CleanType DefaultValue = 0;
};

template <typename T> struct RemoveChecked<Checked<T, CrashOnOverflow> > {
    typedef typename RemoveChecked<T>::CleanType CleanType;
    static const CleanType DefaultValue = 0;
};

template <typename T> struct RemoveChecked<Checked<T, RecordOverflow> > {
    typedef typename RemoveChecked<T>::CleanType CleanType;
    static const CleanType DefaultValue = 0;
};



template <typename U, typename V, bool uIsBigger = (sizeof(U) > sizeof(V)), bool sameSize = (sizeof(U) == sizeof(V))> struct ResultBase;
template <typename U, typename V> struct ResultBase<U, V, true, false> {
    typedef U ResultType;
};

template <typename U, typename V> struct ResultBase<U, V, false, false> {
    typedef V ResultType;
};

template <typename U> struct ResultBase<U, U, false, true> {
    typedef U ResultType;
};

template <typename U, typename V, bool uIsSigned = std::numeric_limits<U>::is_signed, bool vIsSigned = std::numeric_limits<V>::is_signed> struct SignednessSelector;
template <typename U, typename V> struct SignednessSelector<U, V, true, true> {
    typedef U ResultType;
};

template <typename U, typename V> struct SignednessSelector<U, V, false, false> {
    typedef U ResultType;
};

template <typename U, typename V> struct SignednessSelector<U, V, true, false> {
    typedef V ResultType;
};

template <typename U, typename V> struct SignednessSelector<U, V, false, true> {
    typedef U ResultType;
};

template <typename U, typename V> struct ResultBase<U, V, false, true> {
    typedef typename SignednessSelector<U, V>::ResultType ResultType;
};

template <typename U, typename V> struct Result : ResultBase<typename RemoveChecked<U>::CleanType, typename RemoveChecked<V>::CleanType> {
};

template <typename LHS, typename RHS, typename ResultType = typename Result<LHS, RHS>::ResultType,
    bool lhsSigned = std::numeric_limits<LHS>::is_signed, bool rhsSigned = std::numeric_limits<RHS>::is_signed> struct ArithmeticOperations;

template <typename LHS, typename RHS, typename ResultType> struct ArithmeticOperations<LHS, RHS, ResultType, true, true> {



    static inline bool signsMatch(LHS lhs, RHS rhs)
    {
        return (lhs ^ rhs) >= 0;
    }

    static inline bool add(LHS lhs, RHS rhs, ResultType& result) __attribute__ ((warn_unused_result))
    {
        if (signsMatch(lhs, rhs)) {
            if (lhs >= 0) {
                if ((std::numeric_limits<ResultType>::max() - rhs) < lhs)
                    return false;
            } else {
                ResultType temp = lhs - std::numeric_limits<ResultType>::min();
                if (rhs < -temp)
                    return false;
            }
        }
        result = lhs + rhs;
        return true;
    }

    static inline bool sub(LHS lhs, RHS rhs, ResultType& result) __attribute__ ((warn_unused_result))
    {
        if (!signsMatch(lhs, rhs)) {
            if (lhs >= 0) {
                if (lhs > std::numeric_limits<ResultType>::max() + rhs)
                    return false;
            } else {
                if (rhs > std::numeric_limits<ResultType>::max() + lhs)
                    return false;
            }
        }
        result = lhs - rhs;
        return true;
    }

    static inline bool multiply(LHS lhs, RHS rhs, ResultType& result) __attribute__ ((warn_unused_result))
    {
        if (signsMatch(lhs, rhs)) {
            if (lhs >= 0) {
                if (lhs && (std::numeric_limits<ResultType>::max() / lhs) < rhs)
                    return false;
            } else {
                if (lhs == std::numeric_limits<ResultType>::min() || rhs == std::numeric_limits<ResultType>::min())
                    return false;
                if ((std::numeric_limits<ResultType>::max() / -lhs) < -rhs)
                    return false;
            }
        } else {
            if (lhs < 0) {
                if (rhs && lhs < (std::numeric_limits<ResultType>::min() / rhs))
                    return false;
            } else {
                if (lhs && rhs < (std::numeric_limits<ResultType>::min() / lhs))
                    return false;
            }
        }
        result = lhs * rhs;
        return true;
    }

    static inline bool equals(LHS lhs, RHS rhs) { return lhs == rhs; }

};

template <typename LHS, typename RHS, typename ResultType> struct ArithmeticOperations<LHS, RHS, ResultType, false, false> {

    static inline bool add(LHS lhs, RHS rhs, ResultType& result) __attribute__ ((warn_unused_result))
    {
        ResultType temp = lhs + rhs;
        if (temp < lhs)
            return false;
        result = temp;
        return true;
    }

    static inline bool sub(LHS lhs, RHS rhs, ResultType& result) __attribute__ ((warn_unused_result))
    {
        ResultType temp = lhs - rhs;
        if (temp > lhs)
            return false;
        result = temp;
        return true;
    }

    static inline bool multiply(LHS lhs, RHS rhs, ResultType& result) __attribute__ ((warn_unused_result))
    {
        ResultType temp = lhs * rhs;
        if (temp < lhs)
            return false;
        result = temp;
        return true;
    }

    static inline bool equals(LHS lhs, RHS rhs) { return lhs == rhs; }

};

template <typename ResultType> struct ArithmeticOperations<int, unsigned, ResultType, true, false> {
    static inline bool add(int64_t lhs, int64_t rhs, ResultType& result)
    {
        int64_t temp = lhs + rhs;
        if (temp < std::numeric_limits<ResultType>::min())
            return false;
        if (temp > std::numeric_limits<ResultType>::max())
            return false;
        result = static_cast<ResultType>(temp);
        return true;
    }

    static inline bool sub(int64_t lhs, int64_t rhs, ResultType& result)
    {
        int64_t temp = lhs - rhs;
        if (temp < std::numeric_limits<ResultType>::min())
            return false;
        if (temp > std::numeric_limits<ResultType>::max())
            return false;
        result = static_cast<ResultType>(temp);
        return true;
    }

    static inline bool multiply(int64_t lhs, int64_t rhs, ResultType& result)
    {
        int64_t temp = lhs * rhs;
        if (temp < std::numeric_limits<ResultType>::min())
            return false;
        if (temp > std::numeric_limits<ResultType>::max())
            return false;
        result = static_cast<ResultType>(temp);
        return true;
    }

    static inline bool equals(int lhs, unsigned rhs)
    {
        return static_cast<int64_t>(lhs) == static_cast<int64_t>(rhs);
    }
};

template <typename ResultType> struct ArithmeticOperations<unsigned, int, ResultType, false, true> {
    static inline bool add(int64_t lhs, int64_t rhs, ResultType& result)
    {
        return ArithmeticOperations<int, unsigned, ResultType>::add(rhs, lhs, result);
    }

    static inline bool sub(int64_t lhs, int64_t rhs, ResultType& result)
    {
        return ArithmeticOperations<int, unsigned, ResultType>::sub(lhs, rhs, result);
    }

    static inline bool multiply(int64_t lhs, int64_t rhs, ResultType& result)
    {
        return ArithmeticOperations<int, unsigned, ResultType>::multiply(rhs, lhs, result);
    }

    static inline bool equals(unsigned lhs, int rhs)
    {
        return ArithmeticOperations<int, unsigned, ResultType>::equals(rhs, lhs);
    }
};

template <typename U, typename V, typename R> static inline bool safeAdd(U lhs, V rhs, R& result)
{
    return ArithmeticOperations<U, V, R>::add(lhs, rhs, result);
}

template <typename U, typename V, typename R> static inline bool safeSub(U lhs, V rhs, R& result)
{
    return ArithmeticOperations<U, V, R>::sub(lhs, rhs, result);
}

template <typename U, typename V, typename R> static inline bool safeMultiply(U lhs, V rhs, R& result)
{
    return ArithmeticOperations<U, V, R>::multiply(lhs, rhs, result);
}

template <typename U, typename V> static inline bool safeEquals(U lhs, V rhs)
{
    return ArithmeticOperations<U, V>::equals(lhs, rhs);
}

enum ResultOverflowedTag { ResultOverflowed };


static inline bool workAroundClangBug() { return true; }

template <typename T, class OverflowHandler> class Checked : public OverflowHandler {
public:
    template <typename _T, class _OverflowHandler> friend class Checked;
    Checked()
        : m_value(0)
    {
    }

    Checked(ResultOverflowedTag)
        : m_value(0)
    {

        if (workAroundClangBug())
            this->overflowed();
    }

    template <typename U> Checked(U value)
    {
        if (!isInBounds<T>(value))
            this->overflowed();
        m_value = static_cast<T>(value);
    }

    template <typename V> Checked(const Checked<T, V>& rhs)
        : m_value(rhs.m_value)
    {
        if (rhs.hasOverflowed())
            this->overflowed();
    }

    template <typename U> Checked(const Checked<U, OverflowHandler>& rhs)
        : OverflowHandler(rhs)
    {
        if (!isInBounds<T>(rhs.m_value))
            this->overflowed();
        m_value = static_cast<T>(rhs.m_value);
    }

    template <typename U, typename V> Checked(const Checked<U, V>& rhs)
    {
        if (rhs.hasOverflowed())
            this->overflowed();
        if (!isInBounds<T>(rhs.m_value))
            this->overflowed();
        m_value = static_cast<T>(rhs.m_value);
    }

    const Checked& operator=(Checked rhs)
    {
        this->clearOverflow();
        if (rhs.hasOverflowed())
            this->overflowed();
        m_value = static_cast<T>(rhs.m_value);
        return *this;
    }

    template <typename U> const Checked& operator=(U value)
    {
        return *this = Checked(value);
    }

    template <typename U, typename V> const Checked& operator=(const Checked<U, V>& rhs)
    {
        return *this = Checked(rhs);
    }


    const Checked& operator++()
    {
        if (m_value == std::numeric_limits<T>::max())
            this->overflowed();
        m_value++;
        return *this;
    }

    const Checked& operator--()
    {
        if (m_value == std::numeric_limits<T>::min())
            this->overflowed();
        m_value--;
        return *this;
    }


    const Checked operator++(int)
    {
        if (m_value == std::numeric_limits<T>::max())
            this->overflowed();
        return Checked(m_value++);
    }

    const Checked operator--(int)
    {
        if (m_value == std::numeric_limits<T>::min())
            this->overflowed();
        return Checked(m_value--);
    }


    bool operator!() const
    {
        if (this->hasOverflowed())
            do { WTFReportBacktrace(); *(int *)(uintptr_t)0xbbadbeef = 0; __builtin_trap(); } while (false);
        return !m_value;
    }

    typedef void* (Checked::*UnspecifiedBoolType);
    operator UnspecifiedBoolType*() const
    {
        if (this->hasOverflowed())
            do { WTFReportBacktrace(); *(int *)(uintptr_t)0xbbadbeef = 0; __builtin_trap(); } while (false);
        return (m_value) ? reinterpret_cast<UnspecifiedBoolType*>(1) : 0;
    }


    T unsafeGet() const
    {
        if (this->hasOverflowed())
            do { WTFReportBacktrace(); *(int *)(uintptr_t)0xbbadbeef = 0; __builtin_trap(); } while (false);
        return m_value;
    }

    bool safeGet(T& value) const __attribute__ ((warn_unused_result))
    {
        value = m_value;
        return this->hasOverflowed();
    }


    template <typename U> const Checked operator+=(U rhs)
    {
        if (!safeAdd(m_value, rhs, m_value))
            this->overflowed();
        return *this;
    }

    template <typename U> const Checked operator-=(U rhs)
    {
        if (!safeSub(m_value, rhs, m_value))
            this->overflowed();
        return *this;
    }

    template <typename U> const Checked operator*=(U rhs)
    {
        if (!safeMultiply(m_value, rhs, m_value))
            this->overflowed();
        return *this;
    }

    template <typename U, typename V> const Checked operator+=(Checked<U, V> rhs)
    {
        if (rhs.hasOverflowed())
            this->overflowed();
        return *this += rhs.m_value;
    }

    template <typename U, typename V> const Checked operator-=(Checked<U, V> rhs)
    {
        if (rhs.hasOverflowed())
            this->overflowed();
        return *this -= rhs.m_value;
    }

    template <typename U, typename V> const Checked operator*=(Checked<U, V> rhs)
    {
        if (rhs.hasOverflowed())
            this->overflowed();
        return *this *= rhs.m_value;
    }


    template <typename V> bool operator==(Checked<T, V> rhs)
    {
        return unsafeGet() == rhs.unsafeGet();
    }

    template <typename U> bool operator==(U rhs)
    {
        if (this->hasOverflowed())
            this->overflowed();
        return safeEquals(m_value, rhs);
    }

    template <typename U, typename V> const Checked operator==(Checked<U, V> rhs)
    {
        return unsafeGet() == Checked(rhs.unsafeGet());
    }

    template <typename U> bool operator!=(U rhs)
    {
        return !(*this == rhs);
    }

private:

    Checked(float);
    Checked(double);
    void operator=(float);
    void operator=(double);
    void operator+=(float);
    void operator+=(double);
    void operator-=(float);
    void operator-=(double);
    T m_value;
};

template <typename U, typename V, typename OverflowHandler> static inline Checked<typename Result<U, V>::ResultType, OverflowHandler> operator+(Checked<U, OverflowHandler> lhs, Checked<V, OverflowHandler> rhs)
{
    U x = 0;
    V y = 0;
    bool overflowed = lhs.safeGet(x) || rhs.safeGet(y);
    typename Result<U, V>::ResultType result = 0;
    overflowed |= !safeAdd(x, y, result);
    if (overflowed)
        return ResultOverflowed;
    return result;
}

template <typename U, typename V, typename OverflowHandler> static inline Checked<typename Result<U, V>::ResultType, OverflowHandler> operator-(Checked<U, OverflowHandler> lhs, Checked<V, OverflowHandler> rhs)
{
    U x = 0;
    V y = 0;
    bool overflowed = lhs.safeGet(x) || rhs.safeGet(y);
    typename Result<U, V>::ResultType result = 0;
    overflowed |= !safeSub(x, y, result);
    if (overflowed)
        return ResultOverflowed;
    return result;
}

template <typename U, typename V, typename OverflowHandler> static inline Checked<typename Result<U, V>::ResultType, OverflowHandler> operator*(Checked<U, OverflowHandler> lhs, Checked<V, OverflowHandler> rhs)
{
    U x = 0;
    V y = 0;
    bool overflowed = lhs.safeGet(x) || rhs.safeGet(y);
    typename Result<U, V>::ResultType result = 0;
    overflowed |= !safeMultiply(x, y, result);
    if (overflowed)
        return ResultOverflowed;
    return result;
}

template <typename U, typename V, typename OverflowHandler> static inline Checked<typename Result<U, V>::ResultType, OverflowHandler> operator+(Checked<U, OverflowHandler> lhs, V rhs)
{
    return lhs + Checked<V, OverflowHandler>(rhs);
}

template <typename U, typename V, typename OverflowHandler> static inline Checked<typename Result<U, V>::ResultType, OverflowHandler> operator-(Checked<U, OverflowHandler> lhs, V rhs)
{
    return lhs - Checked<V, OverflowHandler>(rhs);
}

template <typename U, typename V, typename OverflowHandler> static inline Checked<typename Result<U, V>::ResultType, OverflowHandler> operator*(Checked<U, OverflowHandler> lhs, V rhs)
{
    return lhs * Checked<V, OverflowHandler>(rhs);
}

template <typename U, typename V, typename OverflowHandler> static inline Checked<typename Result<U, V>::ResultType, OverflowHandler> operator+(U lhs, Checked<V, OverflowHandler> rhs)
{
    return Checked<U, OverflowHandler>(lhs) + rhs;
}

template <typename U, typename V, typename OverflowHandler> static inline Checked<typename Result<U, V>::ResultType, OverflowHandler> operator-(U lhs, Checked<V, OverflowHandler> rhs)
{
    return Checked<U, OverflowHandler>(lhs) - rhs;
}

template <typename U, typename V, typename OverflowHandler> static inline Checked<typename Result<U, V>::ResultType, OverflowHandler> operator*(U lhs, Checked<V, OverflowHandler> rhs)
{
    return Checked<U, OverflowHandler>(lhs) * rhs;
}

}

using WTF::Checked;
using WTF::RecordOverflow;
# 30 "./wtf/StdLibExtras.h" 2
# 108 "./wtf/StdLibExtras.h"
namespace WTF {




template<typename TO, typename FROM>
inline TO bitwise_cast(FROM from)
{
    typedef int dummyWTF_bitwise_cast_sizeof_casted_types_is_equal [(sizeof(TO) == sizeof(FROM)) ? 1 : -1];
    union {
        FROM from;
        TO to;
    } u;
    u.from = from;
    return u.to;
}

template<typename To, typename From>
inline To safeCast(From value)
{
    ((void)0);
    return static_cast<To>(value);
}


inline size_t bitCount(unsigned bits)
{
    bits = bits - ((bits >> 1) & 0x55555555);
    bits = (bits & 0x33333333) + ((bits >> 2) & 0x33333333);
    return (((bits + (bits >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24;
}


template<typename T, size_t Size> char (&ArrayLengthHelperFunction(T (&)[Size]))[Size];



template<size_t divisor> inline size_t roundUpToMultipleOf(size_t x)
{
    typedef int dummydivisor_is_a_power_of_two [(divisor && !(divisor & (divisor - 1))) ? 1 : -1];

    size_t remainderMask = divisor - 1;
    return (x + remainderMask) & ~remainderMask;
}

enum BinarySearchMode {
    KeyMustBePresentInArray,
    KeyMustNotBePresentInArray
};



template<typename ArrayElementType, typename KeyType, KeyType(*extractKey)(ArrayElementType*)>
inline ArrayElementType* binarySearch(ArrayElementType* array, size_t size, KeyType key, BinarySearchMode mode = KeyMustBePresentInArray)
{


    while (size > 1) {

        int pos = (size - 1) >> 1;
        KeyType val = extractKey(&array[pos]);


        if (val == key)
            return &array[pos];


        else if (key < val)
            size = pos;

        else {
            size -= (pos + 1);
            array += (pos + 1);
        }


        if (mode == KeyMustBePresentInArray)
            ((void)0);
    }



    if (mode == KeyMustBePresentInArray) {
        ((void)0);
        ((void)0);
    }

    return &array[0];
}




template<typename ArrayElementType, typename KeyType, typename ExtractKey>
inline ArrayElementType* binarySearchWithFunctor(ArrayElementType* array, size_t size, KeyType key, BinarySearchMode mode = KeyMustBePresentInArray, const ExtractKey& extractKey = ExtractKey())
{


    while (size > 1) {

        int pos = (size - 1) >> 1;
        KeyType val = extractKey(&array[pos]);


        if (val == key)
            return &array[pos];


        else if (key < val)
            size = pos;

        else {
            size -= (pos + 1);
            array += (pos + 1);
        }


        if (mode == KeyMustBePresentInArray)
            ((void)0);
    }



    if (mode == KeyMustBePresentInArray) {
        ((void)0);
        ((void)0);
    }

    return &array[0];
}




template<typename ArrayElementType, typename KeyType, KeyType(*extractKey)(ArrayElementType*), typename ArrayType>
inline ArrayElementType* genericBinarySearch(ArrayType& array, size_t size, KeyType key)
{


    size_t offset = 0;
    while (size > 1) {

        int pos = (size - 1) >> 1;
        KeyType val = extractKey(&array[offset + pos]);


        if (val == key)
            return &array[offset + pos];


        if (key < val)
            size = pos;

        else {
            size -= (pos + 1);
            offset += (pos + 1);
        }


        ((void)0);
    }


    ((void)0);
    ((void)0);
    return &array[offset];
}

}

using WTF::binarySearch;
using WTF::bitwise_cast;
using WTF::safeCast;
# 36 "./wtf/MathExtras.h" 2
# 57 "./wtf/MathExtras.h"
const double piDouble = 3.14159265358979323846264338327950288;
const float piFloat = static_cast<float>(3.14159265358979323846264338327950288);






const double piOverTwoDouble = 1.57079632679489661923132169163975144;
const float piOverTwoFloat = static_cast<float>(1.57079632679489661923132169163975144);






const double piOverFourDouble = 0.785398163397448309615660845819875721;
const float piOverFourFloat = static_cast<float>(0.785398163397448309615660845819875721);





inline double wtf_ceil(double x) { return copysign(ceil(x), x); }
# 200 "./wtf/MathExtras.h"
inline double deg2rad(double d) { return d * piDouble / 180.0; }
inline double rad2deg(double r) { return r * 180.0 / piDouble; }
inline double deg2grad(double d) { return d * 400.0 / 360.0; }
inline double grad2deg(double g) { return g * 360.0 / 400.0; }
inline double turn2deg(double t) { return t * 360.0; }
inline double deg2turn(double d) { return d / 360.0; }
inline double rad2grad(double r) { return r * 200.0 / piDouble; }
inline double grad2rad(double g) { return g * piDouble / 200.0; }

inline float deg2rad(float d) { return d * piFloat / 180.0f; }
inline float rad2deg(float r) { return r * 180.0f / piFloat; }
inline float deg2grad(float d) { return d * 400.0f / 360.0f; }
inline float grad2deg(float g) { return g * 360.0f / 400.0f; }
inline float turn2deg(float t) { return t * 360.0f; }
inline float deg2turn(float d) { return d / 360.0f; }
inline float rad2grad(float r) { return r * 200.0f / piFloat; }
inline float grad2rad(float g) { return g * piFloat / 200.0f; }


template<typename T> inline T defaultMinimumForClamp() { return std::numeric_limits<T>::min(); }
template<> inline float defaultMinimumForClamp() { return -std::numeric_limits<float>::max(); }
template<> inline double defaultMinimumForClamp() { return -std::numeric_limits<double>::max(); }
template<typename T> inline T defaultMaximumForClamp() { return std::numeric_limits<T>::max(); }

template<typename T> inline T clampTo(double value, T min = defaultMinimumForClamp<T>(), T max = defaultMaximumForClamp<T>())
{
    if (value >= static_cast<double>(max))
        return max;
    if (value <= static_cast<double>(min))
        return min;
    return static_cast<T>(value);
}
template<> inline long long int clampTo(double, long long int, long long int);

inline int clampToInteger(double value)
{
    return clampTo<int>(value);
}

inline float clampToFloat(double value)
{
    return clampTo<float>(value);
}

inline int clampToPositiveInteger(double value)
{
    return clampTo<int>(value, 0);
}

inline int clampToInteger(float value)
{
    return clampTo<int>(value);
}

inline int clampToInteger(unsigned x)
{
    const unsigned intMax = static_cast<unsigned>(std::numeric_limits<int>::max());

    if (x >= intMax)
        return std::numeric_limits<int>::max();
    return static_cast<int>(x);
}

inline bool isWithinIntRange(float x)
{
    return x > static_cast<float>(std::numeric_limits<int>::min()) && x < static_cast<float>(std::numeric_limits<int>::max());
}


using std::isfinite;
using std::isinf;
using std::isnan;
using std::signbit;





inline void decomposeDouble(double number, bool& sign, int32_t& exponent, uint64_t& mantissa)
{
    ((void)0);

    sign = signbit(number);

    uint64_t bits = WTF::bitwise_cast<uint64_t>(number);
    exponent = (static_cast<int32_t>(bits >> 52) & 0x7ff) - 0x3ff;
    mantissa = bits & 0xFFFFFFFFFFFFFull;



    if (exponent == -0x3ff)
        exponent = mantissa ? -0x3fe : 0;
    else
        mantissa |= 0x10000000000000ull;
}
# 34 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSValue.h" 2


namespace JSC {

    class ExecState;
    class Identifier;
    class JSCell;
    class JSGlobalData;
    class JSGlobalObject;
    class JSObject;
    class JSString;
    class PropertySlot;
    class PutPropertySlot;
    class UString;

    namespace DFG {
        class JITCompiler;
        class JITCodeGenerator;
        class SpeculativeJIT;
    }


    struct ClassInfo;
    struct Instruction;
    struct MethodTable;

    template <class T> class WriteBarrierBase;

    enum PreferredPrimitiveType { NoPreference, PreferNumber, PreferString };





    typedef void* EncodedJSValue;


    union EncodedValueDescriptor {
        int64_t asInt64;



        JSCell* ptr;
# 85 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSValue.h"
        struct {
            int32_t payload;
            int32_t tag;
        } asBits;

    };


    int32_t toInt32(double);


    inline uint32_t toUInt32(double number)
    {


        return toInt32(number);
    }

    class JSValue {
        friend struct EncodedJSValueHashTraits;
        friend class JIT;
        friend class JITStubs;
        friend class JITStubCall;
        friend class JSInterfaceJIT;
        friend class SpecializedThunkJIT;

        friend class DFG::JITCompiler;
        friend class DFG::JITCodeGenerator;
        friend class DFG::SpeculativeJIT;


    public:
        static EncodedJSValue encode(JSValue);
        static JSValue decode(EncodedJSValue);

        enum JSNullTag { JSNull };
        enum JSUndefinedTag { JSUndefined };
        enum JSTrueTag { JSTrue };
        enum JSFalseTag { JSFalse };
        enum EncodeAsDoubleTag { EncodeAsDouble };

        JSValue();
        JSValue(JSNullTag);
        JSValue(JSUndefinedTag);
        JSValue(JSTrueTag);
        JSValue(JSFalseTag);
        JSValue(JSCell* ptr);
        JSValue(const JSCell* ptr);


        JSValue(EncodeAsDoubleTag, double);
        explicit JSValue(double);
        explicit JSValue(char);
        explicit JSValue(unsigned char);
        explicit JSValue(short);
        explicit JSValue(unsigned short);
        explicit JSValue(int);
        explicit JSValue(unsigned);
        explicit JSValue(long);
        explicit JSValue(unsigned long);
        explicit JSValue(long long);
        explicit JSValue(unsigned long long);

        operator bool() const;
        bool operator==(const JSValue& other) const;
        bool operator!=(const JSValue& other) const;

        bool isInt32() const;
        bool isUInt32() const;
        bool isDouble() const;
        bool isTrue() const;
        bool isFalse() const;

        int32_t asInt32() const;
        uint32_t asUInt32() const;
        double asDouble() const;
        bool asBoolean() const;
        double asNumber() const;


        bool isUndefined() const;
        bool isNull() const;
        bool isUndefinedOrNull() const;
        bool isBoolean() const;
        bool isNumber() const;
        bool isString() const;
        bool isPrimitive() const;
        bool isGetterSetter() const;
        bool isObject() const;
        bool inherits(const ClassInfo*) const;


        bool getString(ExecState* exec, UString&) const;
        UString getString(ExecState* exec) const;
        JSObject* getObject() const;


        bool getUInt32(uint32_t&) const;


        JSValue toPrimitive(ExecState*, PreferredPrimitiveType = NoPreference) const;
        bool getPrimitiveNumber(ExecState*, double& number, JSValue&);

        bool toBoolean(ExecState*) const;



        double toNumber(ExecState*) const;
        UString toString(ExecState*) const;
        JSString* toPrimitiveString(ExecState*) const;
        JSObject* toObject(ExecState*) const;
        JSObject* toObject(ExecState*, JSGlobalObject*) const;


        double toInteger(ExecState*) const;
        double toIntegerPreserveNaN(ExecState*) const;
        int32_t toInt32(ExecState*) const;
        uint32_t toUInt32(ExecState*) const;



        float toFloat(ExecState* exec) const { return static_cast<float>(toNumber(exec)); }


        JSValue get(ExecState*, const Identifier& propertyName) const;
        JSValue get(ExecState*, const Identifier& propertyName, PropertySlot&) const;
        JSValue get(ExecState*, unsigned propertyName) const;
        JSValue get(ExecState*, unsigned propertyName, PropertySlot&) const;
        void put(ExecState*, const Identifier& propertyName, JSValue, PutPropertySlot&);
        void putDirect(ExecState*, const Identifier& propertyName, JSValue, PutPropertySlot&);
        void put(ExecState*, unsigned propertyName, JSValue);

        JSObject* toThisObject(ExecState*) const;

        static bool equal(ExecState* exec, JSValue v1, JSValue v2);
        static bool equalSlowCase(ExecState* exec, JSValue v1, JSValue v2);
        static bool equalSlowCaseInline(ExecState* exec, JSValue v1, JSValue v2);
        static bool strictEqual(ExecState* exec, JSValue v1, JSValue v2);
        static bool strictEqualSlowCase(ExecState* exec, JSValue v1, JSValue v2);
        static bool strictEqualSlowCaseInline(ExecState* exec, JSValue v1, JSValue v2);

        bool isCell() const;
        JSCell* asCell() const;
        bool isValidCallee();





    private:
        template <class T> JSValue(WriteBarrierBase<T>);

        enum HashTableDeletedValueTag { HashTableDeletedValue };
        JSValue(HashTableDeletedValueTag);

        inline const JSValue asValue() const { return *this; }
        double toNumberSlowCase(ExecState*) const;
        JSObject* toObjectSlowCase(ExecState*, JSGlobalObject*) const;
        JSObject* toThisObjectSlowCase(ExecState*) const;

        JSObject* synthesizePrototype(ExecState*) const;
        JSObject* synthesizeObject(ExecState*) const;
# 362 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSValue.h"
        EncodedValueDescriptor u;
    };
# 375 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSValue.h"
    typedef PtrHash<EncodedJSValue> EncodedJSValueHash;

    struct EncodedJSValueHashTraits : HashTraits<EncodedJSValue> {
        static void constructDeletedValue(EncodedJSValue& slot) { slot = JSValue::encode(JSValue(JSValue::HashTableDeletedValue)); }
        static bool isDeletedValue(EncodedJSValue value) { return value == JSValue::encode(JSValue(JSValue::HashTableDeletedValue)); }
    };


    typedef HashMap<EncodedJSValue, unsigned, EncodedJSValueHash, EncodedJSValueHashTraits> JSValueMap;


    inline JSValue jsNull()
    {
        return JSValue(JSValue::JSNull);
    }

    inline JSValue jsUndefined()
    {
        return JSValue(JSValue::JSUndefined);
    }

    inline JSValue jsBoolean(bool b)
    {
        return b ? JSValue(JSValue::JSTrue) : JSValue(JSValue::JSFalse);
    }

    inline __attribute__((__always_inline__)) JSValue jsDoubleNumber(double d)
    {
        ((void)0);
        return JSValue(JSValue::EncodeAsDouble, d);
    }

    inline __attribute__((__always_inline__)) JSValue jsNumber(double d)
    {
        ((void)0);
        return JSValue(d);
    }

    inline __attribute__((__always_inline__)) JSValue jsNumber(char i)
    {
        return JSValue(i);
    }

    inline __attribute__((__always_inline__)) JSValue jsNumber(unsigned char i)
    {
        return JSValue(i);
    }

    inline __attribute__((__always_inline__)) JSValue jsNumber(short i)
    {
        return JSValue(i);
    }

    inline __attribute__((__always_inline__)) JSValue jsNumber(unsigned short i)
    {
        return JSValue(i);
    }

    inline __attribute__((__always_inline__)) JSValue jsNumber(int i)
    {
        return JSValue(i);
    }

    inline __attribute__((__always_inline__)) JSValue jsNumber(unsigned i)
    {
        return JSValue(i);
    }

    inline __attribute__((__always_inline__)) JSValue jsNumber(long i)
    {
        return JSValue(i);
    }

    inline __attribute__((__always_inline__)) JSValue jsNumber(unsigned long i)
    {
        return JSValue(i);
    }

    inline __attribute__((__always_inline__)) JSValue jsNumber(long long i)
    {
        return JSValue(i);
    }

    inline __attribute__((__always_inline__)) JSValue jsNumber(unsigned long long i)
    {
        return JSValue(i);
    }

    inline bool operator==(const JSValue a, const JSCell* b) { return a == JSValue(b); }
    inline bool operator==(const JSCell* a, const JSValue b) { return JSValue(a) == b; }

    inline bool operator!=(const JSValue a, const JSCell* b) { return a != JSValue(b); }
    inline bool operator!=(const JSCell* a, const JSValue b) { return JSValue(a) != b; }

}
# 30 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/CachedTranscendentalFunction.h" 2

namespace JSC {

typedef double (*TranscendentalFunctionPtr)(double);




template<TranscendentalFunctionPtr orignalFunction>
class CachedTranscendentalFunction {
    struct CacheEntry {
        double operand;
        double result;
    };

public:
    CachedTranscendentalFunction()
        : m_cache(0)
    {
    }

    ~CachedTranscendentalFunction()
    {
        if (m_cache)
            fastFree(m_cache);
    }

    JSValue operator() (double operand)
    {
        if (__builtin_expect((!m_cache), 0))
            initialize();
        CacheEntry* entry = &m_cache[hash(operand)];

        if (entry->operand == operand)
            return jsDoubleNumber(entry->result);
        double result = orignalFunction(operand);
        entry->operand = operand;
        entry->result = result;
        return jsDoubleNumber(result);
    }

private:
    void initialize()
    {

        m_cache = static_cast<CacheEntry*>(fastMalloc(s_cacheSize * sizeof(CacheEntry)));
        for (unsigned x = 0; x < s_cacheSize; ++x) {
            m_cache[x].operand = std::numeric_limits<double>::quiet_NaN();
            m_cache[x].result = std::numeric_limits<double>::quiet_NaN();
        }
    }

    static unsigned hash(double d)
    {
        union doubleAndUInt64 {
            double d;
            uint32_t is[2];
        } u;
        u.d = d;

        unsigned x = u.is[0] ^ u.is[1];
        x = (x >> 20) ^ (x >> 8);
        return x & (s_cacheSize - 1);
    }

    static const unsigned s_cacheSize = 0x1000;
    CacheEntry* m_cache;
};

}
# 33 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSGlobalData.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/dfg/DFGIntrinsic.h" 1
# 29 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/dfg/DFGIntrinsic.h"
namespace JSC { namespace DFG {

enum Intrinsic {
    NoIntrinsic,
    AbsIntrinsic,
    MinIntrinsic,
    MaxIntrinsic,
    SqrtIntrinsic,
    ArrayPushIntrinsic,
    ArrayPopIntrinsic,
    CharCodeAtIntrinsic,
    CharAtIntrinsic
};

} }
# 34 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSGlobalData.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/DateInstanceCache.h" 1
# 29 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/DateInstanceCache.h"
# 1 "./wtf/DateMath.h" 1
# 50 "./wtf/DateMath.h"
# 1 "./wtf/CurrentTime.h" 1
# 37 "./wtf/CurrentTime.h"
namespace WTF {




double currentTime();


inline double currentTimeMS()
{
    return currentTime() * 1000.0;
}

inline void getLocalTime(const time_t* localTime, struct tm* localTM)
{





    localtime_r(localTime, localTM);

}



double monotonicallyIncreasingTime();

}

using WTF::currentTime;
using WTF::currentTimeMS;
using WTF::getLocalTime;
using WTF::monotonicallyIncreasingTime;
# 51 "./wtf/DateMath.h" 2

# 1 "./wtf/OwnArrayPtr.h" 1
# 27 "./wtf/OwnArrayPtr.h"
# 1 "./wtf/PassOwnArrayPtr.h" 1
# 33 "./wtf/PassOwnArrayPtr.h"
namespace WTF {

template<typename T> class OwnArrayPtr;
template<typename T> class PassOwnArrayPtr;
template<typename T> PassOwnArrayPtr<T> adoptArrayPtr(T*);
template<typename T> void deleteOwnedArrayPtr(T* ptr);

template<typename T> class PassOwnArrayPtr {
public:
    typedef T* PtrType;

    PassOwnArrayPtr() : m_ptr(0) { }
    PassOwnArrayPtr(std::nullptr_t) : m_ptr(0) { }




    PassOwnArrayPtr(const PassOwnArrayPtr& o) : m_ptr(o.leakPtr()) { }
    template<typename U> PassOwnArrayPtr(const PassOwnArrayPtr<U>& o) : m_ptr(o.leakPtr()) { }

    ~PassOwnArrayPtr() { deleteOwnedArrayPtr(m_ptr); }

    PtrType get() const { return m_ptr; }

    PtrType leakPtr() const __attribute__ ((warn_unused_result));

    T& operator*() const { ((void)0); return *m_ptr; }
    PtrType operator->() const { ((void)0); return m_ptr; }

    bool operator!() const { return !m_ptr; }





    typedef PtrType PassOwnArrayPtr::*UnspecifiedBoolType;
    operator UnspecifiedBoolType() const { return m_ptr ? &PassOwnArrayPtr::m_ptr : 0; }


    PassOwnArrayPtr& operator=(const PassOwnArrayPtr&) { typedef int dummyPassOwnArrayPtr_should_never_be_assigned_to [(!sizeof(T*)) ? 1 : -1]; return *this; }

    template<typename U> friend PassOwnArrayPtr<U> adoptArrayPtr(U*);

private:
    explicit PassOwnArrayPtr(PtrType ptr) : m_ptr(ptr) { }

    mutable PtrType m_ptr;
};

template<typename T> inline typename PassOwnArrayPtr<T>::PtrType PassOwnArrayPtr<T>::leakPtr() const
{
    PtrType ptr = m_ptr;
    m_ptr = 0;
    return ptr;
}

template<typename T, typename U> inline bool operator==(const PassOwnArrayPtr<T>& a, const PassOwnArrayPtr<U>& b)
{
    return a.get() == b.get();
}

template<typename T, typename U> inline bool operator==(const PassOwnArrayPtr<T>& a, const OwnArrayPtr<U>& b)
{
    return a.get() == b.get();
}

template<typename T, typename U> inline bool operator==(const OwnArrayPtr<T>& a, const PassOwnArrayPtr<U>& b)
{
    return a.get() == b.get();
}

template<typename T, typename U> inline bool operator==(const PassOwnArrayPtr<T>& a, U* b)
{
    return a.get() == b;
}

template<typename T, typename U> inline bool operator==(T* a, const PassOwnArrayPtr<U>& b)
{
    return a == b.get();
}

template<typename T, typename U> inline bool operator!=(const PassOwnArrayPtr<T>& a, const PassOwnArrayPtr<U>& b)
{
    return a.get() != b.get();
}

template<typename T, typename U> inline bool operator!=(const PassOwnArrayPtr<T>& a, const OwnArrayPtr<U>& b)
{
    return a.get() != b.get();
}

template<typename T, typename U> inline bool operator!=(const OwnArrayPtr<T>& a, const PassOwnArrayPtr<U>& b)
{
    return a.get() != b.get();
}

template<typename T, typename U> inline bool operator!=(const PassOwnArrayPtr<T>& a, U* b)
{
    return a.get() != b;
}

template<typename T, typename U> inline bool operator!=(T* a, const PassOwnArrayPtr<U>& b)
{
    return a != b.get();
}

template<typename T> inline PassOwnArrayPtr<T> adoptArrayPtr(T* ptr)
{
    return PassOwnArrayPtr<T>(ptr);
}

template<typename T> inline void deleteOwnedArrayPtr(T* ptr)
{
    typedef char known[sizeof(T) ? 1 : -1];
    if (sizeof(known))
        delete [] ptr;
}

template<typename T, typename U> inline PassOwnArrayPtr<T> static_pointer_cast(const PassOwnArrayPtr<U>& p)
{
    return adoptArrayPtr(static_cast<T*>(p.leakPtr()));
}

template<typename T, typename U> inline PassOwnArrayPtr<T> const_pointer_cast(const PassOwnArrayPtr<U>& p)
{
    return adoptArrayPtr(const_cast<T*>(p.leakPtr()));
}

template<typename T> inline T* getPtr(const PassOwnArrayPtr<T>& p)
{
    return p.get();
}

}

using WTF::PassOwnArrayPtr;
using WTF::adoptArrayPtr;
using WTF::const_pointer_cast;
using WTF::static_pointer_cast;
# 28 "./wtf/OwnArrayPtr.h" 2


namespace WTF {

template<typename T> class PassOwnArrayPtr;
template<typename T> PassOwnArrayPtr<T> adoptArrayPtr(T*);

template <typename T> class OwnArrayPtr {
public:
    typedef T* PtrType;

    OwnArrayPtr() : m_ptr(0) { }


    template<typename U> OwnArrayPtr(const PassOwnArrayPtr<U>& o);





    OwnArrayPtr(const OwnArrayPtr<T>&);

    ~OwnArrayPtr() { deleteOwnedArrayPtr(m_ptr); }

    PtrType get() const { return m_ptr; }

    void clear();
    PassOwnArrayPtr<T> release();
    PtrType leakPtr() __attribute__ ((warn_unused_result));

    T& operator*() const { ((void)0); return *m_ptr; }
    PtrType operator->() const { ((void)0); return m_ptr; }

    T& operator[](std::ptrdiff_t i) const { ((void)0); ((void)0); return m_ptr[i]; }

    bool operator!() const { return !m_ptr; }





    typedef T* OwnArrayPtr::*UnspecifiedBoolType;
    operator UnspecifiedBoolType() const { return m_ptr ? &OwnArrayPtr::m_ptr : 0; }


    OwnArrayPtr& operator=(const PassOwnArrayPtr<T>&);
    OwnArrayPtr& operator=(std::nullptr_t) { clear(); return *this; }
    template<typename U> OwnArrayPtr& operator=(const PassOwnArrayPtr<U>&);

    void swap(OwnArrayPtr& o) { std::swap(m_ptr, o.m_ptr); }

private:
    PtrType m_ptr;
};

template<typename T> template<typename U> inline OwnArrayPtr<T>::OwnArrayPtr(const PassOwnArrayPtr<U>& o)
    : m_ptr(o.leakPtr())
{
}

template<typename T> inline void OwnArrayPtr<T>::clear()
{
    PtrType ptr = m_ptr;
    m_ptr = 0;
    deleteOwnedArrayPtr(ptr);
}

template<typename T> inline PassOwnArrayPtr<T> OwnArrayPtr<T>::release()
{
    PtrType ptr = m_ptr;
    m_ptr = 0;
    return adoptArrayPtr(ptr);
}

template<typename T> inline typename OwnArrayPtr<T>::PtrType OwnArrayPtr<T>::leakPtr()
{
    PtrType ptr = m_ptr;
    m_ptr = 0;
    return ptr;
}

template<typename T> inline OwnArrayPtr<T>& OwnArrayPtr<T>::operator=(const PassOwnArrayPtr<T>& o)
{
    PtrType ptr = m_ptr;
    m_ptr = o.leakPtr();
    ((void)0);
    deleteOwnedArrayPtr(ptr);
    return *this;
}

template<typename T> template<typename U> inline OwnArrayPtr<T>& OwnArrayPtr<T>::operator=(const PassOwnArrayPtr<U>& o)
{
    PtrType ptr = m_ptr;
    m_ptr = o.leakPtr();
    ((void)0);
    deleteOwnedArrayPtr(ptr);
    return *this;
}

template <typename T> inline void swap(OwnArrayPtr<T>& a, OwnArrayPtr<T>& b)
{
    a.swap(b);
}

template<typename T, typename U> inline bool operator==(const OwnArrayPtr<T>& a, U* b)
{
    return a.get() == b;
}

template<typename T, typename U> inline bool operator==(T* a, const OwnArrayPtr<U>& b)
{
    return a == b.get();
}

template<typename T, typename U> inline bool operator!=(const OwnArrayPtr<T>& a, U* b)
{
    return a.get() != b;
}

template<typename T, typename U> inline bool operator!=(T* a, const OwnArrayPtr<U>& b)
{
    return a != b.get();
}

template <typename T> inline T* getPtr(const OwnArrayPtr<T>& p)
{
    return p.get();
}

}

using WTF::OwnArrayPtr;
# 53 "./wtf/DateMath.h" 2

# 1 "./wtf/text/WTFString.h" 1
# 28 "./wtf/text/WTFString.h"
# 1 "./wtf/text/StringImpl.h" 1
# 27 "./wtf/text/StringImpl.h"
# 1 "./wtf/ASCIICType.h" 1
# 44 "./wtf/ASCIICType.h"
namespace WTF {

    inline bool isASCII(char c) { return !(c & ~0x7F); }
    inline bool isASCII(unsigned short c) { return !(c & ~0x7F); }

    inline bool isASCII(wchar_t c) { return !(c & ~0x7F); }

    inline bool isASCII(int c) { return !(c & ~0x7F); }
    inline bool isASCII(unsigned c) { return !(c & ~0x7F); }

    inline bool isASCIIAlpha(char c) { return (c | 0x20) >= 'a' && (c | 0x20) <= 'z'; }
    inline bool isASCIIAlpha(unsigned short c) { return (c | 0x20) >= 'a' && (c | 0x20) <= 'z'; }

    inline bool isASCIIAlpha(wchar_t c) { return (c | 0x20) >= 'a' && (c | 0x20) <= 'z'; }

    inline bool isASCIIAlpha(int c) { return (c | 0x20) >= 'a' && (c | 0x20) <= 'z'; }
    inline bool isASCIIAlpha(unsigned c) { return (c | 0x20) >= 'a' && (c | 0x20) <= 'z'; }

    inline bool isASCIIAlphanumeric(char c) { return (c >= '0' && c <= '9') || ((c | 0x20) >= 'a' && (c | 0x20) <= 'z'); }
    inline bool isASCIIAlphanumeric(unsigned short c) { return (c >= '0' && c <= '9') || ((c | 0x20) >= 'a' && (c | 0x20) <= 'z'); }

    inline bool isASCIIAlphanumeric(wchar_t c) { return (c >= '0' && c <= '9') || ((c | 0x20) >= 'a' && (c | 0x20) <= 'z'); }

    inline bool isASCIIAlphanumeric(int c) { return (c >= '0' && c <= '9') || ((c | 0x20) >= 'a' && (c | 0x20) <= 'z'); }
    inline bool isASCIIAlphanumeric(unsigned c) { return (c >= '0' && c <= '9') || ((c | 0x20) >= 'a' && (c | 0x20) <= 'z'); }

    inline bool isASCIIDigit(char c) { return (c >= '0') & (c <= '9'); }
    inline bool isASCIIDigit(unsigned short c) { return (c >= '0') & (c <= '9'); }

    inline bool isASCIIDigit(wchar_t c) { return (c >= '0') & (c <= '9'); }

    inline bool isASCIIDigit(int c) { return (c >= '0') & (c <= '9'); }
    inline bool isASCIIDigit(unsigned c) { return (c >= '0') & (c <= '9'); }

    inline bool isASCIIHexDigit(char c) { return (c >= '0' && c <= '9') || ((c | 0x20) >= 'a' && (c | 0x20) <= 'f'); }
    inline bool isASCIIHexDigit(unsigned short c) { return (c >= '0' && c <= '9') || ((c | 0x20) >= 'a' && (c | 0x20) <= 'f'); }

    inline bool isASCIIHexDigit(wchar_t c) { return (c >= '0' && c <= '9') || ((c | 0x20) >= 'a' && (c | 0x20) <= 'f'); }

    inline bool isASCIIHexDigit(int c) { return (c >= '0' && c <= '9') || ((c | 0x20) >= 'a' && (c | 0x20) <= 'f'); }
    inline bool isASCIIHexDigit(unsigned c) { return (c >= '0' && c <= '9') || ((c | 0x20) >= 'a' && (c | 0x20) <= 'f'); }

    inline bool isASCIIOctalDigit(char c) { return (c >= '0') & (c <= '7'); }
    inline bool isASCIIOctalDigit(unsigned short c) { return (c >= '0') & (c <= '7'); }

    inline bool isASCIIOctalDigit(wchar_t c) { return (c >= '0') & (c <= '7'); }

    inline bool isASCIIOctalDigit(int c) { return (c >= '0') & (c <= '7'); }
    inline bool isASCIIOctalDigit(unsigned c) { return (c >= '0') & (c <= '7'); }

    inline bool isASCIILower(char c) { return c >= 'a' && c <= 'z'; }
    inline bool isASCIILower(unsigned short c) { return c >= 'a' && c <= 'z'; }

    inline bool isASCIILower(wchar_t c) { return c >= 'a' && c <= 'z'; }

    inline bool isASCIILower(int c) { return c >= 'a' && c <= 'z'; }
    inline bool isASCIILower(unsigned c) { return c >= 'a' && c <= 'z'; }

    inline bool isASCIIUpper(char c) { return c >= 'A' && c <= 'Z'; }
    inline bool isASCIIUpper(unsigned short c) { return c >= 'A' && c <= 'Z'; }

    inline bool isASCIIUpper(wchar_t c) { return c >= 'A' && c <= 'Z'; }

    inline bool isASCIIUpper(int c) { return c >= 'A' && c <= 'Z'; }
    inline bool isASCIIUpper(unsigned c) { return c >= 'A' && c <= 'Z'; }
# 123 "./wtf/ASCIICType.h"
    inline bool isASCIISpace(char c) { return c <= ' ' && (c == ' ' || (c <= 0xD && c >= 0x9)); }
    inline bool isASCIISpace(unsigned short c) { return c <= ' ' && (c == ' ' || (c <= 0xD && c >= 0x9)); }

    inline bool isASCIISpace(wchar_t c) { return c <= ' ' && (c == ' ' || (c <= 0xD && c >= 0x9)); }

    inline bool isASCIISpace(int c) { return c <= ' ' && (c == ' ' || (c <= 0xD && c >= 0x9)); }
    inline bool isASCIISpace(unsigned c) { return c <= ' ' && (c == ' ' || (c <= 0xD && c >= 0x9)); }

    inline char toASCIILower(char c) { return c | ((c >= 'A' && c <= 'Z') << 5); }
    inline unsigned short toASCIILower(unsigned short c) { return c | ((c >= 'A' && c <= 'Z') << 5); }

    inline wchar_t toASCIILower(wchar_t c) { return c | ((c >= 'A' && c <= 'Z') << 5); }

    inline int toASCIILower(int c) { return c | ((c >= 'A' && c <= 'Z') << 5); }
    inline unsigned toASCIILower(unsigned c) { return c | ((c >= 'A' && c <= 'Z') << 5); }


    inline char toASCIIUpper(char c) { return static_cast<char>(c & ~((c >= 'a' && c <= 'z') << 5)); }
    inline unsigned short toASCIIUpper(unsigned short c) { return static_cast<unsigned short>(c & ~((c >= 'a' && c <= 'z') << 5)); }

    inline wchar_t toASCIIUpper(wchar_t c) { return static_cast<wchar_t>(c & ~((c >= 'a' && c <= 'z') << 5)); }

    inline int toASCIIUpper(int c) { return static_cast<int>(c & ~((c >= 'a' && c <= 'z') << 5)); }
    inline unsigned toASCIIUpper(unsigned c) { return static_cast<unsigned>(c & ~((c >= 'a' && c <= 'z') << 5)); }

    inline int toASCIIHexValue(char c) { ((void)0); return c < 'A' ? c - '0' : (c - 'A' + 10) & 0xF; }
    inline int toASCIIHexValue(char upperValue, char lowerValue) { ((void)0); return ((toASCIIHexValue(upperValue) << 4) & 0xF0) | toASCIIHexValue(lowerValue); }
    inline int toASCIIHexValue(unsigned short c) { ((void)0); return c < 'A' ? c - '0' : (c - 'A' + 10) & 0xF; }

    inline int toASCIIHexValue(wchar_t c) { ((void)0); return c < 'A' ? c - '0' : (c - 'A' + 10) & 0xF; }

    inline int toASCIIHexValue(int c) { ((void)0); return c < 'A' ? c - '0' : (c - 'A' + 10) & 0xF; }
    inline int toASCIIHexValue(unsigned c) { ((void)0); return c < 'A' ? c - '0' : (c - 'A' + 10) & 0xF; }

    inline char lowerNibbleToASCIIHexDigit(char c) { char nibble = c & 0xF; return nibble < 10 ? '0' + nibble : 'A' + nibble - 10; }
    inline char upperNibbleToASCIIHexDigit(char c) { char nibble = (c >> 4) & 0xF; return nibble < 10 ? '0' + nibble : 'A' + nibble - 10; }

    inline bool isASCIIPrintable(char c) { return c >= ' ' && c <= '~'; }
    inline bool isASCIIPrintable(unsigned short c) { return c >= ' ' && c <= '~'; }

    inline bool isASCIIPrintable(wchar_t c) { return c >= ' ' && c <= '~'; }

    inline bool isASCIIPrintable(int c) { return c >= ' ' && c <= '~'; }
    inline bool isASCIIPrintable(unsigned c) { return c >= ' ' && c <= '~'; }
}

using WTF::isASCII;
using WTF::isASCIIAlpha;
using WTF::isASCIIAlphanumeric;
using WTF::isASCIIDigit;
using WTF::isASCIIHexDigit;
using WTF::isASCIILower;
using WTF::isASCIIOctalDigit;
using WTF::isASCIIPrintable;
using WTF::isASCIISpace;
using WTF::isASCIIUpper;
using WTF::toASCIIHexValue;
using WTF::toASCIILower;
using WTF::toASCIIUpper;
using WTF::lowerNibbleToASCIIHexDigit;
using WTF::upperNibbleToASCIIHexDigit;
# 28 "./wtf/text/StringImpl.h" 2
# 1 "./wtf/Forward.h" 1
# 24 "./wtf/Forward.h"
# 1 "/Users/ddunbar/rt/11003353/clang-r152231-t20120307_081803-b13838/Developer/usr/bin/../lib/clang/3.1/include/stddef.h" 1 3 4
# 25 "./wtf/Forward.h" 2

namespace WTF {
    template<typename T> class ListRefPtr;
    template<typename T> class OwnArrayPtr;
    template<typename T> class OwnPtr;
    template<typename T> class PassOwnArrayPtr;
    template<typename T> class PassOwnPtr;
    template<typename T> class PassRefPtr;
    template<typename T> class RefPtr;
    template<typename T, size_t inlineCapacity> class Vector;

    class AtomicString;
    class AtomicStringImpl;
    class CString;
    class Decoder;
    class Encoder;
    class String;
    class StringBuffer;
    class StringBuilder;
    class StringImpl;
}

using WTF::ListRefPtr;
using WTF::OwnArrayPtr;
using WTF::OwnPtr;
using WTF::PassOwnArrayPtr;
using WTF::PassOwnPtr;
using WTF::PassRefPtr;
using WTF::RefPtr;
using WTF::Vector;

using WTF::AtomicString;
using WTF::AtomicStringImpl;
using WTF::CString;
using WTF::Encoder;
using WTF::Decoder;
using WTF::String;
using WTF::StringBuffer;
using WTF::StringBuilder;
using WTF::StringImpl;
# 29 "./wtf/text/StringImpl.h" 2
# 1 "./wtf/OwnFastMallocPtr.h" 1
# 28 "./wtf/OwnFastMallocPtr.h"
namespace WTF {

    template<class T> class OwnFastMallocPtr {
        private: OwnFastMallocPtr(const OwnFastMallocPtr&); OwnFastMallocPtr& operator=(const OwnFastMallocPtr&);
    public:
        explicit OwnFastMallocPtr(T* ptr) : m_ptr(ptr)
        {
        }

        ~OwnFastMallocPtr()
        {
            fastFree(const_cast<void*>(static_cast<const void*>(const_cast<const T*>(m_ptr))));
        }

        T* get() const { return m_ptr; }
        T* release() { T* ptr = m_ptr; m_ptr = 0; return ptr; }

    private:
        T* m_ptr;
    };

}

using WTF::OwnFastMallocPtr;
# 30 "./wtf/text/StringImpl.h" 2

# 1 "./wtf/StringHasher.h" 1
# 24 "./wtf/StringHasher.h"
# 1 "./wtf/unicode/Unicode.h" 1
# 31 "./wtf/unicode/Unicode.h"
# 1 "./wtf/unicode/icu/UnicodeIcu.h" 1
# 27 "./wtf/unicode/icu/UnicodeIcu.h"
# 1 "icu/unicode/uchar.h" 1
# 26 "icu/unicode/uchar.h"
# 1 "icu/unicode/utypes.h" 1
# 36 "icu/unicode/utypes.h"
# 1 "icu/unicode/umachine.h" 1
# 47 "icu/unicode/umachine.h"
# 1 "icu/unicode/platform.h" 1
# 84 "icu/unicode/platform.h"
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/types.h" 1 3 4
# 84 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/types.h" 3 4
typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;

typedef unsigned long u_long;


typedef unsigned short ushort;
typedef unsigned int uint;


typedef u_int64_t u_quad_t;
typedef int64_t quad_t;
typedef quad_t * qaddr_t;

typedef char * caddr_t;
typedef int32_t daddr_t;






typedef u_int32_t fixpt_t;


typedef __darwin_blkcnt_t blkcnt_t;




typedef __darwin_blksize_t blksize_t;
# 126 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/types.h" 3 4
typedef __uint32_t in_addr_t;




typedef __uint16_t in_port_t;



typedef __darwin_ino_t ino_t;





typedef __darwin_ino64_t ino64_t;






typedef __int32_t key_t;
# 157 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/types.h" 3 4
typedef __uint16_t nlink_t;
# 176 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/types.h" 3 4
typedef int32_t segsz_t;
typedef int32_t swblk_t;
# 197 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/types.h" 3 4
static inline __int32_t major(__uint32_t _x)
{
 return (__int32_t)(((__uint32_t)_x >> 24) & 0xff);
}

static inline __int32_t minor(__uint32_t _x)
{
 return (__int32_t)((_x) & 0xffffff);
}

static inline dev_t makedev(__uint32_t _major, __uint32_t _minor)
{
 return (dev_t)(((_major) << 24) | (_minor));
}
# 260 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/types.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/_structs.h" 1 3 4
# 261 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/types.h" 2 3 4




typedef __int32_t fd_mask;
# 363 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/types.h" 3 4
typedef __darwin_fsblkcnt_t fsblkcnt_t;




typedef __darwin_fsfilcnt_t fsfilcnt_t;
# 85 "icu/unicode/platform.h" 2
# 48 "icu/unicode/umachine.h" 2






# 1 "/Users/ddunbar/rt/11003353/clang-r152231-t20120307_081803-b13838/Developer/usr/bin/../lib/clang/3.1/include/stddef.h" 1 3 4
# 55 "icu/unicode/umachine.h" 2
# 235 "icu/unicode/umachine.h"
typedef int8_t UBool;
# 326 "icu/unicode/umachine.h"
    typedef uint16_t UChar;
# 346 "icu/unicode/umachine.h"
typedef int32_t UChar32;
# 369 "icu/unicode/umachine.h"
# 1 "icu/unicode/urename.h" 1
# 370 "icu/unicode/umachine.h" 2
# 37 "icu/unicode/utypes.h" 2
# 1 "icu/unicode/utf.h" 1
# 101 "icu/unicode/utf.h"
# 1 "icu/unicode/utypes.h" 1
# 102 "icu/unicode/utf.h" 2
# 215 "icu/unicode/utf.h"
# 1 "icu/unicode/utf8.h" 1
# 55 "icu/unicode/utf8.h"
extern "C" const uint8_t

utf8_countTrailBytes[256];
# 75 "icu/unicode/utf8.h"
extern "C" UChar32
utf8_nextCharSafeBody(const uint8_t *s, int32_t *pi, int32_t length, UChar32 c, UBool strict);





extern "C" int32_t
utf8_appendCharSafeBody(uint8_t *s, int32_t i, int32_t length, UChar32 c, UBool *pIsError);





extern "C" UChar32
utf8_prevCharSafeBody(const uint8_t *s, int32_t start, int32_t *pi, UChar32 c, UBool strict);





extern "C" int32_t
utf8_back1SafeBody(const uint8_t *s, int32_t start, int32_t i);
# 216 "icu/unicode/utf.h" 2
# 1 "icu/unicode/utf16.h" 1
# 217 "icu/unicode/utf.h" 2


# 1 "icu/unicode/utf_old.h" 1
# 220 "icu/unicode/utf.h" 2
# 38 "icu/unicode/utypes.h" 2
# 1 "icu/unicode/uversion.h" 1
# 109 "icu/unicode/uversion.h"
typedef uint8_t UVersionInfo[4];




namespace icu { }





using namespace icu;
# 139 "icu/unicode/uversion.h"
extern "C" void
u_versionFromString(UVersionInfo versionArray, const char *versionString);
# 154 "icu/unicode/uversion.h"
extern "C" void
u_versionToString(UVersionInfo versionArray, char *versionString);
# 165 "icu/unicode/uversion.h"
extern "C" void
u_getVersion(UVersionInfo versionArray);
# 39 "icu/unicode/utypes.h" 2
# 1 "icu/unicode/uconfig.h" 1
# 40 "icu/unicode/utypes.h" 2
# 239 "icu/unicode/utypes.h"
typedef double UDate;
# 297 "icu/unicode/utypes.h"
typedef void* UClassID;
# 522 "icu/unicode/utypes.h"
typedef enum UErrorCode {





    U_USING_FALLBACK_WARNING = -128,

    U_ERROR_WARNING_START = -128,

    U_USING_DEFAULT_WARNING = -127,

    U_SAFECLONE_ALLOCATED_WARNING = -126,

    U_STATE_OLD_WARNING = -125,

    U_STRING_NOT_TERMINATED_WARNING = -124,

    U_SORT_KEY_TOO_SHORT_WARNING = -123,

    U_AMBIGUOUS_ALIAS_WARNING = -122,

    U_DIFFERENT_UCA_VERSION = -121,

    U_ERROR_WARNING_LIMIT,


    U_ZERO_ERROR = 0,

    U_ILLEGAL_ARGUMENT_ERROR = 1,
    U_MISSING_RESOURCE_ERROR = 2,
    U_INVALID_FORMAT_ERROR = 3,
    U_FILE_ACCESS_ERROR = 4,
    U_INTERNAL_PROGRAM_ERROR = 5,
    U_MESSAGE_PARSE_ERROR = 6,
    U_MEMORY_ALLOCATION_ERROR = 7,
    U_INDEX_OUTOFBOUNDS_ERROR = 8,
    U_PARSE_ERROR = 9,
    U_INVALID_CHAR_FOUND = 10,
    U_TRUNCATED_CHAR_FOUND = 11,
    U_ILLEGAL_CHAR_FOUND = 12,
    U_INVALID_TABLE_FORMAT = 13,
    U_INVALID_TABLE_FILE = 14,
    U_BUFFER_OVERFLOW_ERROR = 15,
    U_UNSUPPORTED_ERROR = 16,
    U_RESOURCE_TYPE_MISMATCH = 17,
    U_ILLEGAL_ESCAPE_SEQUENCE = 18,
    U_UNSUPPORTED_ESCAPE_SEQUENCE = 19,
    U_NO_SPACE_AVAILABLE = 20,
    U_CE_NOT_FOUND_ERROR = 21,
    U_PRIMARY_TOO_LONG_ERROR = 22,
    U_STATE_TOO_OLD_ERROR = 23,
    U_TOO_MANY_ALIASES_ERROR = 24,

    U_ENUM_OUT_OF_SYNC_ERROR = 25,
    U_INVARIANT_CONVERSION_ERROR = 26,
    U_INVALID_STATE_ERROR = 27,
    U_COLLATOR_VERSION_MISMATCH = 28,
    U_USELESS_COLLATOR_ERROR = 29,

    U_STANDARD_ERROR_LIMIT,



    U_BAD_VARIABLE_DEFINITION=0x10000,
    U_PARSE_ERROR_START = 0x10000,
    U_MALFORMED_RULE,
    U_MALFORMED_SET,
    U_MALFORMED_SYMBOL_REFERENCE,
    U_MALFORMED_UNICODE_ESCAPE,
    U_MALFORMED_VARIABLE_DEFINITION,
    U_MALFORMED_VARIABLE_REFERENCE,
    U_MISMATCHED_SEGMENT_DELIMITERS,
    U_MISPLACED_ANCHOR_START,
    U_MISPLACED_CURSOR_OFFSET,
    U_MISPLACED_QUANTIFIER,
    U_MISSING_OPERATOR,
    U_MISSING_SEGMENT_CLOSE,
    U_MULTIPLE_ANTE_CONTEXTS,
    U_MULTIPLE_CURSORS,
    U_MULTIPLE_POST_CONTEXTS,
    U_TRAILING_BACKSLASH,
    U_UNDEFINED_SEGMENT_REFERENCE,
    U_UNDEFINED_VARIABLE,
    U_UNQUOTED_SPECIAL,
    U_UNTERMINATED_QUOTE,
    U_RULE_MASK_ERROR,
    U_MISPLACED_COMPOUND_FILTER,
    U_MULTIPLE_COMPOUND_FILTERS,
    U_INVALID_RBT_SYNTAX,
    U_INVALID_PROPERTY_PATTERN,
    U_MALFORMED_PRAGMA,
    U_UNCLOSED_SEGMENT,
    U_ILLEGAL_CHAR_IN_SEGMENT,
    U_VARIABLE_RANGE_EXHAUSTED,
    U_VARIABLE_RANGE_OVERLAP,
    U_ILLEGAL_CHARACTER,
    U_INTERNAL_TRANSLITERATOR_ERROR,
    U_INVALID_ID,
    U_INVALID_FUNCTION,
    U_PARSE_ERROR_LIMIT,




    U_UNEXPECTED_TOKEN=0x10100,
    U_FMT_PARSE_ERROR_START=0x10100,
    U_MULTIPLE_DECIMAL_SEPARATORS,
    U_MULTIPLE_DECIMAL_SEPERATORS = U_MULTIPLE_DECIMAL_SEPARATORS,
    U_MULTIPLE_EXPONENTIAL_SYMBOLS,
    U_MALFORMED_EXPONENTIAL_PATTERN,
    U_MULTIPLE_PERCENT_SYMBOLS,
    U_MULTIPLE_PERMILL_SYMBOLS,
    U_MULTIPLE_PAD_SPECIFIERS,
    U_PATTERN_SYNTAX_ERROR,
    U_ILLEGAL_PAD_POSITION,
    U_UNMATCHED_BRACES,
    U_UNSUPPORTED_PROPERTY,
    U_UNSUPPORTED_ATTRIBUTE,
    U_FMT_PARSE_ERROR_LIMIT,




    U_BRK_ERROR_START=0x10200,
    U_BRK_INTERNAL_ERROR,
    U_BRK_HEX_DIGITS_EXPECTED,
    U_BRK_SEMICOLON_EXPECTED,
    U_BRK_RULE_SYNTAX,
    U_BRK_UNCLOSED_SET,
    U_BRK_ASSIGN_ERROR,
    U_BRK_VARIABLE_REDFINITION,
    U_BRK_MISMATCHED_PAREN,
    U_BRK_NEW_LINE_IN_QUOTED_STRING,
    U_BRK_UNDEFINED_VARIABLE,
    U_BRK_INIT_ERROR,
    U_BRK_RULE_EMPTY_SET,
    U_BRK_UNRECOGNIZED_OPTION,
    U_BRK_MALFORMED_RULE_TAG,
    U_BRK_ERROR_LIMIT,




    U_REGEX_ERROR_START=0x10300,
    U_REGEX_INTERNAL_ERROR,
    U_REGEX_RULE_SYNTAX,
    U_REGEX_INVALID_STATE,
    U_REGEX_BAD_ESCAPE_SEQUENCE,
    U_REGEX_PROPERTY_SYNTAX,
    U_REGEX_UNIMPLEMENTED,
    U_REGEX_MISMATCHED_PAREN,
    U_REGEX_NUMBER_TOO_BIG,
    U_REGEX_BAD_INTERVAL,
    U_REGEX_MAX_LT_MIN,
    U_REGEX_INVALID_BACK_REF,
    U_REGEX_INVALID_FLAG,
    U_REGEX_LOOK_BEHIND_LIMIT,
    U_REGEX_SET_CONTAINS_STRING,
    U_REGEX_ERROR_LIMIT,




    U_IDNA_ERROR_START=0x10400,
    U_IDNA_PROHIBITED_ERROR,
    U_IDNA_UNASSIGNED_ERROR,
    U_IDNA_CHECK_BIDI_ERROR,
    U_IDNA_STD3_ASCII_RULES_ERROR,
    U_IDNA_ACE_PREFIX_ERROR,
    U_IDNA_VERIFICATION_ERROR,
    U_IDNA_LABEL_TOO_LONG_ERROR,
    U_IDNA_ERROR_LIMIT,



    U_STRINGPREP_PROHIBITED_ERROR = U_IDNA_PROHIBITED_ERROR,
    U_STRINGPREP_UNASSIGNED_ERROR = U_IDNA_UNASSIGNED_ERROR,
    U_STRINGPREP_CHECK_BIDI_ERROR = U_IDNA_CHECK_BIDI_ERROR,


    U_ERROR_LIMIT=U_IDNA_ERROR_LIMIT
} UErrorCode;
# 714 "icu/unicode/utypes.h"
    static
    inline UBool U_SUCCESS(UErrorCode code) { return (UBool)(code<=U_ZERO_ERROR); }




    static
    inline UBool U_FAILURE(UErrorCode code) { return (UBool)(code>U_ZERO_ERROR); }
# 741 "icu/unicode/utypes.h"
extern "C" const char *
u_errorName(UErrorCode code);
# 27 "icu/unicode/uchar.h" 2

extern "C" {
# 153 "icu/unicode/uchar.h"
typedef enum UProperty {
# 165 "icu/unicode/uchar.h"
    UCHAR_ALPHABETIC=0,

    UCHAR_BINARY_START=UCHAR_ALPHABETIC,

    UCHAR_ASCII_HEX_DIGIT,



    UCHAR_BIDI_CONTROL,




    UCHAR_BIDI_MIRRORED,

    UCHAR_DASH,



    UCHAR_DEFAULT_IGNORABLE_CODE_POINT,


    UCHAR_DEPRECATED,


    UCHAR_DIACRITIC,



    UCHAR_EXTENDER,



    UCHAR_FULL_COMPOSITION_EXCLUSION,



    UCHAR_GRAPHEME_BASE,



    UCHAR_GRAPHEME_EXTEND,


    UCHAR_GRAPHEME_LINK,


    UCHAR_HEX_DIGIT,


    UCHAR_HYPHEN,




    UCHAR_ID_CONTINUE,



    UCHAR_ID_START,


    UCHAR_IDEOGRAPHIC,



    UCHAR_IDS_BINARY_OPERATOR,



    UCHAR_IDS_TRINARY_OPERATOR,


    UCHAR_JOIN_CONTROL,



    UCHAR_LOGICAL_ORDER_EXCEPTION,


    UCHAR_LOWERCASE,

    UCHAR_MATH,



    UCHAR_NONCHARACTER_CODE_POINT,

    UCHAR_QUOTATION_MARK,



    UCHAR_RADICAL,




    UCHAR_SOFT_DOTTED,



    UCHAR_TERMINAL_PUNCTUATION,



    UCHAR_UNIFIED_IDEOGRAPH,


    UCHAR_UPPERCASE,



    UCHAR_WHITE_SPACE,



    UCHAR_XID_CONTINUE,


    UCHAR_XID_START,



    UCHAR_CASE_SENSITIVE,




    UCHAR_S_TERM,





    UCHAR_VARIATION_SELECTOR,
# 322 "icu/unicode/uchar.h"
    UCHAR_NFD_INERT,
# 331 "icu/unicode/uchar.h"
    UCHAR_NFKD_INERT,
# 340 "icu/unicode/uchar.h"
    UCHAR_NFC_INERT,
# 349 "icu/unicode/uchar.h"
    UCHAR_NFKC_INERT,
# 360 "icu/unicode/uchar.h"
    UCHAR_SEGMENT_STARTER,

    UCHAR_BINARY_LIMIT,



    UCHAR_BIDI_CLASS=0x1000,

    UCHAR_INT_START=UCHAR_BIDI_CLASS,


    UCHAR_BLOCK,


    UCHAR_CANONICAL_COMBINING_CLASS,


    UCHAR_DECOMPOSITION_TYPE,



    UCHAR_EAST_ASIAN_WIDTH,


    UCHAR_GENERAL_CATEGORY,


    UCHAR_JOINING_GROUP,


    UCHAR_JOINING_TYPE,


    UCHAR_LINE_BREAK,


    UCHAR_NUMERIC_TYPE,


    UCHAR_SCRIPT,


    UCHAR_HANGUL_SYLLABLE_TYPE,


    UCHAR_NFD_QUICK_CHECK,


    UCHAR_NFKD_QUICK_CHECK,


    UCHAR_NFC_QUICK_CHECK,


    UCHAR_NFKC_QUICK_CHECK,






    UCHAR_LEAD_CANONICAL_COMBINING_CLASS,






    UCHAR_TRAIL_CANONICAL_COMBINING_CLASS,

    UCHAR_INT_LIMIT,
# 440 "icu/unicode/uchar.h"
    UCHAR_GENERAL_CATEGORY_MASK=0x2000,

    UCHAR_MASK_START=UCHAR_GENERAL_CATEGORY_MASK,

    UCHAR_MASK_LIMIT,



    UCHAR_NUMERIC_VALUE=0x3000,

    UCHAR_DOUBLE_START=UCHAR_NUMERIC_VALUE,

    UCHAR_DOUBLE_LIMIT,



    UCHAR_AGE=0x4000,

    UCHAR_STRING_START=UCHAR_AGE,


    UCHAR_BIDI_MIRRORING_GLYPH,


    UCHAR_CASE_FOLDING,


    UCHAR_ISO_COMMENT,


    UCHAR_LOWERCASE_MAPPING,


    UCHAR_NAME,


    UCHAR_SIMPLE_CASE_FOLDING,


    UCHAR_SIMPLE_LOWERCASE_MAPPING,


    UCHAR_SIMPLE_TITLECASE_MAPPING,


    UCHAR_SIMPLE_UPPERCASE_MAPPING,


    UCHAR_TITLECASE_MAPPING,


    UCHAR_UNICODE_1_NAME,


    UCHAR_UPPERCASE_MAPPING,

    UCHAR_STRING_LIMIT,


    UCHAR_INVALID_CODE = -1
} UProperty;






typedef enum UCharCategory
{



    U_UNASSIGNED = 0,

    U_GENERAL_OTHER_TYPES = 0,

    U_UPPERCASE_LETTER = 1,

    U_LOWERCASE_LETTER = 2,

    U_TITLECASE_LETTER = 3,

    U_MODIFIER_LETTER = 4,

    U_OTHER_LETTER = 5,

    U_NON_SPACING_MARK = 6,

    U_ENCLOSING_MARK = 7,

    U_COMBINING_SPACING_MARK = 8,

    U_DECIMAL_DIGIT_NUMBER = 9,

    U_LETTER_NUMBER = 10,

    U_OTHER_NUMBER = 11,

    U_SPACE_SEPARATOR = 12,

    U_LINE_SEPARATOR = 13,

    U_PARAGRAPH_SEPARATOR = 14,

    U_CONTROL_CHAR = 15,

    U_FORMAT_CHAR = 16,

    U_PRIVATE_USE_CHAR = 17,

    U_SURROGATE = 18,

    U_DASH_PUNCTUATION = 19,

    U_START_PUNCTUATION = 20,

    U_END_PUNCTUATION = 21,

    U_CONNECTOR_PUNCTUATION = 22,

    U_OTHER_PUNCTUATION = 23,

    U_MATH_SYMBOL = 24,

    U_CURRENCY_SYMBOL = 25,

    U_MODIFIER_SYMBOL = 26,

    U_OTHER_SYMBOL = 27,

    U_INITIAL_PUNCTUATION = 28,

    U_FINAL_PUNCTUATION = 29,

    U_CHAR_CATEGORY_COUNT
} UCharCategory;
# 693 "icu/unicode/uchar.h"
typedef enum UCharDirection {



    U_LEFT_TO_RIGHT = 0,

    U_RIGHT_TO_LEFT = 1,

    U_EUROPEAN_NUMBER = 2,

    U_EUROPEAN_NUMBER_SEPARATOR = 3,

    U_EUROPEAN_NUMBER_TERMINATOR = 4,

    U_ARABIC_NUMBER = 5,

    U_COMMON_NUMBER_SEPARATOR = 6,

    U_BLOCK_SEPARATOR = 7,

    U_SEGMENT_SEPARATOR = 8,

    U_WHITE_SPACE_NEUTRAL = 9,

    U_OTHER_NEUTRAL = 10,

    U_LEFT_TO_RIGHT_EMBEDDING = 11,

    U_LEFT_TO_RIGHT_OVERRIDE = 12,

    U_RIGHT_TO_LEFT_ARABIC = 13,

    U_RIGHT_TO_LEFT_EMBEDDING = 14,

    U_RIGHT_TO_LEFT_OVERRIDE = 15,

    U_POP_DIRECTIONAL_FORMAT = 16,

    U_DIR_NON_SPACING_MARK = 17,

    U_BOUNDARY_NEUTRAL = 18,

    U_CHAR_DIRECTION_COUNT
} UCharDirection;





enum UBlockCode {


    UBLOCK_NO_BLOCK = 0,


    UBLOCK_BASIC_LATIN = 1,


    UBLOCK_LATIN_1_SUPPLEMENT=2,


    UBLOCK_LATIN_EXTENDED_A =3,


    UBLOCK_LATIN_EXTENDED_B =4,


    UBLOCK_IPA_EXTENSIONS =5,


    UBLOCK_SPACING_MODIFIER_LETTERS =6,


    UBLOCK_COMBINING_DIACRITICAL_MARKS =7,





    UBLOCK_GREEK =8,


    UBLOCK_CYRILLIC =9,


    UBLOCK_ARMENIAN =10,


    UBLOCK_HEBREW =11,


    UBLOCK_ARABIC =12,


    UBLOCK_SYRIAC =13,


    UBLOCK_THAANA =14,


    UBLOCK_DEVANAGARI =15,


    UBLOCK_BENGALI =16,


    UBLOCK_GURMUKHI =17,


    UBLOCK_GUJARATI =18,


    UBLOCK_ORIYA =19,


    UBLOCK_TAMIL =20,


    UBLOCK_TELUGU =21,


    UBLOCK_KANNADA =22,


    UBLOCK_MALAYALAM =23,


    UBLOCK_SINHALA =24,


    UBLOCK_THAI =25,


    UBLOCK_LAO =26,


    UBLOCK_TIBETAN =27,


    UBLOCK_MYANMAR =28,


    UBLOCK_GEORGIAN =29,


    UBLOCK_HANGUL_JAMO =30,


    UBLOCK_ETHIOPIC =31,


    UBLOCK_CHEROKEE =32,


    UBLOCK_UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS =33,


    UBLOCK_OGHAM =34,


    UBLOCK_RUNIC =35,


    UBLOCK_KHMER =36,


    UBLOCK_MONGOLIAN =37,


    UBLOCK_LATIN_EXTENDED_ADDITIONAL =38,


    UBLOCK_GREEK_EXTENDED =39,


    UBLOCK_GENERAL_PUNCTUATION =40,


    UBLOCK_SUPERSCRIPTS_AND_SUBSCRIPTS =41,


    UBLOCK_CURRENCY_SYMBOLS =42,





    UBLOCK_COMBINING_MARKS_FOR_SYMBOLS =43,


    UBLOCK_LETTERLIKE_SYMBOLS =44,


    UBLOCK_NUMBER_FORMS =45,


    UBLOCK_ARROWS =46,


    UBLOCK_MATHEMATICAL_OPERATORS =47,


    UBLOCK_MISCELLANEOUS_TECHNICAL =48,


    UBLOCK_CONTROL_PICTURES =49,


    UBLOCK_OPTICAL_CHARACTER_RECOGNITION =50,


    UBLOCK_ENCLOSED_ALPHANUMERICS =51,


    UBLOCK_BOX_DRAWING =52,


    UBLOCK_BLOCK_ELEMENTS =53,


    UBLOCK_GEOMETRIC_SHAPES =54,


    UBLOCK_MISCELLANEOUS_SYMBOLS =55,


    UBLOCK_DINGBATS =56,


    UBLOCK_BRAILLE_PATTERNS =57,


    UBLOCK_CJK_RADICALS_SUPPLEMENT =58,


    UBLOCK_KANGXI_RADICALS =59,


    UBLOCK_IDEOGRAPHIC_DESCRIPTION_CHARACTERS =60,


    UBLOCK_CJK_SYMBOLS_AND_PUNCTUATION =61,


    UBLOCK_HIRAGANA =62,


    UBLOCK_KATAKANA =63,


    UBLOCK_BOPOMOFO =64,


    UBLOCK_HANGUL_COMPATIBILITY_JAMO =65,


    UBLOCK_KANBUN =66,


    UBLOCK_BOPOMOFO_EXTENDED =67,


    UBLOCK_ENCLOSED_CJK_LETTERS_AND_MONTHS =68,


    UBLOCK_CJK_COMPATIBILITY =69,


    UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A =70,


    UBLOCK_CJK_UNIFIED_IDEOGRAPHS =71,


    UBLOCK_YI_SYLLABLES =72,


    UBLOCK_YI_RADICALS =73,


    UBLOCK_HANGUL_SYLLABLES =74,


    UBLOCK_HIGH_SURROGATES =75,


    UBLOCK_HIGH_PRIVATE_USE_SURROGATES =76,


    UBLOCK_LOW_SURROGATES =77,
# 993 "icu/unicode/uchar.h"
    UBLOCK_PRIVATE_USE = 78,
# 1003 "icu/unicode/uchar.h"
    UBLOCK_PRIVATE_USE_AREA =UBLOCK_PRIVATE_USE,


    UBLOCK_CJK_COMPATIBILITY_IDEOGRAPHS =79,


    UBLOCK_ALPHABETIC_PRESENTATION_FORMS =80,


    UBLOCK_ARABIC_PRESENTATION_FORMS_A =81,


    UBLOCK_COMBINING_HALF_MARKS =82,


    UBLOCK_CJK_COMPATIBILITY_FORMS =83,


    UBLOCK_SMALL_FORM_VARIANTS =84,


    UBLOCK_ARABIC_PRESENTATION_FORMS_B =85,


    UBLOCK_SPECIALS =86,


    UBLOCK_HALFWIDTH_AND_FULLWIDTH_FORMS =87,




    UBLOCK_OLD_ITALIC = 88 ,

    UBLOCK_GOTHIC = 89 ,

    UBLOCK_DESERET = 90 ,

    UBLOCK_BYZANTINE_MUSICAL_SYMBOLS = 91 ,

    UBLOCK_MUSICAL_SYMBOLS = 92 ,

    UBLOCK_MATHEMATICAL_ALPHANUMERIC_SYMBOLS = 93 ,

    UBLOCK_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B = 94 ,

    UBLOCK_CJK_COMPATIBILITY_IDEOGRAPHS_SUPPLEMENT = 95 ,

    UBLOCK_TAGS = 96,







    UBLOCK_CYRILLIC_SUPPLEMENTARY = 97,

    UBLOCK_CYRILLIC_SUPPLEMENT = UBLOCK_CYRILLIC_SUPPLEMENTARY,

    UBLOCK_TAGALOG = 98,

    UBLOCK_HANUNOO = 99,

    UBLOCK_BUHID = 100,

    UBLOCK_TAGBANWA = 101,

    UBLOCK_MISCELLANEOUS_MATHEMATICAL_SYMBOLS_A = 102,

    UBLOCK_SUPPLEMENTAL_ARROWS_A = 103,

    UBLOCK_SUPPLEMENTAL_ARROWS_B = 104,

    UBLOCK_MISCELLANEOUS_MATHEMATICAL_SYMBOLS_B = 105,

    UBLOCK_SUPPLEMENTAL_MATHEMATICAL_OPERATORS = 106,

    UBLOCK_KATAKANA_PHONETIC_EXTENSIONS = 107,

    UBLOCK_VARIATION_SELECTORS = 108,

    UBLOCK_SUPPLEMENTARY_PRIVATE_USE_AREA_A = 109,

    UBLOCK_SUPPLEMENTARY_PRIVATE_USE_AREA_B = 110,




    UBLOCK_LIMBU = 111,

    UBLOCK_TAI_LE = 112,

    UBLOCK_KHMER_SYMBOLS = 113,

    UBLOCK_PHONETIC_EXTENSIONS = 114,

    UBLOCK_MISCELLANEOUS_SYMBOLS_AND_ARROWS = 115,

    UBLOCK_YIJING_HEXAGRAM_SYMBOLS = 116,

    UBLOCK_LINEAR_B_SYLLABARY = 117,

    UBLOCK_LINEAR_B_IDEOGRAMS = 118,

    UBLOCK_AEGEAN_NUMBERS = 119,

    UBLOCK_UGARITIC = 120,

    UBLOCK_SHAVIAN = 121,

    UBLOCK_OSMANYA = 122,

    UBLOCK_CYPRIOT_SYLLABARY = 123,

    UBLOCK_TAI_XUAN_JING_SYMBOLS = 124,

    UBLOCK_VARIATION_SELECTORS_SUPPLEMENT = 125,


    UBLOCK_COUNT,


    UBLOCK_INVALID_CODE=-1
};


typedef enum UBlockCode UBlockCode;
# 1139 "icu/unicode/uchar.h"
typedef enum UEastAsianWidth {
    U_EA_NEUTRAL,
    U_EA_AMBIGUOUS,
    U_EA_HALFWIDTH,
    U_EA_FULLWIDTH,
    U_EA_NARROW,
    U_EA_WIDE,
    U_EA_COUNT
} UEastAsianWidth;
# 1164 "icu/unicode/uchar.h"
typedef enum UCharNameChoice {
    U_UNICODE_CHAR_NAME,
    U_UNICODE_10_CHAR_NAME,
    U_EXTENDED_CHAR_NAME,
    U_CHAR_NAME_CHOICE_COUNT
} UCharNameChoice;
# 1184 "icu/unicode/uchar.h"
typedef enum UPropertyNameChoice {
    U_SHORT_PROPERTY_NAME,
    U_LONG_PROPERTY_NAME,
    U_PROPERTY_NAME_CHOICE_COUNT
} UPropertyNameChoice;







typedef enum UDecompositionType {
    U_DT_NONE,
    U_DT_CANONICAL,
    U_DT_COMPAT,
    U_DT_CIRCLE,
    U_DT_FINAL,
    U_DT_FONT,
    U_DT_FRACTION,
    U_DT_INITIAL,
    U_DT_ISOLATED,
    U_DT_MEDIAL,
    U_DT_NARROW,
    U_DT_NOBREAK,
    U_DT_SMALL,
    U_DT_SQUARE,
    U_DT_SUB,
    U_DT_SUPER,
    U_DT_VERTICAL,
    U_DT_WIDE,
    U_DT_COUNT
} UDecompositionType;







typedef enum UJoiningType {
    U_JT_NON_JOINING,
    U_JT_JOIN_CAUSING,
    U_JT_DUAL_JOINING,
    U_JT_LEFT_JOINING,
    U_JT_RIGHT_JOINING,
    U_JT_TRANSPARENT,
    U_JT_COUNT
} UJoiningType;







typedef enum UJoiningGroup {
    U_JG_NO_JOINING_GROUP,
    U_JG_AIN,
    U_JG_ALAPH,
    U_JG_ALEF,
    U_JG_BEH,
    U_JG_BETH,
    U_JG_DAL,
    U_JG_DALATH_RISH,
    U_JG_E,
    U_JG_FEH,
    U_JG_FINAL_SEMKATH,
    U_JG_GAF,
    U_JG_GAMAL,
    U_JG_HAH,
    U_JG_HAMZA_ON_HEH_GOAL,
    U_JG_HE,
    U_JG_HEH,
    U_JG_HEH_GOAL,
    U_JG_HETH,
    U_JG_KAF,
    U_JG_KAPH,
    U_JG_KNOTTED_HEH,
    U_JG_LAM,
    U_JG_LAMADH,
    U_JG_MEEM,
    U_JG_MIM,
    U_JG_NOON,
    U_JG_NUN,
    U_JG_PE,
    U_JG_QAF,
    U_JG_QAPH,
    U_JG_REH,
    U_JG_REVERSED_PE,
    U_JG_SAD,
    U_JG_SADHE,
    U_JG_SEEN,
    U_JG_SEMKATH,
    U_JG_SHIN,
    U_JG_SWASH_KAF,
    U_JG_SYRIAC_WAW,
    U_JG_TAH,
    U_JG_TAW,
    U_JG_TEH_MARBUTA,
    U_JG_TETH,
    U_JG_WAW,
    U_JG_YEH,
    U_JG_YEH_BARREE,
    U_JG_YEH_WITH_TAIL,
    U_JG_YUDH,
    U_JG_YUDH_HE,
    U_JG_ZAIN,
    U_JG_FE,
    U_JG_KHAPH,
    U_JG_ZHAIN,
    U_JG_COUNT
} UJoiningGroup;







typedef enum ULineBreak {
    U_LB_UNKNOWN,
    U_LB_AMBIGUOUS,
    U_LB_ALPHABETIC,
    U_LB_BREAK_BOTH,
    U_LB_BREAK_AFTER,
    U_LB_BREAK_BEFORE,
    U_LB_MANDATORY_BREAK,
    U_LB_CONTINGENT_BREAK,
    U_LB_CLOSE_PUNCTUATION,
    U_LB_COMBINING_MARK,
    U_LB_CARRIAGE_RETURN,
    U_LB_EXCLAMATION,
    U_LB_GLUE,
    U_LB_HYPHEN,
    U_LB_IDEOGRAPHIC,
    U_LB_INSEPERABLE,

    U_LB_INSEPARABLE=U_LB_INSEPERABLE,
    U_LB_INFIX_NUMERIC,
    U_LB_LINE_FEED,
    U_LB_NONSTARTER,
    U_LB_NUMERIC,
    U_LB_OPEN_PUNCTUATION,
    U_LB_POSTFIX_NUMERIC,
    U_LB_PREFIX_NUMERIC,
    U_LB_QUOTATION,
    U_LB_COMPLEX_CONTEXT,
    U_LB_SURROGATE,
    U_LB_SPACE,
    U_LB_BREAK_SYMBOLS,
    U_LB_ZWSPACE,
    U_LB_NEXT_LINE,
    U_LB_WORD_JOINER,
    U_LB_COUNT
} ULineBreak;







typedef enum UNumericType {
    U_NT_NONE,
    U_NT_DECIMAL,
    U_NT_DIGIT,
    U_NT_NUMERIC,
    U_NT_COUNT
} UNumericType;







typedef enum UHangulSyllableType {
    U_HST_NOT_APPLICABLE,
    U_HST_LEADING_JAMO,
    U_HST_VOWEL_JAMO,
    U_HST_TRAILING_JAMO,
    U_HST_LV_SYLLABLE,
    U_HST_LVT_SYLLABLE,
    U_HST_COUNT
} UHangulSyllableType;
# 1397 "icu/unicode/uchar.h"
extern "C" UBool
u_hasBinaryProperty(UChar32 c, UProperty which);
# 1412 "icu/unicode/uchar.h"
extern "C" UBool
u_isUAlphabetic(UChar32 c);
# 1427 "icu/unicode/uchar.h"
extern "C" UBool
u_isULowercase(UChar32 c);
# 1442 "icu/unicode/uchar.h"
extern "C" UBool
u_isUUppercase(UChar32 c);
# 1463 "icu/unicode/uchar.h"
extern "C" UBool
u_isUWhiteSpace(UChar32 c);
# 1503 "icu/unicode/uchar.h"
extern "C" int32_t
u_getIntPropertyValue(UChar32 c, UProperty which);
# 1524 "icu/unicode/uchar.h"
extern "C" int32_t
u_getIntPropertyMinValue(UProperty which);
# 1553 "icu/unicode/uchar.h"
extern "C" int32_t
u_getIntPropertyMaxValue(UProperty which);
# 1576 "icu/unicode/uchar.h"
extern "C" double
u_getNumericValue(UChar32 c);
# 1612 "icu/unicode/uchar.h"
extern "C" UBool
u_islower(UChar32 c);
# 1639 "icu/unicode/uchar.h"
extern "C" UBool
u_isupper(UChar32 c);
# 1656 "icu/unicode/uchar.h"
extern "C" UBool
u_istitle(UChar32 c);
# 1677 "icu/unicode/uchar.h"
extern "C" UBool
u_isdigit(UChar32 c);
# 1698 "icu/unicode/uchar.h"
extern "C" UBool
u_isalpha(UChar32 c);
# 1719 "icu/unicode/uchar.h"
extern "C" UBool
u_isalnum(UChar32 c);
# 1742 "icu/unicode/uchar.h"
extern "C" UBool
u_isxdigit(UChar32 c);
# 1758 "icu/unicode/uchar.h"
extern "C" UBool
u_ispunct(UChar32 c);
# 1777 "icu/unicode/uchar.h"
extern "C" UBool
u_isgraph(UChar32 c);
# 1806 "icu/unicode/uchar.h"
extern "C" UBool
u_isblank(UChar32 c);
# 1831 "icu/unicode/uchar.h"
extern "C" UBool
u_isdefined(UChar32 c);
# 1852 "icu/unicode/uchar.h"
extern "C" UBool
u_isspace(UChar32 c);
# 1873 "icu/unicode/uchar.h"
extern "C" UBool
u_isJavaSpaceChar(UChar32 c);
# 1907 "icu/unicode/uchar.h"
extern "C" UBool
u_isWhitespace(UChar32 c);
# 1931 "icu/unicode/uchar.h"
extern "C" UBool
u_iscntrl(UChar32 c);
# 1946 "icu/unicode/uchar.h"
extern "C" UBool
u_isISOControl(UChar32 c);
# 1964 "icu/unicode/uchar.h"
extern "C" UBool
u_isprint(UChar32 c);
# 1985 "icu/unicode/uchar.h"
extern "C" UBool
u_isbase(UChar32 c);
# 2004 "icu/unicode/uchar.h"
extern "C" UCharDirection
u_charDirection(UChar32 c);
# 2022 "icu/unicode/uchar.h"
extern "C" UBool
u_isMirrored(UChar32 c);
# 2044 "icu/unicode/uchar.h"
extern "C" UChar32
u_charMirror(UChar32 c);
# 2058 "icu/unicode/uchar.h"
extern "C" int8_t
u_charType(UChar32 c);
# 2093 "icu/unicode/uchar.h"
typedef UBool
UCharEnumTypeRange(const void *context, UChar32 start, UChar32 limit, UCharCategory type);
# 2115 "icu/unicode/uchar.h"
extern "C" void
u_enumCharTypes(UCharEnumTypeRange *enumRange, const void *context);
# 2127 "icu/unicode/uchar.h"
extern "C" uint8_t
u_getCombiningClass(UChar32 c);
# 2155 "icu/unicode/uchar.h"
extern "C" int32_t
u_charDigitValue(UChar32 c);
# 2167 "icu/unicode/uchar.h"
extern "C" UBlockCode
ublock_getCode(UChar32 c);
# 2202 "icu/unicode/uchar.h"
extern "C" int32_t
u_charName(UChar32 code, UCharNameChoice nameChoice,
           char *buffer, int32_t bufferLength,
           UErrorCode *pErrorCode);
# 2229 "icu/unicode/uchar.h"
extern "C" int32_t
u_getISOComment(UChar32 c,
                char *dest, int32_t destCapacity,
                UErrorCode *pErrorCode);
# 2254 "icu/unicode/uchar.h"
extern "C" UChar32
u_charFromName(UCharNameChoice nameChoice,
               const char *name,
               UErrorCode *pErrorCode);
# 2276 "icu/unicode/uchar.h"
typedef UBool UEnumCharNamesFn(void *context,
                               UChar32 code,
                               UCharNameChoice nameChoice,
                               const char *name,
                               int32_t length);
# 2303 "icu/unicode/uchar.h"
extern "C" void
u_enumCharNames(UChar32 start, UChar32 limit,
                UEnumCharNamesFn *fn,
                void *context,
                UCharNameChoice nameChoice,
                UErrorCode *pErrorCode);
# 2341 "icu/unicode/uchar.h"
extern "C" const char*
u_getPropertyName(UProperty property,
                  UPropertyNameChoice nameChoice);
# 2364 "icu/unicode/uchar.h"
extern "C" UProperty
u_getPropertyEnum(const char* alias);
# 2414 "icu/unicode/uchar.h"
extern "C" const char*
u_getPropertyValueName(UProperty property,
                       int32_t value,
                       UPropertyNameChoice nameChoice);
# 2450 "icu/unicode/uchar.h"
extern "C" int32_t
u_getPropertyValueEnum(UProperty property,
                       const char* alias);
# 2471 "icu/unicode/uchar.h"
extern "C" UBool
u_isIDStart(UChar32 c);
# 2495 "icu/unicode/uchar.h"
extern "C" UBool
u_isIDPart(UChar32 c);
# 2520 "icu/unicode/uchar.h"
extern "C" UBool
u_isIDIgnorable(UChar32 c);
# 2539 "icu/unicode/uchar.h"
extern "C" UBool
u_isJavaIDStart(UChar32 c);
# 2560 "icu/unicode/uchar.h"
extern "C" UBool
u_isJavaIDPart(UChar32 c);
# 2581 "icu/unicode/uchar.h"
extern "C" UChar32
u_tolower(UChar32 c);
# 2602 "icu/unicode/uchar.h"
extern "C" UChar32
u_toupper(UChar32 c);
# 2623 "icu/unicode/uchar.h"
extern "C" UChar32
u_totitle(UChar32 c);
# 2665 "icu/unicode/uchar.h"
extern "C" UChar32
u_foldCase(UChar32 c, uint32_t options);
# 2706 "icu/unicode/uchar.h"
extern "C" int32_t
u_digit(UChar32 ch, int8_t radix);
# 2737 "icu/unicode/uchar.h"
extern "C" UChar32
u_forDigit(int32_t digit, int8_t radix);
# 2754 "icu/unicode/uchar.h"
extern "C" void
u_charAge(UChar32 c, UVersionInfo versionArray);
# 2768 "icu/unicode/uchar.h"
extern "C" void
u_getUnicodeVersion(UVersionInfo versionArray);
# 2792 "icu/unicode/uchar.h"
extern "C" int32_t
u_getFC_NFKC_Closure(UChar32 c, UChar *dest, int32_t destCapacity, UErrorCode *pErrorCode);

}
# 28 "./wtf/unicode/icu/UnicodeIcu.h" 2
# 1 "icu/unicode/uscript.h" 1
# 45 "icu/unicode/uscript.h"
typedef enum UScriptCode {
      USCRIPT_INVALID_CODE = -1,
      USCRIPT_COMMON = 0 ,
      USCRIPT_INHERITED = 1,
      USCRIPT_ARABIC = 2,
      USCRIPT_ARMENIAN = 3,
      USCRIPT_BENGALI = 4,
      USCRIPT_BOPOMOFO = 5,
      USCRIPT_CHEROKEE = 6,
      USCRIPT_COPTIC = 7,
      USCRIPT_CYRILLIC = 8,
      USCRIPT_DESERET = 9,
      USCRIPT_DEVANAGARI = 10,
      USCRIPT_ETHIOPIC = 11,
      USCRIPT_GEORGIAN = 12,
      USCRIPT_GOTHIC = 13,
      USCRIPT_GREEK = 14,
      USCRIPT_GUJARATI = 15,
      USCRIPT_GURMUKHI = 16,
      USCRIPT_HAN = 17,
      USCRIPT_HANGUL = 18,
      USCRIPT_HEBREW = 19,
      USCRIPT_HIRAGANA = 20,
      USCRIPT_KANNADA = 21,
      USCRIPT_KATAKANA = 22,
      USCRIPT_KHMER = 23,
      USCRIPT_LAO = 24,
      USCRIPT_LATIN = 25,
      USCRIPT_MALAYALAM = 26,
      USCRIPT_MONGOLIAN = 27,
      USCRIPT_MYANMAR = 28,
      USCRIPT_OGHAM = 29,
      USCRIPT_OLD_ITALIC = 30,
      USCRIPT_ORIYA = 31,
      USCRIPT_RUNIC = 32,
      USCRIPT_SINHALA = 33,
      USCRIPT_SYRIAC = 34,
      USCRIPT_TAMIL = 35,
      USCRIPT_TELUGU = 36,
      USCRIPT_THAANA = 37,
      USCRIPT_THAI = 38,
      USCRIPT_TIBETAN = 39,

      USCRIPT_CANADIAN_ABORIGINAL = 40,

      USCRIPT_UCAS = USCRIPT_CANADIAN_ABORIGINAL,
      USCRIPT_YI = 41,
      USCRIPT_TAGALOG = 42,
      USCRIPT_HANUNOO = 43,
      USCRIPT_BUHID = 44,
      USCRIPT_TAGBANWA = 45,


      USCRIPT_BRAILLE = 46,
      USCRIPT_CYPRIOT = 47,
      USCRIPT_LIMBU = 48,
      USCRIPT_LINEAR_B = 49,
      USCRIPT_OSMANYA = 50,
      USCRIPT_SHAVIAN = 51,
      USCRIPT_TAI_LE = 52,
      USCRIPT_UGARITIC = 53,


      USCRIPT_KATAKANA_OR_HIRAGANA = 54,



      USCRIPT_BUGINESE = 55,
      USCRIPT_GLAGOLITIC = 56,
      USCRIPT_KHAROSHTHI = 57,
      USCRIPT_SYLOTI_NAGRI = 58,
      USCRIPT_NEW_TAI_LUE = 59,
      USCRIPT_TIFINAGH = 60,
      USCRIPT_OLD_PERSIAN = 61,


      USCRIPT_BALINESE = 62,
      USCRIPT_BATAK = 63,
      USCRIPT_BLISSYMBOLS = 64,
      USCRIPT_BRAHMI = 65,
      USCRIPT_CHAM = 66,
      USCRIPT_CIRTH = 67,
      USCRIPT_OLD_CHURCH_SLAVONIC_CYRILLIC = 68,
      USCRIPT_DEMOTIC_EGYPTIAN = 69,
      USCRIPT_HIERATIC_EGYPTIAN = 70,
      USCRIPT_EGYPTIAN_HIEROGLYPHS = 71,
      USCRIPT_KHUTSURI = 72,
      USCRIPT_SIMPLIFIED_HAN = 73,
      USCRIPT_TRADITIONAL_HAN = 74,
      USCRIPT_PAHAWH_HMONG = 75,
      USCRIPT_OLD_HUNGARIAN = 76,
      USCRIPT_HARAPPAN_INDUS = 77,
      USCRIPT_JAVANESE = 78,
      USCRIPT_KAYAH_LI = 79,
      USCRIPT_LATIN_FRAKTUR = 80,
      USCRIPT_LATIN_GAELIC = 81,
      USCRIPT_LEPCHA = 82,
      USCRIPT_LINEAR_A = 83,
      USCRIPT_MANDAEAN = 84,
      USCRIPT_MAYAN_HIEROGLYPHS = 85,
      USCRIPT_MEROITIC = 86,
      USCRIPT_NKO = 87,
      USCRIPT_ORKHON = 88,
      USCRIPT_OLD_PERMIC = 89,
      USCRIPT_PHAGS_PA = 90,
      USCRIPT_PHOENICIAN = 91,
      USCRIPT_PHONETIC_POLLARD = 92,
      USCRIPT_RONGORONGO = 93,
      USCRIPT_SARATI = 94,
      USCRIPT_ESTRANGELO_SYRIAC = 95,
      USCRIPT_WESTERN_SYRIAC = 96,
      USCRIPT_EASTERN_SYRIAC = 97,
      USCRIPT_TENGWAR = 98,
      USCRIPT_VAI = 99,
      USCRIPT_VISIBLE_SPEECH = 100,
      USCRIPT_CUNEIFORM = 101,
      USCRIPT_UNWRITTEN_LANGUAGES = 102,
      USCRIPT_UNKNOWN = 103,


      USCRIPT_CODE_LIMIT = 104
} UScriptCode;
# 186 "icu/unicode/uscript.h"
extern "C" int32_t
uscript_getCode(const char* nameOrAbbrOrLocale,UScriptCode* fillIn,int32_t capacity,UErrorCode *err);
# 197 "icu/unicode/uscript.h"
extern "C" const char*
uscript_getName(UScriptCode scriptCode);
# 208 "icu/unicode/uscript.h"
extern "C" const char*
uscript_getShortName(UScriptCode scriptCode);
# 219 "icu/unicode/uscript.h"
extern "C" UScriptCode
uscript_getScript(UChar32 codepoint, UErrorCode *err);
# 29 "./wtf/unicode/icu/UnicodeIcu.h" 2
# 1 "icu/unicode/ustring.h" 1
# 20 "icu/unicode/ustring.h"
# 1 "icu/unicode/putil.h" 1
# 65 "icu/unicode/putil.h"
extern "C" const char* u_getDataDirectory(void);
# 86 "icu/unicode/putil.h"
extern "C" void u_setDataDirectory(const char *directory);
# 96 "icu/unicode/putil.h"
extern "C" const char* uprv_getDefaultCodepage(void);
# 107 "icu/unicode/putil.h"
extern "C" const char* uprv_getDefaultLocaleID(void);
# 155 "icu/unicode/putil.h"
extern "C" void
u_charsToUChars(const char *cs, UChar *us, int32_t length);
# 177 "icu/unicode/putil.h"
extern "C" void
u_UCharsToChars(const UChar *us, char *cs, int32_t length);
# 21 "icu/unicode/ustring.h" 2
# 1 "icu/unicode/uiter.h" 1
# 30 "icu/unicode/uiter.h"
    namespace icu {

    class CharacterIterator;
    class Replaceable;

    }


extern "C" {

struct UCharIterator;
typedef struct UCharIterator UCharIterator;







typedef enum UCharIteratorOrigin {
    UITER_START, UITER_CURRENT, UITER_LIMIT, UITER_ZERO, UITER_LENGTH
} UCharIteratorOrigin;


enum {
# 69 "icu/unicode/uiter.h"
    UITER_UNKNOWN_INDEX=-2
};
# 104 "icu/unicode/uiter.h"
typedef int32_t
UCharIteratorGetIndex(UCharIterator *iter, UCharIteratorOrigin origin);
# 141 "icu/unicode/uiter.h"
typedef int32_t
UCharIteratorMove(UCharIterator *iter, int32_t delta, UCharIteratorOrigin origin);
# 156 "icu/unicode/uiter.h"
typedef UBool
UCharIteratorHasNext(UCharIterator *iter);
# 170 "icu/unicode/uiter.h"
typedef UBool
UCharIteratorHasPrevious(UCharIterator *iter);
# 185 "icu/unicode/uiter.h"
typedef UChar32
UCharIteratorCurrent(UCharIterator *iter);
# 201 "icu/unicode/uiter.h"
typedef UChar32
UCharIteratorNext(UCharIterator *iter);
# 217 "icu/unicode/uiter.h"
typedef UChar32
UCharIteratorPrevious(UCharIterator *iter);
# 231 "icu/unicode/uiter.h"
typedef int32_t
UCharIteratorReserved(UCharIterator *iter, int32_t something);
# 278 "icu/unicode/uiter.h"
typedef uint32_t
UCharIteratorGetState(const UCharIterator *iter);
# 306 "icu/unicode/uiter.h"
typedef void
UCharIteratorSetState(UCharIterator *iter, uint32_t state, UErrorCode *pErrorCode);
# 339 "icu/unicode/uiter.h"
struct UCharIterator {





    const void *context;






    int32_t length;






    int32_t start;






    int32_t index;






    int32_t limit;





    int32_t reservedField;
# 388 "icu/unicode/uiter.h"
    UCharIteratorGetIndex *getIndex;
# 399 "icu/unicode/uiter.h"
    UCharIteratorMove *move;
# 408 "icu/unicode/uiter.h"
    UCharIteratorHasNext *hasNext;







    UCharIteratorHasPrevious *hasPrevious;
# 425 "icu/unicode/uiter.h"
    UCharIteratorCurrent *current;
# 435 "icu/unicode/uiter.h"
    UCharIteratorNext *next;
# 445 "icu/unicode/uiter.h"
    UCharIteratorPrevious *previous;







    UCharIteratorReserved *reservedFn;
# 462 "icu/unicode/uiter.h"
    UCharIteratorGetState *getState;
# 472 "icu/unicode/uiter.h"
    UCharIteratorSetState *setState;
};
# 493 "icu/unicode/uiter.h"
extern "C" UChar32
uiter_current32(UCharIterator *iter);
# 510 "icu/unicode/uiter.h"
extern "C" UChar32
uiter_next32(UCharIterator *iter);
# 527 "icu/unicode/uiter.h"
extern "C" UChar32
uiter_previous32(UCharIterator *iter);
# 548 "icu/unicode/uiter.h"
extern "C" uint32_t
uiter_getState(const UCharIterator *iter);
# 566 "icu/unicode/uiter.h"
extern "C" void
uiter_setState(UCharIterator *iter, uint32_t state, UErrorCode *pErrorCode);
# 591 "icu/unicode/uiter.h"
extern "C" void
uiter_setString(UCharIterator *iter, const UChar *s, int32_t length);
# 614 "icu/unicode/uiter.h"
extern "C" void
uiter_setUTF16BE(UCharIterator *iter, const char *s, int32_t length);
# 650 "icu/unicode/uiter.h"
extern "C" void
uiter_setUTF8(UCharIterator *iter, const char *s, int32_t length);
# 675 "icu/unicode/uiter.h"
extern "C" void
uiter_setCharacterIterator(UCharIterator *iter, CharacterIterator *charIter);
# 700 "icu/unicode/uiter.h"
extern "C" void
uiter_setReplaceable(UCharIterator *iter, const Replaceable *rep);



}
# 22 "icu/unicode/ustring.h" 2




    typedef void UBreakIterator;
# 80 "icu/unicode/ustring.h"
extern "C" int32_t
u_strlen(const UChar *s);
# 96 "icu/unicode/ustring.h"
extern "C" int32_t
u_countChar32(const UChar *s, int32_t length);
# 117 "icu/unicode/ustring.h"
extern "C" UBool
u_strHasMoreChar32Than(const UChar *s, int32_t length, int32_t number);
# 130 "icu/unicode/ustring.h"
extern "C" UChar*
u_strcat(UChar *dst,
    const UChar *src);
# 148 "icu/unicode/ustring.h"
extern "C" UChar*
u_strncat(UChar *dst,
     const UChar *src,
     int32_t n);
# 173 "icu/unicode/ustring.h"
extern "C" UChar *
u_strstr(const UChar *s, const UChar *substring);
# 197 "icu/unicode/ustring.h"
extern "C" UChar *
u_strFindFirst(const UChar *s, int32_t length, const UChar *substring, int32_t subLength);
# 217 "icu/unicode/ustring.h"
extern "C" UChar *
u_strchr(const UChar *s, UChar c);
# 237 "icu/unicode/ustring.h"
extern "C" UChar *
u_strchr32(const UChar *s, UChar32 c);
# 260 "icu/unicode/ustring.h"
extern "C" UChar *
u_strrstr(const UChar *s, const UChar *substring);
# 284 "icu/unicode/ustring.h"
extern "C" UChar *
u_strFindLast(const UChar *s, int32_t length, const UChar *substring, int32_t subLength);
# 304 "icu/unicode/ustring.h"
extern "C" UChar *
u_strrchr(const UChar *s, UChar c);
# 324 "icu/unicode/ustring.h"
extern "C" UChar *
u_strrchr32(const UChar *s, UChar32 c);
# 339 "icu/unicode/ustring.h"
extern "C" UChar *
u_strpbrk(const UChar *string, const UChar *matchSet);
# 355 "icu/unicode/ustring.h"
extern "C" int32_t
u_strcspn(const UChar *string, const UChar *matchSet);
# 371 "icu/unicode/ustring.h"
extern "C" int32_t
u_strspn(const UChar *string, const UChar *matchSet);
# 399 "icu/unicode/ustring.h"
extern "C" UChar *
u_strtok_r(UChar *src,
     const UChar *delim,
           UChar **saveState);
# 414 "icu/unicode/ustring.h"
extern "C" int32_t
u_strcmp(const UChar *s1,
         const UChar *s2);
# 429 "icu/unicode/ustring.h"
extern "C" int32_t
u_strcmpCodePointOrder(const UChar *s1, const UChar *s2);
# 459 "icu/unicode/ustring.h"
extern "C" int32_t
u_strCompare(const UChar *s1, int32_t length1,
             const UChar *s2, int32_t length2,
             UBool codePointOrder);
# 484 "icu/unicode/ustring.h"
extern "C" int32_t
u_strCompareIter(UCharIterator *iter1, UCharIterator *iter2, UBool codePointOrder);
# 537 "icu/unicode/ustring.h"
extern "C" int32_t
u_strCaseCompare(const UChar *s1, int32_t length1,
                 const UChar *s2, int32_t length2,
                 uint32_t options,
                 UErrorCode *pErrorCode);
# 555 "icu/unicode/ustring.h"
extern "C" int32_t
u_strncmp(const UChar *ucs1,
     const UChar *ucs2,
     int32_t n);
# 573 "icu/unicode/ustring.h"
extern "C" int32_t
u_strncmpCodePointOrder(const UChar *s1, const UChar *s2, int32_t n);
# 595 "icu/unicode/ustring.h"
extern "C" int32_t
u_strcasecmp(const UChar *s1, const UChar *s2, uint32_t options);
# 619 "icu/unicode/ustring.h"
extern "C" int32_t
u_strncasecmp(const UChar *s1, const UChar *s2, int32_t n, uint32_t options);
# 643 "icu/unicode/ustring.h"
extern "C" int32_t
u_memcasecmp(const UChar *s1, const UChar *s2, int32_t length, uint32_t options);
# 654 "icu/unicode/ustring.h"
extern "C" UChar*
u_strcpy(UChar *dst,
    const UChar *src);
# 669 "icu/unicode/ustring.h"
extern "C" UChar*
u_strncpy(UChar *dst,
     const UChar *src,
     int32_t n);
# 686 "icu/unicode/ustring.h"
extern "C" UChar* u_uastrcpy(UChar *dst,
               const char *src );
# 701 "icu/unicode/ustring.h"
extern "C" UChar* u_uastrncpy(UChar *dst,
            const char *src,
            int32_t n);
# 715 "icu/unicode/ustring.h"
extern "C" char* u_austrcpy(char *dst,
            const UChar *src );
# 730 "icu/unicode/ustring.h"
extern "C" char* u_austrncpy(char *dst,
            const UChar *src,
            int32_t n );
# 744 "icu/unicode/ustring.h"
extern "C" UChar*
u_memcpy(UChar *dest, const UChar *src, int32_t count);
# 755 "icu/unicode/ustring.h"
extern "C" UChar*
u_memmove(UChar *dest, const UChar *src, int32_t count);
# 767 "icu/unicode/ustring.h"
extern "C" UChar*
u_memset(UChar *dest, UChar c, int32_t count);
# 781 "icu/unicode/ustring.h"
extern "C" int32_t
u_memcmp(const UChar *buf1, const UChar *buf2, int32_t count);
# 797 "icu/unicode/ustring.h"
extern "C" int32_t
u_memcmpCodePointOrder(const UChar *s1, const UChar *s2, int32_t count);
# 817 "icu/unicode/ustring.h"
extern "C" UChar*
u_memchr(const UChar *s, UChar c, int32_t count);
# 837 "icu/unicode/ustring.h"
extern "C" UChar*
u_memchr32(const UChar *s, UChar32 c, int32_t count);
# 857 "icu/unicode/ustring.h"
extern "C" UChar*
u_memrchr(const UChar *s, UChar c, int32_t count);
# 877 "icu/unicode/ustring.h"
extern "C" UChar*
u_memrchr32(const UChar *s, UChar32 c, int32_t count);
# 977 "icu/unicode/ustring.h"
extern "C" int32_t
u_unescape(const char *src,
           UChar *dest, int32_t destCapacity);

extern "C" {
# 994 "icu/unicode/ustring.h"
typedef UChar ( *UNESCAPE_CHAR_AT)(int32_t offset, void *context);
}
# 1025 "icu/unicode/ustring.h"
extern "C" UChar32
u_unescapeAt(UNESCAPE_CHAR_AT charAt,
             int32_t *offset,
             int32_t length,
             void *context);
# 1051 "icu/unicode/ustring.h"
extern "C" int32_t
u_strToUpper(UChar *dest, int32_t destCapacity,
             const UChar *src, int32_t srcLength,
             const char *locale,
             UErrorCode *pErrorCode);
# 1077 "icu/unicode/ustring.h"
extern "C" int32_t
u_strToLower(UChar *dest, int32_t destCapacity,
             const UChar *src, int32_t srcLength,
             const char *locale,
             UErrorCode *pErrorCode);
# 1123 "icu/unicode/ustring.h"
extern "C" int32_t
u_strToTitle(UChar *dest, int32_t destCapacity,
             const UChar *src, int32_t srcLength,
             UBreakIterator *titleIter,
             const char *locale,
             UErrorCode *pErrorCode);
# 1154 "icu/unicode/ustring.h"
extern "C" int32_t
u_strFoldCase(UChar *dest, int32_t destCapacity,
              const UChar *src, int32_t srcLength,
              uint32_t options,
              UErrorCode *pErrorCode);
# 1179 "icu/unicode/ustring.h"
extern "C" wchar_t*
u_strToWCS(wchar_t *dest,
           int32_t destCapacity,
           int32_t *pDestLength,
           const UChar *src,
           int32_t srcLength,
           UErrorCode *pErrorCode);
# 1205 "icu/unicode/ustring.h"
extern "C" UChar*
u_strFromWCS(UChar *dest,
             int32_t destCapacity,
             int32_t *pDestLength,
             const wchar_t *src,
             int32_t srcLength,
             UErrorCode *pErrorCode);
# 1231 "icu/unicode/ustring.h"
extern "C" char*
u_strToUTF8(char *dest,
            int32_t destCapacity,
            int32_t *pDestLength,
            const UChar *src,
            int32_t srcLength,
            UErrorCode *pErrorCode);
# 1258 "icu/unicode/ustring.h"
extern "C" UChar*
u_strFromUTF8(UChar *dest,
              int32_t destCapacity,
              int32_t *pDestLength,
              const char *src,
              int32_t srcLength,
              UErrorCode *pErrorCode);
# 1285 "icu/unicode/ustring.h"
extern "C" UChar32*
u_strToUTF32(UChar32 *dest,
             int32_t destCapacity,
             int32_t *pDestLength,
             const UChar *src,
             int32_t srcLength,
             UErrorCode *pErrorCode);
# 1312 "icu/unicode/ustring.h"
extern "C" UChar*
u_strFromUTF32(UChar *dest,
               int32_t destCapacity,
               int32_t *pDestLength,
               const UChar32 *src,
               int32_t srcLength,
               UErrorCode *pErrorCode);
# 30 "./wtf/unicode/icu/UnicodeIcu.h" 2


namespace WTF {
namespace Unicode {

enum Direction {
    LeftToRight = U_LEFT_TO_RIGHT,
    RightToLeft = U_RIGHT_TO_LEFT,
    EuropeanNumber = U_EUROPEAN_NUMBER,
    EuropeanNumberSeparator = U_EUROPEAN_NUMBER_SEPARATOR,
    EuropeanNumberTerminator = U_EUROPEAN_NUMBER_TERMINATOR,
    ArabicNumber = U_ARABIC_NUMBER,
    CommonNumberSeparator = U_COMMON_NUMBER_SEPARATOR,
    BlockSeparator = U_BLOCK_SEPARATOR,
    SegmentSeparator = U_SEGMENT_SEPARATOR,
    WhiteSpaceNeutral = U_WHITE_SPACE_NEUTRAL,
    OtherNeutral = U_OTHER_NEUTRAL,
    LeftToRightEmbedding = U_LEFT_TO_RIGHT_EMBEDDING,
    LeftToRightOverride = U_LEFT_TO_RIGHT_OVERRIDE,
    RightToLeftArabic = U_RIGHT_TO_LEFT_ARABIC,
    RightToLeftEmbedding = U_RIGHT_TO_LEFT_EMBEDDING,
    RightToLeftOverride = U_RIGHT_TO_LEFT_OVERRIDE,
    PopDirectionalFormat = U_POP_DIRECTIONAL_FORMAT,
    NonSpacingMark = U_DIR_NON_SPACING_MARK,
    BoundaryNeutral = U_BOUNDARY_NEUTRAL
};

enum DecompositionType {
    DecompositionNone = U_DT_NONE,
    DecompositionCanonical = U_DT_CANONICAL,
    DecompositionCompat = U_DT_COMPAT,
    DecompositionCircle = U_DT_CIRCLE,
    DecompositionFinal = U_DT_FINAL,
    DecompositionFont = U_DT_FONT,
    DecompositionFraction = U_DT_FRACTION,
    DecompositionInitial = U_DT_INITIAL,
    DecompositionIsolated = U_DT_ISOLATED,
    DecompositionMedial = U_DT_MEDIAL,
    DecompositionNarrow = U_DT_NARROW,
    DecompositionNoBreak = U_DT_NOBREAK,
    DecompositionSmall = U_DT_SMALL,
    DecompositionSquare = U_DT_SQUARE,
    DecompositionSub = U_DT_SUB,
    DecompositionSuper = U_DT_SUPER,
    DecompositionVertical = U_DT_VERTICAL,
    DecompositionWide = U_DT_WIDE,
};

enum CharCategory {
    NoCategory = 0,
    Other_NotAssigned = ((uint32_t)1<<(U_GENERAL_OTHER_TYPES)),
    Letter_Uppercase = ((uint32_t)1<<(U_UPPERCASE_LETTER)),
    Letter_Lowercase = ((uint32_t)1<<(U_LOWERCASE_LETTER)),
    Letter_Titlecase = ((uint32_t)1<<(U_TITLECASE_LETTER)),
    Letter_Modifier = ((uint32_t)1<<(U_MODIFIER_LETTER)),
    Letter_Other = ((uint32_t)1<<(U_OTHER_LETTER)),

    Mark_NonSpacing = ((uint32_t)1<<(U_NON_SPACING_MARK)),
    Mark_Enclosing = ((uint32_t)1<<(U_ENCLOSING_MARK)),
    Mark_SpacingCombining = ((uint32_t)1<<(U_COMBINING_SPACING_MARK)),

    Number_DecimalDigit = ((uint32_t)1<<(U_DECIMAL_DIGIT_NUMBER)),
    Number_Letter = ((uint32_t)1<<(U_LETTER_NUMBER)),
    Number_Other = ((uint32_t)1<<(U_OTHER_NUMBER)),

    Separator_Space = ((uint32_t)1<<(U_SPACE_SEPARATOR)),
    Separator_Line = ((uint32_t)1<<(U_LINE_SEPARATOR)),
    Separator_Paragraph = ((uint32_t)1<<(U_PARAGRAPH_SEPARATOR)),

    Other_Control = ((uint32_t)1<<(U_CONTROL_CHAR)),
    Other_Format = ((uint32_t)1<<(U_FORMAT_CHAR)),
    Other_PrivateUse = ((uint32_t)1<<(U_PRIVATE_USE_CHAR)),
    Other_Surrogate = ((uint32_t)1<<(U_SURROGATE)),

    Punctuation_Dash = ((uint32_t)1<<(U_DASH_PUNCTUATION)),
    Punctuation_Open = ((uint32_t)1<<(U_START_PUNCTUATION)),
    Punctuation_Close = ((uint32_t)1<<(U_END_PUNCTUATION)),
    Punctuation_Connector = ((uint32_t)1<<(U_CONNECTOR_PUNCTUATION)),
    Punctuation_Other = ((uint32_t)1<<(U_OTHER_PUNCTUATION)),

    Symbol_Math = ((uint32_t)1<<(U_MATH_SYMBOL)),
    Symbol_Currency = ((uint32_t)1<<(U_CURRENCY_SYMBOL)),
    Symbol_Modifier = ((uint32_t)1<<(U_MODIFIER_SYMBOL)),
    Symbol_Other = ((uint32_t)1<<(U_OTHER_SYMBOL)),

    Punctuation_InitialQuote = ((uint32_t)1<<(U_INITIAL_PUNCTUATION)),
    Punctuation_FinalQuote = ((uint32_t)1<<(U_FINAL_PUNCTUATION))
};

inline UChar32 foldCase(UChar32 c)
{
    return u_foldCase(c, 0);
}

inline int foldCase(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)
{
    UErrorCode status = U_ZERO_ERROR;
    int realLength = u_strFoldCase(result, resultLength, src, srcLength, 0, &status);
    *error = !U_SUCCESS(status);
    return realLength;
}

inline int toLower(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)
{
    UErrorCode status = U_ZERO_ERROR;
    int realLength = u_strToLower(result, resultLength, src, srcLength, "", &status);
    *error = !!U_FAILURE(status);
    return realLength;
}

inline UChar32 toLower(UChar32 c)
{
    return u_tolower(c);
}

inline UChar32 toUpper(UChar32 c)
{
    return u_toupper(c);
}

inline int toUpper(UChar* result, int resultLength, const UChar* src, int srcLength, bool* error)
{
    UErrorCode status = U_ZERO_ERROR;
    int realLength = u_strToUpper(result, resultLength, src, srcLength, "", &status);
    *error = !!U_FAILURE(status);
    return realLength;
}

inline UChar32 toTitleCase(UChar32 c)
{
    return u_totitle(c);
}

inline bool isArabicChar(UChar32 c)
{
      return ublock_getCode(c) == UBLOCK_ARABIC;
}

inline bool isAlphanumeric(UChar32 c)
{
    return u_isalnum(c);
}

inline bool isSeparatorSpace(UChar32 c)
{
    return u_charType(c) == U_SPACE_SEPARATOR;
}

inline bool isPrintableChar(UChar32 c)
{
    return !!u_isprint(c);
}

inline bool isPunct(UChar32 c)
{
    return !!u_ispunct(c);
}

inline bool hasLineBreakingPropertyComplexContext(UChar32 c)
{
    return u_getIntPropertyValue(c, UCHAR_LINE_BREAK) == U_LB_COMPLEX_CONTEXT;
}

inline bool hasLineBreakingPropertyComplexContextOrIdeographic(UChar32 c)
{
    int32_t prop = u_getIntPropertyValue(c, UCHAR_LINE_BREAK);
    return prop == U_LB_COMPLEX_CONTEXT || prop == U_LB_IDEOGRAPHIC;
}

inline UChar32 mirroredChar(UChar32 c)
{
    return u_charMirror(c);
}

inline CharCategory category(UChar32 c)
{
    return static_cast<CharCategory>(((uint32_t)1<<(u_charType(c))));
}

inline Direction direction(UChar32 c)
{
    return static_cast<Direction>(u_charDirection(c));
}

inline bool isLower(UChar32 c)
{
    return !!u_islower(c);
}

inline uint8_t combiningClass(UChar32 c)
{
    return u_getCombiningClass(c);
}

inline DecompositionType decompositionType(UChar32 c)
{
    return static_cast<DecompositionType>(u_getIntPropertyValue(c, UCHAR_DECOMPOSITION_TYPE));
}

inline int umemcasecmp(const UChar* a, const UChar* b, int len)
{
    return u_memcasecmp(a, b, len, 0);
}

} }
# 32 "./wtf/unicode/Unicode.h" 2








typedef int dummyUCharIsTwoBytes [(sizeof(UChar) == 2) ? 1 : -1];
# 25 "./wtf/StringHasher.h" 2

namespace WTF {


static const unsigned stringHashingStartValue = 0x9e3779b9U;







class StringHasher {
public:
    static const unsigned flagCount = 8;

    inline StringHasher()
        : m_hash(stringHashingStartValue)
        , m_hasPendingCharacter(false)
        , m_pendingCharacter(0)
    {
    }

    inline void addCharacters(UChar a, UChar b)
    {
        ((void)0);
        addCharactersToHash(a, b);
    }

    inline void addCharacter(UChar ch)
    {
        if (m_hasPendingCharacter) {
            addCharactersToHash(m_pendingCharacter, ch);
            m_hasPendingCharacter = false;
            return;
        }

        m_pendingCharacter = ch;
        m_hasPendingCharacter = true;
    }

    inline unsigned hash() const
    {
        unsigned result = m_hash;


        if (m_hasPendingCharacter) {
            result += m_pendingCharacter;
            result ^= result << 11;
            result += result >> 17;
        }


        result ^= result << 3;
        result += result >> 5;
        result ^= result << 2;
        result += result >> 15;
        result ^= result << 10;



        result &= (1u << (sizeof(result) * 8 - flagCount)) - 1;





        if (!result)
            result = 0x80000000 >> flagCount;

        return result;
    }

    template<typename T, UChar Converter(T)> static inline unsigned computeHash(const T* data, unsigned length)
    {
        StringHasher hasher;
        bool rem = length & 1;
        length >>= 1;

        while (length--) {
            hasher.addCharacters(Converter(data[0]), Converter(data[1]));
            data += 2;
        }

        if (rem)
            hasher.addCharacter(Converter(*data));

        return hasher.hash();
    }

    template<typename T, UChar Converter(T)> static inline unsigned computeHash(const T* data)
    {
        StringHasher hasher;

        while (true) {
            UChar b0 = Converter(*data++);
            if (!b0)
                break;
            UChar b1 = Converter(*data++);
            if (!b1) {
                hasher.addCharacter(b0);
                break;
            }

            hasher.addCharacters(b0, b1);
        }

        return hasher.hash();
    }

    template<typename T> static inline unsigned computeHash(const T* data, unsigned length)
    {
        return computeHash<T, defaultCoverter>(data, length);
    }

    template<typename T> static inline unsigned computeHash(const T* data)
    {
        return computeHash<T, defaultCoverter>(data);
    }

    template<size_t length> static inline unsigned hashMemory(const void* data)
    {
        typedef int dummylength_must_be_a_multible_of_four [(!(length % 4)) ? 1 : -1];
        return computeHash<UChar>(static_cast<const UChar*>(data), length / sizeof(UChar));
    }

    static inline unsigned hashMemory(const void* data, unsigned size)
    {
        ((void)0);
        return computeHash<UChar>(static_cast<const UChar*>(data), size / sizeof(UChar));
    }

private:
    static inline UChar defaultCoverter(UChar ch)
    {
        return ch;
    }

    static inline UChar defaultCoverter(char ch)
    {
        return static_cast<unsigned char>(ch);
    }

    inline void addCharactersToHash(UChar a, UChar b)
    {
        m_hash += a;
        unsigned tmp = (b << 11) ^ m_hash;
        m_hash = (m_hash << 16) ^ tmp;
        m_hash += m_hash >> 11;
    }

    unsigned m_hash;
    bool m_hasPendingCharacter;
    UChar m_pendingCharacter;
};

}

using WTF::StringHasher;
# 32 "./wtf/text/StringImpl.h" 2
# 1 "./wtf/Vector.h" 1
# 26 "./wtf/Vector.h"
# 1 "./wtf/NotFound.h" 1
# 29 "./wtf/NotFound.h"
namespace WTF {

    const size_t notFound = static_cast<size_t>(-1);

}

using WTF::notFound;
# 27 "./wtf/Vector.h" 2


# 1 "./wtf/VectorTraits.h" 1
# 24 "./wtf/VectorTraits.h"
# 1 "./wtf/OwnPtr.h" 1
# 26 "./wtf/OwnPtr.h"
# 1 "./wtf/OwnPtrCommon.h" 1
# 47 "./wtf/OwnPtrCommon.h"
namespace WTF {

    template <typename T> inline void deleteOwnedPtr(T* ptr)
    {
        typedef char known[sizeof(T) ? 1 : -1];
        if (sizeof(known))
            delete ptr;
    }
# 72 "./wtf/OwnPtrCommon.h"
}
# 27 "./wtf/OwnPtr.h" 2




namespace WTF {



    template<typename T> class PassOwnPtr;
    template<typename T> PassOwnPtr<T> adoptPtr(T*);

    template<typename T> class OwnPtr {
    public:
        typedef typename RemovePointer<T>::Type ValueType;
        typedef ValueType* PtrType;

        OwnPtr() : m_ptr(0) { }


        template<typename U> OwnPtr(const PassOwnPtr<U>& o);





        OwnPtr(const OwnPtr<ValueType>&);

        ~OwnPtr() { deleteOwnedPtr(m_ptr); }

        PtrType get() const { return m_ptr; }

        void clear();
        PassOwnPtr<T> release();
        PtrType leakPtr() __attribute__ ((warn_unused_result));

        ValueType& operator*() const { ((void)0); return *m_ptr; }
        PtrType operator->() const { ((void)0); return m_ptr; }

        bool operator!() const { return !m_ptr; }


        typedef PtrType OwnPtr::*UnspecifiedBoolType;
        operator UnspecifiedBoolType() const { return m_ptr ? &OwnPtr::m_ptr : 0; }

        OwnPtr& operator=(const PassOwnPtr<T>&);
        OwnPtr& operator=(std::nullptr_t) { clear(); return *this; }
        template<typename U> OwnPtr& operator=(const PassOwnPtr<U>&);

        void swap(OwnPtr& o) { std::swap(m_ptr, o.m_ptr); }

    private:
        OwnPtr& operator=(const OwnPtr<T>&);



        template<typename U> bool operator==(const OwnPtr<U>&) { typedef int dummyOwnPtrs_should_never_be_equal [(!sizeof(U*)) ? 1 : -1]; return false; }
        template<typename U> bool operator!=(const OwnPtr<U>&) { typedef int dummyOwnPtrs_should_never_be_equal [(!sizeof(U*)) ? 1 : -1]; return false; }
        template<typename U> bool operator==(const PassOwnPtr<U>&) { typedef int dummyOwnPtrs_should_never_be_equal [(!sizeof(U*)) ? 1 : -1]; return false; }
        template<typename U> bool operator!=(const PassOwnPtr<U>&) { typedef int dummyOwnPtrs_should_never_be_equal [(!sizeof(U*)) ? 1 : -1]; return false; }

        PtrType m_ptr;
    };

    template<typename T> template<typename U> inline OwnPtr<T>::OwnPtr(const PassOwnPtr<U>& o)
        : m_ptr(o.leakPtr())
    {
    }

    template<typename T> inline void OwnPtr<T>::clear()
    {
        PtrType ptr = m_ptr;
        m_ptr = 0;
        deleteOwnedPtr(ptr);
    }

    template<typename T> inline PassOwnPtr<T> OwnPtr<T>::release()
    {
        PtrType ptr = m_ptr;
        m_ptr = 0;
        return adoptPtr(ptr);
    }

    template<typename T> inline typename OwnPtr<T>::PtrType OwnPtr<T>::leakPtr()
    {
        PtrType ptr = m_ptr;
        m_ptr = 0;
        return ptr;
    }

    template<typename T> inline OwnPtr<T>& OwnPtr<T>::operator=(const PassOwnPtr<T>& o)
    {
        PtrType ptr = m_ptr;
        m_ptr = o.leakPtr();
        ((void)0);
        deleteOwnedPtr(ptr);
        return *this;
    }

    template<typename T> template<typename U> inline OwnPtr<T>& OwnPtr<T>::operator=(const PassOwnPtr<U>& o)
    {
        PtrType ptr = m_ptr;
        m_ptr = o.leakPtr();
        ((void)0);
        deleteOwnedPtr(ptr);
        return *this;
    }

    template<typename T> inline void swap(OwnPtr<T>& a, OwnPtr<T>& b)
    {
        a.swap(b);
    }

    template<typename T, typename U> inline bool operator==(const OwnPtr<T>& a, U* b)
    {
        return a.get() == b;
    }

    template<typename T, typename U> inline bool operator==(T* a, const OwnPtr<U>& b)
    {
        return a == b.get();
    }

    template<typename T, typename U> inline bool operator!=(const OwnPtr<T>& a, U* b)
    {
        return a.get() != b;
    }

    template<typename T, typename U> inline bool operator!=(T* a, const OwnPtr<U>& b)
    {
        return a != b.get();
    }

    template<typename T> inline typename OwnPtr<T>::PtrType getPtr(const OwnPtr<T>& p)
    {
        return p.get();
    }

}

using WTF::OwnPtr;
# 25 "./wtf/VectorTraits.h" 2





using std::pair;

namespace WTF {

    template<bool isPod, typename T>
    struct VectorTraitsBase;

    template<typename T>
    struct VectorTraitsBase<false, T>
    {
        static const bool needsDestruction = true;
        static const bool needsInitialization = true;
        static const bool canInitializeWithMemset = false;
        static const bool canMoveWithMemcpy = false;
        static const bool canCopyWithMemcpy = false;
        static const bool canFillWithMemset = false;
        static const bool canCompareWithMemcmp = false;
    };

    template<typename T>
    struct VectorTraitsBase<true, T>
    {
        static const bool needsDestruction = false;
        static const bool needsInitialization = false;
        static const bool canInitializeWithMemset = false;
        static const bool canMoveWithMemcpy = true;
        static const bool canCopyWithMemcpy = true;
        static const bool canFillWithMemset = sizeof(T) == sizeof(char);
        static const bool canCompareWithMemcmp = true;
    };

    template<typename T>
    struct VectorTraits : VectorTraitsBase<IsPod<T>::value, T> { };

    struct SimpleClassVectorTraits : VectorTraitsBase<false, void>
    {
        static const bool canInitializeWithMemset = true;
        static const bool canMoveWithMemcpy = true;
        static const bool canCompareWithMemcmp = true;
    };



    template<typename P>
    struct VectorTraits<RefPtr<P> > : SimpleClassVectorTraits { };

    template<typename P>
    struct VectorTraits<OwnPtr<P> > : SimpleClassVectorTraits { };

    template<typename First, typename Second>
    struct VectorTraits<pair<First, Second> >
    {
        typedef VectorTraits<First> FirstTraits;
        typedef VectorTraits<Second> SecondTraits;

        static const bool needsDestruction = FirstTraits::needsDestruction || SecondTraits::needsDestruction;
        static const bool needsInitialization = FirstTraits::needsInitialization || SecondTraits::needsInitialization;
        static const bool canInitializeWithMemset = FirstTraits::canInitializeWithMemset && SecondTraits::canInitializeWithMemset;
        static const bool canMoveWithMemcpy = FirstTraits::canMoveWithMemcpy && SecondTraits::canMoveWithMemcpy;
        static const bool canCopyWithMemcpy = FirstTraits::canCopyWithMemcpy && SecondTraits::canCopyWithMemcpy;
        static const bool canFillWithMemset = false;
        static const bool canCompareWithMemcmp = FirstTraits::canCompareWithMemcmp && SecondTraits::canCompareWithMemcmp;
    };

}

using WTF::VectorTraits;
using WTF::SimpleClassVectorTraits;
# 30 "./wtf/Vector.h" 2


# 1 "./wtf/Alignment.h" 1
# 33 "./wtf/Vector.h" 2





namespace WTF {

    using std::min;
    using std::max;


        typedef char __attribute__((__may_alias__)) AlignedBufferChar;




    template <size_t size, size_t alignment> struct AlignedBuffer;
    template <size_t size> struct AlignedBuffer<size, 1> { AlignedBufferChar buffer[size]; };
    template <size_t size> struct AlignedBuffer<size, 2> { AlignedBufferChar buffer[size] __attribute__((__aligned__(2))); };
    template <size_t size> struct AlignedBuffer<size, 4> { AlignedBufferChar buffer[size] __attribute__((__aligned__(4))); };
    template <size_t size> struct AlignedBuffer<size, 8> { AlignedBufferChar buffer[size] __attribute__((__aligned__(8))); };
    template <size_t size> struct AlignedBuffer<size, 16> { AlignedBufferChar buffer[size] __attribute__((__aligned__(16))); };
    template <size_t size> struct AlignedBuffer<size, 32> { AlignedBufferChar buffer[size] __attribute__((__aligned__(32))); };
    template <size_t size> struct AlignedBuffer<size, 64> { AlignedBufferChar buffer[size] __attribute__((__aligned__(64))); };

    template <size_t size, size_t alignment>
    void swap(AlignedBuffer<size, alignment>& a, AlignedBuffer<size, alignment>& b)
    {
        for (size_t i = 0; i < size; ++i)
            std::swap(a.buffer[i], b.buffer[i]);
    }

    template <bool needsDestruction, typename T>
    struct VectorDestructor;

    template<typename T>
    struct VectorDestructor<false, T>
    {
        static void destruct(T*, T*) {}
    };

    template<typename T>
    struct VectorDestructor<true, T>
    {
        static void destruct(T* begin, T* end)
        {
            for (T* cur = begin; cur != end; ++cur)
                cur->~T();
        }
    };

    template <bool needsInitialization, bool canInitializeWithMemset, typename T>
    struct VectorInitializer;

    template<bool ignore, typename T>
    struct VectorInitializer<false, ignore, T>
    {
        static void initialize(T*, T*) {}
    };

    template<typename T>
    struct VectorInitializer<true, false, T>
    {
        static void initialize(T* begin, T* end)
        {
            for (T* cur = begin; cur != end; ++cur)
                new (cur) T;
        }
    };

    template<typename T>
    struct VectorInitializer<true, true, T>
    {
        static void initialize(T* begin, T* end)
        {
            memset(begin, 0, reinterpret_cast<char*>(end) - reinterpret_cast<char*>(begin));
        }
    };

    template <bool canMoveWithMemcpy, typename T>
    struct VectorMover;

    template<typename T>
    struct VectorMover<false, T>
    {
        static void move(const T* src, const T* srcEnd, T* dst)
        {
            while (src != srcEnd) {
                new (dst) T(*src);



                src->~T();

                ++dst;
                ++src;
            }
        }
        static void moveOverlapping(const T* src, const T* srcEnd, T* dst)
        {
            if (src > dst)
                move(src, srcEnd, dst);
            else {
                T* dstEnd = dst + (srcEnd - src);
                while (src != srcEnd) {
                    --srcEnd;
                    --dstEnd;
                    new (dstEnd) T(*srcEnd);
                    srcEnd->~T();
                }
            }
        }
    };

    template<typename T>
    struct VectorMover<true, T>
    {
        static void move(const T* src, const T* srcEnd, T* dst)
        {
            memcpy(dst, src, reinterpret_cast<const char*>(srcEnd) - reinterpret_cast<const char*>(src));
        }
        static void moveOverlapping(const T* src, const T* srcEnd, T* dst)
        {
            memmove(dst, src, reinterpret_cast<const char*>(srcEnd) - reinterpret_cast<const char*>(src));
        }
    };

    template <bool canCopyWithMemcpy, typename T>
    struct VectorCopier;

    template<typename T>
    struct VectorCopier<false, T>
    {
        static void uninitializedCopy(const T* src, const T* srcEnd, T* dst)
        {
            while (src != srcEnd) {
                new (dst) T(*src);
                ++dst;
                ++src;
            }
        }
    };

    template<typename T>
    struct VectorCopier<true, T>
    {
        static void uninitializedCopy(const T* src, const T* srcEnd, T* dst)
        {
            memcpy(dst, src, reinterpret_cast<const char*>(srcEnd) - reinterpret_cast<const char*>(src));
        }
    };

    template <bool canFillWithMemset, typename T>
    struct VectorFiller;

    template<typename T>
    struct VectorFiller<false, T>
    {
        static void uninitializedFill(T* dst, T* dstEnd, const T& val)
        {
            while (dst != dstEnd) {
                new (dst) T(val);
                ++dst;
            }
        }
    };

    template<typename T>
    struct VectorFiller<true, T>
    {
        static void uninitializedFill(T* dst, T* dstEnd, const T& val)
        {
            ((void)0);
            memset(dst, val, dstEnd - dst);
        }
    };

    template<bool canCompareWithMemcmp, typename T>
    struct VectorComparer;

    template<typename T>
    struct VectorComparer<false, T>
    {
        static bool compare(const T* a, const T* b, size_t size)
        {
            for (size_t i = 0; i < size; ++i)
                if (a[i] != b[i])
                    return false;
            return true;
        }
    };

    template<typename T>
    struct VectorComparer<true, T>
    {
        static bool compare(const T* a, const T* b, size_t size)
        {
            return memcmp(a, b, sizeof(T) * size) == 0;
        }
    };

    template<typename T>
    struct VectorTypeOperations
    {
        static void destruct(T* begin, T* end)
        {
            VectorDestructor<VectorTraits<T>::needsDestruction, T>::destruct(begin, end);
        }

        static void initialize(T* begin, T* end)
        {
            VectorInitializer<VectorTraits<T>::needsInitialization, VectorTraits<T>::canInitializeWithMemset, T>::initialize(begin, end);
        }

        static void move(const T* src, const T* srcEnd, T* dst)
        {
            VectorMover<VectorTraits<T>::canMoveWithMemcpy, T>::move(src, srcEnd, dst);
        }

        static void moveOverlapping(const T* src, const T* srcEnd, T* dst)
        {
            VectorMover<VectorTraits<T>::canMoveWithMemcpy, T>::moveOverlapping(src, srcEnd, dst);
        }

        static void uninitializedCopy(const T* src, const T* srcEnd, T* dst)
        {
            VectorCopier<VectorTraits<T>::canCopyWithMemcpy, T>::uninitializedCopy(src, srcEnd, dst);
        }

        static void uninitializedFill(T* dst, T* dstEnd, const T& val)
        {
            VectorFiller<VectorTraits<T>::canFillWithMemset, T>::uninitializedFill(dst, dstEnd, val);
        }

        static bool compare(const T* a, const T* b, size_t size)
        {
            return VectorComparer<VectorTraits<T>::canCompareWithMemcmp, T>::compare(a, b, size);
        }
    };

    template<typename T>
    class VectorBufferBase {
        private: VectorBufferBase(const VectorBufferBase&); VectorBufferBase& operator=(const VectorBufferBase&);
    public:
        void allocateBuffer(size_t newCapacity)
        {
            ((void)0);
            m_capacity = newCapacity;
            if (newCapacity > std::numeric_limits<size_t>::max() / sizeof(T))
                do { WTFReportBacktrace(); *(int *)(uintptr_t)0xbbadbeef = 0; __builtin_trap(); } while (false);
            m_buffer = static_cast<T*>(fastMalloc(newCapacity * sizeof(T)));
        }

        bool tryAllocateBuffer(size_t newCapacity)
        {
            ((void)0);
            if (newCapacity > std::numeric_limits<size_t>::max() / sizeof(T))
                return false;

            T* newBuffer;
            if (tryFastMalloc(newCapacity * sizeof(T)).getValue(newBuffer)) {
                m_capacity = newCapacity;
                m_buffer = newBuffer;
                return true;
            }
            return false;
        }

        void deallocateBuffer(T* bufferToDeallocate)
        {
            if (m_buffer == bufferToDeallocate) {
                m_buffer = 0;
                m_capacity = 0;
            }
            fastFree(bufferToDeallocate);
        }

        T* buffer() { return m_buffer; }
        const T* buffer() const { return m_buffer; }
        T** bufferSlot() { return &m_buffer; }
        size_t capacity() const { return m_capacity; }

        T* releaseBuffer()
        {
            T* buffer = m_buffer;
            m_buffer = 0;
            m_capacity = 0;
            return buffer;
        }

    protected:
        VectorBufferBase()
            : m_buffer(0)
            , m_capacity(0)
        {
        }

        VectorBufferBase(T* buffer, size_t capacity)
            : m_buffer(buffer)
            , m_capacity(capacity)
        {
        }

        ~VectorBufferBase()
        {

        }

        T* m_buffer;
        size_t m_capacity;
    };

    template<typename T, size_t inlineCapacity>
    class VectorBuffer;

    template<typename T>
    class VectorBuffer<T, 0> : private VectorBufferBase<T> {
    private:
        typedef VectorBufferBase<T> Base;
    public:
        VectorBuffer()
        {
        }

        VectorBuffer(size_t capacity)
        {


            if (capacity)
                allocateBuffer(capacity);
        }

        ~VectorBuffer()
        {
            deallocateBuffer(buffer());
        }

        void swap(VectorBuffer<T, 0>& other)
        {
            std::swap(m_buffer, other.m_buffer);
            std::swap(m_capacity, other.m_capacity);
        }

        void restoreInlineBufferIfNeeded() { }

        using Base::allocateBuffer;
        using Base::tryAllocateBuffer;
        using Base::deallocateBuffer;

        using Base::buffer;
        using Base::bufferSlot;
        using Base::capacity;

        using Base::releaseBuffer;
    private:
        using Base::m_buffer;
        using Base::m_capacity;
    };

    template<typename T, size_t inlineCapacity>
    class VectorBuffer : private VectorBufferBase<T> {
        private: VectorBuffer(const VectorBuffer&); VectorBuffer& operator=(const VectorBuffer&);
    private:
        typedef VectorBufferBase<T> Base;
    public:
        VectorBuffer()
            : Base(inlineBuffer(), inlineCapacity)
        {
        }

        VectorBuffer(size_t capacity)
            : Base(inlineBuffer(), inlineCapacity)
        {
            if (capacity > inlineCapacity)
                Base::allocateBuffer(capacity);
        }

        ~VectorBuffer()
        {
            deallocateBuffer(buffer());
        }

        void allocateBuffer(size_t newCapacity)
        {

            if (newCapacity > inlineCapacity)
                Base::allocateBuffer(newCapacity);
            else {
                m_buffer = inlineBuffer();
                m_capacity = inlineCapacity;
            }
        }

        bool tryAllocateBuffer(size_t newCapacity)
        {
            if (newCapacity > inlineCapacity)
                return Base::tryAllocateBuffer(newCapacity);
            m_buffer = inlineBuffer();
            m_capacity = inlineCapacity;
            return true;
        }

        void deallocateBuffer(T* bufferToDeallocate)
        {
            if (bufferToDeallocate == inlineBuffer())
                return;
            Base::deallocateBuffer(bufferToDeallocate);
        }

        void swap(VectorBuffer<T, inlineCapacity>& other)
        {
            if (buffer() == inlineBuffer() && other.buffer() == other.inlineBuffer()) {
                WTF::swap(m_inlineBuffer, other.m_inlineBuffer);
                std::swap(m_capacity, other.m_capacity);
            } else if (buffer() == inlineBuffer()) {
                m_buffer = other.m_buffer;
                other.m_buffer = other.inlineBuffer();
                WTF::swap(m_inlineBuffer, other.m_inlineBuffer);
                std::swap(m_capacity, other.m_capacity);
            } else if (other.buffer() == other.inlineBuffer()) {
                other.m_buffer = m_buffer;
                m_buffer = inlineBuffer();
                WTF::swap(m_inlineBuffer, other.m_inlineBuffer);
                std::swap(m_capacity, other.m_capacity);
            } else {
                std::swap(m_buffer, other.m_buffer);
                std::swap(m_capacity, other.m_capacity);
            }
        }

        void restoreInlineBufferIfNeeded()
        {
            if (m_buffer)
                return;
            m_buffer = inlineBuffer();
            m_capacity = inlineCapacity;
        }

        using Base::buffer;
        using Base::bufferSlot;
        using Base::capacity;

        T* releaseBuffer()
        {
            if (buffer() == inlineBuffer())
                return 0;
            return Base::releaseBuffer();
        }

    private:
        using Base::m_buffer;
        using Base::m_capacity;

        static const size_t m_inlineBufferSize = inlineCapacity * sizeof(T);
        T* inlineBuffer() { return reinterpret_cast<T*>(m_inlineBuffer.buffer); }

        AlignedBuffer<m_inlineBufferSize, __alignof__(T)> m_inlineBuffer;
    };

    template<typename T, size_t inlineCapacity = 0>
    class Vector {
        public: void* operator new(size_t, void* p) { return p; } void* operator new[](size_t, void* p) { return p; } void* operator new(size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNew); return p; } void operator delete(void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNew); ::WTF::fastFree(p); } void* operator new[](size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNewArray); return p; } void operator delete[](void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNewArray); ::WTF::fastFree(p); } private: typedef int ThisIsHereToForceASemicolonAfterThisMacro;
    private:
        typedef VectorBuffer<T, inlineCapacity> Buffer;
        typedef VectorTypeOperations<T> TypeOperations;

    public:
        typedef T ValueType;

        typedef T* iterator;
        typedef const T* const_iterator;

        Vector()
            : m_size(0)
        {
        }

        explicit Vector(size_t size)
            : m_size(size)
            , m_buffer(size)
        {
            if (begin())
                TypeOperations::initialize(begin(), end());
        }

        ~Vector()
        {
            if (m_size) shrink(0);
        }

        Vector(const Vector&);
        template<size_t otherCapacity>
        Vector(const Vector<T, otherCapacity>&);

        Vector& operator=(const Vector&);
        template<size_t otherCapacity>
        Vector& operator=(const Vector<T, otherCapacity>&);

        size_t size() const { return m_size; }
        size_t capacity() const { return m_buffer.capacity(); }
        bool isEmpty() const { return !size(); }

        T& at(size_t i)
        {
            ((void)0);
            return m_buffer.buffer()[i];
        }
        const T& at(size_t i) const
        {
            ((void)0);
            return m_buffer.buffer()[i];
        }

        T& operator[](size_t i) { return at(i); }
        const T& operator[](size_t i) const { return at(i); }

        T* data() { return m_buffer.buffer(); }
        const T* data() const { return m_buffer.buffer(); }
        T** dataSlot() { return m_buffer.bufferSlot(); }

        iterator begin() { return data(); }
        iterator end() { return begin() + m_size; }
        const_iterator begin() const { return data(); }
        const_iterator end() const { return begin() + m_size; }

        T& first() { return at(0); }
        const T& first() const { return at(0); }
        T& last() { return at(size() - 1); }
        const T& last() const { return at(size() - 1); }

        template<typename U> bool contains(const U&) const;
        template<typename U> size_t find(const U&) const;
        template<typename U> size_t reverseFind(const U&) const;

        void shrink(size_t size);
        void grow(size_t size);
        void resize(size_t size);
        void reserveCapacity(size_t newCapacity);
        bool tryReserveCapacity(size_t newCapacity);
        void reserveInitialCapacity(size_t initialCapacity);
        void shrinkCapacity(size_t newCapacity);
        void shrinkToFit() { shrinkCapacity(size()); }

        void clear() { shrinkCapacity(0); }

        template<typename U> void append(const U*, size_t);
        template<typename U> void append(const U&);
        template<typename U> void uncheckedAppend(const U& val);
        template<size_t otherCapacity> void append(const Vector<T, otherCapacity>&);
        template<typename U> bool tryAppend(const U*, size_t);

        template<typename U> void insert(size_t position, const U*, size_t);
        template<typename U> void insert(size_t position, const U&);
        template<typename U, size_t c> void insert(size_t position, const Vector<U, c>&);

        template<typename U> void prepend(const U*, size_t);
        template<typename U> void prepend(const U&);
        template<typename U, size_t c> void prepend(const Vector<U, c>&);

        void remove(size_t position);
        void remove(size_t position, size_t length);

        void removeLast()
        {
            ((void)0);
            shrink(size() - 1);
        }

        Vector(size_t size, const T& val)
            : m_size(size)
            , m_buffer(size)
        {
            if (begin())
                TypeOperations::uninitializedFill(begin(), end(), val);
        }

        void fill(const T&, size_t);
        void fill(const T& val) { fill(val, size()); }

        template<typename Iterator> void appendRange(Iterator start, Iterator end);

        T* releaseBuffer();

        void swap(Vector<T, inlineCapacity>& other)
        {
            std::swap(m_size, other.m_size);
            m_buffer.swap(other.m_buffer);
        }

        void reverse();

        void checkConsistency();

    private:
        void expandCapacity(size_t newMinCapacity);
        const T* expandCapacity(size_t newMinCapacity, const T*);
        bool tryExpandCapacity(size_t newMinCapacity);
        const T* tryExpandCapacity(size_t newMinCapacity, const T*);
        template<typename U> U* expandCapacity(size_t newMinCapacity, U*);

        size_t m_size;
        Buffer m_buffer;
    };
# 663 "./wtf/Vector.h"
    template<typename T, size_t inlineCapacity>
    Vector<T, inlineCapacity>::Vector(const Vector& other)
        : m_size(other.size())
        , m_buffer(other.capacity())
    {
        if (begin())
            TypeOperations::uninitializedCopy(other.begin(), other.end(), begin());
    }

    template<typename T, size_t inlineCapacity>
    template<size_t otherCapacity>
    Vector<T, inlineCapacity>::Vector(const Vector<T, otherCapacity>& other)
        : m_size(other.size())
        , m_buffer(other.capacity())
    {
        if (begin())
            TypeOperations::uninitializedCopy(other.begin(), other.end(), begin());
    }

    template<typename T, size_t inlineCapacity>
    Vector<T, inlineCapacity>& Vector<T, inlineCapacity>::operator=(const Vector<T, inlineCapacity>& other)
    {
        if (&other == this)
            return *this;

        if (size() > other.size())
            shrink(other.size());
        else if (other.size() > capacity()) {
            clear();
            reserveCapacity(other.size());
            if (!begin())
                return *this;
        }







        std::copy(other.begin(), other.begin() + size(), begin());
        TypeOperations::uninitializedCopy(other.begin() + size(), other.end(), end());
        m_size = other.size();

        return *this;
    }

    inline bool typelessPointersAreEqual(const void* a, const void* b) { return a == b; }

    template<typename T, size_t inlineCapacity>
    template<size_t otherCapacity>
    Vector<T, inlineCapacity>& Vector<T, inlineCapacity>::operator=(const Vector<T, otherCapacity>& other)
    {



        ((void)0);

        if (size() > other.size())
            shrink(other.size());
        else if (other.size() > capacity()) {
            clear();
            reserveCapacity(other.size());
            if (!begin())
                return *this;
        }







        std::copy(other.begin(), other.begin() + size(), begin());
        TypeOperations::uninitializedCopy(other.begin() + size(), other.end(), end());
        m_size = other.size();

        return *this;
    }

    template<typename T, size_t inlineCapacity>
    template<typename U>
    bool Vector<T, inlineCapacity>::contains(const U& value) const
    {
        return find(value) != notFound;
    }

    template<typename T, size_t inlineCapacity>
    template<typename U>
    size_t Vector<T, inlineCapacity>::find(const U& value) const
    {
        for (size_t i = 0; i < size(); ++i) {
            if (at(i) == value)
                return i;
        }
        return notFound;
    }

    template<typename T, size_t inlineCapacity>
    template<typename U>
    size_t Vector<T, inlineCapacity>::reverseFind(const U& value) const
    {
        for (size_t i = 1; i <= size(); ++i) {
            const size_t index = size() - i;
            if (at(index) == value)
                return index;
        }
        return notFound;
    }

    template<typename T, size_t inlineCapacity>
    void Vector<T, inlineCapacity>::fill(const T& val, size_t newSize)
    {
        if (size() > newSize)
            shrink(newSize);
        else if (newSize > capacity()) {
            clear();
            reserveCapacity(newSize);
            if (!begin())
                return;
        }

        std::fill(begin(), end(), val);
        TypeOperations::uninitializedFill(end(), begin() + newSize, val);
        m_size = newSize;
    }

    template<typename T, size_t inlineCapacity>
    template<typename Iterator>
    void Vector<T, inlineCapacity>::appendRange(Iterator start, Iterator end)
    {
        for (Iterator it = start; it != end; ++it)
            append(*it);
    }

    template<typename T, size_t inlineCapacity>
    void Vector<T, inlineCapacity>::expandCapacity(size_t newMinCapacity)
    {
        reserveCapacity(max(newMinCapacity, max(static_cast<size_t>(16), capacity() + capacity() / 4 + 1)));
    }

    template<typename T, size_t inlineCapacity>
    const T* Vector<T, inlineCapacity>::expandCapacity(size_t newMinCapacity, const T* ptr)
    {
        if (ptr < begin() || ptr >= end()) {
            expandCapacity(newMinCapacity);
            return ptr;
        }
        size_t index = ptr - begin();
        expandCapacity(newMinCapacity);
        return begin() + index;
    }

    template<typename T, size_t inlineCapacity>
    bool Vector<T, inlineCapacity>::tryExpandCapacity(size_t newMinCapacity)
    {
        return tryReserveCapacity(max(newMinCapacity, max(static_cast<size_t>(16), capacity() + capacity() / 4 + 1)));
    }

    template<typename T, size_t inlineCapacity>
    const T* Vector<T, inlineCapacity>::tryExpandCapacity(size_t newMinCapacity, const T* ptr)
    {
        if (ptr < begin() || ptr >= end()) {
            if (!tryExpandCapacity(newMinCapacity))
                return 0;
            return ptr;
        }
        size_t index = ptr - begin();
        if (!tryExpandCapacity(newMinCapacity))
            return 0;
        return begin() + index;
    }

    template<typename T, size_t inlineCapacity> template<typename U>
    inline U* Vector<T, inlineCapacity>::expandCapacity(size_t newMinCapacity, U* ptr)
    {
        expandCapacity(newMinCapacity);
        return ptr;
    }

    template<typename T, size_t inlineCapacity>
    inline void Vector<T, inlineCapacity>::resize(size_t size)
    {
        if (size <= m_size)
            TypeOperations::destruct(begin() + size, end());
        else {
            if (size > capacity())
                expandCapacity(size);
            if (begin())
                TypeOperations::initialize(end(), begin() + size);
        }

        m_size = size;
    }

    template<typename T, size_t inlineCapacity>
    void Vector<T, inlineCapacity>::shrink(size_t size)
    {
        ((void)0);
        TypeOperations::destruct(begin() + size, end());
        m_size = size;
    }

    template<typename T, size_t inlineCapacity>
    void Vector<T, inlineCapacity>::grow(size_t size)
    {
        ((void)0);
        if (size > capacity())
            expandCapacity(size);
        if (begin())
            TypeOperations::initialize(end(), begin() + size);
        m_size = size;
    }

    template<typename T, size_t inlineCapacity>
    void Vector<T, inlineCapacity>::reserveCapacity(size_t newCapacity)
    {
        if (newCapacity <= capacity())
            return;
        T* oldBuffer = begin();
        T* oldEnd = end();
        m_buffer.allocateBuffer(newCapacity);
        if (begin())
            TypeOperations::move(oldBuffer, oldEnd, begin());
        m_buffer.deallocateBuffer(oldBuffer);
    }

    template<typename T, size_t inlineCapacity>
    bool Vector<T, inlineCapacity>::tryReserveCapacity(size_t newCapacity)
    {
        if (newCapacity <= capacity())
            return true;
        T* oldBuffer = begin();
        T* oldEnd = end();
        if (!m_buffer.tryAllocateBuffer(newCapacity))
            return false;
        ((void)0);
        TypeOperations::move(oldBuffer, oldEnd, begin());
        m_buffer.deallocateBuffer(oldBuffer);
        return true;
    }

    template<typename T, size_t inlineCapacity>
    inline void Vector<T, inlineCapacity>::reserveInitialCapacity(size_t initialCapacity)
    {
        ((void)0);
        ((void)0);
        if (initialCapacity > inlineCapacity)
            m_buffer.allocateBuffer(initialCapacity);
    }

    template<typename T, size_t inlineCapacity>
    void Vector<T, inlineCapacity>::shrinkCapacity(size_t newCapacity)
    {
        if (newCapacity >= capacity())
            return;

        if (newCapacity < size())
            shrink(newCapacity);

        T* oldBuffer = begin();
        if (newCapacity > 0) {
            T* oldEnd = end();
            m_buffer.allocateBuffer(newCapacity);
            if (begin() != oldBuffer)
                TypeOperations::move(oldBuffer, oldEnd, begin());
        }

        m_buffer.deallocateBuffer(oldBuffer);
        m_buffer.restoreInlineBufferIfNeeded();
    }





    template<typename T, size_t inlineCapacity> template<typename U>
    void Vector<T, inlineCapacity>::append(const U* data, size_t dataSize)
    {
        size_t newSize = m_size + dataSize;
        if (newSize > capacity()) {
            data = expandCapacity(newSize, data);
            if (!begin())
                return;
        }
        if (newSize < m_size)
            do { WTFReportBacktrace(); *(int *)(uintptr_t)0xbbadbeef = 0; __builtin_trap(); } while (false);
        T* dest = end();
        for (size_t i = 0; i < dataSize; ++i)
            new (&dest[i]) T(data[i]);
        m_size = newSize;
    }

    template<typename T, size_t inlineCapacity> template<typename U>
    bool Vector<T, inlineCapacity>::tryAppend(const U* data, size_t dataSize)
    {
        size_t newSize = m_size + dataSize;
        if (newSize > capacity()) {
            data = tryExpandCapacity(newSize, data);
            if (!data)
                return false;
            ((void)0);
        }
        if (newSize < m_size)
            return false;
        T* dest = end();
        for (size_t i = 0; i < dataSize; ++i)
            new (&dest[i]) T(data[i]);
        m_size = newSize;
        return true;
    }

    template<typename T, size_t inlineCapacity> template<typename U>
    inline __attribute__((__always_inline__)) void Vector<T, inlineCapacity>::append(const U& val)
    {
        const U* ptr = &val;
        if (size() == capacity()) {
            ptr = expandCapacity(size() + 1, ptr);
            if (!begin())
                return;
        }
# 994 "./wtf/Vector.h"
        new (end()) T(*ptr);

        ++m_size;
    }




    template<typename T, size_t inlineCapacity> template<typename U>
    inline void Vector<T, inlineCapacity>::uncheckedAppend(const U& val)
    {
        ((void)0);
        const U* ptr = &val;
        new (end()) T(*ptr);
        ++m_size;
    }




    template<typename T, size_t inlineCapacity> template<size_t otherCapacity>
    inline void Vector<T, inlineCapacity>::append(const Vector<T, otherCapacity>& val)
    {
        append(val.begin(), val.size());
    }

    template<typename T, size_t inlineCapacity> template<typename U>
    void Vector<T, inlineCapacity>::insert(size_t position, const U* data, size_t dataSize)
    {
        ((void)0);
        size_t newSize = m_size + dataSize;
        if (newSize > capacity()) {
            data = expandCapacity(newSize, data);
            if (!begin())
                return;
        }
        if (newSize < m_size)
            do { WTFReportBacktrace(); *(int *)(uintptr_t)0xbbadbeef = 0; __builtin_trap(); } while (false);
        T* spot = begin() + position;
        TypeOperations::moveOverlapping(spot, end(), spot + dataSize);
        for (size_t i = 0; i < dataSize; ++i)
            new (&spot[i]) T(data[i]);
        m_size = newSize;
    }

    template<typename T, size_t inlineCapacity> template<typename U>
    inline void Vector<T, inlineCapacity>::insert(size_t position, const U& val)
    {
        ((void)0);
        const U* data = &val;
        if (size() == capacity()) {
            data = expandCapacity(size() + 1, data);
            if (!begin())
                return;
        }
        T* spot = begin() + position;
        TypeOperations::moveOverlapping(spot, end(), spot + 1);
        new (spot) T(*data);
        ++m_size;
    }

    template<typename T, size_t inlineCapacity> template<typename U, size_t c>
    inline void Vector<T, inlineCapacity>::insert(size_t position, const Vector<U, c>& val)
    {
        insert(position, val.begin(), val.size());
    }

    template<typename T, size_t inlineCapacity> template<typename U>
    void Vector<T, inlineCapacity>::prepend(const U* data, size_t dataSize)
    {
        insert(0, data, dataSize);
    }

    template<typename T, size_t inlineCapacity> template<typename U>
    inline void Vector<T, inlineCapacity>::prepend(const U& val)
    {
        insert(0, val);
    }

    template<typename T, size_t inlineCapacity> template<typename U, size_t c>
    inline void Vector<T, inlineCapacity>::prepend(const Vector<U, c>& val)
    {
        insert(0, val.begin(), val.size());
    }

    template<typename T, size_t inlineCapacity>
    inline void Vector<T, inlineCapacity>::remove(size_t position)
    {
        ((void)0);
        T* spot = begin() + position;
        spot->~T();
        TypeOperations::moveOverlapping(spot + 1, end(), spot);
        --m_size;
    }

    template<typename T, size_t inlineCapacity>
    inline void Vector<T, inlineCapacity>::remove(size_t position, size_t length)
    {
        ((void)0);
        ((void)0);
        T* beginSpot = begin() + position;
        T* endSpot = beginSpot + length;
        TypeOperations::destruct(beginSpot, endSpot);
        TypeOperations::moveOverlapping(endSpot, end(), beginSpot);
        m_size -= length;
    }

    template<typename T, size_t inlineCapacity>
    inline void Vector<T, inlineCapacity>::reverse()
    {
        for (size_t i = 0; i < m_size / 2; ++i)
            std::swap(at(i), at(m_size - 1 - i));
    }

    template<typename T, size_t inlineCapacity>
    inline T* Vector<T, inlineCapacity>::releaseBuffer()
    {
        T* buffer = m_buffer.releaseBuffer();
        if (inlineCapacity && !buffer && m_size) {



            size_t bytes = m_size * sizeof(T);
            buffer = static_cast<T*>(fastMalloc(bytes));
            memcpy(buffer, data(), bytes);
        }
        m_size = 0;
        return buffer;
    }

    template<typename T, size_t inlineCapacity>
    inline void Vector<T, inlineCapacity>::checkConsistency()
    {




    }

    template<typename T, size_t inlineCapacity>
    void deleteAllValues(const Vector<T, inlineCapacity>& collection)
    {
        typedef typename Vector<T, inlineCapacity>::const_iterator iterator;
        iterator end = collection.end();
        for (iterator it = collection.begin(); it != end; ++it)
            delete *it;
    }

    template<typename T, size_t inlineCapacity>
    inline void swap(Vector<T, inlineCapacity>& a, Vector<T, inlineCapacity>& b)
    {
        a.swap(b);
    }

    template<typename T, size_t inlineCapacity>
    bool operator==(const Vector<T, inlineCapacity>& a, const Vector<T, inlineCapacity>& b)
    {
        if (a.size() != b.size())
            return false;

        return VectorTypeOperations<T>::compare(a.data(), b.data(), a.size());
    }

    template<typename T, size_t inlineCapacity>
    inline bool operator!=(const Vector<T, inlineCapacity>& a, const Vector<T, inlineCapacity>& b)
    {
        return !(a == b);
    }
# 1173 "./wtf/Vector.h"
}

using WTF::Vector;
# 33 "./wtf/text/StringImpl.h" 2



typedef const struct __CFString * CFStringRef;
# 45 "./wtf/text/StringImpl.h"
namespace JSC {
struct IdentifierCStringTranslator;
struct IdentifierUCharBufferTranslator;
}

namespace WTF {

struct CStringTranslator;
struct HashAndCharactersTranslator;
struct HashAndUTF8CharactersTranslator;
struct UCharBufferTranslator;

enum TextCaseSensitivity { TextCaseSensitive, TextCaseInsensitive };

typedef bool (*CharacterMatchFunctionPtr)(UChar);
typedef bool (*IsWhiteSpaceFunctionPtr)(UChar);

class StringImpl {
    private: StringImpl(const StringImpl&); StringImpl& operator=(const StringImpl&); public: void* operator new(size_t, void* p) { return p; } void* operator new[](size_t, void* p) { return p; } void* operator new(size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNew); return p; } void operator delete(void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNew); ::WTF::fastFree(p); } void* operator new[](size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNewArray); return p; } void operator delete[](void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNewArray); ::WTF::fastFree(p); } private: typedef int ThisIsHereToForceASemicolonAfterThisMacro;
    friend struct JSC::IdentifierCStringTranslator;
    friend struct JSC::IdentifierUCharBufferTranslator;
    friend struct WTF::CStringTranslator;
    friend struct WTF::HashAndCharactersTranslator;
    friend struct WTF::HashAndUTF8CharactersTranslator;
    friend struct WTF::UCharBufferTranslator;
    friend class AtomicStringImpl;

private:
    enum BufferOwnership {
        BufferInternal,
        BufferOwned,
        BufferSubstring,
    };




    enum ConstructStaticStringTag { ConstructStaticString };
    StringImpl(const UChar* characters, unsigned length, ConstructStaticStringTag)
        : m_refCount(s_refCountFlagIsStaticString)
        , m_length(length)
        , m_data(characters)
        , m_buffer(0)
        , m_hashAndFlags(s_hashFlagIsIdentifier | BufferOwned)
    {



        hash();
    }


    StringImpl(unsigned length)
        : m_refCount(s_refCountIncrement)
        , m_length(length)
        , m_data(reinterpret_cast<const UChar*>(this + 1))
        , m_buffer(0)
        , m_hashAndFlags(BufferInternal)
    {
        ((void)0);
        ((void)0);
    }


    StringImpl(const UChar* characters, unsigned length)
        : m_refCount(s_refCountIncrement)
        , m_length(length)
        , m_data(characters)
        , m_buffer(0)
        , m_hashAndFlags(BufferOwned)
    {
        ((void)0);
        ((void)0);
    }


    StringImpl(const UChar* characters, unsigned length, PassRefPtr<StringImpl> base)
        : m_refCount(s_refCountIncrement)
        , m_length(length)
        , m_data(characters)
        , m_substringBuffer(base.leakRef())
        , m_hashAndFlags(BufferSubstring)
    {
        ((void)0);
        ((void)0);
        ((void)0);
    }

public:
    ~StringImpl();

    static PassRefPtr<StringImpl> create(const UChar*, unsigned length);
    static PassRefPtr<StringImpl> create(const char*, unsigned length);
    static PassRefPtr<StringImpl> create(const char*);
    static inline __attribute__((__always_inline__)) PassRefPtr<StringImpl> create(PassRefPtr<StringImpl> rep, unsigned offset, unsigned length)
    {
        ((void)0);
        ((void)0);

        if (!length)
            return empty();

        StringImpl* ownerRep = (rep->bufferOwnership() == BufferSubstring) ? rep->m_substringBuffer : rep.get();
        return adoptRef(new StringImpl(rep->m_data + offset, length, ownerRep));
    }

    static PassRefPtr<StringImpl> createUninitialized(unsigned length, UChar*& data);
    static inline __attribute__((__always_inline__)) PassRefPtr<StringImpl> tryCreateUninitialized(unsigned length, UChar*& output)
    {
        if (!length) {
            output = 0;
            return empty();
        }

        if (length > ((std::numeric_limits<unsigned>::max() - sizeof(StringImpl)) / sizeof(UChar))) {
            output = 0;
            return 0;
        }
        StringImpl* resultImpl;
        if (!tryFastMalloc(sizeof(UChar) * length + sizeof(StringImpl)).getValue(resultImpl)) {
            output = 0;
            return 0;
        }
        output = reinterpret_cast<UChar*>(resultImpl + 1);
        return adoptRef(new(resultImpl) StringImpl(length));
    }




    static PassRefPtr<StringImpl> reallocate(PassRefPtr<StringImpl> originalString, unsigned length, UChar*& data);

    static unsigned dataOffset() { return (reinterpret_cast<ptrdiff_t>(&(reinterpret_cast<StringImpl*>(0x4000)->m_data)) - 0x4000); }
    static PassRefPtr<StringImpl> createWithTerminatingNullCharacter(const StringImpl&);

    template<size_t inlineCapacity>
    static PassRefPtr<StringImpl> adopt(Vector<UChar, inlineCapacity>& vector)
    {
        if (size_t size = vector.size()) {
            ((void)0);
            if (size > std::numeric_limits<unsigned>::max())
                do { WTFReportBacktrace(); *(int *)(uintptr_t)0xbbadbeef = 0; __builtin_trap(); } while (false);
            return adoptRef(new StringImpl(vector.releaseBuffer(), size));
        }
        return empty();
    }
    static PassRefPtr<StringImpl> adopt(StringBuffer&);

    unsigned length() const { return m_length; }
    const UChar* characters() const { return m_data; }

    size_t cost()
    {

        if (bufferOwnership() == BufferSubstring)
            return m_substringBuffer->cost();

        if (m_hashAndFlags & s_hashFlagDidReportCost)
            return 0;

        m_hashAndFlags |= s_hashFlagDidReportCost;
        return m_length;
    }

    bool isIdentifier() const { return m_hashAndFlags & s_hashFlagIsIdentifier; }
    void setIsIdentifier(bool isIdentifier)
    {
        ((void)0);
        if (isIdentifier)
            m_hashAndFlags |= s_hashFlagIsIdentifier;
        else
            m_hashAndFlags &= ~s_hashFlagIsIdentifier;
    }

    bool hasTerminatingNullCharacter() const { return m_hashAndFlags & s_hashFlagHasTerminatingNullCharacter; }

    bool isAtomic() const { return m_hashAndFlags & s_hashFlagIsAtomic; }
    void setIsAtomic(bool isIdentifier)
    {
        ((void)0);
        if (isIdentifier)
            m_hashAndFlags |= s_hashFlagIsAtomic;
        else
            m_hashAndFlags &= ~s_hashFlagIsAtomic;
    }

private:



    void setHash(unsigned hash) const
    {
        ((void)0);
        ((void)0);
        ((void)0);

        hash <<= s_flagCount;
        ((void)0);
        ((void)0);

        m_hashAndFlags |= hash;
    }

    unsigned rawHash() const
    {
        return m_hashAndFlags >> s_flagCount;
    }

public:
    bool hasHash() const
    {
        return rawHash() != 0;
    }

    unsigned existingHash() const
    {
        ((void)0);
        return rawHash();
    }

    unsigned hash() const
    {
        if (!hasHash())
            setHash(StringHasher::computeHash(m_data, m_length));
        return existingHash();
    }

    inline bool hasOneRef() const
    {
        return m_refCount == s_refCountIncrement;
    }

    inline void ref()
    {
        m_refCount += s_refCountIncrement;
    }

    inline void deref()
    {
        if (m_refCount == s_refCountIncrement) {
            delete this;
            return;
        }

        m_refCount -= s_refCountIncrement;
    }

    static StringImpl* empty();

    static void copyChars(UChar* destination, const UChar* source, unsigned numCharacters)
    {
        if (numCharacters <= s_copyCharsInlineCutOff) {
            for (unsigned i = 0; i < numCharacters; ++i)
                destination[i] = source[i];
        } else
            memcpy(destination, source, numCharacters * sizeof(UChar));
    }




    PassRefPtr<StringImpl> isolatedCopy() const;

    PassRefPtr<StringImpl> substring(unsigned pos, unsigned len = (2147483647 *2U +1U));

    UChar operator[](unsigned i) { ((void)0); return m_data[i]; }
    UChar32 characterStartingAt(unsigned);

    bool containsOnlyWhitespace();

    int toIntStrict(bool* ok = 0, int base = 10);
    unsigned toUIntStrict(bool* ok = 0, int base = 10);
    int64_t toInt64Strict(bool* ok = 0, int base = 10);
    uint64_t toUInt64Strict(bool* ok = 0, int base = 10);
    intptr_t toIntPtrStrict(bool* ok = 0, int base = 10);

    int toInt(bool* ok = 0);
    unsigned toUInt(bool* ok = 0);
    int64_t toInt64(bool* ok = 0);
    uint64_t toUInt64(bool* ok = 0);
    intptr_t toIntPtr(bool* ok = 0);

    double toDouble(bool* ok = 0, bool* didReadNumber = 0);
    float toFloat(bool* ok = 0, bool* didReadNumber = 0);

    PassRefPtr<StringImpl> lower();
    PassRefPtr<StringImpl> upper();

    PassRefPtr<StringImpl> fill(UChar);
    PassRefPtr<StringImpl> foldCase();

    PassRefPtr<StringImpl> stripWhiteSpace();
    PassRefPtr<StringImpl> stripWhiteSpace(IsWhiteSpaceFunctionPtr);
    PassRefPtr<StringImpl> simplifyWhiteSpace();
    PassRefPtr<StringImpl> simplifyWhiteSpace(IsWhiteSpaceFunctionPtr);

    PassRefPtr<StringImpl> removeCharacters(CharacterMatchFunctionPtr);

    size_t find(UChar, unsigned index = 0);
    size_t find(CharacterMatchFunctionPtr, unsigned index = 0);
    size_t find(const char*, unsigned index = 0);
    size_t find(StringImpl*, unsigned index = 0);
    size_t findIgnoringCase(const char*, unsigned index = 0);
    size_t findIgnoringCase(StringImpl*, unsigned index = 0);

    size_t reverseFind(UChar, unsigned index = (2147483647 *2U +1U));
    size_t reverseFind(StringImpl*, unsigned index = (2147483647 *2U +1U));
    size_t reverseFindIgnoringCase(StringImpl*, unsigned index = (2147483647 *2U +1U));

    bool startsWith(StringImpl* str, bool caseSensitive = true) { return (caseSensitive ? reverseFind(str, 0) : reverseFindIgnoringCase(str, 0)) == 0; }
    bool endsWith(StringImpl*, bool caseSensitive = true);

    PassRefPtr<StringImpl> replace(UChar, UChar);
    PassRefPtr<StringImpl> replace(UChar, StringImpl*);
    PassRefPtr<StringImpl> replace(StringImpl*, StringImpl*);
    PassRefPtr<StringImpl> replace(unsigned index, unsigned len, StringImpl*);

    WTF::Unicode::Direction defaultWritingDirection(bool* hasStrongDirectionality = 0);


    CFStringRef createCFString();





private:

    static const unsigned s_copyCharsInlineCutOff = 20;

    BufferOwnership bufferOwnership() const { return static_cast<BufferOwnership>(m_hashAndFlags & s_hashMaskBufferOwnership); }
    bool isStatic() const { return m_refCount & s_refCountFlagIsStaticString; }
    template <class UCharPredicate> PassRefPtr<StringImpl> stripMatchedCharacters(UCharPredicate);
    template <class UCharPredicate> PassRefPtr<StringImpl> simplifyMatchedCharactersToSpace(UCharPredicate);


    static const unsigned s_refCountFlagIsStaticString = 0x1;
    static const unsigned s_refCountIncrement = 0x2;


    static const unsigned s_flagCount = 8;
    static const unsigned s_flagMask = (1u << s_flagCount) - 1;
    typedef int dummyStringHasher_reserves_enough_bits_for_StringImpl_flags [(s_flagCount == StringHasher::flagCount) ? 1 : -1];

    static const unsigned s_hashFlagHasTerminatingNullCharacter = 1u << 5;
    static const unsigned s_hashFlagIsAtomic = 1u << 4;
    static const unsigned s_hashFlagDidReportCost = 1u << 3;
    static const unsigned s_hashFlagIsIdentifier = 1u << 2;
    static const unsigned s_hashMaskBufferOwnership = 1u | (1u << 1);

    unsigned m_refCount;
    unsigned m_length;
    const UChar* m_data;
    union {
        void* m_buffer;
        StringImpl* m_substringBuffer;
    };
    mutable unsigned m_hashAndFlags;
};

bool equal(const StringImpl*, const StringImpl*);
bool equal(const StringImpl*, const char*);
inline bool equal(const char* a, StringImpl* b) { return equal(b, a); }
bool equal(const StringImpl*, const UChar*, unsigned);

bool equalIgnoringCase(StringImpl*, StringImpl*);
bool equalIgnoringCase(StringImpl*, const char*);
inline bool equalIgnoringCase(const char* a, StringImpl* b) { return equalIgnoringCase(b, a); }
bool equalIgnoringCase(const UChar* a, const char* b, unsigned length);
inline bool equalIgnoringCase(const char* a, const UChar* b, unsigned length) { return equalIgnoringCase(b, a, length); }

bool equalIgnoringNullity(StringImpl*, StringImpl*);

template<size_t inlineCapacity>
bool equalIgnoringNullity(const Vector<UChar, inlineCapacity>& a, StringImpl* b)
{
    if (!b)
        return !a.size();
    if (a.size() != b->length())
        return false;
    return !memcmp(a.data(), b->characters(), b->length());
}

int codePointCompare(const StringImpl*, const StringImpl*);

static inline bool isSpaceOrNewline(UChar c)
{


    return c <= 0x7F ? WTF::isASCIISpace(c) : WTF::Unicode::direction(c) == WTF::Unicode::WhiteSpaceNeutral;
}

inline PassRefPtr<StringImpl> StringImpl::isolatedCopy() const
{
    return create(m_data, m_length);
}

struct StringHash;


template<typename T> struct DefaultHash;
template<> struct DefaultHash<StringImpl*> {
    typedef StringHash Hash;
};
template<> struct DefaultHash<RefPtr<StringImpl> > {
    typedef StringHash Hash;
};

}

using WTF::StringImpl;
using WTF::equal;
using WTF::TextCaseSensitivity;
using WTF::TextCaseSensitive;
using WTF::TextCaseInsensitive;
# 29 "./wtf/text/WTFString.h" 2






typedef const struct __CFString * CFStringRef;
# 49 "./wtf/text/WTFString.h"
namespace WTF {

class CString;
struct StringHash;



bool charactersAreAllASCII(const UChar*, size_t);
bool charactersAreAllLatin1(const UChar*, size_t);
                   int charactersToIntStrict(const UChar*, size_t, bool* ok = 0, int base = 10);
                   unsigned charactersToUIntStrict(const UChar*, size_t, bool* ok = 0, int base = 10);
int64_t charactersToInt64Strict(const UChar*, size_t, bool* ok = 0, int base = 10);
uint64_t charactersToUInt64Strict(const UChar*, size_t, bool* ok = 0, int base = 10);
intptr_t charactersToIntPtrStrict(const UChar*, size_t, bool* ok = 0, int base = 10);

int charactersToInt(const UChar*, size_t, bool* ok = 0);
unsigned charactersToUInt(const UChar*, size_t, bool* ok = 0);
int64_t charactersToInt64(const UChar*, size_t, bool* ok = 0);
uint64_t charactersToUInt64(const UChar*, size_t, bool* ok = 0);
intptr_t charactersToIntPtr(const UChar*, size_t, bool* ok = 0);

                   double charactersToDouble(const UChar*, size_t, bool* ok = 0, bool* didReadNumber = 0);
float charactersToFloat(const UChar*, size_t, bool* ok = 0, bool* didReadNumber = 0);

template<bool isSpecialCharacter(UChar)> bool isAllSpecialCharacters(const UChar*, size_t);

class String {
public:

                       String() { }


                       String(const UChar* characters, unsigned length);



    template<size_t inlineCapacity>
    explicit String(const Vector<UChar, inlineCapacity>&);


                       String(const UChar*);


                       String(const char* characters, unsigned length);


                       String(const char* characters);


                       String(StringImpl* impl) : m_impl(impl) { }
                       String(PassRefPtr<StringImpl> impl) : m_impl(impl) { }
                       String(RefPtr<StringImpl> impl) : m_impl(impl) { }


    inline __attribute__((__always_inline__)) ~String() { }

    void swap(String& o) { m_impl.swap(o.m_impl); }

    static String adopt(StringBuffer& buffer) { return StringImpl::adopt(buffer); }
    template<size_t inlineCapacity>
    static String adopt(Vector<UChar, inlineCapacity>& vector) { return StringImpl::adopt(vector); }

    bool isNull() const { return !m_impl; }
    bool isEmpty() const { return !m_impl || !m_impl->length(); }

    StringImpl* impl() const { return m_impl.get(); }

    unsigned length() const
    {
        if (!m_impl)
            return 0;
        return m_impl->length();
    }

    const UChar* characters() const
    {
        if (!m_impl)
            return 0;
        return m_impl->characters();
    }

                       CString ascii() const;
                       CString latin1() const;
                       CString utf8(bool strict = false) const;

    UChar operator[](unsigned index) const
    {
        if (!m_impl || index >= m_impl->length())
            return 0;
        return m_impl->characters()[index];
    }

                       static String number(short);
                       static String number(unsigned short);
                       static String number(int);
                       static String number(unsigned);
                       static String number(long);
                       static String number(unsigned long);
                       static String number(long long);
                       static String number(unsigned long long);
                       static String number(double);


    size_t find(UChar c, unsigned start = 0) const
        { return m_impl ? m_impl->find(c, start) : notFound; }
    size_t find(const String& str, unsigned start = 0) const
        { return m_impl ? m_impl->find(str.impl(), start) : notFound; }
    size_t find(CharacterMatchFunctionPtr matchFunction, unsigned start = 0) const
        { return m_impl ? m_impl->find(matchFunction, start) : notFound; }
    size_t find(const char* str, unsigned start = 0) const
        { return m_impl ? m_impl->find(str, start) : notFound; }


    size_t reverseFind(UChar c, unsigned start = (2147483647 *2U +1U)) const
        { return m_impl ? m_impl->reverseFind(c, start) : notFound; }
    size_t reverseFind(const String& str, unsigned start = (2147483647 *2U +1U)) const
        { return m_impl ? m_impl->reverseFind(str.impl(), start) : notFound; }


                       size_t findIgnoringCase(const char* str, unsigned start = 0) const
        { return m_impl ? m_impl->findIgnoringCase(str, start) : notFound; }
                       size_t findIgnoringCase(const String& str, unsigned start = 0) const
        { return m_impl ? m_impl->findIgnoringCase(str.impl(), start) : notFound; }
    size_t reverseFindIgnoringCase(const String& str, unsigned start = (2147483647 *2U +1U)) const
        { return m_impl ? m_impl->reverseFindIgnoringCase(str.impl(), start) : notFound; }


    size_t find(const char* str, unsigned start, bool caseSensitive) const
        { return caseSensitive ? find(str, start) : findIgnoringCase(str, start); }
    size_t find(const String& str, unsigned start, bool caseSensitive) const
        { return caseSensitive ? find(str, start) : findIgnoringCase(str, start); }
    size_t reverseFind(const String& str, unsigned start, bool caseSensitive) const
        { return caseSensitive ? reverseFind(str, start) : reverseFindIgnoringCase(str, start); }

                       const UChar* charactersWithNullTermination();

                       UChar32 characterStartingAt(unsigned) const;

    bool contains(UChar c) const { return find(c) != notFound; }
    bool contains(const char* str, bool caseSensitive = true) const { return find(str, 0, caseSensitive) != notFound; }
    bool contains(const String& str, bool caseSensitive = true) const { return find(str, 0, caseSensitive) != notFound; }

    bool startsWith(const String& s, bool caseSensitive = true) const
        { return m_impl ? m_impl->startsWith(s.impl(), caseSensitive) : s.isEmpty(); }
    bool endsWith(const String& s, bool caseSensitive = true) const
        { return m_impl ? m_impl->endsWith(s.impl(), caseSensitive) : s.isEmpty(); }

                       void append(const String&);
                       void append(char);
                       void append(UChar);
                       void append(const UChar*, unsigned length);
                       void insert(const String&, unsigned pos);
    void insert(const UChar*, unsigned length, unsigned pos);

    String& replace(UChar a, UChar b) { if (m_impl) m_impl = m_impl->replace(a, b); return *this; }
    String& replace(UChar a, const String& b) { if (m_impl) m_impl = m_impl->replace(a, b.impl()); return *this; }
    String& replace(const String& a, const String& b) { if (m_impl) m_impl = m_impl->replace(a.impl(), b.impl()); return *this; }
    String& replace(unsigned index, unsigned len, const String& b) { if (m_impl) m_impl = m_impl->replace(index, len, b.impl()); return *this; }

    void makeLower() { if (m_impl) m_impl = m_impl->lower(); }
    void makeUpper() { if (m_impl) m_impl = m_impl->upper(); }
    void fill(UChar c) { if (m_impl) m_impl = m_impl->fill(c); }

                       void truncate(unsigned len);
                       void remove(unsigned pos, int len = 1);

                       String substring(unsigned pos, unsigned len = (2147483647 *2U +1U)) const;
    String substringSharingImpl(unsigned pos, unsigned len = (2147483647 *2U +1U)) const;
    String left(unsigned len) const { return substring(0, len); }
    String right(unsigned len) const { return substring(length() - len, len); }


                       String lower() const;
                       String upper() const;

                       String stripWhiteSpace() const;
                       String stripWhiteSpace(IsWhiteSpaceFunctionPtr) const;
                       String simplifyWhiteSpace() const;
                       String simplifyWhiteSpace(IsWhiteSpaceFunctionPtr) const;

                       String removeCharacters(CharacterMatchFunctionPtr) const;
    template<bool isSpecialCharacter(UChar)> bool isAllSpecialCharacters() const;


                       String foldCase() const;


                       static String format(const char *, ...) __attribute__((__format__(printf, 1, 2)));







    static String createUninitialized(unsigned length, UChar*& data) { return StringImpl::createUninitialized(length, data); }

                       void split(const String& separator, Vector<String>& result) const;
                       void split(const String& separator, bool allowEmptyEntries, Vector<String>& result) const;
                       void split(UChar separator, Vector<String>& result) const;
                       void split(UChar separator, bool allowEmptyEntries, Vector<String>& result) const;

                       int toIntStrict(bool* ok = 0, int base = 10) const;
                       unsigned toUIntStrict(bool* ok = 0, int base = 10) const;
                       int64_t toInt64Strict(bool* ok = 0, int base = 10) const;
                       uint64_t toUInt64Strict(bool* ok = 0, int base = 10) const;
                       intptr_t toIntPtrStrict(bool* ok = 0, int base = 10) const;

                       int toInt(bool* ok = 0) const;
                       unsigned toUInt(bool* ok = 0) const;
    int64_t toInt64(bool* ok = 0) const;
                       uint64_t toUInt64(bool* ok = 0) const;
                       intptr_t toIntPtr(bool* ok = 0) const;
                       double toDouble(bool* ok = 0, bool* didReadNumber = 0) const;
                       float toFloat(bool* ok = 0, bool* didReadNumber = 0) const;

    bool percentage(int& percentage) const;

                       String isolatedCopy() const;



    typedef struct ImplicitConversionFromWTFStringToBoolDisallowedA* (String::*UnspecifiedBoolTypeA);
    typedef struct ImplicitConversionFromWTFStringToBoolDisallowedB* (String::*UnspecifiedBoolTypeB);
    operator UnspecifiedBoolTypeA() const;
    operator UnspecifiedBoolTypeB() const;


    String(CFStringRef);
    CFStringRef createCFString() const;
# 302 "./wtf/text/WTFString.h"
                       static String fromUTF8(const char*, size_t);
                       static String fromUTF8(const char*);


                       static String fromUTF8WithLatin1Fallback(const char*, size_t);


    WTF::Unicode::Direction defaultWritingDirection(bool* hasStrongDirectionality = 0) const
    {
        if (m_impl)
            return m_impl->defaultWritingDirection(hasStrongDirectionality);
        if (hasStrongDirectionality)
            *hasStrongDirectionality = false;
        return WTF::Unicode::LeftToRight;
    }

    bool containsOnlyASCII() const { return charactersAreAllASCII(characters(), length()); }
    bool containsOnlyLatin1() const { return charactersAreAllLatin1(characters(), length()); }


    String(WTF::HashTableDeletedValueType) : m_impl(WTF::HashTableDeletedValue) { }
                       bool isHashTableDeletedValue() const { return m_impl.isHashTableDeletedValue(); }





private:
    RefPtr<StringImpl> m_impl;
};






inline String& operator+=(String& a, const String& b) { a.append(b); return a; }

inline bool operator==(const String& a, const String& b) { return equal(a.impl(), b.impl()); }
inline bool operator==(const String& a, const char* b) { return equal(a.impl(), b); }
inline bool operator==(const char* a, const String& b) { return equal(a, b.impl()); }

inline bool operator!=(const String& a, const String& b) { return !equal(a.impl(), b.impl()); }
inline bool operator!=(const String& a, const char* b) { return !equal(a.impl(), b); }
inline bool operator!=(const char* a, const String& b) { return !equal(a, b.impl()); }

inline bool equalIgnoringCase(const String& a, const String& b) { return equalIgnoringCase(a.impl(), b.impl()); }
inline bool equalIgnoringCase(const String& a, const char* b) { return equalIgnoringCase(a.impl(), b); }
inline bool equalIgnoringCase(const char* a, const String& b) { return equalIgnoringCase(a, b.impl()); }

inline bool equalPossiblyIgnoringCase(const String& a, const String& b, bool ignoreCase)
{
    return ignoreCase ? equalIgnoringCase(a, b) : (a == b);
}

inline bool equalIgnoringNullity(const String& a, const String& b) { return equalIgnoringNullity(a.impl(), b.impl()); }

template<size_t inlineCapacity>
inline bool equalIgnoringNullity(const Vector<UChar, inlineCapacity>& a, const String& b) { return equalIgnoringNullity(a, b.impl()); }

inline bool operator!(const String& str) { return str.isNull(); }

inline void swap(String& a, String& b) { a.swap(b); }



template<size_t inlineCapacity>
String::String(const Vector<UChar, inlineCapacity>& vector)
    : m_impl(vector.size() ? StringImpl::create(vector.data(), vector.size()) : 0)
{
}
# 381 "./wtf/text/WTFString.h"
inline bool charactersAreAllASCII(const UChar* characters, size_t length)
{
    UChar ored = 0;
    for (size_t i = 0; i < length; ++i)
        ored |= characters[i];
    return !(ored & 0xFF80);
}

inline bool charactersAreAllLatin1(const UChar* characters, size_t length)
{
    UChar ored = 0;
    for (size_t i = 0; i < length; ++i)
        ored |= characters[i];
    return !(ored & 0xFF00);
}

                   int codePointCompare(const String&, const String&);

inline size_t find(const UChar* characters, unsigned length, UChar matchCharacter, unsigned index = 0)
{
    while (index < length) {
        if (characters[index] == matchCharacter)
            return index;
        ++index;
    }
    return notFound;
}

inline size_t find(const UChar* characters, unsigned length, CharacterMatchFunctionPtr matchFunction, unsigned index = 0)
{
    while (index < length) {
        if (matchFunction(characters[index]))
            return index;
        ++index;
    }
    return notFound;
}

inline size_t reverseFind(const UChar* characters, unsigned length, UChar matchCharacter, unsigned index = (2147483647 *2U +1U))
{
    if (!length)
        return notFound;
    if (index >= length)
        index = length - 1;
    while (characters[index] != matchCharacter) {
        if (!index--)
            return notFound;
    }
    return index;
}

inline void append(Vector<UChar>& vector, const String& string)
{
    vector.append(string.characters(), string.length());
}

inline void appendNumber(Vector<UChar>& vector, unsigned char number)
{
    int numberLength = number > 99 ? 3 : (number > 9 ? 2 : 1);
    size_t vectorSize = vector.size();
    vector.grow(vectorSize + numberLength);

    switch (numberLength) {
    case 3:
        vector[vectorSize + 2] = number % 10 + '0';
        number /= 10;

    case 2:
        vector[vectorSize + 1] = number % 10 + '0';
        number /= 10;

    case 1:
        vector[vectorSize] = number % 10 + '0';
    }
}

template<bool isSpecialCharacter(UChar)> inline bool isAllSpecialCharacters(const UChar* characters, size_t length)
{
    for (size_t i = 0; i < length; ++i) {
        if (!isSpecialCharacter(characters[i]))
            return false;
    }
    return true;
}

template<bool isSpecialCharacter(UChar)> inline bool String::isAllSpecialCharacters() const
{
    return WTF::isAllSpecialCharacters<isSpecialCharacter>(characters(), length());
}


template<typename T> struct DefaultHash;
template<> struct DefaultHash<String> {
    typedef StringHash Hash;
};

template <> struct VectorTraits<String> : SimpleClassVectorTraits { };


                   const String& emptyString();

}

using WTF::CString;
using WTF::String;
using WTF::emptyString;
using WTF::append;
using WTF::appendNumber;
using WTF::charactersAreAllASCII;
using WTF::charactersAreAllLatin1;
using WTF::charactersToIntStrict;
using WTF::charactersToUIntStrict;
using WTF::charactersToInt64Strict;
using WTF::charactersToUInt64Strict;
using WTF::charactersToIntPtrStrict;
using WTF::charactersToInt;
using WTF::charactersToUInt;
using WTF::charactersToInt64;
using WTF::charactersToUInt64;
using WTF::charactersToIntPtr;
using WTF::charactersToDouble;
using WTF::charactersToFloat;
using WTF::equal;
using WTF::equalIgnoringCase;
using WTF::find;
using WTF::isAllSpecialCharacters;
using WTF::isSpaceOrNewline;
using WTF::reverseFind;


# 1 "./wtf/text/AtomicString.h" 1
# 24 "./wtf/text/AtomicString.h"
# 1 "./wtf/text/AtomicStringImpl.h" 1
# 26 "./wtf/text/AtomicStringImpl.h"
namespace WTF {

class AtomicStringImpl : public StringImpl
{
public:
    AtomicStringImpl() : StringImpl(0) {}
};

}

using WTF::AtomicStringImpl;
# 25 "./wtf/text/AtomicString.h" 2
# 1 "./wtf/text/WTFString.h" 1
# 26 "./wtf/text/AtomicString.h" 2
# 35 "./wtf/text/AtomicString.h"
namespace WTF {

struct AtomicStringHash;

class AtomicString {
public:
    static void init();

    AtomicString() { }
    AtomicString(const char* s) : m_string(add(s)) { }
    AtomicString(const UChar* s, unsigned length) : m_string(add(s, length)) { }
    AtomicString(const UChar* s, unsigned length, unsigned existingHash) : m_string(add(s, length, existingHash)) { }
    AtomicString(const UChar* s) : m_string(add(s)) { }
                            AtomicString(StringImpl* imp) : m_string(add(imp)) { }
    AtomicString(AtomicStringImpl* imp) : m_string(imp) { }
                            AtomicString(const String& s) : m_string(add(s.impl())) { }


    AtomicString(WTF::HashTableDeletedValueType) : m_string(WTF::HashTableDeletedValue) { }
    bool isHashTableDeletedValue() const { return m_string.isHashTableDeletedValue(); }

    static AtomicStringImpl* find(const UChar* s, unsigned length, unsigned existingHash);

    operator const String&() const { return m_string; }
    const String& string() const { return m_string; };

    AtomicStringImpl* impl() const { return static_cast<AtomicStringImpl *>(m_string.impl()); }

    const UChar* characters() const { return m_string.characters(); }
    unsigned length() const { return m_string.length(); }

    UChar operator[](unsigned int i) const { return m_string[i]; }

    bool contains(UChar c) const { return m_string.contains(c); }
    bool contains(const char* s, bool caseSensitive = true) const
        { return m_string.contains(s, caseSensitive); }
    bool contains(const String& s, bool caseSensitive = true) const
        { return m_string.contains(s, caseSensitive); }

    size_t find(UChar c, size_t start = 0) const { return m_string.find(c, start); }
    size_t find(const char* s, size_t start = 0, bool caseSentitive = true) const
        { return m_string.find(s, start, caseSentitive); }
    size_t find(const String& s, size_t start = 0, bool caseSentitive = true) const
        { return m_string.find(s, start, caseSentitive); }

    bool startsWith(const String& s, bool caseSensitive = true) const
        { return m_string.startsWith(s, caseSensitive); }
    bool endsWith(const String& s, bool caseSensitive = true) const
        { return m_string.endsWith(s, caseSensitive); }

    AtomicString lower() const;
    AtomicString upper() const { return AtomicString(impl()->upper()); }

    int toInt(bool* ok = 0) const { return m_string.toInt(ok); }
    double toDouble(bool* ok = 0) const { return m_string.toDouble(ok); }
    float toFloat(bool* ok = 0) const { return m_string.toFloat(ok); }
    bool percentage(int& p) const { return m_string.percentage(p); }

    bool isNull() const { return m_string.isNull(); }
    bool isEmpty() const { return m_string.isEmpty(); }

    static void remove(StringImpl*);


    AtomicString(CFStringRef s) : m_string(add(String(s).impl())) { }
    CFStringRef createCFString() const { return m_string.createCFString(); }
# 113 "./wtf/text/AtomicString.h"
    static AtomicString fromUTF8(const char*, size_t);
    static AtomicString fromUTF8(const char*);




private:
    String m_string;

    static PassRefPtr<StringImpl> add(const char*);
    static PassRefPtr<StringImpl> add(const UChar*, unsigned length);
    static PassRefPtr<StringImpl> add(const UChar*, unsigned length, unsigned existingHash);
    static PassRefPtr<StringImpl> add(const UChar*);
    inline __attribute__((__always_inline__)) PassRefPtr<StringImpl> add(StringImpl* r)
    {
        if (!r || r->isAtomic())
            return r;
        return addSlowCase(r);
    }
    static PassRefPtr<StringImpl> addSlowCase(StringImpl*);
    static AtomicString fromUTF8Internal(const char*, const char*);
};

inline bool operator==(const AtomicString& a, const AtomicString& b) { return a.impl() == b.impl(); }
bool operator==(const AtomicString& a, const char* b);
inline bool operator==(const AtomicString& a, const char* b) { return WTF::equal(a.impl(), b); }
inline bool operator==(const AtomicString& a, const Vector<UChar>& b) { return a.impl() && equal(a.impl(), b.data(), b.size()); }
inline bool operator==(const AtomicString& a, const String& b) { return equal(a.impl(), b.impl()); }
inline bool operator==(const char* a, const AtomicString& b) { return b == a; }
inline bool operator==(const String& a, const AtomicString& b) { return equal(a.impl(), b.impl()); }
inline bool operator==(const Vector<UChar>& a, const AtomicString& b) { return b == a; }

inline bool operator!=(const AtomicString& a, const AtomicString& b) { return a.impl() != b.impl(); }
inline bool operator!=(const AtomicString& a, const char *b) { return !(a == b); }
inline bool operator!=(const AtomicString& a, const String& b) { return !equal(a.impl(), b.impl()); }
inline bool operator!=(const AtomicString& a, const Vector<UChar>& b) { return !(a == b); }
inline bool operator!=(const char* a, const AtomicString& b) { return !(b == a); }
inline bool operator!=(const String& a, const AtomicString& b) { return !equal(a.impl(), b.impl()); }
inline bool operator!=(const Vector<UChar>& a, const AtomicString& b) { return !(a == b); }

inline bool equalIgnoringCase(const AtomicString& a, const AtomicString& b) { return equalIgnoringCase(a.impl(), b.impl()); }
inline bool equalIgnoringCase(const AtomicString& a, const char* b) { return equalIgnoringCase(a.impl(), b); }
inline bool equalIgnoringCase(const AtomicString& a, const String& b) { return equalIgnoringCase(a.impl(), b.impl()); }
inline bool equalIgnoringCase(const char* a, const AtomicString& b) { return equalIgnoringCase(a, b.impl()); }
inline bool equalIgnoringCase(const String& a, const AtomicString& b) { return equalIgnoringCase(a.impl(), b.impl()); }




extern const AtomicString nullAtom;
extern const AtomicString emptyAtom;
extern const AtomicString textAtom;
extern const AtomicString commentAtom;
extern const AtomicString starAtom;
extern const AtomicString xmlAtom;
extern const AtomicString xmlnsAtom;

inline AtomicString AtomicString::fromUTF8(const char* characters, size_t length)
{
    if (!characters)
        return nullAtom;
    if (!length)
        return emptyAtom;
    return fromUTF8Internal(characters, characters + length);
}

inline AtomicString AtomicString::fromUTF8(const char* characters)
{
    if (!characters)
        return nullAtom;
    if (!*characters)
        return emptyAtom;
    return fromUTF8Internal(characters, 0);
}



template<typename T> struct DefaultHash;
template<> struct DefaultHash<AtomicString> {
    typedef AtomicStringHash Hash;
};

}


using WTF::AtomicString;
using WTF::nullAtom;
using WTF::emptyAtom;
using WTF::textAtom;
using WTF::commentAtom;
using WTF::starAtom;
using WTF::xmlAtom;
using WTF::xmlnsAtom;



# 1 "./wtf/text/StringConcatenate.h" 1
# 39 "./wtf/text/StringConcatenate.h"
namespace WTF {

template<typename StringType>
class StringTypeAdapter {
};

template<>
class StringTypeAdapter<char> {
public:
    StringTypeAdapter<char>(char buffer)
        : m_buffer(buffer)
    {
    }

    unsigned length() { return 1; }
    void writeTo(UChar* destination) { *destination = m_buffer; }

private:
    unsigned char m_buffer;
};

template<>
class StringTypeAdapter<UChar> {
public:
    StringTypeAdapter<UChar>(UChar buffer)
        : m_buffer(buffer)
    {
    }

    unsigned length() { return 1; }
    void writeTo(UChar* destination) { *destination = m_buffer; }

private:
    UChar m_buffer;
};

template<>
class StringTypeAdapter<char*> {
public:
    StringTypeAdapter<char*>(char* buffer)
        : m_buffer(buffer)
        , m_length(strlen(buffer))
    {
    }

    unsigned length() { return m_length; }

    void writeTo(UChar* destination)
    {
        for (unsigned i = 0; i < m_length; ++i) {
            unsigned char c = m_buffer[i];
            destination[i] = c;
        }
    }

private:
    const char* m_buffer;
    unsigned m_length;
};

template<>
class StringTypeAdapter<const UChar*> {
public:
    StringTypeAdapter<const UChar*>(const UChar* buffer)
        : m_buffer(buffer)
    {
        size_t len = 0;
        while (m_buffer[len] != UChar(0))
            len++;

        if (len > std::numeric_limits<unsigned>::max())
            do { WTFReportBacktrace(); *(int *)(uintptr_t)0xbbadbeef = 0; __builtin_trap(); } while (false);

        m_length = len;
    }

    unsigned length() { return m_length; }

    void writeTo(UChar* destination)
    {
        memcpy(destination, m_buffer, static_cast<size_t>(m_length) * sizeof(UChar));
    }

private:
    const UChar* m_buffer;
    unsigned m_length;
};

template<>
class StringTypeAdapter<const char*> {
public:
    StringTypeAdapter<const char*>(const char* buffer)
        : m_buffer(buffer)
        , m_length(strlen(buffer))
    {
    }

    unsigned length() { return m_length; }

    void writeTo(UChar* destination)
    {
        for (unsigned i = 0; i < m_length; ++i) {
            unsigned char c = m_buffer[i];
            destination[i] = c;
        }
    }

private:
    const char* m_buffer;
    unsigned m_length;
};

template<>
class StringTypeAdapter<Vector<char> > {
public:
    StringTypeAdapter<Vector<char> >(const Vector<char>& buffer)
        : m_buffer(buffer)
    {
    }

    size_t length() { return m_buffer.size(); }

    void writeTo(UChar* destination)
    {
        for (size_t i = 0; i < m_buffer.size(); ++i) {
            unsigned char c = m_buffer[i];
            destination[i] = c;
        }
    }

private:
    const Vector<char>& m_buffer;
};

template<>
class StringTypeAdapter<String> {
public:
    StringTypeAdapter<String>(const String& string)
        : m_buffer(string)
    {
    }

    unsigned length() { return m_buffer.length(); }

    void writeTo(UChar* destination)
    {
        const UChar* data = m_buffer.characters();
        unsigned length = m_buffer.length();
        for (unsigned i = 0; i < length; ++i)
            destination[i] = data[i];

        ((void)0);
    }

private:
    const String& m_buffer;
};

template<>
class StringTypeAdapter<AtomicString> {
public:
    StringTypeAdapter<AtomicString>(const AtomicString& string)
        : m_adapter(string.string())
    {
    }

    unsigned length() { return m_adapter.length(); }
    void writeTo(UChar* destination) { m_adapter.writeTo(destination); }

private:
    StringTypeAdapter<String> m_adapter;
};

inline void sumWithOverflow(unsigned& total, unsigned addend, bool& overflow)
{
    unsigned oldTotal = total;
    total = oldTotal + addend;
    if (total < oldTotal)
        overflow = true;
}

template<typename StringType1, typename StringType2>
PassRefPtr<StringImpl> tryMakeString(StringType1 string1, StringType2 string2)
{
    StringTypeAdapter<StringType1> adapter1(string1);
    StringTypeAdapter<StringType2> adapter2(string2);

    UChar* buffer;
    bool overflow = false;
    unsigned length = adapter1.length();
    sumWithOverflow(length, adapter2.length(), overflow);
    if (overflow)
        return 0;
    RefPtr<StringImpl> resultImpl = StringImpl::tryCreateUninitialized(length, buffer);
    if (!resultImpl)
        return 0;

    UChar* result = buffer;
    adapter1.writeTo(result);
    result += adapter1.length();
    adapter2.writeTo(result);

    return resultImpl.release();
}

template<typename StringType1, typename StringType2, typename StringType3>
PassRefPtr<StringImpl> tryMakeString(StringType1 string1, StringType2 string2, StringType3 string3)
{
    StringTypeAdapter<StringType1> adapter1(string1);
    StringTypeAdapter<StringType2> adapter2(string2);
    StringTypeAdapter<StringType3> adapter3(string3);

    UChar* buffer = 0;
    bool overflow = false;
    unsigned length = adapter1.length();
    sumWithOverflow(length, adapter2.length(), overflow);
    sumWithOverflow(length, adapter3.length(), overflow);
    if (overflow)
        return 0;
    RefPtr<StringImpl> resultImpl = StringImpl::tryCreateUninitialized(length, buffer);
    if (!resultImpl)
        return 0;

    UChar* result = buffer;
    adapter1.writeTo(result);
    result += adapter1.length();
    adapter2.writeTo(result);
    result += adapter2.length();
    adapter3.writeTo(result);

    return resultImpl.release();
}

template<typename StringType1, typename StringType2, typename StringType3, typename StringType4>
PassRefPtr<StringImpl> tryMakeString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4)
{
    StringTypeAdapter<StringType1> adapter1(string1);
    StringTypeAdapter<StringType2> adapter2(string2);
    StringTypeAdapter<StringType3> adapter3(string3);
    StringTypeAdapter<StringType4> adapter4(string4);

    UChar* buffer;
    bool overflow = false;
    unsigned length = adapter1.length();
    sumWithOverflow(length, adapter2.length(), overflow);
    sumWithOverflow(length, adapter3.length(), overflow);
    sumWithOverflow(length, adapter4.length(), overflow);
    if (overflow)
        return 0;
    RefPtr<StringImpl> resultImpl = StringImpl::tryCreateUninitialized(length, buffer);
    if (!resultImpl)
        return 0;

    UChar* result = buffer;
    adapter1.writeTo(result);
    result += adapter1.length();
    adapter2.writeTo(result);
    result += adapter2.length();
    adapter3.writeTo(result);
    result += adapter3.length();
    adapter4.writeTo(result);

    return resultImpl.release();
}

template<typename StringType1, typename StringType2, typename StringType3, typename StringType4, typename StringType5>
PassRefPtr<StringImpl> tryMakeString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5)
{
    StringTypeAdapter<StringType1> adapter1(string1);
    StringTypeAdapter<StringType2> adapter2(string2);
    StringTypeAdapter<StringType3> adapter3(string3);
    StringTypeAdapter<StringType4> adapter4(string4);
    StringTypeAdapter<StringType5> adapter5(string5);

    UChar* buffer;
    bool overflow = false;
    unsigned length = adapter1.length();
    sumWithOverflow(length, adapter2.length(), overflow);
    sumWithOverflow(length, adapter3.length(), overflow);
    sumWithOverflow(length, adapter4.length(), overflow);
    sumWithOverflow(length, adapter5.length(), overflow);
    if (overflow)
        return 0;
    RefPtr<StringImpl> resultImpl = StringImpl::tryCreateUninitialized(length, buffer);
    if (!resultImpl)
        return 0;

    UChar* result = buffer;
    adapter1.writeTo(result);
    result += adapter1.length();
    adapter2.writeTo(result);
    result += adapter2.length();
    adapter3.writeTo(result);
    result += adapter3.length();
    adapter4.writeTo(result);
    result += adapter4.length();
    adapter5.writeTo(result);

    return resultImpl.release();
}

template<typename StringType1, typename StringType2, typename StringType3, typename StringType4, typename StringType5, typename StringType6>
PassRefPtr<StringImpl> tryMakeString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6)
{
    StringTypeAdapter<StringType1> adapter1(string1);
    StringTypeAdapter<StringType2> adapter2(string2);
    StringTypeAdapter<StringType3> adapter3(string3);
    StringTypeAdapter<StringType4> adapter4(string4);
    StringTypeAdapter<StringType5> adapter5(string5);
    StringTypeAdapter<StringType6> adapter6(string6);

    UChar* buffer;
    bool overflow = false;
    unsigned length = adapter1.length();
    sumWithOverflow(length, adapter2.length(), overflow);
    sumWithOverflow(length, adapter3.length(), overflow);
    sumWithOverflow(length, adapter4.length(), overflow);
    sumWithOverflow(length, adapter5.length(), overflow);
    sumWithOverflow(length, adapter6.length(), overflow);
    if (overflow)
        return 0;
    RefPtr<StringImpl> resultImpl = StringImpl::tryCreateUninitialized(length, buffer);
    if (!resultImpl)
        return 0;

    UChar* result = buffer;
    adapter1.writeTo(result);
    result += adapter1.length();
    adapter2.writeTo(result);
    result += adapter2.length();
    adapter3.writeTo(result);
    result += adapter3.length();
    adapter4.writeTo(result);
    result += adapter4.length();
    adapter5.writeTo(result);
    result += adapter5.length();
    adapter6.writeTo(result);

    return resultImpl.release();
}

template<typename StringType1, typename StringType2, typename StringType3, typename StringType4, typename StringType5, typename StringType6, typename StringType7>
PassRefPtr<StringImpl> tryMakeString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6, StringType7 string7)
{
    StringTypeAdapter<StringType1> adapter1(string1);
    StringTypeAdapter<StringType2> adapter2(string2);
    StringTypeAdapter<StringType3> adapter3(string3);
    StringTypeAdapter<StringType4> adapter4(string4);
    StringTypeAdapter<StringType5> adapter5(string5);
    StringTypeAdapter<StringType6> adapter6(string6);
    StringTypeAdapter<StringType7> adapter7(string7);

    UChar* buffer;
    bool overflow = false;
    unsigned length = adapter1.length();
    sumWithOverflow(length, adapter2.length(), overflow);
    sumWithOverflow(length, adapter3.length(), overflow);
    sumWithOverflow(length, adapter4.length(), overflow);
    sumWithOverflow(length, adapter5.length(), overflow);
    sumWithOverflow(length, adapter6.length(), overflow);
    sumWithOverflow(length, adapter7.length(), overflow);
    if (overflow)
        return 0;
    RefPtr<StringImpl> resultImpl = StringImpl::tryCreateUninitialized(length, buffer);
    if (!resultImpl)
        return 0;

    UChar* result = buffer;
    adapter1.writeTo(result);
    result += adapter1.length();
    adapter2.writeTo(result);
    result += adapter2.length();
    adapter3.writeTo(result);
    result += adapter3.length();
    adapter4.writeTo(result);
    result += adapter4.length();
    adapter5.writeTo(result);
    result += adapter5.length();
    adapter6.writeTo(result);
    result += adapter6.length();
    adapter7.writeTo(result);

    return resultImpl.release();
}

template<typename StringType1, typename StringType2, typename StringType3, typename StringType4, typename StringType5, typename StringType6, typename StringType7, typename StringType8>
PassRefPtr<StringImpl> tryMakeString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6, StringType7 string7, StringType8 string8)
{
    StringTypeAdapter<StringType1> adapter1(string1);
    StringTypeAdapter<StringType2> adapter2(string2);
    StringTypeAdapter<StringType3> adapter3(string3);
    StringTypeAdapter<StringType4> adapter4(string4);
    StringTypeAdapter<StringType5> adapter5(string5);
    StringTypeAdapter<StringType6> adapter6(string6);
    StringTypeAdapter<StringType7> adapter7(string7);
    StringTypeAdapter<StringType8> adapter8(string8);

    UChar* buffer;
    bool overflow = false;
    unsigned length = adapter1.length();
    sumWithOverflow(length, adapter2.length(), overflow);
    sumWithOverflow(length, adapter3.length(), overflow);
    sumWithOverflow(length, adapter4.length(), overflow);
    sumWithOverflow(length, adapter5.length(), overflow);
    sumWithOverflow(length, adapter6.length(), overflow);
    sumWithOverflow(length, adapter7.length(), overflow);
    sumWithOverflow(length, adapter8.length(), overflow);
    if (overflow)
        return 0;
    RefPtr<StringImpl> resultImpl = StringImpl::tryCreateUninitialized(length, buffer);
    if (!resultImpl)
        return 0;

    UChar* result = buffer;
    adapter1.writeTo(result);
    result += adapter1.length();
    adapter2.writeTo(result);
    result += adapter2.length();
    adapter3.writeTo(result);
    result += adapter3.length();
    adapter4.writeTo(result);
    result += adapter4.length();
    adapter5.writeTo(result);
    result += adapter5.length();
    adapter6.writeTo(result);
    result += adapter6.length();
    adapter7.writeTo(result);
    result += adapter7.length();
    adapter8.writeTo(result);

    return resultImpl.release();
}

template<typename StringType1, typename StringType2, typename StringType3, typename StringType4, typename StringType5, typename StringType6, typename StringType7, typename StringType8, typename StringType9>
PassRefPtr<StringImpl> tryMakeString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6, StringType7 string7, StringType8 string8, StringType9 string9)
{
    StringTypeAdapter<StringType1> adapter1(string1);
    StringTypeAdapter<StringType2> adapter2(string2);
    StringTypeAdapter<StringType3> adapter3(string3);
    StringTypeAdapter<StringType4> adapter4(string4);
    StringTypeAdapter<StringType5> adapter5(string5);
    StringTypeAdapter<StringType6> adapter6(string6);
    StringTypeAdapter<StringType7> adapter7(string7);
    StringTypeAdapter<StringType8> adapter8(string8);
    StringTypeAdapter<StringType9> adapter9(string9);

    UChar* buffer;
    bool overflow = false;
    unsigned length = adapter1.length();
    sumWithOverflow(length, adapter2.length(), overflow);
    sumWithOverflow(length, adapter3.length(), overflow);
    sumWithOverflow(length, adapter4.length(), overflow);
    sumWithOverflow(length, adapter5.length(), overflow);
    sumWithOverflow(length, adapter6.length(), overflow);
    sumWithOverflow(length, adapter7.length(), overflow);
    sumWithOverflow(length, adapter8.length(), overflow);
    sumWithOverflow(length, adapter9.length(), overflow);
    if (overflow)
        return 0;
    RefPtr<StringImpl> resultImpl = StringImpl::tryCreateUninitialized(length, buffer);
    if (!resultImpl)
        return 0;

    UChar* result = buffer;
    adapter1.writeTo(result);
    result += adapter1.length();
    adapter2.writeTo(result);
    result += adapter2.length();
    adapter3.writeTo(result);
    result += adapter3.length();
    adapter4.writeTo(result);
    result += adapter4.length();
    adapter5.writeTo(result);
    result += adapter5.length();
    adapter6.writeTo(result);
    result += adapter6.length();
    adapter7.writeTo(result);
    result += adapter7.length();
    adapter8.writeTo(result);
    result += adapter8.length();
    adapter9.writeTo(result);

    return resultImpl.release();
}



template<typename StringType1>
String makeString(StringType1 string1)
{
    return String(string1);
}

template<typename StringType1, typename StringType2>
String makeString(StringType1 string1, StringType2 string2)
{
    RefPtr<StringImpl> resultImpl = tryMakeString(string1, string2);
    if (!resultImpl)
        do { WTFReportBacktrace(); *(int *)(uintptr_t)0xbbadbeef = 0; __builtin_trap(); } while (false);
    return resultImpl.release();
}

template<typename StringType1, typename StringType2, typename StringType3>
String makeString(StringType1 string1, StringType2 string2, StringType3 string3)
{
    RefPtr<StringImpl> resultImpl = tryMakeString(string1, string2, string3);
    if (!resultImpl)
        do { WTFReportBacktrace(); *(int *)(uintptr_t)0xbbadbeef = 0; __builtin_trap(); } while (false);
    return resultImpl.release();
}

template<typename StringType1, typename StringType2, typename StringType3, typename StringType4>
String makeString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4)
{
    RefPtr<StringImpl> resultImpl = tryMakeString(string1, string2, string3, string4);
    if (!resultImpl)
        do { WTFReportBacktrace(); *(int *)(uintptr_t)0xbbadbeef = 0; __builtin_trap(); } while (false);
    return resultImpl.release();
}

template<typename StringType1, typename StringType2, typename StringType3, typename StringType4, typename StringType5>
String makeString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5)
{
    RefPtr<StringImpl> resultImpl = tryMakeString(string1, string2, string3, string4, string5);
    if (!resultImpl)
        do { WTFReportBacktrace(); *(int *)(uintptr_t)0xbbadbeef = 0; __builtin_trap(); } while (false);
    return resultImpl.release();
}

template<typename StringType1, typename StringType2, typename StringType3, typename StringType4, typename StringType5, typename StringType6>
String makeString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6)
{
    RefPtr<StringImpl> resultImpl = tryMakeString(string1, string2, string3, string4, string5, string6);
    if (!resultImpl)
        do { WTFReportBacktrace(); *(int *)(uintptr_t)0xbbadbeef = 0; __builtin_trap(); } while (false);
    return resultImpl.release();
}

template<typename StringType1, typename StringType2, typename StringType3, typename StringType4, typename StringType5, typename StringType6, typename StringType7>
String makeString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6, StringType7 string7)
{
    RefPtr<StringImpl> resultImpl = tryMakeString(string1, string2, string3, string4, string5, string6, string7);
    if (!resultImpl)
        do { WTFReportBacktrace(); *(int *)(uintptr_t)0xbbadbeef = 0; __builtin_trap(); } while (false);
    return resultImpl.release();
}

template<typename StringType1, typename StringType2, typename StringType3, typename StringType4, typename StringType5, typename StringType6, typename StringType7, typename StringType8>
String makeString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6, StringType7 string7, StringType8 string8)
{
    RefPtr<StringImpl> resultImpl = tryMakeString(string1, string2, string3, string4, string5, string6, string7, string8);
    if (!resultImpl)
        do { WTFReportBacktrace(); *(int *)(uintptr_t)0xbbadbeef = 0; __builtin_trap(); } while (false);
    return resultImpl.release();
}

template<typename StringType1, typename StringType2, typename StringType3, typename StringType4, typename StringType5, typename StringType6, typename StringType7, typename StringType8, typename StringType9>
String makeString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6, StringType7 string7, StringType8 string8, StringType9 string9)
{
    RefPtr<StringImpl> resultImpl = tryMakeString(string1, string2, string3, string4, string5, string6, string7, string8, string9);
    if (!resultImpl)
        do { WTFReportBacktrace(); *(int *)(uintptr_t)0xbbadbeef = 0; __builtin_trap(); } while (false);
    return resultImpl.release();
}

}

using WTF::makeString;


# 1 "./wtf/text/StringOperators.h" 1
# 25 "./wtf/text/StringOperators.h"
namespace WTF {

template<typename StringType1, typename StringType2>
class StringAppend {
public:
    StringAppend(StringType1 string1, StringType2 string2)
        : m_string1(string1)
        , m_string2(string2)
    {
    }

    operator String() const
    {
        RefPtr<StringImpl> resultImpl = tryMakeString(m_string1, m_string2);
        if (!resultImpl)
            do { WTFReportBacktrace(); *(int *)(uintptr_t)0xbbadbeef = 0; __builtin_trap(); } while (false);
        return resultImpl.release();
    }

    operator AtomicString() const
    {
        return operator String();
    }

    void writeTo(UChar* destination)
    {
        StringTypeAdapter<StringType1> adapter1(m_string1);
        StringTypeAdapter<StringType2> adapter2(m_string2);
        adapter1.writeTo(destination);
        adapter2.writeTo(destination + adapter1.length());
    }

    unsigned length()
    {
        StringTypeAdapter<StringType1> adapter1(m_string1);
        StringTypeAdapter<StringType2> adapter2(m_string2);
        return adapter1.length() + adapter2.length();
    }

private:
    StringType1 m_string1;
    StringType2 m_string2;
};

template<typename StringType1, typename StringType2>
class StringTypeAdapter<StringAppend<StringType1, StringType2> > {
public:
    StringTypeAdapter<StringAppend<StringType1, StringType2> >(StringAppend<StringType1, StringType2>& buffer)
        : m_buffer(buffer)
    {
    }

    unsigned length() { return m_buffer.length(); }
    void writeTo(UChar* destination) { m_buffer.writeTo(destination); }

private:
    StringAppend<StringType1, StringType2>& m_buffer;
};

inline StringAppend<const char*, String> operator+(const char* string1, const String& string2)
{
    return StringAppend<const char*, String>(string1, string2);
}

inline StringAppend<const char*, AtomicString> operator+(const char* string1, const AtomicString& string2)
{
    return StringAppend<const char*, AtomicString>(string1, string2);
}

template<typename U, typename V>
StringAppend<const char*, StringAppend<U, V> > operator+(const char* string1, const StringAppend<U, V>& string2)
{
    return StringAppend<const char*, StringAppend<U, V> >(string1, string2);
}

inline StringAppend<const UChar*, String> operator+(const UChar* string1, const String& string2)
{
    return StringAppend<const UChar*, String>(string1, string2);
}

inline StringAppend<const UChar*, AtomicString> operator+(const UChar* string1, const AtomicString& string2)
{
    return StringAppend<const UChar*, AtomicString>(string1, string2);
}

template<typename U, typename V>
StringAppend<const UChar*, StringAppend<U, V> > operator+(const UChar* string1, const StringAppend<U, V>& string2)
{
    return StringAppend<const UChar*, StringAppend<U, V> >(string1, string2);
}

template<typename T>
StringAppend<String, T> operator+(const String& string1, T string2)
{
    return StringAppend<String, T>(string1, string2);
}

template<typename U, typename V, typename W>
StringAppend<StringAppend<U, V>, W> operator+(const StringAppend<U, V>& string1, W string2)
{
    return StringAppend<StringAppend<U, V>, W>(string1, string2);
}

}
# 609 "./wtf/text/StringConcatenate.h" 2
# 209 "./wtf/text/AtomicString.h" 2
# 511 "./wtf/text/WTFString.h" 2
# 55 "./wtf/DateMath.h" 2
# 1 "./wtf/UnusedParam.h" 1
# 56 "./wtf/DateMath.h" 2

namespace WTF {
void initializeDates();
int equivalentYearForDST(int year);


double parseES5DateFromNullTerminatedCharacters(const char* dateString);
double parseDateFromNullTerminatedCharacters(const char* dateString);
double timeClip(double);

String makeRFC2822DateString(unsigned dayOfWeek, unsigned day, unsigned month, unsigned year, unsigned hours, unsigned minutes, unsigned seconds, int utcOffset);

inline double jsCurrentTime()
{

    return floor(WTF::currentTimeMS());
}

const char * const weekdayName[7] = { "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun" };
const char * const monthName[12] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };

const double hoursPerDay = 24.0;
const double minutesPerHour = 60.0;
const double secondsPerHour = 60.0 * 60.0;
const double secondsPerMinute = 60.0;
const double msPerSecond = 1000.0;
const double msPerMinute = 60.0 * 1000.0;
const double msPerHour = 60.0 * 60.0 * 1000.0;
const double msPerDay = 24.0 * 60.0 * 60.0 * 1000.0;
const double msPerMonth = 2592000000.0;


double dateToDaysFrom1970(int year, int month, int day);
int msToYear(double ms);
int dayInYear(double ms, int year);
int monthFromDayInYear(int dayInYear, bool leapYear);
int dayInMonthFromDayInYear(int dayInYear, bool leapYear);


int32_t calculateUTCOffset();
double calculateDSTOffset(double ms, double utcOffset);

}

using WTF::adoptArrayPtr;
using WTF::dateToDaysFrom1970;
using WTF::dayInMonthFromDayInYear;
using WTF::dayInYear;
using WTF::minutesPerHour;
using WTF::monthFromDayInYear;
using WTF::msPerDay;
using WTF::msPerMinute;
using WTF::msPerSecond;
using WTF::msToYear;
using WTF::secondsPerMinute;
using WTF::parseDateFromNullTerminatedCharacters;
using WTF::makeRFC2822DateString;
using WTF::calculateUTCOffset;
using WTF::calculateDSTOffset;


namespace JSC {
class ExecState;
struct GregorianDateTime;

void msToGregorianDateTime(ExecState*, double, bool outputIsUTC, GregorianDateTime&);
double gregorianDateTimeToMS(ExecState*, const GregorianDateTime&, double, bool inputIsUTC);
double getUTCOffset(ExecState*);
double parseDateFromNullTerminatedCharacters(ExecState*, const char* dateString);



struct GregorianDateTime {
    private: GregorianDateTime(const GregorianDateTime&); GregorianDateTime& operator=(const GregorianDateTime&);
public:
    GregorianDateTime()
        : second(0)
        , minute(0)
        , hour(0)
        , weekDay(0)
        , monthDay(0)
        , yearDay(0)
        , month(0)
        , year(0)
        , isDST(0)
        , utcOffset(0)
    {
    }

    GregorianDateTime(ExecState* exec, const tm& inTm)
        : second(inTm.tm_sec)
        , minute(inTm.tm_min)
        , hour(inTm.tm_hour)
        , weekDay(inTm.tm_wday)
        , monthDay(inTm.tm_mday)
        , yearDay(inTm.tm_yday)
        , month(inTm.tm_mon)
        , year(inTm.tm_year)
        , isDST(inTm.tm_isdst)
    {
        (void)exec;

        utcOffset = static_cast<int>(inTm.tm_gmtoff);





        int inZoneSize = strlen(inTm.tm_zone) + 1;
        timeZone = adoptArrayPtr(new char[inZoneSize]);
        strncpy(timeZone.get(), inTm.tm_zone, inZoneSize);



    }

    operator tm() const
    {
        tm ret;
        memset(&ret, 0, sizeof(ret));

        ret.tm_sec = second;
        ret.tm_min = minute;
        ret.tm_hour = hour;
        ret.tm_wday = weekDay;
        ret.tm_mday = monthDay;
        ret.tm_yday = yearDay;
        ret.tm_mon = month;
        ret.tm_year = year;
        ret.tm_isdst = isDST;


        ret.tm_gmtoff = static_cast<long>(utcOffset);


        ret.tm_zone = timeZone.get();


        return ret;
    }

    void copyFrom(const GregorianDateTime& rhs)
    {
        second = rhs.second;
        minute = rhs.minute;
        hour = rhs.hour;
        weekDay = rhs.weekDay;
        monthDay = rhs.monthDay;
        yearDay = rhs.yearDay;
        month = rhs.month;
        year = rhs.year;
        isDST = rhs.isDST;
        utcOffset = rhs.utcOffset;
        if (rhs.timeZone) {
            int inZoneSize = strlen(rhs.timeZone.get()) + 1;
            timeZone = adoptArrayPtr(new char[inZoneSize]);
            strncpy(timeZone.get(), rhs.timeZone.get(), inZoneSize);
        } else
            timeZone = nullptr;
    }

    int second;
    int minute;
    int hour;
    int weekDay;
    int monthDay;
    int yearDay;
    int month;
    int year;
    int isDST;
    int utcOffset;
    OwnArrayPtr<char> timeZone;
};

static inline int gmtoffset(const GregorianDateTime& t)
{
    return t.utcOffset;
}
}
# 30 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/DateInstanceCache.h" 2
# 1 "./wtf/FixedArray.h" 1
# 31 "./wtf/FixedArray.h"
namespace WTF {

template <typename T, size_t Size> class FixedArray {
public:
    T& operator[](size_t i)
    {
        ((void)0);
        return m_data[i];
    }

    const T& operator[](size_t i) const
    {
        ((void)0);
        return m_data[i];
    }

    T* data() { return m_data; }
    size_t size() const { return Size; }

private:
    T m_data[Size];
};

}

using WTF::FixedArray;
# 31 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/DateInstanceCache.h" 2


# 1 "./wtf/RefCounted.h" 1
# 26 "./wtf/RefCounted.h"
# 1 "./wtf/ThreadRestrictionVerifier.h" 1
# 39 "./wtf/ThreadRestrictionVerifier.h"
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/dispatch.h" 1 3 4
# 29 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/dispatch.h" 3 4
# 1 "/Users/ddunbar/rt/11003353/clang-r152231-t20120307_081803-b13838/Developer/usr/bin/../lib/clang/3.1/include/stddef.h" 1 3 4
# 30 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/dispatch.h" 2 3 4
# 47 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/dispatch.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/base.h" 1 3 4
# 33 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/base.h" 3 4
typedef struct dispatch_object_s {
private:
 dispatch_object_s();
 ~dispatch_object_s();
 dispatch_object_s(const dispatch_object_s &);
 void operator=(const dispatch_object_s &);
} *dispatch_object_t;
# 57 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/base.h" 3 4
typedef void (*dispatch_function_t)(void *);
# 48 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/dispatch.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/object.h" 1 3 4
# 29 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/object.h" 3 4
extern "C" {
# 50 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/object.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__(2))) __attribute__((__nothrow__)) __attribute__((__format__(printf,2,3)))
void
dispatch_debug(dispatch_object_t object, const char *message, ...);

__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__(2))) __attribute__((__nothrow__)) __attribute__((__format__(printf,2,0)))
void
dispatch_debugv(dispatch_object_t object, const char *message, va_list ap);
# 74 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/object.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__)) __attribute__((__nothrow__))
void
dispatch_retain(dispatch_object_t object);
# 95 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/object.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__)) __attribute__((__nothrow__))
void
dispatch_release(dispatch_object_t object);
# 112 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/object.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__)) __attribute__((__pure__)) __attribute__((__warn_unused_result__)) __attribute__((__nothrow__))
void *
dispatch_get_context(dispatch_object_t object);
# 130 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/object.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nothrow__))
void
dispatch_set_context(dispatch_object_t object, void *context);
# 156 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/object.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nothrow__))
void
dispatch_set_finalizer_f(dispatch_object_t object,
 dispatch_function_t finalizer);
# 180 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/object.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__)) __attribute__((__nothrow__))
void
dispatch_suspend(dispatch_object_t object);
# 195 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/object.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__)) __attribute__((__nothrow__))
void
dispatch_resume(dispatch_object_t object);

}
# 49 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/dispatch.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/time.h" 1 3 4
# 31 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/time.h" 3 4
extern "C" {

struct timespec;
# 61 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/time.h" 3 4
typedef uint64_t dispatch_time_t;
# 86 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/time.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__warn_unused_result__)) __attribute__((__nothrow__))
dispatch_time_t
dispatch_time(dispatch_time_t when, int64_t delta);
# 110 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/time.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__warn_unused_result__)) __attribute__((__nothrow__))
dispatch_time_t
dispatch_walltime(const struct timespec *when, int64_t delta);

}
# 50 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/dispatch.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/queue.h" 1 3 4
# 67 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/queue.h" 3 4
typedef struct dispatch_queue_s : public dispatch_object_s {} *dispatch_queue_t;







typedef struct dispatch_queue_attr_s : public dispatch_object_s {} *dispatch_queue_attr_t;
# 111 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/queue.h" 3 4
typedef void (^dispatch_block_t)(void);


extern "C" {
# 145 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/queue.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__)) __attribute__((__nothrow__))
void
dispatch_async(dispatch_queue_t queue, dispatch_block_t block);
# 175 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/queue.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__(1))) __attribute__((__nonnull__(3))) __attribute__((__nothrow__))
void
dispatch_async_f(dispatch_queue_t queue,
 void *context,
 dispatch_function_t work);
# 213 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/queue.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__)) __attribute__((__nothrow__))
void
dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);
# 241 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/queue.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__(1))) __attribute__((__nonnull__(3))) __attribute__((__nothrow__))
void
dispatch_sync_f(dispatch_queue_t queue,
 void *context,
 dispatch_function_t work);
# 274 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/queue.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__)) __attribute__((__nothrow__))
void
dispatch_apply(size_t iterations, dispatch_queue_t queue, void (^block)(size_t));
# 306 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/queue.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__(2))) __attribute__((__nonnull__(4))) __attribute__((__nothrow__))
void
dispatch_apply_f(size_t iterations, dispatch_queue_t queue,
 void *context,
 void (*work)(void *, size_t));
# 335 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/queue.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__pure__)) __attribute__((__warn_unused_result__)) __attribute__((__nothrow__))
dispatch_queue_t
dispatch_get_current_queue(void);
# 355 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/queue.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) struct dispatch_queue_s _dispatch_main_q;
# 392 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/queue.h" 3 4
typedef long dispatch_queue_priority_t;
# 415 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/queue.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__const__)) __attribute__((__warn_unused_result__)) __attribute__((__nothrow__))
dispatch_queue_t
dispatch_get_global_queue(dispatch_queue_priority_t priority, unsigned long flags);
# 432 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/queue.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default")))
struct dispatch_queue_attr_s _dispatch_queue_attr_concurrent;
# 470 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/queue.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__malloc__)) __attribute__((__warn_unused_result__)) __attribute__((__nothrow__))
dispatch_queue_t
dispatch_queue_create(const char *label, dispatch_queue_attr_t attr);
# 488 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/queue.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__)) __attribute__((__pure__)) __attribute__((__warn_unused_result__)) __attribute__((__nothrow__))
const char *
dispatch_queue_get_label(dispatch_queue_t queue);
# 540 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/queue.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nothrow__))
void
dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t queue);
# 558 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/queue.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nothrow__)) __attribute__((__noreturn__))
void
dispatch_main(void);
# 586 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/queue.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__(2))) __attribute__((__nonnull__(3))) __attribute__((__nothrow__))
void
dispatch_after(dispatch_time_t when,
 dispatch_queue_t queue,
 dispatch_block_t block);
# 619 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/queue.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__(2))) __attribute__((__nonnull__(4))) __attribute__((__nothrow__))
void
dispatch_after_f(dispatch_time_t when,
 dispatch_queue_t queue,
 void *context,
 dispatch_function_t work);
# 666 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/queue.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__)) __attribute__((__nothrow__))
void
dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);
# 700 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/queue.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__(1))) __attribute__((__nonnull__(3))) __attribute__((__nothrow__))
void
dispatch_barrier_async_f(dispatch_queue_t queue,
 void *context,
 dispatch_function_t work);
# 728 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/queue.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__)) __attribute__((__nothrow__))
void
dispatch_barrier_sync(dispatch_queue_t queue, dispatch_block_t block);
# 759 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/queue.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__(1))) __attribute__((__nonnull__(3))) __attribute__((__nothrow__))
void
dispatch_barrier_sync_f(dispatch_queue_t queue,
 void *context,
 dispatch_function_t work);
# 802 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/queue.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__(1))) __attribute__((__nonnull__(2))) __attribute__((__nothrow__))
void
dispatch_queue_set_specific(dispatch_queue_t queue, const void *key,
 void *context, dispatch_function_t destructor);
# 831 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/queue.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__)) __attribute__((__pure__)) __attribute__((__warn_unused_result__)) __attribute__((__nothrow__))
void *
dispatch_queue_get_specific(dispatch_queue_t queue, const void *key);
# 857 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/queue.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__)) __attribute__((__pure__)) __attribute__((__warn_unused_result__)) __attribute__((__nothrow__))
void *
dispatch_get_specific(const void *key);

}
# 51 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/dispatch.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/source.h" 1 3 4
# 30 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/source.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/port.h" 1 3 4
# 91 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/port.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/boolean.h" 1 3 4
# 73 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/boolean.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/machine/boolean.h" 1 3 4
# 33 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/machine/boolean.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/i386/boolean.h" 1 3 4
# 69 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/i386/boolean.h" 3 4
typedef unsigned int boolean_t;
# 34 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/machine/boolean.h" 2 3 4
# 74 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/boolean.h" 2 3 4
# 92 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/port.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/machine/vm_types.h" 1 3 4
# 33 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/machine/vm_types.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/i386/vm_types.h" 1 3 4
# 73 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/i386/vm_types.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/i386/vm_param.h" 1 3 4
# 74 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/i386/vm_types.h" 2 3 4
# 93 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/i386/vm_types.h" 3 4
typedef __darwin_natural_t natural_t;
typedef int integer_t;






typedef uintptr_t vm_offset_t;
# 112 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/i386/vm_types.h" 3 4
typedef uintptr_t vm_size_t;
# 124 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/i386/vm_types.h" 3 4
typedef uint64_t mach_vm_address_t;
typedef uint64_t mach_vm_offset_t;
typedef uint64_t mach_vm_size_t;

typedef uint64_t vm_map_offset_t;
typedef uint64_t vm_map_address_t;
typedef uint64_t vm_map_size_t;
# 34 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/machine/vm_types.h" 2 3 4
# 93 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/port.h" 2 3 4
# 106 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/port.h" 3 4
typedef natural_t mach_port_name_t;
typedef mach_port_name_t *mach_port_name_array_t;
# 132 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/port.h" 3 4
typedef mach_port_t *mach_port_array_t;
# 190 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/port.h" 3 4
typedef natural_t mach_port_right_t;
# 200 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/port.h" 3 4
typedef natural_t mach_port_type_t;
typedef mach_port_type_t *mach_port_type_array_t;
# 235 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/port.h" 3 4
typedef natural_t mach_port_urefs_t;
typedef integer_t mach_port_delta_t;



typedef natural_t mach_port_seqno_t;
typedef natural_t mach_port_mscount_t;
typedef natural_t mach_port_msgcount_t;
typedef natural_t mach_port_rights_t;






typedef unsigned int mach_port_srights_t;

typedef struct mach_port_status {
 mach_port_rights_t mps_pset;
 mach_port_seqno_t mps_seqno;
 mach_port_mscount_t mps_mscount;
 mach_port_msgcount_t mps_qlimit;
 mach_port_msgcount_t mps_msgcount;
 mach_port_rights_t mps_sorights;
 boolean_t mps_srights;
 boolean_t mps_pdrequest;
 boolean_t mps_nsrequest;
 natural_t mps_flags;
} mach_port_status_t;
# 275 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/port.h" 3 4
typedef struct mach_port_limits {
 mach_port_msgcount_t mpl_qlimit;
} mach_port_limits_t;

typedef integer_t *mach_port_info_t;


typedef int mach_port_flavor_t;
# 297 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/port.h" 3 4
typedef struct mach_port_qos {
 unsigned int name:1;
 unsigned int prealloc:1;
 boolean_t pad1:30;
 natural_t len;
} mach_port_qos_t;
# 31 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/source.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/message.h" 1 3 4
# 77 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/message.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/kern_return.h" 1 3 4
# 70 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/kern_return.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/machine/kern_return.h" 1 3 4
# 33 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/machine/kern_return.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/i386/kern_return.h" 1 3 4
# 71 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/i386/kern_return.h" 3 4
typedef int kern_return_t;
# 34 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/machine/kern_return.h" 2 3 4
# 71 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/kern_return.h" 2 3 4
# 78 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/message.h" 2 3 4
# 89 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/message.h" 3 4
typedef natural_t mach_msg_timeout_t;
# 172 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/message.h" 3 4
typedef unsigned int mach_msg_bits_t;
typedef natural_t mach_msg_size_t;
typedef integer_t mach_msg_id_t;




typedef unsigned int mach_msg_type_name_t;
# 189 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/message.h" 3 4
typedef unsigned int mach_msg_copy_options_t;
# 211 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/message.h" 3 4
typedef unsigned int mach_msg_descriptor_type_t;






#pragma pack(4)

typedef struct
{
  natural_t pad1;
  mach_msg_size_t pad2;
  unsigned int pad3 : 24;
  mach_msg_descriptor_type_t type : 8;
} mach_msg_type_descriptor_t;

typedef struct
{
  mach_port_t name;


  mach_msg_size_t pad1;

  unsigned int pad2 : 16;
  mach_msg_type_name_t disposition : 8;
  mach_msg_descriptor_type_t type : 8;
} mach_msg_port_descriptor_t;

typedef struct
{
  uint32_t address;
  mach_msg_size_t size;
  boolean_t deallocate: 8;
  mach_msg_copy_options_t copy: 8;
  unsigned int pad1: 8;
  mach_msg_descriptor_type_t type: 8;
} mach_msg_ool_descriptor32_t;

typedef struct
{
  uint64_t address;
  boolean_t deallocate: 8;
  mach_msg_copy_options_t copy: 8;
  unsigned int pad1: 8;
  mach_msg_descriptor_type_t type: 8;
  mach_msg_size_t size;
} mach_msg_ool_descriptor64_t;

typedef struct
{
  void* address;



  boolean_t deallocate: 8;
  mach_msg_copy_options_t copy: 8;
  unsigned int pad1: 8;
  mach_msg_descriptor_type_t type: 8;

  mach_msg_size_t size;




} mach_msg_ool_descriptor_t;

typedef struct
{
  uint32_t address;
  mach_msg_size_t count;
  boolean_t deallocate: 8;
  mach_msg_copy_options_t copy: 8;
  mach_msg_type_name_t disposition : 8;
  mach_msg_descriptor_type_t type : 8;
} mach_msg_ool_ports_descriptor32_t;

typedef struct
{
  uint64_t address;
  boolean_t deallocate: 8;
  mach_msg_copy_options_t copy: 8;
  mach_msg_type_name_t disposition : 8;
  mach_msg_descriptor_type_t type : 8;
  mach_msg_size_t count;
} mach_msg_ool_ports_descriptor64_t;

typedef struct
{
  void* address;



  boolean_t deallocate: 8;
  mach_msg_copy_options_t copy: 8;
  mach_msg_type_name_t disposition : 8;
  mach_msg_descriptor_type_t type : 8;

  mach_msg_size_t count;




} mach_msg_ool_ports_descriptor_t;
# 330 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/message.h" 3 4
typedef union
{
  mach_msg_port_descriptor_t port;
  mach_msg_ool_descriptor_t out_of_line;
  mach_msg_ool_ports_descriptor_t ool_ports;
  mach_msg_type_descriptor_t type;
} mach_msg_descriptor_t;


typedef struct
{
        mach_msg_size_t msgh_descriptor_count;
} mach_msg_body_t;




typedef struct
{
  mach_msg_bits_t msgh_bits;
  mach_msg_size_t msgh_size;
  mach_port_t msgh_remote_port;
  mach_port_t msgh_local_port;
  mach_msg_size_t msgh_reserved;
  mach_msg_id_t msgh_id;
} mach_msg_header_t;



typedef struct
{
        mach_msg_header_t header;
        mach_msg_body_t body;
} mach_msg_base_t;

typedef unsigned int mach_msg_trailer_type_t;



typedef unsigned int mach_msg_trailer_size_t;

typedef struct
{
  mach_msg_trailer_type_t msgh_trailer_type;
  mach_msg_trailer_size_t msgh_trailer_size;
} mach_msg_trailer_t;

typedef struct
{
  mach_msg_trailer_type_t msgh_trailer_type;
  mach_msg_trailer_size_t msgh_trailer_size;
  mach_port_seqno_t msgh_seqno;
} mach_msg_seqno_trailer_t;

typedef struct
{
  unsigned int val[2];
} security_token_t;

typedef struct
{
  mach_msg_trailer_type_t msgh_trailer_type;
  mach_msg_trailer_size_t msgh_trailer_size;
  mach_port_seqno_t msgh_seqno;
  security_token_t msgh_sender;
} mach_msg_security_trailer_t;
# 406 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/message.h" 3 4
typedef struct
{
  unsigned int val[8];
} audit_token_t;

typedef struct
{
  mach_msg_trailer_type_t msgh_trailer_type;
  mach_msg_trailer_size_t msgh_trailer_size;
  mach_port_seqno_t msgh_seqno;
  security_token_t msgh_sender;
  audit_token_t msgh_audit;
} mach_msg_audit_trailer_t;

typedef struct
{
  mach_msg_trailer_type_t msgh_trailer_type;
  mach_msg_trailer_size_t msgh_trailer_size;
  mach_port_seqno_t msgh_seqno;
  security_token_t msgh_sender;
  audit_token_t msgh_audit;
  mach_vm_address_t msgh_context;
} mach_msg_context_trailer_t;


typedef struct
{
  mach_port_name_t sender;
} msg_labels_t;






typedef struct
{
  mach_msg_trailer_type_t msgh_trailer_type;
  mach_msg_trailer_size_t msgh_trailer_size;
  mach_port_seqno_t msgh_seqno;
  security_token_t msgh_sender;
  audit_token_t msgh_audit;
  mach_vm_address_t msgh_context;
  int msgh_ad;
  msg_labels_t msgh_labels;
} mach_msg_mac_trailer_t;
# 464 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/message.h" 3 4
typedef mach_msg_mac_trailer_t mach_msg_max_trailer_t;
# 474 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/message.h" 3 4
typedef mach_msg_security_trailer_t mach_msg_format_0_trailer_t;







extern security_token_t KERNEL_SECURITY_TOKEN;


extern audit_token_t KERNEL_AUDIT_TOKEN;

typedef integer_t mach_msg_options_t;

typedef struct
{
  mach_msg_header_t header;
} mach_msg_empty_send_t;

typedef struct
{
  mach_msg_header_t header;
  mach_msg_trailer_t trailer;
} mach_msg_empty_rcv_t;

typedef union
{
  mach_msg_empty_send_t send;
  mach_msg_empty_rcv_t rcv;
} mach_msg_empty_t;

#pragma pack()
# 527 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/message.h" 3 4
typedef natural_t mach_msg_type_size_t;
typedef natural_t mach_msg_type_number_t;
# 571 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/message.h" 3 4
typedef integer_t mach_msg_option_t;
# 648 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/message.h" 3 4
typedef kern_return_t mach_msg_return_t;
# 731 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/message.h" 3 4
extern "C" {
# 750 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/message.h" 3 4
extern mach_msg_return_t mach_msg_overwrite(
     mach_msg_header_t *msg,
     mach_msg_option_t option,
     mach_msg_size_t send_size,
     mach_msg_size_t rcv_size,
     mach_port_name_t rcv_name,
     mach_msg_timeout_t timeout,
     mach_port_name_t notify,
     mach_msg_header_t *rcv_msg,
     mach_msg_size_t rcv_limit);
# 770 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/message.h" 3 4
extern mach_msg_return_t mach_msg(
     mach_msg_header_t *msg,
     mach_msg_option_t option,
     mach_msg_size_t send_size,
     mach_msg_size_t rcv_size,
     mach_port_name_t rcv_name,
     mach_msg_timeout_t timeout,
     mach_port_name_t notify);


}
# 32 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/source.h" 2 3 4
# 52 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/source.h" 3 4
typedef struct dispatch_source_s : public dispatch_object_s {} *dispatch_source_t;
# 65 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/source.h" 3 4
typedef const struct dispatch_source_type_s *dispatch_source_type_t;
# 75 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/source.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default")))
const struct dispatch_source_type_s _dispatch_source_type_data_add;
# 88 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/source.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default")))
const struct dispatch_source_type_s _dispatch_source_type_data_or;
# 100 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/source.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default")))
const struct dispatch_source_type_s _dispatch_source_type_mach_send;
# 111 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/source.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default")))
const struct dispatch_source_type_s _dispatch_source_type_mach_recv;
# 123 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/source.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default")))
const struct dispatch_source_type_s _dispatch_source_type_proc;
# 135 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/source.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default")))
const struct dispatch_source_type_s _dispatch_source_type_read;
# 146 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/source.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default")))
const struct dispatch_source_type_s _dispatch_source_type_signal;
# 158 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/source.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default")))
const struct dispatch_source_type_s _dispatch_source_type_timer;
# 170 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/source.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default")))
const struct dispatch_source_type_s _dispatch_source_type_vnode;
# 182 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/source.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default")))
const struct dispatch_source_type_s _dispatch_source_type_write;
# 195 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/source.h" 3 4
typedef unsigned long dispatch_source_mach_send_flags_t;
# 219 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/source.h" 3 4
typedef unsigned long dispatch_source_proc_flags_t;
# 255 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/source.h" 3 4
typedef unsigned long dispatch_source_vnode_flags_t;

extern "C" {
# 290 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/source.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__malloc__)) __attribute__((__warn_unused_result__)) __attribute__((__nothrow__))
dispatch_source_t
dispatch_source_create(dispatch_source_type_t type,
 uintptr_t handle,
 unsigned long mask,
 dispatch_queue_t queue);
# 312 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/source.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__(1))) __attribute__((__nothrow__))
void
dispatch_source_set_event_handler(dispatch_source_t source,
 dispatch_block_t handler);
# 335 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/source.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__(1))) __attribute__((__nothrow__))
void
dispatch_source_set_event_handler_f(dispatch_source_t source,
 dispatch_function_t handler);
# 369 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/source.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__(1))) __attribute__((__nothrow__))
void
dispatch_source_set_cancel_handler(dispatch_source_t source,
 dispatch_block_t cancel_handler);
# 394 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/source.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__(1))) __attribute__((__nothrow__))
void
dispatch_source_set_cancel_handler_f(dispatch_source_t source,
 dispatch_function_t cancel_handler);
# 422 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/source.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__)) __attribute__((__nothrow__))
void
dispatch_source_cancel(dispatch_source_t source);
# 440 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/source.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__)) __attribute__((__warn_unused_result__)) __attribute__((__pure__)) __attribute__((__nothrow__))
long
dispatch_source_testcancel(dispatch_source_t source);
# 469 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/source.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__)) __attribute__((__warn_unused_result__)) __attribute__((__pure__)) __attribute__((__nothrow__))
uintptr_t
dispatch_source_get_handle(dispatch_source_t source);
# 498 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/source.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__)) __attribute__((__warn_unused_result__)) __attribute__((__pure__)) __attribute__((__nothrow__))
unsigned long
dispatch_source_get_mask(dispatch_source_t source);
# 534 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/source.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__)) __attribute__((__warn_unused_result__)) __attribute__((__pure__)) __attribute__((__nothrow__))
unsigned long
dispatch_source_get_data(dispatch_source_t source);
# 555 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/source.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__)) __attribute__((__nothrow__))
void
dispatch_source_merge_data(dispatch_source_t source, unsigned long value);
# 592 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/source.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__)) __attribute__((__nothrow__))
void
dispatch_source_set_timer(dispatch_source_t source,
 dispatch_time_t start,
 uint64_t interval,
 uint64_t leeway);
# 622 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/source.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__(1))) __attribute__((__nothrow__))
void
dispatch_source_set_registration_handler(dispatch_source_t source,
 dispatch_block_t registration_handler);
# 647 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/source.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__(1))) __attribute__((__nothrow__))
void
dispatch_source_set_registration_handler_f(dispatch_source_t source,
 dispatch_function_t registration_handler);

}
# 52 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/dispatch.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/group.h" 1 3 4
# 34 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/group.h" 3 4
typedef struct dispatch_group_s : public dispatch_object_s {} *dispatch_group_t;

extern "C" {
# 52 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/group.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__malloc__)) __attribute__((__warn_unused_result__)) __attribute__((__nothrow__))
dispatch_group_t
dispatch_group_create(void);
# 81 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/group.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__)) __attribute__((__nothrow__))
void
dispatch_group_async(dispatch_group_t group,
 dispatch_queue_t queue,
 dispatch_block_t block);
# 115 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/group.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__(1))) __attribute__((__nonnull__(2))) __attribute__((__nonnull__(4))) __attribute__((__nothrow__))
void
dispatch_group_async_f(dispatch_group_t group,
 dispatch_queue_t queue,
 void *context,
 dispatch_function_t work);
# 158 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/group.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__)) __attribute__((__nothrow__))
long
dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout);
# 194 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/group.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__)) __attribute__((__nothrow__))
void
dispatch_group_notify(dispatch_group_t group,
 dispatch_queue_t queue,
 dispatch_block_t block);
# 224 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/group.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__(1))) __attribute__((__nonnull__(2))) __attribute__((__nonnull__(4))) __attribute__((__nothrow__))
void
dispatch_group_notify_f(dispatch_group_t group,
 dispatch_queue_t queue,
 void *context,
 dispatch_function_t work);
# 247 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/group.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__)) __attribute__((__nothrow__))
void
dispatch_group_enter(dispatch_group_t group);
# 266 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/group.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__)) __attribute__((__nothrow__))
void
dispatch_group_leave(dispatch_group_t group);

}
# 53 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/dispatch.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/semaphore.h" 1 3 4
# 35 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/semaphore.h" 3 4
typedef struct dispatch_semaphore_s : public dispatch_object_s {} *dispatch_semaphore_t;

extern "C" {
# 58 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/semaphore.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__malloc__)) __attribute__((__warn_unused_result__)) __attribute__((__nothrow__))
dispatch_semaphore_t
dispatch_semaphore_create(long value);
# 83 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/semaphore.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__)) __attribute__((__nothrow__))
long
dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout);
# 105 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/semaphore.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__)) __attribute__((__nothrow__))
long
dispatch_semaphore_signal(dispatch_semaphore_t dsema);

}
# 54 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/dispatch.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/once.h" 1 3 4
# 29 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/once.h" 3 4
extern "C" {
# 38 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/once.h" 3 4
typedef long dispatch_once_t;
# 58 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/once.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__)) __attribute__((__nothrow__))
void
dispatch_once(dispatch_once_t *predicate, dispatch_block_t block);

static __inline__ __attribute__((__always_inline__)) __attribute__((__nonnull__)) __attribute__((__nothrow__))
void
_dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
 if (__builtin_expect((*predicate), (~0l)) != ~0l) {
  dispatch_once(predicate, block);
 }
}




__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__(1))) __attribute__((__nonnull__(3))) __attribute__((__nothrow__))
void
dispatch_once_f(dispatch_once_t *predicate, void *context, dispatch_function_t function);

static __inline__ __attribute__((__always_inline__)) __attribute__((__nonnull__(1))) __attribute__((__nonnull__(3))) __attribute__((__nothrow__))
void
_dispatch_once_f(dispatch_once_t *predicate, void *context, dispatch_function_t function)
{
 if (__builtin_expect((*predicate), (~0l)) != ~0l) {
  dispatch_once_f(predicate, context, function);
 }
}



}
# 55 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/dispatch.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/data.h" 1 3 4
# 29 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/data.h" 3 4
extern "C" {
# 42 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/data.h" 3 4
typedef struct dispatch_data_s : public dispatch_object_s {} *dispatch_data_t;







__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) struct dispatch_data_s _dispatch_data_empty;
# 70 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/data.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) const dispatch_block_t _dispatch_data_destructor_free;
# 94 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/data.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__malloc__)) __attribute__((__warn_unused_result__)) __attribute__((__nothrow__))
dispatch_data_t
dispatch_data_create(const void *buffer,
 size_t size,
 dispatch_queue_t queue,
 dispatch_block_t destructor);
# 110 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/data.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__nothrow__))
size_t
dispatch_data_get_size(dispatch_data_t data);
# 132 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/data.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__)) __attribute__((__nothrow__))
dispatch_data_t
dispatch_data_create_map(dispatch_data_t data,
 const void **buffer_ptr,
 size_t *size_ptr);
# 154 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/data.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__)) __attribute__((__warn_unused_result__)) __attribute__((__nothrow__))
dispatch_data_t
dispatch_data_create_concat(dispatch_data_t data1, dispatch_data_t data2);
# 174 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/data.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__(1))) __attribute__((__warn_unused_result__)) __attribute__((__nothrow__))
dispatch_data_t
dispatch_data_create_subrange(dispatch_data_t data,
 size_t offset,
 size_t length);
# 192 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/data.h" 3 4
typedef bool (^dispatch_data_applier_t)(dispatch_data_t region,
 size_t offset,
 const void *buffer,
 size_t size);
# 217 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/data.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__)) __attribute__((__nothrow__))
bool
dispatch_data_apply(dispatch_data_t data, dispatch_data_applier_t applier);
# 236 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/data.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__(1))) __attribute__((__nonnull__(3))) __attribute__((__warn_unused_result__)) __attribute__((__nothrow__))
dispatch_data_t
dispatch_data_copy_region(dispatch_data_t data,
 size_t location,
 size_t *offset_ptr);



}
# 56 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/dispatch.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/io.h" 1 3 4
# 29 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/io.h" 3 4
extern "C" {
# 51 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/io.h" 3 4
typedef int dispatch_fd_t;
# 104 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/io.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__(3))) __attribute__((__nonnull__(4))) __attribute__((__nothrow__))
void
dispatch_read(dispatch_fd_t fd,
 size_t length,
 dispatch_queue_t queue,
 void (^handler)(dispatch_data_t data, int error));
# 142 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/io.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__(2))) __attribute__((__nonnull__(3))) __attribute__((__nonnull__(4))) __attribute__((__nothrow__))
void
dispatch_write(dispatch_fd_t fd,
 dispatch_data_t data,
 dispatch_queue_t queue,
 void (^handler)(dispatch_data_t data, int error));
# 160 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/io.h" 3 4
typedef struct dispatch_io_s : public dispatch_object_s {} *dispatch_io_t;
# 170 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/io.h" 3 4
typedef void (^dispatch_io_handler_t)(bool done, dispatch_data_t data, int error);
# 193 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/io.h" 3 4
typedef unsigned long dispatch_io_type_t;
# 220 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/io.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__malloc__)) __attribute__((__warn_unused_result__)) __attribute__((__nothrow__))
dispatch_io_t
dispatch_io_create(dispatch_io_type_t type,
 dispatch_fd_t fd,
 dispatch_queue_t queue,
 void (^cleanup_handler)(int error));
# 255 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/io.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__malloc__)) __attribute__((__nonnull__(2))) __attribute__((__warn_unused_result__)) __attribute__((__nothrow__))
dispatch_io_t
dispatch_io_create_with_path(dispatch_io_type_t type,
 const char *path, int oflag, mode_t mode,
 dispatch_queue_t queue,
 void (^cleanup_handler)(int error));
# 294 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/io.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__(2))) __attribute__((__malloc__)) __attribute__((__warn_unused_result__)) __attribute__((__nothrow__))
dispatch_io_t
dispatch_io_create_with_io(dispatch_io_type_t type,
 dispatch_io_t io,
 dispatch_queue_t queue,
 void (^cleanup_handler)(int error));
# 344 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/io.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__(1))) __attribute__((__nonnull__(4))) __attribute__((__nonnull__(5))) __attribute__((__nothrow__))
void
dispatch_io_read(dispatch_io_t channel,
 off_t offset,
 size_t length,
 dispatch_queue_t queue,
 dispatch_io_handler_t io_handler);
# 396 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/io.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__(1))) __attribute__((__nonnull__(3))) __attribute__((__nonnull__(4))) __attribute__((__nonnull__(5))) __attribute__((__nothrow__))
void
dispatch_io_write(dispatch_io_t channel,
 off_t offset,
 dispatch_data_t data,
 dispatch_queue_t queue,
 dispatch_io_handler_t io_handler);
# 414 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/io.h" 3 4
typedef unsigned long dispatch_io_close_flags_t;
# 433 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/io.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__(1))) __attribute__((__nothrow__))
void
dispatch_io_close(dispatch_io_t channel, dispatch_io_close_flags_t flags);
# 459 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/io.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__)) __attribute__((__nothrow__))
void
dispatch_io_barrier(dispatch_io_t channel, dispatch_block_t barrier);
# 478 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/io.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__)) __attribute__((__warn_unused_result__)) __attribute__((__nothrow__))
dispatch_fd_t
dispatch_io_get_descriptor(dispatch_io_t channel);
# 499 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/io.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__(1))) __attribute__((__nothrow__))
void
dispatch_io_set_high_water(dispatch_io_t channel, size_t high_water);
# 530 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/io.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__(1))) __attribute__((__nothrow__))
void
dispatch_io_set_low_water(dispatch_io_t channel, size_t low_water);
# 545 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/io.h" 3 4
typedef unsigned long dispatch_io_interval_flags_t;
# 569 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/io.h" 3 4
__attribute__((visibility("default")))
extern __attribute__((visibility("default"))) __attribute__((__nonnull__(1))) __attribute__((__nothrow__))
void
dispatch_io_set_interval(dispatch_io_t channel,
 uint64_t interval,
 dispatch_io_interval_flags_t flags);



}
# 57 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/dispatch/dispatch.h" 2 3 4
# 40 "./wtf/ThreadRestrictionVerifier.h" 2
# 27 "./wtf/RefCounted.h" 2




namespace WTF {




class RefCountedBase {
public:
    void ref()
    {
# 53 "./wtf/RefCounted.h"
        ((void)0);
        ((void)0);
        ((void)0);
        ++m_refCount;
    }

    bool hasOneRef() const
    {
        ((void)0);
        ((void)0);
        return m_refCount == 1;
    }

    int refCount() const
    {
        ((void)0);
        return m_refCount;
    }

    void setMutexForVerifier(Mutex&);


    void setDispatchQueueForVerifier(dispatch_queue_t);





    void deprecatedTurnOffVerifier()
    {



    }

    void relaxAdoptionRequirement()
    {





    }


    const int* addressOfCount() const
    {
        return &m_refCount;
    }

protected:
    RefCountedBase()
        : m_refCount(1)




    {
    }

    ~RefCountedBase()
    {
        ((void)0);
        ((void)0);
    }


    bool derefBase()
    {
        ((void)0);
        ((void)0);
        ((void)0);

        ((void)0);
        if (m_refCount == 1) {



            return true;
        }

        --m_refCount;






        return false;
    }
# 151 "./wtf/RefCounted.h"
private:





    int m_refCount;





};
# 177 "./wtf/RefCounted.h"
template<typename T> class RefCounted : public RefCountedBase {
    private: RefCounted(const RefCounted&); RefCounted& operator=(const RefCounted&); public: void* operator new(size_t, void* p) { return p; } void* operator new[](size_t, void* p) { return p; } void* operator new(size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNew); return p; } void operator delete(void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNew); ::WTF::fastFree(p); } void* operator new[](size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNewArray); return p; } void operator delete[](void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNewArray); ::WTF::fastFree(p); } private: typedef int ThisIsHereToForceASemicolonAfterThisMacro;
public:
    void deref()
    {
        if (derefBase())
            delete static_cast<T*>(this);
    }

protected:
    RefCounted() { }
    ~RefCounted()
    {
    }
};

template<typename T> class RefCountedCustomAllocated : public RefCountedBase {
    private: RefCountedCustomAllocated(const RefCountedCustomAllocated&); RefCountedCustomAllocated& operator=(const RefCountedCustomAllocated&);

public:
    void deref()
    {
        if (derefBase())
            delete static_cast<T*>(this);
    }

protected:
    ~RefCountedCustomAllocated()
    {
    }
};


inline void RefCountedBase::setMutexForVerifier(Mutex&) { }
# 220 "./wtf/RefCounted.h"
inline void RefCountedBase::setDispatchQueueForVerifier(dispatch_queue_t) { }
# 229 "./wtf/RefCounted.h"
}

using WTF::RefCounted;
using WTF::RefCountedCustomAllocated;
# 34 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/DateInstanceCache.h" 2

namespace JSC {

    class DateInstanceData : public RefCounted<DateInstanceData> {
    public:
        static PassRefPtr<DateInstanceData> create() { return adoptRef(new DateInstanceData); }

        double m_gregorianDateTimeCachedForMS;
        GregorianDateTime m_cachedGregorianDateTime;
        double m_gregorianDateTimeUTCCachedForMS;
        GregorianDateTime m_cachedGregorianDateTimeUTC;

    private:
        DateInstanceData()
            : m_gregorianDateTimeCachedForMS(std::numeric_limits<double>::quiet_NaN())
            , m_gregorianDateTimeUTCCachedForMS(std::numeric_limits<double>::quiet_NaN())
        {
        }
    };

    class DateInstanceCache {
    public:
        DateInstanceCache()
        {
            reset();
        }

        void reset()
        {
            for (size_t i = 0; i < cacheSize; ++i)
                m_cache[i].key = std::numeric_limits<double>::quiet_NaN();
        }

        DateInstanceData* add(double d)
        {
            CacheEntry& entry = lookup(d);
            if (d == entry.key)
                return entry.value.get();

            entry.key = d;
            entry.value = DateInstanceData::create();
            return entry.value.get();
        }

    private:
        static const size_t cacheSize = 16;

        struct CacheEntry {
            double key;
            RefPtr<DateInstanceData> value;
        };

        CacheEntry& lookup(double d) { return m_cache[WTF::FloatHash<double>::hash(d) & (cacheSize - 1)]; }

        FixedArray<CacheEntry, cacheSize> m_cache;
    };

}
# 35 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSGlobalData.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/jit/ExecutableAllocator.h" 1
# 28 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/jit/ExecutableAllocator.h"
# 1 "/Users/ddunbar/rt/11003353/clang-r152231-t20120307_081803-b13838/Developer/usr/bin/../lib/clang/3.1/include/stddef.h" 1 3 4
# 29 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/jit/ExecutableAllocator.h" 2


# 1 "./wtf/MetaAllocatorHandle.h" 1
# 36 "./wtf/MetaAllocatorHandle.h"
namespace WTF {

class MetaAllocator;

class MetaAllocatorHandle: public RefCounted<MetaAllocatorHandle> {
private:
    MetaAllocatorHandle(MetaAllocator*, void* start, size_t sizeInBytes);

    MetaAllocatorHandle(void* start, size_t sizeInBytes)
        : m_allocator(0)
        , m_start(start)
        , m_sizeInBytes(sizeInBytes)
    {
        ((void)0);
    }

public:
    ~MetaAllocatorHandle();

    static PassRefPtr<MetaAllocatorHandle> createSelfManagedHandle(void* start, size_t sizeInBytes)
    {
        return adoptRef(new MetaAllocatorHandle(start, sizeInBytes));
    }

    void* start()
    {
        return m_start;
    }

    void* end()
    {
        return reinterpret_cast<void*>(reinterpret_cast<uintptr_t>(m_start) + m_sizeInBytes);
    }

    size_t sizeInBytes()
    {
        return m_sizeInBytes;
    }

    void shrink(size_t newSizeInBytes);

    bool isManaged()
    {
        return !!m_allocator;
    }

    MetaAllocator* allocator()
    {
        ((void)0);
        return m_allocator;
    }

private:
    friend class MetaAllocator;

    MetaAllocator* m_allocator;
    void* m_start;
    size_t m_sizeInBytes;
};

}
# 32 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/jit/ExecutableAllocator.h" 2
# 1 "./wtf/PageAllocation.h" 1
# 30 "./wtf/PageAllocation.h"
# 1 "./wtf/OSAllocator.h" 1
# 30 "./wtf/OSAllocator.h"
# 1 "./wtf/VMTags.h" 1
# 33 "./wtf/VMTags.h"
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/vm_statistics.h" 1 3 4
# 84 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/vm_statistics.h" 3 4
struct vm_statistics {
 natural_t free_count;
 natural_t active_count;
 natural_t inactive_count;
 natural_t wire_count;
 natural_t zero_fill_count;
 natural_t reactivations;
 natural_t pageins;
 natural_t pageouts;
 natural_t faults;
 natural_t cow_faults;
 natural_t lookups;
 natural_t hits;


 natural_t purgeable_count;
 natural_t purges;
# 109 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/vm_statistics.h" 3 4
 natural_t speculative_count;
};


typedef struct vm_statistics *vm_statistics_t;
typedef struct vm_statistics vm_statistics_data_t;
# 132 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/vm_statistics.h" 3 4
struct vm_statistics64 {
 natural_t free_count;
 natural_t active_count;
 natural_t inactive_count;
 natural_t wire_count;
 uint64_t zero_fill_count;
 uint64_t reactivations;
 uint64_t pageins;
 uint64_t pageouts;
 uint64_t faults;
 uint64_t cow_faults;
 uint64_t lookups;
 uint64_t hits;


 uint64_t purges;
 natural_t purgeable_count;
# 157 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/vm_statistics.h" 3 4
 natural_t speculative_count;

} __attribute__((aligned(8)));

typedef struct vm_statistics64 *vm_statistics64_t;
typedef struct vm_statistics64 vm_statistics64_data_t;
# 182 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/vm_statistics.h" 3 4
struct vm_extmod_statistics {
 int64_t task_for_pid_count;
 int64_t task_for_pid_caller_count;
 int64_t thread_creation_count;
 int64_t thread_creation_caller_count;
 int64_t thread_set_state_count;
 int64_t thread_set_state_caller_count;
} __attribute__((aligned(8)));

typedef struct vm_extmod_statistics *vm_extmod_statistics_t;
typedef struct vm_extmod_statistics vm_extmod_statistics_data_t;
# 34 "./wtf/VMTags.h" 2
# 31 "./wtf/OSAllocator.h" 2


namespace WTF {

class OSAllocator {
public:
    enum Usage {
        UnknownUsage = -1,
        FastMallocPages = ((53) << 24),
        JSGCHeapPages = ((63) << 24),
        JSVMStackPages = ((65) << 24),
        JSJITCodePages = ((64) << 24),
    };




    static void* reserveUncommitted(size_t, Usage = UnknownUsage, bool writable = true, bool executable = false, bool includesGuardPages = false);
    static void releaseDecommitted(void*, size_t);




    static void commit(void*, size_t, bool writable, bool executable);
    static void decommit(void*, size_t);




    static void* reserveAndCommit(size_t, Usage = UnknownUsage, bool writable = true, bool executable = false, bool includesGuardPages = false);
    static void decommitAndRelease(void* base, size_t size);




    static void* reserveAndCommit(size_t reserveSize, size_t commitSize, Usage = UnknownUsage, bool writable = true, bool executable = false);
    static void decommitAndRelease(void* releaseBase, size_t releaseSize, void* decommitBase, size_t decommitSize);
};

inline void* OSAllocator::reserveAndCommit(size_t reserveSize, size_t commitSize, Usage usage, bool writable, bool executable)
{
    void* base = reserveUncommitted(reserveSize, usage, writable, executable);
    commit(base, commitSize, writable, executable);
    return base;
}

inline void OSAllocator::decommitAndRelease(void* releaseBase, size_t releaseSize, void* decommitBase, size_t decommitSize)
{
    ((void)0);





    (void)decommitBase;
    (void)decommitSize;

    releaseDecommitted(releaseBase, releaseSize);
}

inline void OSAllocator::decommitAndRelease(void* base, size_t size)
{
    decommitAndRelease(base, size, base, size);
}

}

using WTF::OSAllocator;
# 31 "./wtf/PageAllocation.h" 2
# 1 "./wtf/PageBlock.h" 1
# 29 "./wtf/PageBlock.h"
namespace WTF {

size_t pageSize();
inline bool isPageAligned(void* address) { return !(reinterpret_cast<intptr_t>(address) & (pageSize() - 1)); }
inline bool isPageAligned(size_t size) { return !(size & (pageSize() - 1)); }
inline bool isPowerOfTwo(size_t size) { return !(size & (size - 1)); }

class PageBlock {
public:
    PageBlock();
    PageBlock(const PageBlock&);
    PageBlock(void*, size_t, bool hasGuardPages);

    void* base() const { return m_base; }
    size_t size() const { return m_size; }

    operator bool() const { return !!m_realBase; }

    bool contains(void* containedBase, size_t containedSize)
    {
        return containedBase >= m_base
            && (static_cast<char*>(containedBase) + containedSize) <= (static_cast<char*>(m_base) + m_size);
    }

private:
    void* m_realBase;
    void* m_base;
    size_t m_size;
};

inline PageBlock::PageBlock()
    : m_realBase(0)
    , m_base(0)
    , m_size(0)
{
}

inline PageBlock::PageBlock(const PageBlock& other)
    : m_realBase(other.m_realBase)
    , m_base(other.m_base)
    , m_size(other.m_size)
{
}

inline PageBlock::PageBlock(void* base, size_t size, bool hasGuardPages)
    : m_realBase(base)
    , m_base(static_cast<char*>(base) + ((base && hasGuardPages) ? pageSize() : 0))
    , m_size(size)
{
}

}

using WTF::pageSize;
using WTF::isPageAligned;
using WTF::isPageAligned;
using WTF::isPowerOfTwo;
# 32 "./wtf/PageAllocation.h" 2





# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mach_init.h" 1 3 4
# 61 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mach_init.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mach_types.h" 1 3 4
# 80 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mach_types.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/host_info.h" 1 3 4
# 70 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/host_info.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/machine.h" 1 3 4
# 67 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/machine.h" 3 4
typedef integer_t cpu_type_t;
typedef integer_t cpu_subtype_t;
typedef integer_t cpu_threadtype_t;
# 71 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/host_info.h" 2 3 4

# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/time_value.h" 1 3 4
# 66 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/time_value.h" 3 4
struct time_value {
 integer_t seconds;
 integer_t microseconds;
};

typedef struct time_value time_value_t;
# 73 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/host_info.h" 2 3 4






typedef integer_t *host_info_t;
typedef integer_t *host_info64_t;


typedef integer_t host_info_data_t[(1024)];


typedef char kernel_version_t[(512)];


typedef char kernel_boot_info_t[(4096)];





typedef integer_t host_flavor_t;








#pragma pack(4)

struct host_basic_info {
 integer_t max_cpus;
 integer_t avail_cpus;
 natural_t memory_size;
 cpu_type_t cpu_type;
 cpu_subtype_t cpu_subtype;
 cpu_threadtype_t cpu_threadtype;
 integer_t physical_cpu;
 integer_t physical_cpu_max;
 integer_t logical_cpu;
 integer_t logical_cpu_max;
 uint64_t max_mem;
};

#pragma pack()

typedef struct host_basic_info host_basic_info_data_t;
typedef struct host_basic_info *host_basic_info_t;



struct host_sched_info {
 integer_t min_timeout;
 integer_t min_quantum;
};

typedef struct host_sched_info host_sched_info_data_t;
typedef struct host_sched_info *host_sched_info_t;



struct kernel_resource_sizes {
 natural_t task;
        natural_t thread;
        natural_t port;
        natural_t memory_region;
        natural_t memory_object;
};

typedef struct kernel_resource_sizes kernel_resource_sizes_data_t;
typedef struct kernel_resource_sizes *kernel_resource_sizes_t;



struct host_priority_info {
     integer_t kernel_priority;
     integer_t system_priority;
     integer_t server_priority;
     integer_t user_priority;
     integer_t depress_priority;
     integer_t idle_priority;
     integer_t minimum_priority;
 integer_t maximum_priority;
};

typedef struct host_priority_info host_priority_info_data_t;
typedef struct host_priority_info *host_priority_info_t;
# 176 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/host_info.h" 3 4
struct host_load_info {
 integer_t avenrun[3];
 integer_t mach_factor[3];
};

typedef struct host_load_info host_load_info_data_t;
typedef struct host_load_info *host_load_info_t;
# 217 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/host_info.h" 3 4
struct host_cpu_load_info {
 natural_t cpu_ticks[4];
};

typedef struct host_cpu_load_info host_cpu_load_info_data_t;
typedef struct host_cpu_load_info *host_cpu_load_info_t;
# 81 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mach_types.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/host_notify.h" 1 3 4
# 82 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mach_types.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/host_special_ports.h" 1 3 4
# 83 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mach_types.h" 2 3 4


# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/memory_object_types.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/memory_object_types.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/vm_prot.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/vm_prot.h" 3 4
typedef int vm_prot_t;
# 76 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/memory_object_types.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/vm_sync.h" 1 3 4
# 66 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/vm_sync.h" 3 4
typedef unsigned vm_sync_t;
# 77 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/memory_object_types.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/vm_types.h" 1 3 4
# 40 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/vm_types.h" 3 4
typedef vm_offset_t pointer_t;
typedef vm_offset_t vm_address_t;







typedef uint64_t addr64_t;
# 61 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/vm_types.h" 3 4
typedef uint32_t reg64_t;






typedef uint32_t ppnum_t;




typedef mach_port_t vm_map_t;
# 82 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/vm_types.h" 3 4
typedef uint64_t vm_object_offset_t;
typedef uint64_t vm_object_size_t;


typedef mach_port_t upl_t;
typedef mach_port_t vm_named_entry_t;
# 78 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/memory_object_types.h" 2 3 4






typedef unsigned long long memory_object_offset_t;
typedef unsigned long long memory_object_size_t;
typedef natural_t memory_object_cluster_size_t;
typedef natural_t * memory_object_fault_info_t;

typedef unsigned long long vm_object_id_t;







typedef mach_port_t memory_object_t;
typedef mach_port_t memory_object_control_t;


typedef memory_object_t *memory_object_array_t;




typedef mach_port_t memory_object_name_t;



typedef mach_port_t memory_object_default_t;
# 120 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/memory_object_types.h" 3 4
typedef int memory_object_copy_strategy_t;
# 156 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/memory_object_types.h" 3 4
typedef int memory_object_return_t;
# 185 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/memory_object_types.h" 3 4
typedef int *memory_object_info_t;
typedef int memory_object_flavor_t;
typedef int memory_object_info_data_t[(1024)];







struct memory_object_perf_info {
 memory_object_cluster_size_t cluster_size;
 boolean_t may_cache;
};

struct memory_object_attr_info {
 memory_object_copy_strategy_t copy_strategy;
 memory_object_cluster_size_t cluster_size;
 boolean_t may_cache_object;
 boolean_t temporary;
};

struct memory_object_behave_info {
 memory_object_copy_strategy_t copy_strategy;
 boolean_t temporary;
 boolean_t invalidate;
 boolean_t silent_overwrite;
 boolean_t advisory_pageout;
};


typedef struct memory_object_behave_info *memory_object_behave_info_t;
typedef struct memory_object_behave_info memory_object_behave_info_data_t;

typedef struct memory_object_perf_info *memory_object_perf_info_t;
typedef struct memory_object_perf_info memory_object_perf_info_data_t;

typedef struct memory_object_attr_info *memory_object_attr_info_t;
typedef struct memory_object_attr_info memory_object_attr_info_data_t;
# 86 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mach_types.h" 2 3 4

# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/exception_types.h" 1 3 4
# 62 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/exception_types.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/machine/exception.h" 1 3 4
# 33 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/machine/exception.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/i386/exception.h" 1 3 4
# 34 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/machine/exception.h" 2 3 4
# 63 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/exception_types.h" 2 3 4
# 159 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/exception_types.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/thread_status.h" 1 3 4
# 76 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/thread_status.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/machine/thread_status.h" 1 3 4
# 33 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/machine/thread_status.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/i386/thread_status.h" 1 3 4
# 72 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/i386/thread_status.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/i386/fp_reg.h" 1 3 4
# 73 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/i386/thread_status.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/i386/thread_state.h" 1 3 4
# 74 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/i386/thread_status.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/i386/eflags.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/i386/thread_status.h" 2 3 4
# 147 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/i386/thread_status.h" 3 4
struct x86_state_hdr {
 int flavor;
 int count;
};
typedef struct x86_state_hdr x86_state_hdr_t;
# 165 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/i386/thread_status.h" 3 4
typedef struct __darwin_i386_thread_state i386_thread_state_t;



typedef struct __darwin_i386_thread_state x86_thread_state32_t;






typedef struct __darwin_i386_float_state i386_float_state_t;



typedef struct __darwin_i386_float_state x86_float_state32_t;



typedef struct __darwin_i386_avx_state x86_avx_state32_t;






typedef struct __darwin_i386_exception_state i386_exception_state_t;



typedef struct __darwin_i386_exception_state x86_exception_state32_t;





typedef struct __darwin_x86_debug_state32 x86_debug_state32_t;





typedef struct __darwin_x86_thread_state64 x86_thread_state64_t;



typedef struct __darwin_x86_float_state64 x86_float_state64_t;



typedef struct __darwin_x86_avx_state64 x86_avx_state64_t;



typedef struct __darwin_x86_exception_state64 x86_exception_state64_t;





typedef struct __darwin_x86_debug_state64 x86_debug_state64_t;
# 234 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/i386/thread_status.h" 3 4
struct x86_thread_state {
 x86_state_hdr_t tsh;
 union {
     x86_thread_state32_t ts32;
     x86_thread_state64_t ts64;
 } uts;
};

struct x86_float_state {
 x86_state_hdr_t fsh;
 union {
  x86_float_state32_t fs32;
  x86_float_state64_t fs64;
 } ufs;
};

struct x86_exception_state {
 x86_state_hdr_t esh;
 union {
  x86_exception_state32_t es32;
  x86_exception_state64_t es64;
 } ues;
};

struct x86_debug_state {
 x86_state_hdr_t dsh;
 union {
  x86_debug_state32_t ds32;
  x86_debug_state64_t ds64;
 } uds;
};

typedef struct x86_thread_state x86_thread_state_t;



typedef struct x86_float_state x86_float_state_t;



typedef struct x86_exception_state x86_exception_state_t;



typedef struct x86_debug_state x86_debug_state_t;
# 302 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/i386/thread_status.h" 3 4
struct x86_seg_load_fault32 {
 uint16_t trapno;
 uint16_t cpu;
 uint32_t err;
 uint32_t eip;
 uint32_t cs;
 uint32_t efl;
};
# 34 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/machine/thread_status.h" 2 3 4
# 77 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/thread_status.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/machine/thread_state.h" 1 3 4
# 78 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/thread_status.h" 2 3 4





typedef natural_t *thread_state_t;


typedef natural_t thread_state_data_t[(144)];




typedef int thread_state_flavor_t;
typedef thread_state_flavor_t *thread_state_flavor_array_t;
# 160 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/exception_types.h" 2 3 4





typedef int exception_type_t;
typedef integer_t exception_data_type_t;
typedef int64_t mach_exception_data_type_t;
typedef int exception_behavior_t;
typedef exception_data_type_t *exception_data_t;
typedef mach_exception_data_type_t *mach_exception_data_t;
typedef unsigned int exception_mask_t;
typedef exception_mask_t *exception_mask_array_t;
typedef exception_behavior_t *exception_behavior_array_t;
typedef thread_state_flavor_t *exception_flavor_array_t;
typedef mach_port_t *exception_port_array_t;
typedef mach_exception_data_type_t mach_exception_code_t;
typedef mach_exception_data_type_t mach_exception_subcode_t;
# 88 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mach_types.h" 2 3 4

# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/processor_info.h" 1 3 4
# 72 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/processor_info.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/machine/processor_info.h" 1 3 4
# 33 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/machine/processor_info.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/i386/processor_info.h" 1 3 4
# 34 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/machine/processor_info.h" 2 3 4
# 73 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/processor_info.h" 2 3 4




typedef integer_t *processor_info_t;
typedef integer_t *processor_info_array_t;


typedef integer_t processor_info_data_t[(1024)];


typedef integer_t *processor_set_info_t;


typedef integer_t processor_set_info_data_t[(1024)];




typedef int processor_flavor_t;





struct processor_basic_info {
 cpu_type_t cpu_type;
 cpu_subtype_t cpu_subtype;
 boolean_t running;
 int slot_num;
 boolean_t is_master;
};

typedef struct processor_basic_info processor_basic_info_data_t;
typedef struct processor_basic_info *processor_basic_info_t;



struct processor_cpu_load_info {
        unsigned int cpu_ticks[4];
};

typedef struct processor_cpu_load_info processor_cpu_load_info_data_t;
typedef struct processor_cpu_load_info *processor_cpu_load_info_t;
# 125 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/processor_info.h" 3 4
typedef int processor_set_flavor_t;


struct processor_set_basic_info {
 int processor_count;
 int default_policy;
};

typedef struct processor_set_basic_info processor_set_basic_info_data_t;
typedef struct processor_set_basic_info *processor_set_basic_info_t;





struct processor_set_load_info {
        int task_count;
        int thread_count;
        integer_t load_average;
        integer_t mach_factor;
};

typedef struct processor_set_load_info processor_set_load_info_data_t;
typedef struct processor_set_load_info *processor_set_load_info_t;
# 90 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mach_types.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/task_info.h" 1 3 4
# 71 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/task_info.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/policy.h" 1 3 4
# 79 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/policy.h" 3 4
typedef int policy_t;
typedef integer_t *policy_info_t;
typedef integer_t *policy_base_t;
typedef integer_t *policy_limit_t;
# 113 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/policy.h" 3 4
struct policy_timeshare_base {
 integer_t base_priority;
};
struct policy_timeshare_limit {
 integer_t max_priority;
};
struct policy_timeshare_info {
 integer_t max_priority;
 integer_t base_priority;
 integer_t cur_priority;
 boolean_t depressed;
 integer_t depress_priority;
};

typedef struct policy_timeshare_base *policy_timeshare_base_t;
typedef struct policy_timeshare_limit *policy_timeshare_limit_t;
typedef struct policy_timeshare_info *policy_timeshare_info_t;

typedef struct policy_timeshare_base policy_timeshare_base_data_t;
typedef struct policy_timeshare_limit policy_timeshare_limit_data_t;
typedef struct policy_timeshare_info policy_timeshare_info_data_t;
# 147 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/policy.h" 3 4
struct policy_rr_base {
 integer_t base_priority;
 integer_t quantum;
};
struct policy_rr_limit {
 integer_t max_priority;
};
struct policy_rr_info {
 integer_t max_priority;
 integer_t base_priority;
 integer_t quantum;
 boolean_t depressed;
 integer_t depress_priority;
};

typedef struct policy_rr_base *policy_rr_base_t;
typedef struct policy_rr_limit *policy_rr_limit_t;
typedef struct policy_rr_info *policy_rr_info_t;

typedef struct policy_rr_base policy_rr_base_data_t;
typedef struct policy_rr_limit policy_rr_limit_data_t;
typedef struct policy_rr_info policy_rr_info_data_t;
# 181 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/policy.h" 3 4
struct policy_fifo_base {
 integer_t base_priority;
};
struct policy_fifo_limit {
 integer_t max_priority;
};
struct policy_fifo_info {
 integer_t max_priority;
 integer_t base_priority;
 boolean_t depressed;
 integer_t depress_priority;
};

typedef struct policy_fifo_base *policy_fifo_base_t;
typedef struct policy_fifo_limit *policy_fifo_limit_t;
typedef struct policy_fifo_info *policy_fifo_info_t;

typedef struct policy_fifo_base policy_fifo_base_data_t;
typedef struct policy_fifo_limit policy_fifo_limit_data_t;
typedef struct policy_fifo_info policy_fifo_info_data_t;
# 213 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/policy.h" 3 4
struct policy_bases {
 policy_timeshare_base_data_t ts;
 policy_rr_base_data_t rr;
 policy_fifo_base_data_t fifo;
};

struct policy_limits {
 policy_timeshare_limit_data_t ts;
 policy_rr_limit_data_t rr;
 policy_fifo_limit_data_t fifo;
};

struct policy_infos {
 policy_timeshare_info_data_t ts;
 policy_rr_info_data_t rr;
 policy_fifo_info_data_t fifo;
};

typedef struct policy_bases policy_base_data_t;
typedef struct policy_limits policy_limit_data_t;
typedef struct policy_infos policy_info_data_t;
# 72 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/task_info.h" 2 3 4






typedef natural_t task_flavor_t;
typedef integer_t *task_info_t;


typedef integer_t task_info_data_t[(1024)];





#pragma pack(4)




struct task_basic_info_32 {
        integer_t suspend_count;
        natural_t virtual_size;
        natural_t resident_size;
        time_value_t user_time;

        time_value_t system_time;

 policy_t policy;
};
typedef struct task_basic_info_32 task_basic_info_32_data_t;
typedef struct task_basic_info_32 *task_basic_info_32_t;






struct task_basic_info_64 {
        integer_t suspend_count;
        mach_vm_size_t virtual_size;
        mach_vm_size_t resident_size;
        time_value_t user_time;

        time_value_t system_time;

 policy_t policy;
};
typedef struct task_basic_info_64 task_basic_info_64_data_t;
typedef struct task_basic_info_64 *task_basic_info_64_t;






struct task_basic_info {
        integer_t suspend_count;
        vm_size_t virtual_size;
        vm_size_t resident_size;
        time_value_t user_time;

        time_value_t system_time;

 policy_t policy;
};

typedef struct task_basic_info task_basic_info_data_t;
typedef struct task_basic_info *task_basic_info_t;
# 154 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/task_info.h" 3 4
struct task_events_info {
 integer_t faults;
 integer_t pageins;
 integer_t cow_faults;
 integer_t messages_sent;
 integer_t messages_received;
        integer_t syscalls_mach;
 integer_t syscalls_unix;
 integer_t csw;
};
typedef struct task_events_info task_events_info_data_t;
typedef struct task_events_info *task_events_info_t;






struct task_thread_times_info {
 time_value_t user_time;

 time_value_t system_time;

};

typedef struct task_thread_times_info task_thread_times_info_data_t;
typedef struct task_thread_times_info *task_thread_times_info_t;





struct task_absolutetime_info {
 uint64_t total_user;
 uint64_t total_system;
 uint64_t threads_user;
 uint64_t threads_system;
};

typedef struct task_absolutetime_info task_absolutetime_info_data_t;
typedef struct task_absolutetime_info *task_absolutetime_info_t;





struct task_kernelmemory_info {
 uint64_t total_palloc;
 uint64_t total_pfree;
 uint64_t total_salloc;
 uint64_t total_sfree;
};

typedef struct task_kernelmemory_info task_kernelmemory_info_data_t;
typedef struct task_kernelmemory_info *task_kernelmemory_info_t;
# 223 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/task_info.h" 3 4
struct task_affinity_tag_info {
 integer_t set_count;
 integer_t min;
 integer_t max;
 integer_t task_count;
};
typedef struct task_affinity_tag_info task_affinity_tag_info_data_t;
typedef struct task_affinity_tag_info *task_affinity_tag_info_t;





struct task_dyld_info {
 mach_vm_address_t all_image_info_addr;
 mach_vm_size_t all_image_info_size;
 integer_t all_image_info_format;
};
typedef struct task_dyld_info task_dyld_info_data_t;
typedef struct task_dyld_info *task_dyld_info_t;







struct task_extmod_info {
 unsigned char task_uuid[16];
 vm_extmod_statistics_data_t extmod_statistics;
};
typedef struct task_extmod_info task_extmod_info_data_t;
typedef struct task_extmod_info *task_extmod_info_t;



#pragma pack()
# 91 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mach_types.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/task_policy.h" 1 3 4
# 32 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/task_policy.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mach_types.h" 1 3 4
# 33 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/task_policy.h" 2 3 4
# 51 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/task_policy.h" 3 4
typedef natural_t task_policy_flavor_t;
typedef integer_t *task_policy_t;
# 106 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/task_policy.h" 3 4
enum task_role {
 TASK_RENICED = -1,
 TASK_UNSPECIFIED = 0,
 TASK_FOREGROUND_APPLICATION,
 TASK_BACKGROUND_APPLICATION,
 TASK_CONTROL_APPLICATION,
 TASK_GRAPHICS_SERVER,
 TASK_THROTTLE_APPLICATION,
 TASK_NONUI_APPLICATION,
 TASK_DEFAULT_APPLICATION
};

typedef enum task_role task_role_t;

struct task_category_policy {
 task_role_t role;
};

typedef struct task_category_policy task_category_policy_data_t;
typedef struct task_category_policy *task_category_policy_t;
# 92 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mach_types.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/task_special_ports.h" 1 3 4
# 70 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/task_special_ports.h" 3 4
typedef int task_special_port_t;
# 93 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mach_types.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/thread_info.h" 1 3 4
# 81 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/thread_info.h" 3 4
typedef natural_t thread_flavor_t;
typedef integer_t *thread_info_t;


typedef integer_t thread_info_data_t[(1024)];






struct thread_basic_info {
        time_value_t user_time;
        time_value_t system_time;
        integer_t cpu_usage;
 policy_t policy;
        integer_t run_state;
        integer_t flags;
        integer_t suspend_count;
        integer_t sleep_time;

};

typedef struct thread_basic_info thread_basic_info_data_t;
typedef struct thread_basic_info *thread_basic_info_t;





struct thread_identifier_info {
 uint64_t thread_id;
 uint64_t thread_handle;
 uint64_t dispatch_qaddr;
};

typedef struct thread_identifier_info thread_identifier_info_data_t;
typedef struct thread_identifier_info *thread_identifier_info_t;
# 94 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mach_types.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/thread_policy.h" 1 3 4
# 32 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/thread_policy.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mach_types.h" 1 3 4
# 33 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/thread_policy.h" 2 3 4
# 51 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/thread_policy.h" 3 4
typedef natural_t thread_policy_flavor_t;
typedef integer_t *thread_policy_t;
# 86 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/thread_policy.h" 3 4
struct thread_standard_policy {
 natural_t no_data;
};

typedef struct thread_standard_policy thread_standard_policy_data_t;
typedef struct thread_standard_policy *thread_standard_policy_t;
# 109 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/thread_policy.h" 3 4
struct thread_extended_policy {
 boolean_t timeshare;
};

typedef struct thread_extended_policy thread_extended_policy_data_t;
typedef struct thread_extended_policy *thread_extended_policy_t;
# 148 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/thread_policy.h" 3 4
struct thread_time_constraint_policy {
 uint32_t period;
 uint32_t computation;
 uint32_t constraint;
 boolean_t preemptible;
};

typedef struct thread_time_constraint_policy thread_time_constraint_policy_data_t;

typedef struct thread_time_constraint_policy *thread_time_constraint_policy_t;
# 176 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/thread_policy.h" 3 4
struct thread_precedence_policy {
 integer_t importance;
};

typedef struct thread_precedence_policy thread_precedence_policy_data_t;
typedef struct thread_precedence_policy *thread_precedence_policy_t;
# 206 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/thread_policy.h" 3 4
struct thread_affinity_policy {
 integer_t affinity_tag;
};



typedef struct thread_affinity_policy thread_affinity_policy_data_t;
typedef struct thread_affinity_policy *thread_affinity_policy_t;
# 224 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/thread_policy.h" 3 4
struct thread_background_policy {
 integer_t priority;
};

typedef struct thread_background_policy thread_background_policy_data_t;
typedef struct thread_background_policy *thread_background_policy_t;
# 95 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mach_types.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/thread_special_ports.h" 1 3 4
# 96 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mach_types.h" 2 3 4


# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/clock_types.h" 1 3 4
# 51 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/clock_types.h" 3 4
typedef int alarm_type_t;
typedef int sleep_type_t;
typedef int clock_id_t;
typedef int clock_flavor_t;
typedef int *clock_attr_t;
typedef int clock_res_t;




struct mach_timespec {
 unsigned int tv_sec;
 clock_res_t tv_nsec;
};
typedef struct mach_timespec mach_timespec_t;
# 99 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mach_types.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/vm_attributes.h" 1 3 4
# 76 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/vm_attributes.h" 3 4
typedef unsigned int vm_machine_attribute_t;
# 85 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/vm_attributes.h" 3 4
typedef int vm_machine_attribute_val_t;
# 100 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mach_types.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/vm_inherit.h" 1 3 4
# 75 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/vm_inherit.h" 3 4
typedef unsigned int vm_inherit_t;
# 101 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mach_types.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/vm_purgable.h" 1 3 4
# 53 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/vm_purgable.h" 3 4
typedef int vm_purgable_t;
# 102 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mach_types.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/vm_behavior.h" 1 3 4
# 47 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/vm_behavior.h" 3 4
typedef int vm_behavior_t;
# 103 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mach_types.h" 2 3 4




# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/vm_region.h" 1 3 4
# 47 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/vm_region.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/machine/vm_param.h" 1 3 4
# 48 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/vm_region.h" 2 3 4





#pragma pack(4)




typedef uint32_t vm32_object_id_t;
# 67 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/vm_region.h" 3 4
typedef int *vm_region_info_t;
typedef int *vm_region_info_64_t;
typedef int *vm_region_recurse_info_t;
typedef int *vm_region_recurse_info_64_t;
typedef int vm_region_flavor_t;
typedef int vm_region_info_data_t[(1024)];


struct vm_region_basic_info_64 {
 vm_prot_t protection;
 vm_prot_t max_protection;
 vm_inherit_t inheritance;
 boolean_t shared;
 boolean_t reserved;
 memory_object_offset_t offset;
 vm_behavior_t behavior;
 unsigned short user_wired_count;
};
typedef struct vm_region_basic_info_64 *vm_region_basic_info_64_t;
typedef struct vm_region_basic_info_64 vm_region_basic_info_data_64_t;
# 103 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/vm_region.h" 3 4
struct vm_region_basic_info {
 vm_prot_t protection;
 vm_prot_t max_protection;
 vm_inherit_t inheritance;
 boolean_t shared;
 boolean_t reserved;
 uint32_t offset;
 vm_behavior_t behavior;
 unsigned short user_wired_count;
};

typedef struct vm_region_basic_info *vm_region_basic_info_t;
typedef struct vm_region_basic_info vm_region_basic_info_data_t;
# 139 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/vm_region.h" 3 4
struct vm_region_extended_info {
 vm_prot_t protection;
        unsigned int user_tag;
        unsigned int pages_resident;
        unsigned int pages_shared_now_private;
        unsigned int pages_swapped_out;
        unsigned int pages_dirtied;
        unsigned int ref_count;
        unsigned short shadow_depth;
        unsigned char external_pager;
        unsigned char share_mode;
};

typedef struct vm_region_extended_info *vm_region_extended_info_t;
typedef struct vm_region_extended_info vm_region_extended_info_data_t;







struct vm_region_top_info {
        unsigned int obj_id;
        unsigned int ref_count;
        unsigned int private_pages_resident;
        unsigned int shared_pages_resident;
        unsigned char share_mode;
};

typedef struct vm_region_top_info *vm_region_top_info_t;
typedef struct vm_region_top_info vm_region_top_info_data_t;
# 197 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/vm_region.h" 3 4
struct vm_region_submap_info {
 vm_prot_t protection;
 vm_prot_t max_protection;
 vm_inherit_t inheritance;
 uint32_t offset;
        unsigned int user_tag;
        unsigned int pages_resident;
        unsigned int pages_shared_now_private;
        unsigned int pages_swapped_out;
        unsigned int pages_dirtied;
        unsigned int ref_count;
        unsigned short shadow_depth;
        unsigned char external_pager;
        unsigned char share_mode;
 boolean_t is_submap;
 vm_behavior_t behavior;
 vm32_object_id_t object_id;
 unsigned short user_wired_count;
};

typedef struct vm_region_submap_info *vm_region_submap_info_t;
typedef struct vm_region_submap_info vm_region_submap_info_data_t;




struct vm_region_submap_info_64 {
 vm_prot_t protection;
 vm_prot_t max_protection;
 vm_inherit_t inheritance;
 memory_object_offset_t offset;
        unsigned int user_tag;
        unsigned int pages_resident;
        unsigned int pages_shared_now_private;
        unsigned int pages_swapped_out;
        unsigned int pages_dirtied;
        unsigned int ref_count;
        unsigned short shadow_depth;
        unsigned char external_pager;
        unsigned char share_mode;
 boolean_t is_submap;
 vm_behavior_t behavior;
 vm32_object_id_t object_id;
 unsigned short user_wired_count;
};

typedef struct vm_region_submap_info_64 *vm_region_submap_info_64_t;
typedef struct vm_region_submap_info_64 vm_region_submap_info_data_64_t;




struct vm_region_submap_short_info_64 {
 vm_prot_t protection;
 vm_prot_t max_protection;
 vm_inherit_t inheritance;
 memory_object_offset_t offset;
        unsigned int user_tag;
        unsigned int ref_count;
        unsigned short shadow_depth;
        unsigned char external_pager;
        unsigned char share_mode;
 boolean_t is_submap;
 vm_behavior_t behavior;
 vm32_object_id_t object_id;
 unsigned short user_wired_count;
};

typedef struct vm_region_submap_short_info_64 *vm_region_submap_short_info_64_t;
typedef struct vm_region_submap_short_info_64 vm_region_submap_short_info_data_64_t;





struct mach_vm_read_entry {
 mach_vm_address_t address;
 mach_vm_size_t size;
};

struct vm_read_entry {
 vm_address_t address;
 vm_size_t size;
};
# 292 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/vm_region.h" 3 4
typedef struct mach_vm_read_entry mach_vm_read_entry_t[(256)];
typedef struct vm_read_entry vm_read_entry_t[(256)];




#pragma pack()



typedef int *vm_page_info_t;
typedef int vm_page_info_data_t[];
typedef int vm_page_info_flavor_t;


struct vm_page_info_basic {
 int disposition;
 int ref_count;
 vm_object_id_t object_id;
 memory_object_offset_t offset;
 int depth;
 int __pad;
};
typedef struct vm_page_info_basic *vm_page_info_basic_t;
typedef struct vm_page_info_basic vm_page_info_basic_data_t;
# 108 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mach_types.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/kmod.h" 1 3 4
# 39 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/kmod.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mach_types.h" 1 3 4
# 40 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/kmod.h" 2 3 4



extern "C" {
# 56 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/kmod.h" 3 4
typedef int kmod_t;

struct kmod_info;
typedef kern_return_t kmod_start_func_t(struct kmod_info * ki, void * data);
typedef kern_return_t kmod_stop_func_t(struct kmod_info * ki, void * data);
# 70 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/kmod.h" 3 4
#pragma pack(4)


typedef struct kmod_reference {
    struct kmod_reference * next;
    struct kmod_info * info;
} kmod_reference_t;
# 87 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/kmod.h" 3 4
typedef struct kmod_info {
    struct kmod_info * next;
    int32_t info_version;
    uint32_t id;
    char name[64];
    char version[64];
    int32_t reference_count;
    kmod_reference_t * reference_list;
    vm_address_t address;
    vm_size_t size;
    vm_size_t hdr_size;
    kmod_start_func_t * start;
    kmod_stop_func_t * stop;
} kmod_info_t;



typedef struct kmod_info_32_v1 {
    uint32_t next_addr;
    int32_t info_version;
    uint32_t id;
    uint8_t name[64];
    uint8_t version[64];
    int32_t reference_count;
    uint32_t reference_list_addr;
    uint32_t address;
    uint32_t size;
    uint32_t hdr_size;
    uint32_t start_addr;
    uint32_t stop_addr;
} kmod_info_32_v1_t;



typedef struct kmod_info_64_v1 {
    uint64_t next_addr;
    int32_t info_version;
    uint32_t id;
    uint8_t name[64];
    uint8_t version[64];
    int32_t reference_count;
    uint64_t reference_list_addr;
    uint64_t address;
    uint64_t size;
    uint64_t hdr_size;
    uint64_t start_addr;
    uint64_t stop_addr;
} kmod_info_64_v1_t;

#pragma pack()
# 174 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/kmod.h" 3 4
typedef void * kmod_args_t;
typedef int kmod_control_flavor_t;
typedef kmod_info_t * kmod_info_array_t;

}
# 109 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mach_types.h" 2 3 4






typedef mach_port_t task_t;
typedef mach_port_t task_name_t;
typedef mach_port_t thread_t;
typedef mach_port_t thread_act_t;
typedef mach_port_t ipc_space_t;
typedef mach_port_t host_t;
typedef mach_port_t host_priv_t;
typedef mach_port_t host_security_t;
typedef mach_port_t processor_t;
typedef mach_port_t processor_set_t;
typedef mach_port_t processor_set_control_t;
typedef mach_port_t semaphore_t;
typedef mach_port_t lock_set_t;
typedef mach_port_t ledger_t;
typedef mach_port_t alarm_t;
typedef mach_port_t clock_serv_t;
typedef mach_port_t clock_ctrl_t;







typedef processor_set_t processor_set_name_t;




typedef mach_port_t clock_reply_t;
typedef mach_port_t bootstrap_t;
typedef mach_port_t mem_entry_name_port_t;
typedef mach_port_t exception_handler_t;
typedef exception_handler_t *exception_handler_array_t;
typedef mach_port_t vm_task_entry_t;
typedef mach_port_t io_master_t;
typedef mach_port_t UNDServerRef;
# 160 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mach_types.h" 3 4
typedef task_t *task_array_t;
typedef thread_t *thread_array_t;
typedef processor_set_t *processor_set_array_t;
typedef processor_set_t *processor_set_name_array_t;
typedef processor_t *processor_array_t;
typedef thread_act_t *thread_act_array_t;
typedef ledger_t *ledger_array_t;







typedef task_t task_port_t;
typedef task_array_t task_port_array_t;
typedef thread_t thread_port_t;
typedef thread_array_t thread_port_array_t;
typedef ipc_space_t ipc_space_port_t;
typedef host_t host_name_t;
typedef host_t host_name_port_t;
typedef processor_set_t processor_set_port_t;
typedef processor_set_t processor_set_name_port_t;
typedef processor_set_array_t processor_set_name_port_array_t;
typedef processor_set_t processor_set_control_port_t;
typedef processor_t processor_port_t;
typedef processor_array_t processor_port_array_t;
typedef thread_act_t thread_act_port_t;
typedef thread_act_array_t thread_act_port_array_t;
typedef semaphore_t semaphore_port_t;
typedef lock_set_t lock_set_port_t;
typedef ledger_t ledger_port_t;
typedef ledger_array_t ledger_port_array_t;
typedef alarm_t alarm_port_t;
typedef clock_serv_t clock_serv_port_t;
typedef clock_ctrl_t clock_ctrl_port_t;
typedef exception_handler_t exception_port_t;
typedef exception_handler_array_t exception_port_arrary_t;
# 218 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mach_types.h" 3 4
typedef natural_t ledger_item_t;


typedef mach_vm_offset_t *emulation_vector_t;
typedef char *user_subsystem_t;

typedef char *labelstr_t;





# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/std_types.h" 1 3 4
# 230 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mach_types.h" 2 3 4
# 62 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mach_init.h" 2 3 4








extern "C" {
extern mach_port_t mach_host_self(void);
extern mach_port_t mach_thread_self(void);
extern kern_return_t host_page_size(host_t, vm_size_t *);

extern mach_port_t mach_task_self_;



}

# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mach_traps.h" 1 3 4
# 82 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mach_traps.h" 3 4
extern "C" {



extern kern_return_t macx_swapon(
    uint64_t filename,
    int flags,
    int size,
    int priority);

extern kern_return_t macx_swapoff(
    uint64_t filename,
    int flags);

extern kern_return_t macx_triggers(
    int hi_water,
    int low_water,
    int flags,
    mach_port_t alert_port);

extern kern_return_t macx_backing_store_suspend(
    boolean_t suspend);

extern kern_return_t macx_backing_store_recovery(
    int pid);

extern boolean_t swtch_pri(int pri);

extern boolean_t swtch(void);

extern kern_return_t thread_switch(
    mach_port_name_t thread_name,
    int option,
    mach_msg_timeout_t option_time);

extern mach_port_name_t task_self_trap(void);





extern kern_return_t task_for_pid(
    mach_port_name_t target_tport,
    int pid,
    mach_port_name_t *t);

extern kern_return_t task_name_for_pid(
    mach_port_name_t target_tport,
    int pid,
    mach_port_name_t *tn);

extern kern_return_t pid_for_task(
    mach_port_name_t t,
    int *x);
# 150 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mach_traps.h" 3 4
}
# 81 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mach_init.h" 2 3 4
extern "C" {





extern mach_port_t bootstrap_port;
# 105 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mach_init.h" 3 4
extern vm_size_t vm_page_size;
extern vm_size_t vm_page_mask;
extern int vm_page_shift;
# 123 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mach_init.h" 3 4
extern int (*vprintf_stderr_func)(const char *format, va_list ap);

}
# 38 "./wtf/PageAllocation.h" 2
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/vm_map.h" 1 3 4






# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/ndr.h" 1 3 4
# 38 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/ndr.h" 3 4
typedef struct {
    unsigned char mig_vers;
    unsigned char if_vers;
    unsigned char reserved1;
    unsigned char mig_encoding;
    unsigned char int_rep;
    unsigned char char_rep;
    unsigned char float_rep;
    unsigned char reserved2;
} NDR_record_t;
# 66 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/ndr.h" 3 4
extern NDR_record_t NDR_record;
# 106 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/ndr.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSByteOrder.h" 1 3 4
# 43 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSByteOrder.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/i386/OSByteOrder.h" 1 3 4
# 41 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/i386/OSByteOrder.h" 3 4
static inline
uint16_t
OSReadSwapInt16(
    const volatile void * base,
    uintptr_t byteOffset
)
{
    uint16_t result;

    result = *(volatile uint16_t *)((uintptr_t)base + byteOffset);
    return _OSSwapInt16(result);
}

static inline
uint32_t
OSReadSwapInt32(
    const volatile void * base,
    uintptr_t byteOffset
)
{
    uint32_t result;

    result = *(volatile uint32_t *)((uintptr_t)base + byteOffset);
    return _OSSwapInt32(result);
}

static inline
uint64_t
OSReadSwapInt64(
    const volatile void * base,
    uintptr_t byteOffset
)
{
    uint64_t result;

    result = *(volatile uint64_t *)((uintptr_t)base + byteOffset);
    return _OSSwapInt64(result);
}



static inline
void
OSWriteSwapInt16(
    volatile void * base,
    uintptr_t byteOffset,
    uint16_t data
)
{
    *(volatile uint16_t *)((uintptr_t)base + byteOffset) = _OSSwapInt16(data);
}

static inline
void
OSWriteSwapInt32(
    volatile void * base,
    uintptr_t byteOffset,
    uint32_t data
)
{
    *(volatile uint32_t *)((uintptr_t)base + byteOffset) = _OSSwapInt32(data);
}

static inline
void
OSWriteSwapInt64(
    volatile void * base,
    uintptr_t byteOffset,
    uint64_t data
)
{
    *(volatile uint64_t *)((uintptr_t)base + byteOffset) = _OSSwapInt64(data);
}
# 44 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSByteOrder.h" 2 3 4
# 60 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSByteOrder.h" 3 4
enum {
    OSUnknownByteOrder,
    OSLittleEndian,
    OSBigEndian
};

static inline
int32_t
OSHostByteOrder(void) {

    return OSLittleEndian;





}
# 89 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/libkern/OSByteOrder.h" 3 4
static inline
uint16_t
_OSReadInt16(
    const volatile void * base,
    uintptr_t byteOffset
)
{
    return *(volatile uint16_t *)((uintptr_t)base + byteOffset);
}

static inline
uint32_t
_OSReadInt32(
    const volatile void * base,
    uintptr_t byteOffset
)
{
    return *(volatile uint32_t *)((uintptr_t)base + byteOffset);
}

static inline
uint64_t
_OSReadInt64(
    const volatile void * base,
    uintptr_t byteOffset
)
{
    return *(volatile uint64_t *)((uintptr_t)base + byteOffset);
}



static inline
void
_OSWriteInt16(
    volatile void * base,
    uintptr_t byteOffset,
    uint16_t data
)
{
    *(volatile uint16_t *)((uintptr_t)base + byteOffset) = data;
}

static inline
void
_OSWriteInt32(
    volatile void * base,
    uintptr_t byteOffset,
    uint32_t data
)
{
    *(volatile uint32_t *)((uintptr_t)base + byteOffset) = data;
}

static inline
void
_OSWriteInt64(
    volatile void * base,
    uintptr_t byteOffset,
    uint64_t data
)
{
    *(volatile uint64_t *)((uintptr_t)base + byteOffset) = data;
}
# 107 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/ndr.h" 2 3 4
# 117 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/ndr.h" 3 4
extern "C" {

static __inline__ float __NDR_READSWAP__float(float *argp) {
 union {
  float sv;
  uint32_t ull;
 } result;
 result.ull = OSReadSwapInt32((void *)(uint32_t *)argp, 0);
 return result.sv;
}

static __inline__ double __NDR_READSWAP__double(double *argp) {
 union {
  double sv;
  uint64_t ull;
 } result;
 result.ull = OSReadSwapInt64((void *)(uint64_t *)argp, 0);
 return result.sv;
}

}
# 8 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/vm_map.h" 2 3 4


# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/notify.h" 1 3 4
# 91 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/notify.h" 3 4
typedef mach_port_t notify_port_t;
# 101 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/notify.h" 3 4
typedef struct {
    mach_msg_header_t not_header;
    NDR_record_t NDR;
    mach_port_name_t not_port;
    mach_msg_format_0_trailer_t trailer;
} mach_port_deleted_notification_t;

typedef struct {
    mach_msg_header_t not_header;
    NDR_record_t NDR;
    mach_port_name_t not_port;
    mach_msg_format_0_trailer_t trailer;
} mach_send_possible_notification_t;

typedef struct {
    mach_msg_header_t not_header;
    mach_msg_body_t not_body;
    mach_msg_port_descriptor_t not_port;
    mach_msg_format_0_trailer_t trailer;
} mach_port_destroyed_notification_t;

typedef struct {
    mach_msg_header_t not_header;
    NDR_record_t NDR;
    mach_msg_type_number_t not_count;
    mach_msg_format_0_trailer_t trailer;
} mach_no_senders_notification_t;

typedef struct {
    mach_msg_header_t not_header;
    mach_msg_format_0_trailer_t trailer;
} mach_send_once_notification_t;

typedef struct {
    mach_msg_header_t not_header;
    NDR_record_t NDR;
    mach_port_name_t not_port;
    mach_msg_format_0_trailer_t trailer;
} mach_dead_name_notification_t;
# 11 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/vm_map.h" 2 3 4


# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mig_errors.h" 1 3 4
# 66 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mig_errors.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mig.h" 1 3 4
# 86 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mig.h" 3 4
typedef void (*mig_stub_routine_t) (mach_msg_header_t *InHeadP,
           mach_msg_header_t *OutHeadP);

typedef mig_stub_routine_t mig_routine_t;






typedef mig_routine_t (*mig_server_routine_t) (mach_msg_header_t *InHeadP);






typedef kern_return_t (*mig_impl_routine_t)(void);

typedef mach_msg_type_descriptor_t routine_arg_descriptor;
typedef mach_msg_type_descriptor_t *routine_arg_descriptor_t;
typedef mach_msg_type_descriptor_t *mig_routine_arg_descriptor_t;



struct routine_descriptor {
 mig_impl_routine_t impl_routine;
 mig_stub_routine_t stub_routine;
 unsigned int argc;
 unsigned int descr_count;
 routine_arg_descriptor_t
      arg_descr;
 unsigned int max_reply_msg;
};
typedef struct routine_descriptor *routine_descriptor_t;

typedef struct routine_descriptor mig_routine_descriptor;
typedef mig_routine_descriptor *mig_routine_descriptor_t;



typedef struct mig_subsystem {
 mig_server_routine_t server;
 mach_msg_id_t start;
 mach_msg_id_t end;
 mach_msg_size_t maxsize;
 vm_address_t reserved;
 mig_routine_descriptor
       routine[1];
} *mig_subsystem_t;



typedef struct mig_symtab {
 char *ms_routine_name;
 int ms_routine_number;
 void (*ms_routine)(void);




} mig_symtab_t;


extern "C" {


extern mach_port_t mig_get_reply_port(void);


extern void mig_dealloc_reply_port(mach_port_t reply_port);


extern void mig_put_reply_port(mach_port_t reply_port);


extern int mig_strncpy(char *dest, const char *src, int len);



extern void mig_allocate(vm_address_t *, vm_size_t);


extern void mig_deallocate(vm_address_t, vm_size_t);


}
# 67 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mig_errors.h" 2 3 4
# 98 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/mig_errors.h" 3 4
#pragma pack(4)
typedef struct {
 mach_msg_header_t Head;
 NDR_record_t NDR;
 kern_return_t RetCode;
} mig_reply_error_t;
#pragma pack()


extern "C" {




static __inline__ void
__NDR_convert__mig_reply_error_t(__attribute__((__unused__)) mig_reply_error_t *x)
{

 if (x->NDR.int_rep != NDR_record.int_rep)
  do { *(&x->RetCode) = (int32_t)OSReadSwapInt32((void *)&x->RetCode, 0); } while (0);

}


}
# 14 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/vm_map.h" 2 3 4
# 36 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/vm_map.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach_debug/mach_debug_types.h" 1 3 4
# 65 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach_debug/mach_debug_types.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach_debug/ipc_info.h" 1 3 4
# 79 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach_debug/ipc_info.h" 3 4
typedef struct ipc_info_space {
 natural_t iis_genno_mask;
 natural_t iis_table_size;
 natural_t iis_table_next;
 natural_t iis_tree_size;
 natural_t iis_tree_small;
 natural_t iis_tree_hash;
} ipc_info_space_t;


typedef struct ipc_info_name {
 mach_port_name_t iin_name;
             integer_t iin_collision;
 mach_port_type_t iin_type;
 mach_port_urefs_t iin_urefs;
 natural_t iin_object;
 natural_t iin_next;
 natural_t iin_hash;
} ipc_info_name_t;

typedef ipc_info_name_t *ipc_info_name_array_t;


typedef struct ipc_info_tree_name {
 ipc_info_name_t iitn_name;
 mach_port_name_t iitn_lchild;
 mach_port_name_t iitn_rchild;
} ipc_info_tree_name_t;

typedef ipc_info_tree_name_t *ipc_info_tree_name_array_t;
# 66 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach_debug/mach_debug_types.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach_debug/vm_info.h" 1 3 4
# 73 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach_debug/vm_info.h" 3 4
#pragma pack(4)





typedef struct mach_vm_info_region {
 mach_vm_offset_t vir_start;
 mach_vm_offset_t vir_end;
 mach_vm_offset_t vir_object;
 memory_object_offset_t vir_offset;
 boolean_t vir_needs_copy;
 vm_prot_t vir_protection;
 vm_prot_t vir_max_protection;
 vm_inherit_t vir_inheritance;
 natural_t vir_wired_count;
 natural_t vir_user_wired_count;
} mach_vm_info_region_t;

typedef struct vm_info_region_64 {
 natural_t vir_start;
 natural_t vir_end;
 natural_t vir_object;
 memory_object_offset_t vir_offset;
 boolean_t vir_needs_copy;
 vm_prot_t vir_protection;
 vm_prot_t vir_max_protection;
 vm_inherit_t vir_inheritance;
 natural_t vir_wired_count;
 natural_t vir_user_wired_count;
} vm_info_region_64_t;

typedef struct vm_info_region {
 natural_t vir_start;
 natural_t vir_end;
 natural_t vir_object;
 natural_t vir_offset;
 boolean_t vir_needs_copy;
 vm_prot_t vir_protection;
 vm_prot_t vir_max_protection;
 vm_inherit_t vir_inheritance;
 natural_t vir_wired_count;
 natural_t vir_user_wired_count;
} vm_info_region_t;


typedef struct vm_info_object {
 natural_t vio_object;
 natural_t vio_size;
 unsigned int vio_ref_count;
 unsigned int vio_resident_page_count;
 unsigned int vio_absent_count;
 natural_t vio_copy;
 natural_t vio_shadow;
 natural_t vio_shadow_offset;
 natural_t vio_paging_offset;
 memory_object_copy_strategy_t vio_copy_strategy;

 vm_offset_t vio_last_alloc;

 unsigned int vio_paging_in_progress;
 boolean_t vio_pager_created;
 boolean_t vio_pager_initialized;
 boolean_t vio_pager_ready;
 boolean_t vio_can_persist;
 boolean_t vio_internal;
 boolean_t vio_temporary;
 boolean_t vio_alive;
 boolean_t vio_purgable;
 boolean_t vio_purgable_volatile;
} vm_info_object_t;

typedef vm_info_object_t *vm_info_object_array_t;

#pragma pack()
# 67 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach_debug/mach_debug_types.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach_debug/zone_info.h" 1 3 4
# 73 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach_debug/zone_info.h" 3 4
typedef struct zone_name {
 char zn_name[80];
} zone_name_t;

typedef zone_name_t *zone_name_array_t;


typedef struct zone_info {
 integer_t zi_count;
 vm_size_t zi_cur_size;
 vm_size_t zi_max_size;
 vm_size_t zi_elem_size;
 vm_size_t zi_alloc_size;
 integer_t zi_pageable;
 integer_t zi_sleepable;
 integer_t zi_exhaustible;
 integer_t zi_collectable;
} zone_info_t;

typedef zone_info_t *zone_info_array_t;
# 102 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach_debug/zone_info.h" 3 4
typedef struct mach_zone_name {
 char mzn_name[80];
} mach_zone_name_t;

typedef mach_zone_name_t *mach_zone_name_array_t;

typedef struct mach_zone_info_data {
 uint64_t mzi_count;
 uint64_t mzi_cur_size;
 uint64_t mzi_max_size;
        uint64_t mzi_elem_size;
 uint64_t mzi_alloc_size;
 uint64_t mzi_sum_size;
 uint64_t mzi_exhaustible;
 uint64_t mzi_collectable;
} mach_zone_info_t;

typedef mach_zone_info_t *mach_zone_info_array_t;

typedef struct task_zone_info_data {
 uint64_t tzi_count;
 uint64_t tzi_cur_size;
 uint64_t tzi_max_size;
        uint64_t tzi_elem_size;
 uint64_t tzi_alloc_size;
 uint64_t tzi_sum_size;
 uint64_t tzi_exhaustible;
 uint64_t tzi_collectable;
 uint64_t tzi_caller_acct;
 uint64_t tzi_task_alloc;
 uint64_t tzi_task_free;
} task_zone_info_t;

typedef task_zone_info_t *task_zone_info_array_t;
# 68 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach_debug/mach_debug_types.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach_debug/page_info.h" 1 3 4
# 63 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach_debug/page_info.h" 3 4
typedef vm_offset_t *page_address_array_t;
# 69 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach_debug/mach_debug_types.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach_debug/hash_info.h" 1 3 4
# 67 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach_debug/hash_info.h" 3 4
typedef struct hash_info_bucket {
 natural_t hib_count;
} hash_info_bucket_t;

typedef hash_info_bucket_t *hash_info_bucket_array_t;
# 70 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach_debug/mach_debug_types.h" 2 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach_debug/lockgroup_info.h" 1 3 4
# 43 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach_debug/lockgroup_info.h" 3 4
typedef struct lockgroup_info {
 char lockgroup_name[64];
 uint64_t lockgroup_attr;
 uint64_t lock_spin_cnt;
 uint64_t lock_spin_util_cnt;
 uint64_t lock_spin_held_cnt;
 uint64_t lock_spin_miss_cnt;
 uint64_t lock_spin_held_max;
 uint64_t lock_spin_held_cum;
 uint64_t lock_mtx_cnt;
 uint64_t lock_mtx_util_cnt;
 uint64_t lock_mtx_held_cnt;
 uint64_t lock_mtx_miss_cnt;
 uint64_t lock_mtx_wait_cnt;
 uint64_t lock_mtx_held_max;
 uint64_t lock_mtx_held_cum;
 uint64_t lock_mtx_wait_max;
 uint64_t lock_mtx_wait_cum;
 uint64_t lock_rw_cnt;
 uint64_t lock_rw_util_cnt;
 uint64_t lock_rw_held_cnt;
 uint64_t lock_rw_miss_cnt;
 uint64_t lock_rw_wait_cnt;
 uint64_t lock_rw_held_max;
 uint64_t lock_rw_held_cum;
 uint64_t lock_rw_wait_max;
 uint64_t lock_rw_wait_cum;
} lockgroup_info_t;

typedef lockgroup_info_t *lockgroup_info_array_t;
# 71 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach_debug/mach_debug_types.h" 2 3 4

typedef char symtab_name_t[32];
# 37 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/vm_map.h" 2 3 4






extern "C" {






extern

kern_return_t vm_region
(
 vm_map_t target_task,
 vm_address_t *address,
 vm_size_t *size,
 vm_region_flavor_t flavor,
 vm_region_info_t info,
 mach_msg_type_number_t *infoCnt,
 mach_port_t *object_name
);





extern

kern_return_t vm_allocate
(
 vm_map_t target_task,
 vm_address_t *address,
 vm_size_t size,
 int flags
);





extern

kern_return_t vm_deallocate
(
 vm_map_t target_task,
 vm_address_t address,
 vm_size_t size
);





extern

kern_return_t vm_protect
(
 vm_map_t target_task,
 vm_address_t address,
 vm_size_t size,
 boolean_t set_maximum,
 vm_prot_t new_protection
);





extern

kern_return_t vm_inherit
(
 vm_map_t target_task,
 vm_address_t address,
 vm_size_t size,
 vm_inherit_t new_inheritance
);





extern

kern_return_t vm_read
(
 vm_map_t target_task,
 vm_address_t address,
 vm_size_t size,
 vm_offset_t *data,
 mach_msg_type_number_t *dataCnt
);





extern

kern_return_t vm_read_list
(
 vm_map_t target_task,
 vm_read_entry_t data_list,
 natural_t count
);





extern

kern_return_t vm_write
(
 vm_map_t target_task,
 vm_address_t address,
 vm_offset_t data,
 mach_msg_type_number_t dataCnt
);





extern

kern_return_t vm_copy
(
 vm_map_t target_task,
 vm_address_t source_address,
 vm_size_t size,
 vm_address_t dest_address
);





extern

kern_return_t vm_read_overwrite
(
 vm_map_t target_task,
 vm_address_t address,
 vm_size_t size,
 vm_address_t data,
 vm_size_t *outsize
);





extern

kern_return_t vm_msync
(
 vm_map_t target_task,
 vm_address_t address,
 vm_size_t size,
 vm_sync_t sync_flags
);





extern

kern_return_t vm_behavior_set
(
 vm_map_t target_task,
 vm_address_t address,
 vm_size_t size,
 vm_behavior_t new_behavior
);





extern

kern_return_t vm_map
(
 vm_map_t target_task,
 vm_address_t *address,
 vm_size_t size,
 vm_address_t mask,
 int flags,
 mem_entry_name_port_t object,
 vm_offset_t offset,
 boolean_t copy,
 vm_prot_t cur_protection,
 vm_prot_t max_protection,
 vm_inherit_t inheritance
);





extern

kern_return_t vm_machine_attribute
(
 vm_map_t target_task,
 vm_address_t address,
 vm_size_t size,
 vm_machine_attribute_t attribute,
 vm_machine_attribute_val_t *value
);





extern

kern_return_t vm_remap
(
 vm_map_t target_task,
 vm_address_t *target_address,
 vm_size_t size,
 vm_address_t mask,
 int flags,
 vm_map_t src_task,
 vm_address_t src_address,
 boolean_t copy,
 vm_prot_t *cur_protection,
 vm_prot_t *max_protection,
 vm_inherit_t inheritance
);





extern

kern_return_t task_wire
(
 vm_map_t target_task,
 boolean_t must_wire
);





extern

kern_return_t mach_make_memory_entry
(
 vm_map_t target_task,
 vm_size_t *size,
 vm_offset_t offset,
 vm_prot_t permission,
 mem_entry_name_port_t *object_handle,
 mem_entry_name_port_t parent_entry
);





extern

kern_return_t vm_map_page_query
(
 vm_map_t target_map,
 vm_offset_t offset,
 integer_t *disposition,
 integer_t *ref_count
);





extern

kern_return_t mach_vm_region_info
(
 vm_map_t task,
 vm_address_t address,
 vm_info_region_t *region,
 vm_info_object_array_t *objects,
 mach_msg_type_number_t *objectsCnt
);





extern

kern_return_t vm_mapped_pages_info
(
 vm_map_t task,
 page_address_array_t *pages,
 mach_msg_type_number_t *pagesCnt
);





extern

kern_return_t vm_region_recurse
(
 vm_map_t target_task,
 vm_address_t *address,
 vm_size_t *size,
 natural_t *nesting_depth,
 vm_region_recurse_info_t info,
 mach_msg_type_number_t *infoCnt
);





extern

kern_return_t vm_region_recurse_64
(
 vm_map_t target_task,
 vm_address_t *address,
 vm_size_t *size,
 natural_t *nesting_depth,
 vm_region_recurse_info_t info,
 mach_msg_type_number_t *infoCnt
);





extern

kern_return_t mach_vm_region_info_64
(
 vm_map_t task,
 vm_address_t address,
 vm_info_region_64_t *region,
 vm_info_object_array_t *objects,
 mach_msg_type_number_t *objectsCnt
);





extern

kern_return_t vm_region_64
(
 vm_map_t target_task,
 vm_address_t *address,
 vm_size_t *size,
 vm_region_flavor_t flavor,
 vm_region_info_t info,
 mach_msg_type_number_t *infoCnt,
 mach_port_t *object_name
);





extern

kern_return_t mach_make_memory_entry_64
(
 vm_map_t target_task,
 memory_object_size_t *size,
 memory_object_offset_t offset,
 vm_prot_t permission,
 mach_port_t *object_handle,
 mem_entry_name_port_t parent_entry
);





extern

kern_return_t vm_map_64
(
 vm_map_t target_task,
 vm_address_t *address,
 vm_size_t size,
 vm_address_t mask,
 int flags,
 mem_entry_name_port_t object,
 memory_object_offset_t offset,
 boolean_t copy,
 vm_prot_t cur_protection,
 vm_prot_t max_protection,
 vm_inherit_t inheritance
);





extern

kern_return_t vm_purgable_control
(
 vm_map_t target_task,
 vm_address_t address,
 vm_purgable_t control,
 int *state
);

}
# 479 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/mach/vm_map.h" 3 4
#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  vm_address_t address;
  vm_region_flavor_t flavor;
  mach_msg_type_number_t infoCnt;
 } __Request__vm_region_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  vm_address_t address;
  vm_size_t size;
  int flags;
 } __Request__vm_allocate_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  vm_address_t address;
  vm_size_t size;
 } __Request__vm_deallocate_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  vm_address_t address;
  vm_size_t size;
  boolean_t set_maximum;
  vm_prot_t new_protection;
 } __Request__vm_protect_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  vm_address_t address;
  vm_size_t size;
  vm_inherit_t new_inheritance;
 } __Request__vm_inherit_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  vm_address_t address;
  vm_size_t size;
 } __Request__vm_read_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  vm_read_entry_t data_list;
  natural_t count;
 } __Request__vm_read_list_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;

  mach_msg_body_t msgh_body;
  mach_msg_ool_descriptor_t data;

  NDR_record_t NDR;
  vm_address_t address;
  mach_msg_type_number_t dataCnt;
 } __Request__vm_write_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  vm_address_t source_address;
  vm_size_t size;
  vm_address_t dest_address;
 } __Request__vm_copy_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  vm_address_t address;
  vm_size_t size;
  vm_address_t data;
 } __Request__vm_read_overwrite_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  vm_address_t address;
  vm_size_t size;
  vm_sync_t sync_flags;
 } __Request__vm_msync_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  vm_address_t address;
  vm_size_t size;
  vm_behavior_t new_behavior;
 } __Request__vm_behavior_set_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;

  mach_msg_body_t msgh_body;
  mach_msg_port_descriptor_t object;

  NDR_record_t NDR;
  vm_address_t address;
  vm_size_t size;
  vm_address_t mask;
  int flags;
  vm_offset_t offset;
  boolean_t copy;
  vm_prot_t cur_protection;
  vm_prot_t max_protection;
  vm_inherit_t inheritance;
 } __Request__vm_map_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  vm_address_t address;
  vm_size_t size;
  vm_machine_attribute_t attribute;
  vm_machine_attribute_val_t value;
 } __Request__vm_machine_attribute_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;

  mach_msg_body_t msgh_body;
  mach_msg_port_descriptor_t src_task;

  NDR_record_t NDR;
  vm_address_t target_address;
  vm_size_t size;
  vm_address_t mask;
  int flags;
  vm_address_t src_address;
  boolean_t copy;
  vm_inherit_t inheritance;
 } __Request__vm_remap_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  boolean_t must_wire;
 } __Request__task_wire_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;

  mach_msg_body_t msgh_body;
  mach_msg_port_descriptor_t parent_entry;

  NDR_record_t NDR;
  vm_size_t size;
  vm_offset_t offset;
  vm_prot_t permission;
 } __Request__mach_make_memory_entry_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  vm_offset_t offset;
 } __Request__vm_map_page_query_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  vm_address_t address;
 } __Request__mach_vm_region_info_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
 } __Request__vm_mapped_pages_info_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  vm_address_t address;
  natural_t nesting_depth;
  mach_msg_type_number_t infoCnt;
 } __Request__vm_region_recurse_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  vm_address_t address;
  natural_t nesting_depth;
  mach_msg_type_number_t infoCnt;
 } __Request__vm_region_recurse_64_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  vm_address_t address;
 } __Request__mach_vm_region_info_64_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  vm_address_t address;
  vm_region_flavor_t flavor;
  mach_msg_type_number_t infoCnt;
 } __Request__vm_region_64_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;

  mach_msg_body_t msgh_body;
  mach_msg_port_descriptor_t parent_entry;

  NDR_record_t NDR;
  memory_object_size_t size;
  memory_object_offset_t offset;
  vm_prot_t permission;
 } __Request__mach_make_memory_entry_64_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;

  mach_msg_body_t msgh_body;
  mach_msg_port_descriptor_t object;

  NDR_record_t NDR;
  vm_address_t address;
  vm_size_t size;
  vm_address_t mask;
  int flags;
  memory_object_offset_t offset;
  boolean_t copy;
  vm_prot_t cur_protection;
  vm_prot_t max_protection;
  vm_inherit_t inheritance;
 } __Request__vm_map_64_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  vm_address_t address;
  vm_purgable_t control;
  int state;
 } __Request__vm_purgable_control_t;

#pragma pack()







union __RequestUnion__vm_map_subsystem {
 __Request__vm_region_t Request_vm_region;
 __Request__vm_allocate_t Request_vm_allocate;
 __Request__vm_deallocate_t Request_vm_deallocate;
 __Request__vm_protect_t Request_vm_protect;
 __Request__vm_inherit_t Request_vm_inherit;
 __Request__vm_read_t Request_vm_read;
 __Request__vm_read_list_t Request_vm_read_list;
 __Request__vm_write_t Request_vm_write;
 __Request__vm_copy_t Request_vm_copy;
 __Request__vm_read_overwrite_t Request_vm_read_overwrite;
 __Request__vm_msync_t Request_vm_msync;
 __Request__vm_behavior_set_t Request_vm_behavior_set;
 __Request__vm_map_t Request_vm_map;
 __Request__vm_machine_attribute_t Request_vm_machine_attribute;
 __Request__vm_remap_t Request_vm_remap;
 __Request__task_wire_t Request_task_wire;
 __Request__mach_make_memory_entry_t Request_mach_make_memory_entry;
 __Request__vm_map_page_query_t Request_vm_map_page_query;
 __Request__mach_vm_region_info_t Request_mach_vm_region_info;
 __Request__vm_mapped_pages_info_t Request_vm_mapped_pages_info;
 __Request__vm_region_recurse_t Request_vm_region_recurse;
 __Request__vm_region_recurse_64_t Request_vm_region_recurse_64;
 __Request__mach_vm_region_info_64_t Request_mach_vm_region_info_64;
 __Request__vm_region_64_t Request_vm_region_64;
 __Request__mach_make_memory_entry_64_t Request_mach_make_memory_entry_64;
 __Request__vm_map_64_t Request_vm_map_64;
 __Request__vm_purgable_control_t Request_vm_purgable_control;
};







#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;

  mach_msg_body_t msgh_body;
  mach_msg_port_descriptor_t object_name;

  NDR_record_t NDR;
  vm_address_t address;
  vm_size_t size;
  mach_msg_type_number_t infoCnt;
  int info[10];
 } __Reply__vm_region_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  kern_return_t RetCode;
  vm_address_t address;
 } __Reply__vm_allocate_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  kern_return_t RetCode;
 } __Reply__vm_deallocate_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  kern_return_t RetCode;
 } __Reply__vm_protect_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  kern_return_t RetCode;
 } __Reply__vm_inherit_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;

  mach_msg_body_t msgh_body;
  mach_msg_ool_descriptor_t data;

  NDR_record_t NDR;
  mach_msg_type_number_t dataCnt;
 } __Reply__vm_read_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  kern_return_t RetCode;
  vm_read_entry_t data_list;
 } __Reply__vm_read_list_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  kern_return_t RetCode;
 } __Reply__vm_write_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  kern_return_t RetCode;
 } __Reply__vm_copy_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  kern_return_t RetCode;
  vm_size_t outsize;
 } __Reply__vm_read_overwrite_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  kern_return_t RetCode;
 } __Reply__vm_msync_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  kern_return_t RetCode;
 } __Reply__vm_behavior_set_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  kern_return_t RetCode;
  vm_address_t address;
 } __Reply__vm_map_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  kern_return_t RetCode;
  vm_machine_attribute_val_t value;
 } __Reply__vm_machine_attribute_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  kern_return_t RetCode;
  vm_address_t target_address;
  vm_prot_t cur_protection;
  vm_prot_t max_protection;
 } __Reply__vm_remap_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  kern_return_t RetCode;
 } __Reply__task_wire_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;

  mach_msg_body_t msgh_body;
  mach_msg_port_descriptor_t object_handle;

  NDR_record_t NDR;
  vm_size_t size;
 } __Reply__mach_make_memory_entry_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  kern_return_t RetCode;
  integer_t disposition;
  integer_t ref_count;
 } __Reply__vm_map_page_query_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;

  mach_msg_body_t msgh_body;
  mach_msg_ool_descriptor_t objects;

  NDR_record_t NDR;
  vm_info_region_t region;
  mach_msg_type_number_t objectsCnt;
 } __Reply__mach_vm_region_info_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;

  mach_msg_body_t msgh_body;
  mach_msg_ool_descriptor_t pages;

  NDR_record_t NDR;
  mach_msg_type_number_t pagesCnt;
 } __Reply__vm_mapped_pages_info_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  kern_return_t RetCode;
  vm_address_t address;
  vm_size_t size;
  natural_t nesting_depth;
  mach_msg_type_number_t infoCnt;
  int info[19];
 } __Reply__vm_region_recurse_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  kern_return_t RetCode;
  vm_address_t address;
  vm_size_t size;
  natural_t nesting_depth;
  mach_msg_type_number_t infoCnt;
  int info[19];
 } __Reply__vm_region_recurse_64_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;

  mach_msg_body_t msgh_body;
  mach_msg_ool_descriptor_t objects;

  NDR_record_t NDR;
  vm_info_region_64_t region;
  mach_msg_type_number_t objectsCnt;
 } __Reply__mach_vm_region_info_64_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;

  mach_msg_body_t msgh_body;
  mach_msg_port_descriptor_t object_name;

  NDR_record_t NDR;
  vm_address_t address;
  vm_size_t size;
  mach_msg_type_number_t infoCnt;
  int info[10];
 } __Reply__vm_region_64_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;

  mach_msg_body_t msgh_body;
  mach_msg_port_descriptor_t object_handle;

  NDR_record_t NDR;
  memory_object_size_t size;
 } __Reply__mach_make_memory_entry_64_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  kern_return_t RetCode;
  vm_address_t address;
 } __Reply__vm_map_64_t;

#pragma pack()



#pragma pack(4)

 typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  kern_return_t RetCode;
  int state;
 } __Reply__vm_purgable_control_t;

#pragma pack()







union __ReplyUnion__vm_map_subsystem {
 __Reply__vm_region_t Reply_vm_region;
 __Reply__vm_allocate_t Reply_vm_allocate;
 __Reply__vm_deallocate_t Reply_vm_deallocate;
 __Reply__vm_protect_t Reply_vm_protect;
 __Reply__vm_inherit_t Reply_vm_inherit;
 __Reply__vm_read_t Reply_vm_read;
 __Reply__vm_read_list_t Reply_vm_read_list;
 __Reply__vm_write_t Reply_vm_write;
 __Reply__vm_copy_t Reply_vm_copy;
 __Reply__vm_read_overwrite_t Reply_vm_read_overwrite;
 __Reply__vm_msync_t Reply_vm_msync;
 __Reply__vm_behavior_set_t Reply_vm_behavior_set;
 __Reply__vm_map_t Reply_vm_map;
 __Reply__vm_machine_attribute_t Reply_vm_machine_attribute;
 __Reply__vm_remap_t Reply_vm_remap;
 __Reply__task_wire_t Reply_task_wire;
 __Reply__mach_make_memory_entry_t Reply_mach_make_memory_entry;
 __Reply__vm_map_page_query_t Reply_vm_map_page_query;
 __Reply__mach_vm_region_info_t Reply_mach_vm_region_info;
 __Reply__vm_mapped_pages_info_t Reply_vm_mapped_pages_info;
 __Reply__vm_region_recurse_t Reply_vm_region_recurse;
 __Reply__vm_region_recurse_64_t Reply_vm_region_recurse_64;
 __Reply__mach_vm_region_info_64_t Reply_mach_vm_region_info_64;
 __Reply__vm_region_64_t Reply_vm_region_64;
 __Reply__mach_make_memory_entry_64_t Reply_mach_make_memory_entry_64;
 __Reply__vm_map_64_t Reply_vm_map_64;
 __Reply__vm_purgable_control_t Reply_vm_purgable_control;
};
# 39 "./wtf/PageAllocation.h" 2








# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/errno.h" 1 3 4
# 23 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/errno.h" 3 4
# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/errno.h" 1 3 4
# 74 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/errno.h" 3 4
extern "C" {
extern int * __error(void);

}
# 24 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/errno.h" 2 3 4
# 48 "./wtf/PageAllocation.h" 2



# 1 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/mman.h" 1 3 4
# 199 "/Developer/SDKs/MacOSX10.7.sdk/usr/include/sys/mman.h" 3 4
extern "C" {

int mlockall(int);
int munlockall(void);

int mlock(const void *, size_t);



void * mmap(void *, size_t, int, int, int, off_t) __asm("_" "mmap" );


int mprotect(void *, size_t, int) __asm("_" "mprotect" );

int msync(void *, size_t, int) __asm("_" "msync" );

int munlock(const void *, size_t);

int munmap(void *, size_t) __asm("_" "munmap" );

int shm_open(const char *, int, ...);
int shm_unlink(const char *);

int posix_madvise(void *, size_t, int);


int madvise(void *, size_t, int);
int mincore(const void *, size_t, char *);
int minherit(void *, size_t, int);

}
# 52 "./wtf/PageAllocation.h" 2



namespace WTF {
# 73 "./wtf/PageAllocation.h"
class PageAllocation : private PageBlock {
public:
    PageAllocation()
    {
    }

    using PageBlock::size;
    using PageBlock::base;






    operator bool() const { return PageBlock::operator bool(); }


    static PageAllocation allocate(size_t size, OSAllocator::Usage usage = OSAllocator::UnknownUsage, bool writable = true, bool executable = false)
    {
        ((void)0);
        return PageAllocation(OSAllocator::reserveAndCommit(size, usage, writable, executable), size);
    }

    void deallocate()
    {


        PageAllocation tmp;
        std::swap(tmp, *this);

        ((void)0);
        ((void)0);

        OSAllocator::decommitAndRelease(tmp.base(), tmp.size());
    }

private:
    PageAllocation(void* base, size_t size)
        : PageBlock(base, size, false)
    {
    }
};

}

using WTF::PageAllocation;
# 33 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/jit/ExecutableAllocator.h" 2
# 73 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/jit/ExecutableAllocator.h"
namespace JSC {

class JSGlobalData;
void releaseExecutableMemory(JSGlobalData&);

inline size_t roundUpAllocationSize(size_t request, size_t granularity)
{
    if ((std::numeric_limits<size_t>::max() - granularity) <= request)
        do { WTFReportBacktrace(); *(int *)(uintptr_t)0xbbadbeef = 0; __builtin_trap(); } while (false);


    size_t size = request + (granularity - 1);
    size = size & ~(granularity - 1);
    ((void)0);
    return size;
}

}



namespace JSC {

typedef WTF::MetaAllocatorHandle ExecutableMemoryHandle;

class ExecutableAllocator {
    enum ProtectionSetting { Writable, Executable };

public:
    ExecutableAllocator(JSGlobalData&);

    static void initializeAllocator();

    bool isValid() const;

    static bool underMemoryPressure();




    static void dumpProfile() { }


    PassRefPtr<ExecutableMemoryHandle> allocate(JSGlobalData&, size_t sizeInBytes);
# 129 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/jit/ExecutableAllocator.h"
    static void makeWritable(void*, size_t) {}
    static void makeExecutable(void*, size_t) {}




    static void cacheFlush(void*, size_t)
    {
    }
# 230 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/jit/ExecutableAllocator.h"
    static size_t committedByteCount();

private:




};

}
# 36 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSGlobalData.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/Heap.h" 1
# 25 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/Heap.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/AllocationSpace.h" 1
# 29 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/AllocationSpace.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/MarkedBlockSet.h" 1
# 29 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/MarkedBlockSet.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/MarkedBlock.h" 1
# 25 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/MarkedBlock.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/CardSet.h" 1
# 33 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/CardSet.h"
namespace JSC {

template <size_t cardSize, size_t blockSize> class CardSet {
    private: CardSet(const CardSet&); CardSet& operator=(const CardSet&);

public:
    static const size_t cardCount = (blockSize + cardSize - 1) / cardSize;

    CardSet()
    {
        memset(m_cards, 0, cardCount);
    }

    bool isCardMarkedForAtom(const void*);
    void markCardForAtom(const void*);
    uint8_t& cardForAtom(const void*);
    bool isCardMarked(size_t);
    bool testAndClear(size_t);

private:
    uint8_t m_cards[cardCount];
    typedef int dummycardSet_cardSize_is_power_of_two [(!(cardSize & (cardSize - 1))) ? 1 : -1];
    typedef int dummycardSet_cardCount_is_power_of_two [(!(cardCount & (cardCount - 1))) ? 1 : -1];
};

template <size_t cardSize, size_t blockSize> uint8_t& CardSet<cardSize, blockSize>::cardForAtom(const void* ptr)
{
    ((void)0);
    uintptr_t card = (reinterpret_cast<uintptr_t>(ptr) / cardSize) % cardCount;
    return m_cards[card];
}

template <size_t cardSize, size_t blockSize> bool CardSet<cardSize, blockSize>::isCardMarkedForAtom(const void* ptr)
{
    return cardForAtom(ptr);
}

template <size_t cardSize, size_t blockSize> void CardSet<cardSize, blockSize>::markCardForAtom(const void* ptr)
{
    cardForAtom(ptr) = 1;
}

template <size_t cardSize, size_t blockSize> bool CardSet<cardSize, blockSize>::isCardMarked(size_t i)
{
    ((void)0);
    return m_cards[i];
}

template <size_t cardSize, size_t blockSize> bool CardSet<cardSize, blockSize>::testAndClear(size_t i)
{
    ((void)0);
    bool result = m_cards[i];
    m_cards[i] = 0;
    return result;
}

}
# 26 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/MarkedBlock.h" 2

# 1 "./wtf/Bitmap.h" 1
# 27 "./wtf/Bitmap.h"
namespace WTF {

template<size_t size>
class Bitmap {
private:
    typedef uint32_t WordType;

public:
    Bitmap();

    bool get(size_t) const;
    void set(size_t);
    bool testAndSet(size_t);
    bool testAndClear(size_t);
    size_t nextPossiblyUnset(size_t) const;
    void clear(size_t);
    void clearAll();
    int64_t findRunOfZeros(size_t) const;
    size_t count(size_t = 0) const;
    size_t isEmpty() const;
    size_t isFull() const;

private:
    static const WordType wordSize = sizeof(WordType) * 8;
    static const WordType words = (size + wordSize - 1) / wordSize;






    static const WordType one = 1;

    FixedArray<WordType, words> bits;
};

template<size_t size>
inline Bitmap<size>::Bitmap()
{
    clearAll();
}

template<size_t size>
inline bool Bitmap<size>::get(size_t n) const
{
    return !!(bits[n / wordSize] & (one << (n % wordSize)));
}

template<size_t size>
inline void Bitmap<size>::set(size_t n)
{
    bits[n / wordSize] |= (one << (n % wordSize));
}

template<size_t size>
inline bool Bitmap<size>::testAndSet(size_t n)
{
    WordType mask = one << (n % wordSize);
    size_t index = n / wordSize;
    bool result = bits[index] & mask;
    bits[index] |= mask;
    return result;
}

template<size_t size>
inline bool Bitmap<size>::testAndClear(size_t n)
{
    WordType mask = one << (n % wordSize);
    size_t index = n / wordSize;
    bool result = bits[index] & mask;
    bits[index] &= ~mask;
    return result;
}

template<size_t size>
inline void Bitmap<size>::clear(size_t n)
{
    bits[n / wordSize] &= ~(one << (n % wordSize));
}

template<size_t size>
inline void Bitmap<size>::clearAll()
{
    memset(bits.data(), 0, sizeof(bits));
}

template<size_t size>
inline size_t Bitmap<size>::nextPossiblyUnset(size_t start) const
{
    if (!~bits[start / wordSize])
        return ((start / wordSize) + 1) * wordSize;
    return start + 1;
}

template<size_t size>
inline int64_t Bitmap<size>::findRunOfZeros(size_t runLength) const
{
    if (!runLength)
        runLength = 1;

    for (size_t i = 0; i <= (size - runLength) ; i++) {
        bool found = true;
        for (size_t j = i; j <= (i + runLength - 1) ; j++) {
            if (get(j)) {
                found = false;
                break;
            }
        }
        if (found)
            return i;
    }
    return -1;
}

template<size_t size>
inline size_t Bitmap<size>::count(size_t start) const
{
    size_t result = 0;
    for ( ; (start % wordSize); ++start) {
        if (get(start))
            ++result;
    }
    for (size_t i = start / wordSize; i < words; ++i)
        result += WTF::bitCount(bits[i]);
    return result;
}

template<size_t size>
inline size_t Bitmap<size>::isEmpty() const
{
    for (size_t i = 0; i < words; ++i)
        if (bits[i])
            return false;
    return true;
}

template<size_t size>
inline size_t Bitmap<size>::isFull() const
{
    for (size_t i = 0; i < words; ++i)
        if (~bits[i])
            return false;
    return true;
}

}
# 28 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/MarkedBlock.h" 2
# 1 "./wtf/DoublyLinkedList.h" 1
# 29 "./wtf/DoublyLinkedList.h"
namespace WTF {


template<typename T> class DoublyLinkedListNode {
public:
    DoublyLinkedListNode();

    void setPrev(T*);
    void setNext(T*);

    T* prev() const;
    T* next() const;
};

template<typename T> inline DoublyLinkedListNode<T>::DoublyLinkedListNode()
{
    setPrev(0);
    setNext(0);
}

template<typename T> inline void DoublyLinkedListNode<T>::setPrev(T* prev)
{
    static_cast<T*>(this)->m_prev = prev;
}

template<typename T> inline void DoublyLinkedListNode<T>::setNext(T* next)
{
    static_cast<T*>(this)->m_next = next;
}

template<typename T> inline T* DoublyLinkedListNode<T>::prev() const
{
    return static_cast<const T*>(this)->m_prev;
}

template<typename T> inline T* DoublyLinkedListNode<T>::next() const
{
    return static_cast<const T*>(this)->m_next;
}

template<typename T> class DoublyLinkedList {
public:
    DoublyLinkedList();

    bool isEmpty() const;
    size_t size() const;
    void clear();

    T* head() const;
    T* removeHead();

    void append(T*);
    void remove(T*);

private:
    T* m_head;
    T* m_tail;
};

template<typename T> inline DoublyLinkedList<T>::DoublyLinkedList()
    : m_head(0)
    , m_tail(0)
{
}

template<typename T> inline bool DoublyLinkedList<T>::isEmpty() const
{
    return !m_head;
}

template<typename T> inline size_t DoublyLinkedList<T>::size() const
{
    size_t size = 0;
    for (T* node = m_head; node; node = node->next())
        ++size;
    return size;
}

template<typename T> inline void DoublyLinkedList<T>::clear()
{
    m_head = 0;
    m_tail = 0;
}

template<typename T> inline T* DoublyLinkedList<T>::head() const
{
    return m_head;
}

template<typename T> inline void DoublyLinkedList<T>::append(T* node)
{
    if (!m_tail) {
        ((void)0);
        m_head = node;
        m_tail = node;
        node->setPrev(0);
        node->setNext(0);
        return;
    }

    ((void)0);
    m_tail->setNext(node);
    node->setPrev(m_tail);
    node->setNext(0);
    m_tail = node;
}

template<typename T> inline void DoublyLinkedList<T>::remove(T* node)
{
    if (node->prev()) {
        ((void)0);
        node->prev()->setNext(node->next());
    } else {
        ((void)0);
        m_head = node->next();
    }

    if (node->next()) {
        ((void)0);
        node->next()->setPrev(node->prev());
    } else {
        ((void)0);
        m_tail = node->prev();
    }
}

template<typename T> inline T* DoublyLinkedList<T>::removeHead()
{
    T* node = head();
    if (node)
        remove(node);
    return node;
}

}

using WTF::DoublyLinkedListNode;
using WTF::DoublyLinkedList;
# 29 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/MarkedBlock.h" 2

# 1 "./wtf/PageAllocationAligned.h" 1
# 30 "./wtf/PageAllocationAligned.h"
# 1 "./wtf/PageReservation.h" 1
# 31 "./wtf/PageReservation.h"
namespace WTF {
# 57 "./wtf/PageReservation.h"
class PageReservation : private PageBlock {
public:
    PageReservation()
        : m_committed(0)
        , m_writable(false)
        , m_executable(false)
    {
    }

    using PageBlock::base;
    using PageBlock::size;






    operator bool() const { return PageBlock::operator bool(); }


    void commit(void* start, size_t size)
    {
        ((void)0);
        ((void)0);
        ((void)0);
        ((void)0);

        m_committed += size;
        OSAllocator::commit(start, size, m_writable, m_executable);
    }

    void decommit(void* start, size_t size)
    {
        ((void)0);
        ((void)0);
        ((void)0);
        ((void)0);

        m_committed -= size;
        OSAllocator::decommit(start, size);
    }

    size_t committed()
    {
        return m_committed;
    }

    static PageReservation reserve(size_t size, OSAllocator::Usage usage = OSAllocator::UnknownUsage, bool writable = true, bool executable = false)
    {
        ((void)0);
        return PageReservation(OSAllocator::reserveUncommitted(size, usage, writable, executable), size, writable, executable, false);
    }

    static PageReservation reserveWithGuardPages(size_t size, OSAllocator::Usage usage = OSAllocator::UnknownUsage, bool writable = true, bool executable = false)
    {
        ((void)0);
        return PageReservation(OSAllocator::reserveUncommitted(size + pageSize() * 2, usage, writable, executable, true), size, writable, executable, true);
    }

    void deallocate()
    {
        ((void)0);



        PageReservation tmp;
        std::swap(tmp, *this);

        ((void)0);
        ((void)0);

        OSAllocator::releaseDecommitted(tmp.base(), tmp.size());
    }

private:
    PageReservation(void* base, size_t size, bool writable, bool executable, bool hasGuardPages)
        : PageBlock(base, size, hasGuardPages)
        , m_committed(0)
        , m_writable(writable)
        , m_executable(executable)
    {
    }

    size_t m_committed;
    bool m_writable;
    bool m_executable;
};

}

using WTF::PageReservation;
# 31 "./wtf/PageAllocationAligned.h" 2

namespace WTF {

class PageAllocationAligned : private PageBlock {
public:
    PageAllocationAligned()
    {
    }

    using PageBlock::operator bool;
    using PageBlock::size;
    using PageBlock::base;

    static PageAllocationAligned allocate(size_t size, size_t alignment, OSAllocator::Usage usage = OSAllocator::UnknownUsage, bool writable = true, bool executable = false);

    void deallocate();

private:

    PageAllocationAligned(void* base, size_t size)
        : PageBlock(base, size, false)
    {
    }
# 63 "./wtf/PageAllocationAligned.h"
};


}

using WTF::PageAllocationAligned;
# 31 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/MarkedBlock.h" 2
# 46 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/MarkedBlock.h"
namespace JSC {

    class Heap;
    class JSCell;

    typedef uintptr_t Bits;

    static const size_t KB = 1024;
    static const size_t MB = 1024 * 1024;

    bool isZapped(const JSCell*);
# 66 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/MarkedBlock.h"
    class MarkedBlock : public DoublyLinkedListNode<MarkedBlock> {
        friend class WTF::DoublyLinkedListNode<MarkedBlock>;
    public:


        static const size_t atomSize = 4 * sizeof(void*);
        static const size_t atomShift = 5;
        static const size_t blockSize = 16 * KB;
        static const size_t blockMask = ~(blockSize - 1);

        static const size_t atomsPerBlock = blockSize / atomSize;
        static const size_t atomMask = atomsPerBlock - 1;
        static const int cardShift = 8;
        static const size_t bytesPerCard = 1 << cardShift;
        static const int cardCount = blockSize / bytesPerCard;
        static const int cardMask = cardCount - 1;

        struct FreeCell {
            FreeCell* next;
        };

        struct VoidFunctor {
            typedef void ReturnType;
            void returnValue() { }
        };

        static MarkedBlock* create(Heap*, size_t cellSize);
        static MarkedBlock* recycle(MarkedBlock*, size_t cellSize);
        static void destroy(MarkedBlock*);

        static bool isAtomAligned(const void*);
        static MarkedBlock* blockFor(const void*);
        static size_t firstAtom();

        Heap* heap() const;

        void* allocate();

        enum SweepMode { SweepOnly, SweepToFreeList };
        FreeCell* sweep(SweepMode = SweepOnly);




        void didConsumeFreeList();
        void zapFreeList(FreeCell* firstFreeCell);

        void clearMarks();
        size_t markCount();
        bool markCountIsZero();

        size_t cellSize();

        size_t size();
        size_t capacity();

        bool isMarked(const void*);
        bool testAndSetMarked(const void*);
        bool isLive(const JSCell*);
        bool isLiveCell(const void*);
        void setMarked(const void*);
# 156 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/MarkedBlock.h"
        template <typename Functor> void forEachCell(Functor&);

    private:
        static const size_t atomAlignmentMask = atomSize - 1;

        enum BlockState { New, FreeListed, Allocated, Marked, Zapped };

        typedef char Atom[atomSize];

        MarkedBlock(const PageAllocationAligned&, Heap*, size_t cellSize);
        Atom* atoms();
        size_t atomNumber(const void*);
        void callDestructor(JSCell*, void* jsFinalObjectVPtr);
        template<BlockState, SweepMode> FreeCell* specializedSweep();





        size_t m_atomsPerCell;
        size_t m_endAtom;
        WTF::Bitmap<atomsPerBlock> m_marks;
        BlockState m_state;
        PageAllocationAligned m_allocation;
        Heap* m_heap;
        MarkedBlock* m_prev;
        MarkedBlock* m_next;
    };

    inline size_t MarkedBlock::firstAtom()
    {
        return WTF::roundUpToMultipleOf<atomSize>(sizeof(MarkedBlock)) / atomSize;
    }

    inline MarkedBlock::Atom* MarkedBlock::atoms()
    {
        return reinterpret_cast<Atom*>(this);
    }

    inline bool MarkedBlock::isAtomAligned(const void* p)
    {
        return !(reinterpret_cast<Bits>(p) & atomAlignmentMask);
    }

    inline MarkedBlock* MarkedBlock::blockFor(const void* p)
    {
        return reinterpret_cast<MarkedBlock*>(reinterpret_cast<Bits>(p) & blockMask);
    }

    inline Heap* MarkedBlock::heap() const
    {
        return m_heap;
    }

    inline void MarkedBlock::didConsumeFreeList()
    {
        ((void)0);

        ((void)0);
        m_state = Allocated;
    }

    inline void MarkedBlock::clearMarks()
    {
        ((void)0);

        ((void)0);
        m_marks.clearAll();



        m_state = Marked;
    }

    inline size_t MarkedBlock::markCount()
    {
        return m_marks.count();
    }

    inline bool MarkedBlock::markCountIsZero()
    {
        return m_marks.isEmpty();
    }

    inline size_t MarkedBlock::cellSize()
    {
        return m_atomsPerCell * atomSize;
    }

    inline size_t MarkedBlock::size()
    {
        return markCount() * cellSize();
    }

    inline size_t MarkedBlock::capacity()
    {
        return m_allocation.size();
    }

    inline size_t MarkedBlock::atomNumber(const void* p)
    {
        return (reinterpret_cast<Bits>(p) - reinterpret_cast<Bits>(this)) / atomSize;
    }

    inline bool MarkedBlock::isMarked(const void* p)
    {
        return m_marks.get(atomNumber(p));
    }

    inline bool MarkedBlock::testAndSetMarked(const void* p)
    {
        return m_marks.testAndSet(atomNumber(p));
    }

    inline void MarkedBlock::setMarked(const void* p)
    {
        m_marks.set(atomNumber(p));
    }

    inline bool MarkedBlock::isLive(const JSCell* cell)
    {
        switch (m_state) {
        case Allocated:
            return true;
        case Zapped:
            return !isZapped(cell);
        case Marked:
            return m_marks.get(atomNumber(cell));

        case New:
        case FreeListed:
            ((void)0);
            return false;
        }

        ((void)0);
        return false;
    }

    inline bool MarkedBlock::isLiveCell(const void* p)
    {
        ((void)0);
        size_t atomNumber = this->atomNumber(p);
        size_t firstAtom = this->firstAtom();
        if (atomNumber < firstAtom)
            return false;
        if ((atomNumber - firstAtom) % m_atomsPerCell)
            return false;

        return isLive(static_cast<const JSCell*>(p));
    }

    template <typename Functor> inline void MarkedBlock::forEachCell(Functor& functor)
    {
        for (size_t i = firstAtom(); i < m_endAtom; i += m_atomsPerCell) {
            JSCell* cell = reinterpret_cast<JSCell*>(&atoms()[i]);
            if (!isLive(cell))
                continue;

            functor(cell);
        }
    }
# 400 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/MarkedBlock.h"
}

namespace WTF {

    struct MarkedBlockHash : PtrHash<JSC::MarkedBlock*> {
        static unsigned hash(JSC::MarkedBlock* const& key)
        {



            return reinterpret_cast<JSC::Bits>(key) / JSC::MarkedBlock::blockSize;
        }
    };

    template<> struct DefaultHash<JSC::MarkedBlock*> {
        typedef MarkedBlockHash Hash;
    };

}
# 30 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/MarkedBlockSet.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/TinyBloomFilter.h" 1
# 29 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/TinyBloomFilter.h"
namespace JSC {

typedef uintptr_t Bits;

class TinyBloomFilter {
public:
    TinyBloomFilter();

    void add(Bits);
    bool ruleOut(Bits) const;

private:
    Bits m_bits;
};

inline TinyBloomFilter::TinyBloomFilter()
    : m_bits(0)
{
}

inline void TinyBloomFilter::add(Bits bits)
{
    m_bits |= bits;
}

inline bool TinyBloomFilter::ruleOut(Bits bits) const
{
    if (!bits)
        return true;

    if ((bits & m_bits) != bits)
        return true;

    return false;
}

}
# 31 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/MarkedBlockSet.h" 2
# 1 "./wtf/HashSet.h" 1
# 27 "./wtf/HashSet.h"
namespace WTF {

    template<typename Value, typename HashFunctions, typename Traits> class HashSet;
    template<typename Value, typename HashFunctions, typename Traits>
    void deleteAllValues(const HashSet<Value, HashFunctions, Traits>&);
    template<typename Value, typename HashFunctions, typename Traits>
    void fastDeleteAllValues(const HashSet<Value, HashFunctions, Traits>&);

    template<typename T> struct IdentityExtractor;

    template<typename ValueArg, typename HashArg = typename DefaultHash<ValueArg>::Hash,
        typename TraitsArg = HashTraits<ValueArg> > class HashSet {
        public: void* operator new(size_t, void* p) { return p; } void* operator new[](size_t, void* p) { return p; } void* operator new(size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNew); return p; } void operator delete(void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNew); ::WTF::fastFree(p); } void* operator new[](size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNewArray); return p; } void operator delete[](void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNewArray); ::WTF::fastFree(p); } private: typedef int ThisIsHereToForceASemicolonAfterThisMacro;
    private:
        typedef HashArg HashFunctions;
        typedef TraitsArg ValueTraits;

    public:
        typedef typename ValueTraits::TraitType ValueType;

    private:
        typedef HashTable<ValueType, ValueType, IdentityExtractor<ValueType>,
            HashFunctions, ValueTraits, ValueTraits> HashTableType;

    public:
        typedef HashTableConstIteratorAdapter<HashTableType, ValueType> iterator;
        typedef HashTableConstIteratorAdapter<HashTableType, ValueType> const_iterator;

        void swap(HashSet&);

        int size() const;
        int capacity() const;
        bool isEmpty() const;

        iterator begin() const;
        iterator end() const;

        iterator find(const ValueType&) const;
        bool contains(const ValueType&) const;






        template<typename T, typename HashTranslator> iterator find(const T&) const;
        template<typename T, typename HashTranslator> bool contains(const T&) const;



        pair<iterator, bool> add(const ValueType&);







        template<typename T, typename HashTranslator> pair<iterator, bool> add(const T&);

        void remove(const ValueType&);
        void remove(iterator);
        void clear();

    private:
        friend void deleteAllValues<>(const HashSet&);
        friend void fastDeleteAllValues<>(const HashSet&);

        HashTableType m_impl;
    };

    template<typename T> struct IdentityExtractor {
        static const T& extract(const T& t) { return t; }
    };

    template<typename ValueType, typename ValueTraits, typename T, typename Translator>
    struct HashSetTranslatorAdapter {
        static unsigned hash(const T& key) { return Translator::hash(key); }
        static bool equal(const ValueType& a, const T& b) { return Translator::equal(a, b); }
        static void translate(ValueType& location, const T& key, const T&, unsigned hashCode)
        {
            Translator::translate(location, key, hashCode);
        }
    };

    template<typename T, typename U, typename V>
    inline void HashSet<T, U, V>::swap(HashSet& other)
    {
        m_impl.swap(other.m_impl);
    }

    template<typename T, typename U, typename V>
    inline int HashSet<T, U, V>::size() const
    {
        return m_impl.size();
    }

    template<typename T, typename U, typename V>
    inline int HashSet<T, U, V>::capacity() const
    {
        return m_impl.capacity();
    }

    template<typename T, typename U, typename V>
    inline bool HashSet<T, U, V>::isEmpty() const
    {
        return m_impl.isEmpty();
    }

    template<typename T, typename U, typename V>
    inline typename HashSet<T, U, V>::iterator HashSet<T, U, V>::begin() const
    {
        return m_impl.begin();
    }

    template<typename T, typename U, typename V>
    inline typename HashSet<T, U, V>::iterator HashSet<T, U, V>::end() const
    {
        return m_impl.end();
    }

    template<typename T, typename U, typename V>
    inline typename HashSet<T, U, V>::iterator HashSet<T, U, V>::find(const ValueType& value) const
    {
        return m_impl.find(value);
    }

    template<typename T, typename U, typename V>
    inline bool HashSet<T, U, V>::contains(const ValueType& value) const
    {
        return m_impl.contains(value);
    }

    template<typename Value, typename HashFunctions, typename Traits>
    template<typename T, typename HashTranslator>
    typename HashSet<Value, HashFunctions, Traits>::iterator
    inline HashSet<Value, HashFunctions, Traits>::find(const T& value) const
    {
        typedef HashSetTranslatorAdapter<ValueType, ValueTraits, T, HashTranslator> Adapter;
        return m_impl.template find<T, Adapter>(value);
    }

    template<typename Value, typename HashFunctions, typename Traits>
    template<typename T, typename HashTranslator>
    inline bool HashSet<Value, HashFunctions, Traits>::contains(const T& value) const
    {
        typedef HashSetTranslatorAdapter<ValueType, ValueTraits, T, HashTranslator> Adapter;
        return m_impl.template contains<T, Adapter>(value);
    }

    template<typename T, typename U, typename V>
    inline pair<typename HashSet<T, U, V>::iterator, bool> HashSet<T, U, V>::add(const ValueType& value)
    {
        return m_impl.add(value);
    }

    template<typename Value, typename HashFunctions, typename Traits>
    template<typename T, typename HashTranslator>
    inline pair<typename HashSet<Value, HashFunctions, Traits>::iterator, bool>
    HashSet<Value, HashFunctions, Traits>::add(const T& value)
    {
        typedef HashSetTranslatorAdapter<ValueType, ValueTraits, T, HashTranslator> Adapter;
        return m_impl.template addPassingHashCode<T, T, Adapter>(value, value);
    }

    template<typename T, typename U, typename V>
    inline void HashSet<T, U, V>::remove(iterator it)
    {
        if (it.m_impl == m_impl.end())
            return;
        m_impl.internalCheckTableConsistency();
        m_impl.removeWithoutEntryConsistencyCheck(it.m_impl);
    }

    template<typename T, typename U, typename V>
    inline void HashSet<T, U, V>::remove(const ValueType& value)
    {
        remove(find(value));
    }

    template<typename T, typename U, typename V>
    inline void HashSet<T, U, V>::clear()
    {
        m_impl.clear();
    }

    template<typename ValueType, typename HashTableType>
    void deleteAllValues(HashTableType& collection)
    {
        typedef typename HashTableType::const_iterator iterator;
        iterator end = collection.end();
        for (iterator it = collection.begin(); it != end; ++it)
            delete *it;
    }

    template<typename T, typename U, typename V>
    inline void deleteAllValues(const HashSet<T, U, V>& collection)
    {
        deleteAllValues<typename HashSet<T, U, V>::ValueType>(collection.m_impl);
    }

    template<typename ValueType, typename HashTableType>
    void fastDeleteAllValues(HashTableType& collection)
    {
        typedef typename HashTableType::const_iterator iterator;
        iterator end = collection.end();
        for (iterator it = collection.begin(); it != end; ++it)
            fastDelete(*it);
    }

    template<typename T, typename U, typename V>
    inline void fastDeleteAllValues(const HashSet<T, U, V>& collection)
    {
        fastDeleteAllValues<typename HashSet<T, U, V>::ValueType>(collection.m_impl);
    }

    template<typename T, typename U, typename V, typename W>
    inline void copyToVector(const HashSet<T, U, V>& collection, W& vector)
    {
        typedef typename HashSet<T, U, V>::const_iterator iterator;

        vector.resize(collection.size());

        iterator it = collection.begin();
        iterator end = collection.end();
        for (unsigned i = 0; it != end; ++it, ++i)
            vector[i] = *it;
    }

}

using WTF::HashSet;
# 32 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/MarkedBlockSet.h" 2

namespace JSC {

class MarkedBlock;

class MarkedBlockSet {
public:
    void add(MarkedBlock*);
    void remove(MarkedBlock*);

    TinyBloomFilter filter() const;
    const HashSet<MarkedBlock*>& set() const;

private:
    void recomputeFilter();

    TinyBloomFilter m_filter;
    HashSet<MarkedBlock*> m_set;
};

inline void MarkedBlockSet::add(MarkedBlock* block)
{
    m_filter.add(reinterpret_cast<Bits>(block));
    m_set.add(block);
}

inline void MarkedBlockSet::remove(MarkedBlock* block)
{
    int oldCapacity = m_set.capacity();
    m_set.remove(block);
    if (m_set.capacity() != oldCapacity)
        recomputeFilter();
}

inline void MarkedBlockSet::recomputeFilter()
{
    TinyBloomFilter filter;
    for (HashSet<MarkedBlock*>::iterator it = m_set.begin(); it != m_set.end(); ++it)
        filter.add(reinterpret_cast<Bits>(*it));
    m_filter = filter;
}

inline TinyBloomFilter MarkedBlockSet::filter() const
{
    return m_filter;
}

inline const HashSet<MarkedBlock*>& MarkedBlockSet::set() const
{
    return m_set;
}

}
# 30 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/AllocationSpace.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/MarkedSpace.h" 1
# 25 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/MarkedSpace.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/MachineStackMarker.h" 1
# 29 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/MachineStackMarker.h"
namespace JSC {

    class Heap;
    class ConservativeRoots;

    class MachineThreads {
        private: MachineThreads(const MachineThreads&); MachineThreads& operator=(const MachineThreads&);
    public:
        MachineThreads(Heap*);
        ~MachineThreads();

        void gatherConservativeRoots(ConservativeRoots&, void* stackCurrent);

        void makeUsableFromMultipleThreads();
        void addCurrentThread();

    private:
        void gatherFromCurrentThread(ConservativeRoots&, void* stackCurrent);

        class Thread;

        static void removeThread(void*);
        void removeCurrentThread();

        void gatherFromOtherThread(ConservativeRoots&, Thread*);

        Heap* m_heap;
        Mutex m_registeredThreadsMutex;
        Thread* m_registeredThreads;
        pthread_key_t m_threadSpecific;
    };

}
# 26 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/MarkedSpace.h" 2
# 37 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/MarkedSpace.h"
namespace JSC {

class Heap;
class JSCell;
class LiveObjectIterator;
class WeakGCHandle;
class SlotVisitor;

class MarkedSpace {
    private: MarkedSpace(const MarkedSpace&); MarkedSpace& operator=(const MarkedSpace&);
public:
    static const size_t maxCellSize = 2048;

    struct SizeClass {
        SizeClass();
        void resetAllocator();
        void zapFreeList();

        MarkedBlock::FreeCell* firstFreeCell;
        MarkedBlock* currentBlock;
        DoublyLinkedList<MarkedBlock> blockList;
        size_t cellSize;
    };

    MarkedSpace(Heap*);

    SizeClass& sizeClassFor(size_t);
    void* allocate(SizeClass&);

    void resetAllocator();

    void addBlock(SizeClass&, MarkedBlock*);
    void removeBlock(MarkedBlock*);

    void canonicalizeCellLivenessData();

    size_t waterMark();
    size_t highWaterMark();
    size_t nurseryWaterMark();
    void setHighWaterMark(size_t);

    template<typename Functor> typename Functor::ReturnType forEachBlock(Functor&);
    template<typename Functor> typename Functor::ReturnType forEachBlock();

private:

    static const size_t preciseStep = MarkedBlock::atomSize;
    static const size_t preciseCutoff = 256;
    static const size_t preciseCount = preciseCutoff / preciseStep;


    static const size_t impreciseStep = preciseCutoff;
    static const size_t impreciseCutoff = maxCellSize;
    static const size_t impreciseCount = impreciseCutoff / impreciseStep;

    FixedArray<SizeClass, preciseCount> m_preciseSizeClasses;
    FixedArray<SizeClass, impreciseCount> m_impreciseSizeClasses;
    size_t m_waterMark;
    size_t m_nurseryWaterMark;
    size_t m_highWaterMark;
    Heap* m_heap;
};

inline size_t MarkedSpace::waterMark()
{
    return m_waterMark;
}

inline size_t MarkedSpace::highWaterMark()
{
    return m_highWaterMark;
}

inline size_t MarkedSpace::nurseryWaterMark()
{
    return m_nurseryWaterMark;
}

inline void MarkedSpace::setHighWaterMark(size_t highWaterMark)
{
    m_highWaterMark = highWaterMark;
}

inline MarkedSpace::SizeClass& MarkedSpace::sizeClassFor(size_t bytes)
{
    ((void)0);
    if (bytes <= preciseCutoff)
        return m_preciseSizeClasses[(bytes - 1) / preciseStep];
    return m_impreciseSizeClasses[(bytes - 1) / impreciseStep];
}

inline void* MarkedSpace::allocate(SizeClass& sizeClass)
{
    MarkedBlock::FreeCell* firstFreeCell = sizeClass.firstFreeCell;
    if (!firstFreeCell) {
        for (MarkedBlock*& block = sizeClass.currentBlock; block; block = block->next()) {
            firstFreeCell = block->sweep(MarkedBlock::SweepToFreeList);
            if (firstFreeCell)
                break;
            m_nurseryWaterMark += block->capacity() - block->size();
            m_waterMark += block->capacity();
            block->didConsumeFreeList();
        }

        if (!firstFreeCell)
            return 0;
    }

    ((void)0);

    sizeClass.firstFreeCell = firstFreeCell->next;
    return firstFreeCell;
}

template <typename Functor> inline typename Functor::ReturnType MarkedSpace::forEachBlock(Functor& functor)
{
    for (size_t i = 0; i < preciseCount; ++i) {
        SizeClass& sizeClass = m_preciseSizeClasses[i];
        MarkedBlock* next;
        for (MarkedBlock* block = sizeClass.blockList.head(); block; block = next) {
            next = block->next();
            functor(block);
        }
    }

    for (size_t i = 0; i < impreciseCount; ++i) {
        SizeClass& sizeClass = m_impreciseSizeClasses[i];
        MarkedBlock* next;
        for (MarkedBlock* block = sizeClass.blockList.head(); block; block = next) {
            next = block->next();
            functor(block);
        }
    }

    return functor.returnValue();
}

template <typename Functor> inline typename Functor::ReturnType MarkedSpace::forEachBlock()
{
    Functor functor;
    return forEachBlock(functor);
}

inline MarkedSpace::SizeClass::SizeClass()
    : firstFreeCell(0)
    , currentBlock(0)
    , cellSize(0)
{
}

inline void MarkedSpace::SizeClass::resetAllocator()
{
    currentBlock = blockList.head();
}

inline void MarkedSpace::SizeClass::zapFreeList()
{
    if (!currentBlock) {
        ((void)0);
        return;
    }

    currentBlock->zapFreeList(firstFreeCell);
    firstFreeCell = 0;
}

}
# 31 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/AllocationSpace.h" 2



namespace JSC {

class Heap;
class MarkedBlock;

class AllocationSpace {
public:
    AllocationSpace(Heap* heap)
        : m_heap(heap)
        , m_markedSpace(heap)
    {
    }

    typedef HashSet<MarkedBlock*>::iterator BlockIterator;

    MarkedBlockSet& blocks() { return m_blocks; }
    MarkedSpace::SizeClass& sizeClassFor(size_t bytes) { return m_markedSpace.sizeClassFor(bytes); }
    void setHighWaterMark(size_t bytes) { m_markedSpace.setHighWaterMark(bytes); }
    size_t highWaterMark() { return m_markedSpace.highWaterMark(); }





    template<typename Functor> typename Functor::ReturnType forEachCell(Functor&);
    template<typename Functor> typename Functor::ReturnType forEachCell();
    template<typename Functor> typename Functor::ReturnType forEachBlock(Functor&);
    template<typename Functor> typename Functor::ReturnType forEachBlock();

    void canonicalizeCellLivenessData() { m_markedSpace.canonicalizeCellLivenessData(); }
    void resetAllocator() { m_markedSpace.resetAllocator(); }

    void* allocate(size_t);
    void freeBlocks(MarkedBlock*);
    void shrink();

private:
    enum AllocationEffort { AllocationMustSucceed, AllocationCanFail };

    void* allocate(MarkedSpace::SizeClass&);
    void* tryAllocate(MarkedSpace::SizeClass&);
    void* allocateSlowCase(MarkedSpace::SizeClass&);
    MarkedBlock* allocateBlock(size_t cellSize, AllocationEffort);

    Heap* m_heap;
    MarkedSpace m_markedSpace;
    MarkedBlockSet m_blocks;
};

template<typename Functor> inline typename Functor::ReturnType AllocationSpace::forEachCell(Functor& functor)
{
    canonicalizeCellLivenessData();

    BlockIterator end = m_blocks.set().end();
    for (BlockIterator it = m_blocks.set().begin(); it != end; ++it)
        (*it)->forEachCell(functor);
    return functor.returnValue();
}

template<typename Functor> inline typename Functor::ReturnType AllocationSpace::forEachCell()
{
    Functor functor;
    return forEachCell(functor);
}

template<typename Functor> inline typename Functor::ReturnType AllocationSpace::forEachBlock(Functor& functor)
{
    BlockIterator end = m_blocks.set().end();
    for (BlockIterator it = m_blocks.set().begin(); it != end; ++it)
        functor(*it);
    return functor.returnValue();
}

template<typename Functor> inline typename Functor::ReturnType AllocationSpace::forEachBlock()
{
    Functor functor;
    return forEachBlock(functor);
}

inline void* AllocationSpace::allocate(MarkedSpace::SizeClass& sizeClass)
{

    MarkedBlock::FreeCell* firstFreeCell = sizeClass.firstFreeCell;
    if (__builtin_expect((!firstFreeCell), 0))
        return allocateSlowCase(sizeClass);

    sizeClass.firstFreeCell = firstFreeCell->next;
    return firstFreeCell;
}

inline void* AllocationSpace::allocate(size_t bytes)
{
    MarkedSpace::SizeClass& sizeClass = sizeClassFor(bytes);
    return allocate(sizeClass);
}

}
# 26 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/Heap.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/HandleHeap.h" 1
# 29 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/HandleHeap.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/wtf/BlockStack.h" 1
# 33 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/wtf/BlockStack.h"
namespace WTF {

template <typename T> class BlockStack {
public:
    static const size_t blockSize = 4096;
    static const size_t blockLength = blockSize / sizeof(T);

    BlockStack();
    ~BlockStack();

    T* grow();
    void shrink(T*);

    const Vector<T*>& blocks();

private:
    Vector<T*> m_blocks;
    T* m_spareBlock;
};

template <typename T> BlockStack<T>::BlockStack()
    : m_spareBlock(0)
{
}

template <typename T> BlockStack<T>::~BlockStack()
{
    if (m_spareBlock)
        fastFree(m_spareBlock);
    for (size_t i = 0; i < m_blocks.size(); ++i)
        fastFree(m_blocks[i]);
}

template <typename T> inline const Vector<T*>& BlockStack<T>::blocks()
{
    return m_blocks;
}

template <typename T> T* BlockStack<T>::grow()
{
    T* block = m_spareBlock ? m_spareBlock : static_cast<T*>(fastMalloc(blockSize));
    m_spareBlock = 0;

    m_blocks.append(block);
    return block;
}

template <typename T> void BlockStack<T>::shrink(T* newEnd)
{
    ((void)0);
    m_spareBlock = m_blocks.last();
    m_blocks.removeLast();

    while (m_blocks.last() + blockLength != newEnd) {
        fastFree(m_blocks.last());
        m_blocks.removeLast();
    }
}

}

using WTF::BlockStack;
# 30 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/HandleHeap.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/Handle.h" 1
# 29 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/Handle.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/HandleTypes.h" 1
# 31 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/HandleTypes.h"
namespace JSC {

typedef enum { } Unknown;
typedef JSValue* HandleSlot;

template<typename T> struct HandleTypes {
    typedef T* ExternalType;
    static ExternalType getFromSlot(HandleSlot slot) { return (slot && *slot) ? reinterpret_cast<ExternalType>(slot->asCell()) : 0; }
    static JSValue toJSValue(T* cell) { return reinterpret_cast<JSCell*>(cell); }
    template<typename U> static void validateUpcast() { T* temp; temp = (U*)0; }
};

template<> struct HandleTypes<Unknown> {
    typedef JSValue ExternalType;
    static ExternalType getFromSlot(HandleSlot slot) { return slot ? *slot : JSValue(); }
    static JSValue toJSValue(const JSValue& v) { return v; }
    template<typename U> static void validateUpcast() { }
};

}
# 30 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/Handle.h" 2

namespace JSC {
# 41 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/Handle.h"
template <class T> class Handle;


template <> class Handle<JSValue>;


template<typename KeyType, typename MappedType, typename FinalizerCallback, typename HashArg, typename KeyTraitsArg> class WeakGCMap;

class HandleBase {
    template <typename T> friend class Weak;
    friend class HandleHeap;
    friend struct JSCallbackObjectData;
    template <typename KeyType, typename MappedType, typename FinalizerCallback, typename HashArg, typename KeyTraitsArg> friend class WeakGCMap;

public:
    bool operator!() const { return !m_slot || !*m_slot; }


    typedef JSValue (HandleBase::*UnspecifiedBoolType);
    operator UnspecifiedBoolType*() const { return (m_slot && *m_slot) ? reinterpret_cast<UnspecifiedBoolType*>(1) : 0; }

protected:
    HandleBase(HandleSlot slot)
        : m_slot(slot)
    {
    }

    void swap(HandleBase& other) { std::swap(m_slot, other.m_slot); }

    HandleSlot slot() const { return m_slot; }
    void setSlot(HandleSlot slot)
    {
        m_slot = slot;
    }

private:
    HandleSlot m_slot;
};

template <typename Base, typename T> struct HandleConverter {
    T* operator->()
    {
        return static_cast<Base*>(this)->get();
    }
    const T* operator->() const
    {
        return static_cast<const Base*>(this)->get();
    }

    T* operator*()
    {
        return static_cast<Base*>(this)->get();
    }
    const T* operator*() const
    {
        return static_cast<const Base*>(this)->get();
    }
};

template <typename Base> struct HandleConverter<Base, Unknown> {
    Handle<JSObject> asObject() const;
    bool isObject() const { return jsValue().isObject(); }
    bool getNumber(double number) const { return jsValue().getNumber(number); }
    UString getString(ExecState*) const;
    bool isUndefinedOrNull() const { return jsValue().isUndefinedOrNull(); }

private:
    JSValue jsValue() const
    {
        return static_cast<const Base*>(this)->get();
    }
};

template <typename T> class Handle : public HandleBase, public HandleConverter<Handle<T>, T> {
public:
    template <typename A, typename B> friend class HandleConverter;
    typedef typename HandleTypes<T>::ExternalType ExternalType;
    template <typename U> Handle(Handle<U> o)
    {
        typename HandleTypes<T>::template validateUpcast<U>();
        setSlot(o.slot());
    }

    void swap(Handle& other) { HandleBase::swap(other); }

    ExternalType get() const { return HandleTypes<T>::getFromSlot(this->slot()); }

protected:
    Handle(HandleSlot slot = 0)
        : HandleBase(slot)
    {
    }

private:
    friend class HandleHeap;

    static Handle<T> wrapSlot(HandleSlot slot)
    {
        return Handle<T>(slot);
    }
};

template <typename Base> Handle<JSObject> HandleConverter<Base, Unknown>::asObject() const
{
    return Handle<JSObject>::wrapSlot(static_cast<const Base*>(this)->slot());
}

template <typename T, typename U> inline bool operator==(const Handle<T>& a, const Handle<U>& b)
{
    return a.get() == b.get();
}

template <typename T, typename U> inline bool operator==(const Handle<T>& a, U* b)
{
    return a.get() == b;
}

template <typename T, typename U> inline bool operator==(T* a, const Handle<U>& b)
{
    return a == b.get();
}

template <typename T, typename U> inline bool operator!=(const Handle<T>& a, const Handle<U>& b)
{
    return a.get() != b.get();
}

template <typename T, typename U> inline bool operator!=(const Handle<T>& a, U* b)
{
    return a.get() != b;
}

template <typename T, typename U> inline bool operator!=(T* a, const Handle<U>& b)
{
    return a != b.get();
}

template <typename T, typename U> inline bool operator!=(const Handle<T>& a, JSValue b)
{
    return a.get() != b;
}

template <typename T, typename U> inline bool operator!=(JSValue a, const Handle<U>& b)
{
    return a != b.get();
}

}
# 31 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/HandleHeap.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/wtf/HashCountedSet.h" 1
# 28 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/wtf/HashCountedSet.h"
namespace WTF {

    template<typename Value, typename HashFunctions = typename DefaultHash<Value>::Hash,
        typename Traits = HashTraits<Value> > class HashCountedSet {
        public: void* operator new(size_t, void* p) { return p; } void* operator new[](size_t, void* p) { return p; } void* operator new(size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNew); return p; } void operator delete(void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNew); ::WTF::fastFree(p); } void* operator new[](size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNewArray); return p; } void operator delete[](void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNewArray); ::WTF::fastFree(p); } private: typedef int ThisIsHereToForceASemicolonAfterThisMacro;
    private:
        typedef HashMap<Value, unsigned, HashFunctions, Traits> ImplType;
    public:
        typedef Value ValueType;
        typedef typename ImplType::iterator iterator;
        typedef typename ImplType::const_iterator const_iterator;

        HashCountedSet() {}

        int size() const;
        int capacity() const;
        bool isEmpty() const;


        iterator begin();
        iterator end();
        const_iterator begin() const;
        const_iterator end() const;

        iterator find(const ValueType&);
        const_iterator find(const ValueType&) const;
        bool contains(const ValueType&) const;
        unsigned count(const ValueType&) const;




        std::pair<iterator, bool> add(const ValueType&);



        bool remove(const ValueType&);
        bool remove(iterator);


        void removeAll(iterator);
        void removeAll(const ValueType&);


        void clear();

    private:
        ImplType m_impl;
    };

    template<typename Value, typename HashFunctions, typename Traits>
    inline int HashCountedSet<Value, HashFunctions, Traits>::size() const
    {
        return m_impl.size();
    }

    template<typename Value, typename HashFunctions, typename Traits>
    inline int HashCountedSet<Value, HashFunctions, Traits>::capacity() const
    {
        return m_impl.capacity();
    }

    template<typename Value, typename HashFunctions, typename Traits>
    inline bool HashCountedSet<Value, HashFunctions, Traits>::isEmpty() const
    {
        return size() == 0;
    }

    template<typename Value, typename HashFunctions, typename Traits>
    inline typename HashCountedSet<Value, HashFunctions, Traits>::iterator HashCountedSet<Value, HashFunctions, Traits>::begin()
    {
        return m_impl.begin();
    }

    template<typename Value, typename HashFunctions, typename Traits>
    inline typename HashCountedSet<Value, HashFunctions, Traits>::iterator HashCountedSet<Value, HashFunctions, Traits>::end()
    {
        return m_impl.end();
    }

    template<typename Value, typename HashFunctions, typename Traits>
    inline typename HashCountedSet<Value, HashFunctions, Traits>::const_iterator HashCountedSet<Value, HashFunctions, Traits>::begin() const
    {
        return m_impl.begin();
    }

    template<typename Value, typename HashFunctions, typename Traits>
    inline typename HashCountedSet<Value, HashFunctions, Traits>::const_iterator HashCountedSet<Value, HashFunctions, Traits>::end() const
    {
        return m_impl.end();
    }

    template<typename Value, typename HashFunctions, typename Traits>
    inline typename HashCountedSet<Value, HashFunctions, Traits>::iterator HashCountedSet<Value, HashFunctions, Traits>::find(const ValueType& value)
    {
        return m_impl.find(value);
    }

    template<typename Value, typename HashFunctions, typename Traits>
    inline typename HashCountedSet<Value, HashFunctions, Traits>::const_iterator HashCountedSet<Value, HashFunctions, Traits>::find(const ValueType& value) const
    {
        return m_impl.find(value);
    }

    template<typename Value, typename HashFunctions, typename Traits>
    inline bool HashCountedSet<Value, HashFunctions, Traits>::contains(const ValueType& value) const
    {
        return m_impl.contains(value);
    }

    template<typename Value, typename HashFunctions, typename Traits>
    inline unsigned HashCountedSet<Value, HashFunctions, Traits>::count(const ValueType& value) const
    {
        return m_impl.get(value);
    }

    template<typename Value, typename HashFunctions, typename Traits>
    inline std::pair<typename HashCountedSet<Value, HashFunctions, Traits>::iterator, bool> HashCountedSet<Value, HashFunctions, Traits>::add(const ValueType &value)
    {
        pair<iterator, bool> result = m_impl.add(value, 0);
        ++result.first->second;
        return result;
    }

    template<typename Value, typename HashFunctions, typename Traits>
    inline bool HashCountedSet<Value, HashFunctions, Traits>::remove(const ValueType& value)
    {
        return remove(find(value));
    }

    template<typename Value, typename HashFunctions, typename Traits>
    inline bool HashCountedSet<Value, HashFunctions, Traits>::remove(iterator it)
    {
        if (it == end())
            return false;

        unsigned oldVal = it->second;
        ((void)0);
        unsigned newVal = oldVal - 1;
        if (newVal) {
            it->second = newVal;
            return false;
        }

        m_impl.remove(it);
        return true;
    }

    template<typename Value, typename HashFunctions, typename Traits>
    inline void HashCountedSet<Value, HashFunctions, Traits>::removeAll(const ValueType& value)
    {
        removeAll(find(value));
    }

    template<typename Value, typename HashFunctions, typename Traits>
    inline void HashCountedSet<Value, HashFunctions, Traits>::removeAll(iterator it)
    {
        if (it == end())
            return;

        m_impl.remove(it);
    }

    template<typename Value, typename HashFunctions, typename Traits>
    inline void HashCountedSet<Value, HashFunctions, Traits>::clear()
    {
        m_impl.clear();
    }

    template<typename Value, typename HashFunctions, typename Traits, typename VectorType>
    inline void copyToVector(const HashCountedSet<Value, HashFunctions, Traits>& collection, VectorType& vector)
    {
        typedef typename HashCountedSet<Value, HashFunctions, Traits>::const_iterator iterator;

        vector.resize(collection.size());

        iterator it = collection.begin();
        iterator end = collection.end();
        for (unsigned i = 0; it != end; ++it, ++i)
            vector[i] = *it;
    }

    template<typename Value, typename HashFunctions, typename Traits>
    inline void copyToVector(const HashCountedSet<Value, HashFunctions, Traits>& collection, Vector<Value>& vector)
    {
        typedef typename HashCountedSet<Value, HashFunctions, Traits>::const_iterator iterator;

        vector.resize(collection.size());

        iterator it = collection.begin();
        iterator end = collection.end();
        for (unsigned i = 0; it != end; ++it, ++i)
            vector[i] = (*it).first;
    }


}

using WTF::HashCountedSet;
# 32 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/HandleHeap.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/wtf/SentinelLinkedList.h" 1
# 40 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/wtf/SentinelLinkedList.h"
namespace WTF {

enum SentinelTag { Sentinel };

template<typename T>
class BasicRawSentinelNode {
public:
    BasicRawSentinelNode(SentinelTag)
        : m_next(0)
        , m_prev(0)
    {
    }

    BasicRawSentinelNode()
        : m_next(0)
        , m_prev(0)
    {
    }

    void setPrev(BasicRawSentinelNode* prev) { m_prev = prev; }
    void setNext(BasicRawSentinelNode* next) { m_next = next; }

    T* prev() { return static_cast<T*>(m_prev); }
    T* next() { return static_cast<T*>(m_next); }

    bool isOnList() const
    {
        ((void)0);
        return !!m_prev;
    }

    void remove();

private:
    BasicRawSentinelNode* m_next;
    BasicRawSentinelNode* m_prev;
};

template <typename T, typename RawNode = T> class SentinelLinkedList {
public:
    typedef T* iterator;

    SentinelLinkedList();

    void push(T*);
    static void remove(T*);

    iterator begin();
    iterator end();

private:
    RawNode m_headSentinel;
    RawNode m_tailSentinel;
};

template <typename T> void BasicRawSentinelNode<T>::remove()
{
    SentinelLinkedList<T, BasicRawSentinelNode<T> >::remove(static_cast<T*>(this));
}

template <typename T, typename RawNode> inline SentinelLinkedList<T, RawNode>::SentinelLinkedList()
    : m_headSentinel(Sentinel)
    , m_tailSentinel(Sentinel)
{
    m_headSentinel.setNext(&m_tailSentinel);
    m_headSentinel.setPrev(0);

    m_tailSentinel.setPrev(&m_headSentinel);
    m_tailSentinel.setNext(0);
}

template <typename T, typename RawNode> inline typename SentinelLinkedList<T, RawNode>::iterator SentinelLinkedList<T, RawNode>::begin()
{
    return static_cast<T*>(m_headSentinel.next());
}

template <typename T, typename RawNode> inline typename SentinelLinkedList<T, RawNode>::iterator SentinelLinkedList<T, RawNode>::end()
{
    return static_cast<T*>(&m_tailSentinel);
}

template <typename T, typename RawNode> inline void SentinelLinkedList<T, RawNode>::push(T* node)
{
    ((void)0);
    ((void)0);
    ((void)0);

    RawNode* prev = &m_headSentinel;
    RawNode* next = m_headSentinel.next();

    node->setPrev(prev);
    node->setNext(next);

    prev->setNext(node);
    next->setPrev(node);
}

template <typename T, typename RawNode> inline void SentinelLinkedList<T, RawNode>::remove(T* node)
{
    ((void)0);
    ((void)0);
    ((void)0);

    RawNode* prev = node->prev();
    RawNode* next = node->next();

    prev->setNext(next);
    next->setPrev(prev);

    node->setPrev(0);
    node->setNext(0);
}

}

using WTF::BasicRawSentinelNode;
using WTF::SentinelLinkedList;
# 33 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/HandleHeap.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/wtf/SinglyLinkedList.h" 1
# 29 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/wtf/SinglyLinkedList.h"
namespace WTF {

template <typename Node> class SinglyLinkedList {
public:
    SinglyLinkedList();

    bool isEmpty();

    void push(Node*);
    Node* pop();

private:
    Node* m_head;
};

template <typename Node> inline SinglyLinkedList<Node>::SinglyLinkedList()
    : m_head(0)
{
}

template <typename Node> inline bool SinglyLinkedList<Node>::isEmpty()
{
    return !m_head;
}

template <typename Node> inline void SinglyLinkedList<Node>::push(Node* node)
{
    ((void)0);
    node->setNext(m_head);
    m_head = node;
}

template <typename Node> inline Node* SinglyLinkedList<Node>::pop()
{
    Node* tmp = m_head;
    m_head = m_head->next();
    return tmp;
}

}

using WTF::SinglyLinkedList;
# 34 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/HandleHeap.h" 2

namespace JSC {

class HandleHeap;
class HeapRootVisitor;
class JSGlobalData;
class JSValue;
class SlotVisitor;

class WeakHandleOwner {
public:
    virtual ~WeakHandleOwner();
    virtual bool isReachableFromOpaqueRoots(Handle<Unknown>, void* context, SlotVisitor&);
    virtual void finalize(Handle<Unknown>, void* context);
};

class HandleHeap {
public:
    static HandleHeap* heapFor(HandleSlot);

    HandleHeap(JSGlobalData*);

    JSGlobalData* globalData();

    HandleSlot allocate();
    void deallocate(HandleSlot);

    void makeWeak(HandleSlot, WeakHandleOwner* = 0, void* context = 0);
    HandleSlot copyWeak(HandleSlot);

    void visitStrongHandles(HeapRootVisitor&);
    void visitWeakHandles(HeapRootVisitor&);
    void finalizeWeakHandles();

    void writeBarrier(HandleSlot, const JSValue&);






    unsigned protectedGlobalObjectCount();

    template<typename Functor> void forEachStrongHandle(Functor&, const HashCountedSet<JSCell*>& skipSet);

private:
    class Node {
    public:
        Node(WTF::SentinelTag);
        Node(HandleHeap*);

        HandleSlot slot();
        HandleHeap* handleHeap();

        void makeWeak(WeakHandleOwner*, void* context);
        bool isWeak();

        WeakHandleOwner* weakOwner();
        void* weakOwnerContext();

        void setPrev(Node*);
        Node* prev();

        void setNext(Node*);
        Node* next();

    private:
        WeakHandleOwner* emptyWeakOwner();

        JSValue m_value;
        HandleHeap* m_handleHeap;
        WeakHandleOwner* m_weakOwner;
        void* m_weakOwnerContext;
        Node* m_prev;
        Node* m_next;
    };

    static HandleSlot toHandle(Node*);
    static Node* toNode(HandleSlot);

    void grow();






    JSGlobalData* m_globalData;
    BlockStack<Node> m_blockStack;

    SentinelLinkedList<Node> m_strongList;
    SentinelLinkedList<Node> m_weakList;
    SentinelLinkedList<Node> m_immediateList;
    SinglyLinkedList<Node> m_freeList;
    Node* m_nextToFinalize;
};

inline HandleHeap* HandleHeap::heapFor(HandleSlot handle)
{
    return toNode(handle)->handleHeap();
}

inline JSGlobalData* HandleHeap::globalData()
{
    return m_globalData;
}

inline HandleSlot HandleHeap::toHandle(Node* node)
{
    return reinterpret_cast<HandleSlot>(node);
}

inline HandleHeap::Node* HandleHeap::toNode(HandleSlot handle)
{
    return reinterpret_cast<Node*>(handle);
}

inline HandleSlot HandleHeap::allocate()
{


    if (m_nextToFinalize)
        do { WTFReportBacktrace(); *(int *)(uintptr_t)0xbbadbeef = 0; __builtin_trap(); } while (false);
    if (m_freeList.isEmpty())
        grow();

    Node* node = m_freeList.pop();
    new (node) Node(this);
    m_immediateList.push(node);
    return toHandle(node);
}

inline void HandleHeap::deallocate(HandleSlot handle)
{
    Node* node = toNode(handle);
    if (node == m_nextToFinalize) {
        ((void)0);
        m_nextToFinalize = m_nextToFinalize->next();
    }

    SentinelLinkedList<Node>::remove(node);
    m_freeList.push(node);
}

inline HandleSlot HandleHeap::copyWeak(HandleSlot other)
{
    Node* node = toNode(allocate());
    node->makeWeak(toNode(other)->weakOwner(), toNode(other)->weakOwnerContext());
    writeBarrier(node->slot(), *other);
    *node->slot() = *other;
    return toHandle(node);
}

inline void HandleHeap::makeWeak(HandleSlot handle, WeakHandleOwner* weakOwner, void* context)
{


    if (m_nextToFinalize)
        do { WTFReportBacktrace(); *(int *)(uintptr_t)0xbbadbeef = 0; __builtin_trap(); } while (false);
    Node* node = toNode(handle);
    node->makeWeak(weakOwner, context);

    SentinelLinkedList<Node>::remove(node);
    if (!*handle || !handle->isCell()) {
        m_immediateList.push(node);
        return;
    }

    m_weakList.push(node);
}
# 217 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/HandleHeap.h"
inline HandleHeap::Node::Node(HandleHeap* handleHeap)
    : m_handleHeap(handleHeap)
    , m_weakOwner(0)
    , m_weakOwnerContext(0)
    , m_prev(0)
    , m_next(0)
{
}

inline HandleHeap::Node::Node(WTF::SentinelTag)
    : m_handleHeap(0)
    , m_weakOwner(0)
    , m_weakOwnerContext(0)
    , m_prev(0)
    , m_next(0)
{
}

inline HandleSlot HandleHeap::Node::slot()
{
    return &m_value;
}

inline HandleHeap* HandleHeap::Node::handleHeap()
{
    return m_handleHeap;
}

inline void HandleHeap::Node::makeWeak(WeakHandleOwner* weakOwner, void* context)
{
    m_weakOwner = weakOwner ? weakOwner : emptyWeakOwner();
    m_weakOwnerContext = context;
}

inline bool HandleHeap::Node::isWeak()
{
    return m_weakOwner;
}

inline WeakHandleOwner* HandleHeap::Node::weakOwner()
{
    return m_weakOwner == emptyWeakOwner() ? 0 : m_weakOwner;
}

inline void* HandleHeap::Node::weakOwnerContext()
{
    ((void)0);
    return m_weakOwnerContext;
}

inline void HandleHeap::Node::setPrev(Node* prev)
{
    m_prev = prev;
}

inline HandleHeap::Node* HandleHeap::Node::prev()
{
    return m_prev;
}

inline void HandleHeap::Node::setNext(Node* next)
{
    m_next = next;
}

inline HandleHeap::Node* HandleHeap::Node::next()
{
    return m_next;
}



inline WeakHandleOwner* HandleHeap::Node::emptyWeakOwner()
{
    return reinterpret_cast<WeakHandleOwner*>(-1);
}

template<typename Functor> void HandleHeap::forEachStrongHandle(Functor& functor, const HashCountedSet<JSCell*>& skipSet)
{
    Node* end = m_strongList.end();
    for (Node* node = m_strongList.begin(); node != end; node = node->next()) {
        JSValue value = *node->slot();
        if (!value || !value.isCell())
            continue;
        if (skipSet.contains(value.asCell()))
            continue;
        functor(value.asCell());
    }
}

}
# 27 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/Heap.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/HandleStack.h" 1
# 35 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/HandleStack.h"
namespace JSC {

class LocalScope;
class HeapRootVisitor;

class HandleStack {
public:
    class Frame {
    public:
        HandleSlot m_next;
        HandleSlot m_end;
    };

    HandleStack();

    void enterScope(Frame&);
    void leaveScope(Frame&);

    HandleSlot push();

    void visit(HeapRootVisitor&);

private:
    void grow();
    void zapTo(Frame&);
    HandleSlot findFirstAfter(HandleSlot);




    BlockStack<JSValue> m_blockStack;
    Frame m_frame;
};

inline void HandleStack::enterScope(Frame& lastFrame)
{




    lastFrame = m_frame;
}



inline void HandleStack::zapTo(Frame& lastFrame)
{

    (void)lastFrame;
# 103 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/HandleStack.h"
}

inline void HandleStack::leaveScope(Frame& lastFrame)
{




    zapTo(lastFrame);

    if (lastFrame.m_end != m_frame.m_end)
        m_blockStack.shrink(lastFrame.m_end);

    m_frame = lastFrame;
}

inline HandleSlot HandleStack::push()
{
    ((void)0);
    if (m_frame.m_next == m_frame.m_end)
        grow();
    return m_frame.m_next++;
}

}
# 28 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/Heap.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/JettisonedCodeBlocks.h" 1
# 31 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/JettisonedCodeBlocks.h"
# 1 "./wtf/PassOwnPtr.h" 1
# 34 "./wtf/PassOwnPtr.h"
namespace WTF {



    template<typename T> class OwnPtr;
    template<typename T> class PassOwnPtr;
    template<typename T> PassOwnPtr<T> adoptPtr(T*);

    template<typename T> class PassOwnPtr {
    public:
        typedef typename RemovePointer<T>::Type ValueType;
        typedef ValueType* PtrType;

        PassOwnPtr() : m_ptr(0) { }
        PassOwnPtr(std::nullptr_t) : m_ptr(0) { }




        PassOwnPtr(const PassOwnPtr& o) : m_ptr(o.leakPtr()) { }
        template<typename U> PassOwnPtr(const PassOwnPtr<U>& o) : m_ptr(o.leakPtr()) { }

        ~PassOwnPtr() { deleteOwnedPtr(m_ptr); }

        PtrType get() const { return m_ptr; }

        PtrType leakPtr() const __attribute__ ((warn_unused_result));

        ValueType& operator*() const { ((void)0); return *m_ptr; }
        PtrType operator->() const { ((void)0); return m_ptr; }

        bool operator!() const { return !m_ptr; }


        typedef PtrType PassOwnPtr::*UnspecifiedBoolType;
        operator UnspecifiedBoolType() const { return m_ptr ? &PassOwnPtr::m_ptr : 0; }

        PassOwnPtr& operator=(const PassOwnPtr&) { typedef int dummyPassOwnPtr_should_never_be_assigned_to [(!sizeof(T*)) ? 1 : -1]; return *this; }

        template<typename U> friend PassOwnPtr<U> adoptPtr(U*);

    private:
        explicit PassOwnPtr(PtrType ptr) : m_ptr(ptr) { }



        template<typename U> bool operator==(const PassOwnPtr<U>&) { typedef int dummyOwnPtrs_should_never_be_equal [(!sizeof(U*)) ? 1 : -1]; return false; }
        template<typename U> bool operator!=(const PassOwnPtr<U>&) { typedef int dummyOwnPtrs_should_never_be_equal [(!sizeof(U*)) ? 1 : -1]; return false; }
        template<typename U> bool operator==(const OwnPtr<U>&) { typedef int dummyOwnPtrs_should_never_be_equal [(!sizeof(U*)) ? 1 : -1]; return false; }
        template<typename U> bool operator!=(const OwnPtr<U>&) { typedef int dummyOwnPtrs_should_never_be_equal [(!sizeof(U*)) ? 1 : -1]; return false; }

        mutable PtrType m_ptr;
    };

    template<typename T> inline typename PassOwnPtr<T>::PtrType PassOwnPtr<T>::leakPtr() const
    {
        PtrType ptr = m_ptr;
        m_ptr = 0;
        return ptr;
    }

    template<typename T, typename U> inline bool operator==(const PassOwnPtr<T>& a, const PassOwnPtr<U>& b)
    {
        return a.get() == b.get();
    }

    template<typename T, typename U> inline bool operator==(const PassOwnPtr<T>& a, const OwnPtr<U>& b)
    {
        return a.get() == b.get();
    }

    template<typename T, typename U> inline bool operator==(const OwnPtr<T>& a, const PassOwnPtr<U>& b)
    {
        return a.get() == b.get();
    }

    template<typename T, typename U> inline bool operator==(const PassOwnPtr<T>& a, U* b)
    {
        return a.get() == b;
    }

    template<typename T, typename U> inline bool operator==(T* a, const PassOwnPtr<U>& b)
    {
        return a == b.get();
    }

    template<typename T, typename U> inline bool operator!=(const PassOwnPtr<T>& a, const PassOwnPtr<U>& b)
    {
        return a.get() != b.get();
    }

    template<typename T, typename U> inline bool operator!=(const PassOwnPtr<T>& a, const OwnPtr<U>& b)
    {
        return a.get() != b.get();
    }

    template<typename T, typename U> inline bool operator!=(const OwnPtr<T>& a, const PassOwnPtr<U>& b)
    {
        return a.get() != b.get();
    }

    template<typename T, typename U> inline bool operator!=(const PassOwnPtr<T>& a, U* b)
    {
        return a.get() != b;
    }

    template<typename T, typename U> inline bool operator!=(T* a, const PassOwnPtr<U>& b)
    {
        return a != b.get();
    }

    template<typename T> inline PassOwnPtr<T> adoptPtr(T* ptr)
    {
        return PassOwnPtr<T>(ptr);
    }

    template<typename T, typename U> inline PassOwnPtr<T> static_pointer_cast(const PassOwnPtr<U>& p)
    {
        return adoptPtr(static_cast<T*>(p.leakPtr()));
    }

    template<typename T, typename U> inline PassOwnPtr<T> const_pointer_cast(const PassOwnPtr<U>& p)
    {
        return adoptPtr(const_cast<T*>(p.leakPtr()));
    }

    template<typename T> inline T* getPtr(const PassOwnPtr<T>& p)
    {
        return p.get();
    }

}

using WTF::PassOwnPtr;
using WTF::adoptPtr;
using WTF::const_pointer_cast;
using WTF::static_pointer_cast;
# 32 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/JettisonedCodeBlocks.h" 2

namespace JSC {

class CodeBlock;
class SlotVisitor;

class JettisonedCodeBlocks {
    public: void* operator new(size_t, void* p) { return p; } void* operator new[](size_t, void* p) { return p; } void* operator new(size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNew); return p; } void operator delete(void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNew); ::WTF::fastFree(p); } void* operator new[](size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNewArray); return p; } void operator delete[](void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNewArray); ::WTF::fastFree(p); } private: typedef int ThisIsHereToForceASemicolonAfterThisMacro;
public:
    JettisonedCodeBlocks();

    ~JettisonedCodeBlocks();

    void addCodeBlock(PassOwnPtr<CodeBlock>);

    void clearMarks();

    void mark(void* candidateCodeBlock)
    {

        uintptr_t value = reinterpret_cast<uintptr_t>(candidateCodeBlock);




        if (value + 1 <= 1)
            return;

        HashMap<CodeBlock*, bool>::iterator iter = m_map.find(static_cast<CodeBlock*>(candidateCodeBlock));
        if (iter == m_map.end())
            return;
        iter->second = true;
    }

    void deleteUnmarkedCodeBlocks();

    void traceCodeBlocks(SlotVisitor&);

private:


    HashMap<CodeBlock*, bool> m_map;
};

}
# 29 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/Heap.h" 2



# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/SlotVisitor.h" 1
# 29 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/SlotVisitor.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/MarkStack.h" 1
# 31 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/MarkStack.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Register.h" 1
# 36 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Register.h"
namespace JSC {

    class CodeBlock;
    class ExecState;
    class JSActivation;
    class JSObject;
    class JSPropertyNameIterator;
    class ScopeChainNode;

    struct InlineCallFrame;
    struct Instruction;

    typedef ExecState CallFrame;

    class Register {
        public: void* operator new(size_t, void* p) { return p; } void* operator new[](size_t, void* p) { return p; } void* operator new(size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNew); return p; } void operator delete(void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNew); ::WTF::fastFree(p); } void* operator new[](size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNewArray); return p; } void operator delete[](void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNewArray); ::WTF::fastFree(p); } private: typedef int ThisIsHereToForceASemicolonAfterThisMacro;
    public:
        Register();

        Register(const JSValue&);
        Register& operator=(const JSValue&);
        JSValue jsValue() const;
        EncodedJSValue encodedJSValue() const;

        Register& operator=(CallFrame*);
        Register& operator=(CodeBlock*);
        Register& operator=(ScopeChainNode*);
        Register& operator=(Instruction*);
        Register& operator=(InlineCallFrame*);

        int32_t i() const;
        JSActivation* activation() const;
        CallFrame* callFrame() const;
        CodeBlock* codeBlock() const;
        JSObject* function() const;
        JSPropertyNameIterator* propertyNameIterator() const;
        ScopeChainNode* scopeChain() const;
        Instruction* vPC() const;
        InlineCallFrame* inlineCallFrame() const;

        static Register withInt(int32_t i)
        {
            Register r = jsNumber(i);
            return r;
        }

        static inline Register withCallee(JSObject* callee);

    private:
        union {
            EncodedJSValue value;
            CallFrame* callFrame;
            CodeBlock* codeBlock;
            Instruction* vPC;
            InlineCallFrame* inlineCallFrame;
        } u;
    };

    inline __attribute__((__always_inline__)) Register::Register()
    {



    }

    inline __attribute__((__always_inline__)) Register::Register(const JSValue& v)
    {
        u.value = JSValue::encode(v);
    }

    inline __attribute__((__always_inline__)) Register& Register::operator=(const JSValue& v)
    {
        u.value = JSValue::encode(v);
        return *this;
    }

    inline __attribute__((__always_inline__)) JSValue Register::jsValue() const
    {
        return JSValue::decode(u.value);
    }

    inline __attribute__((__always_inline__)) EncodedJSValue Register::encodedJSValue() const
    {
        return u.value;
    }



    inline __attribute__((__always_inline__)) Register& Register::operator=(CallFrame* callFrame)
    {
        u.callFrame = callFrame;
        return *this;
    }

    inline __attribute__((__always_inline__)) Register& Register::operator=(CodeBlock* codeBlock)
    {
        u.codeBlock = codeBlock;
        return *this;
    }

    inline __attribute__((__always_inline__)) Register& Register::operator=(Instruction* vPC)
    {
        u.vPC = vPC;
        return *this;
    }

    inline __attribute__((__always_inline__)) Register& Register::operator=(InlineCallFrame* inlineCallFrame)
    {
        u.inlineCallFrame = inlineCallFrame;
        return *this;
    }

    inline __attribute__((__always_inline__)) int32_t Register::i() const
    {
        return jsValue().asInt32();
    }

    inline __attribute__((__always_inline__)) CallFrame* Register::callFrame() const
    {
        return u.callFrame;
    }

    inline __attribute__((__always_inline__)) CodeBlock* Register::codeBlock() const
    {
        return u.codeBlock;
    }

    inline __attribute__((__always_inline__)) Instruction* Register::vPC() const
    {
        return u.vPC;
    }

    inline __attribute__((__always_inline__)) InlineCallFrame* Register::inlineCallFrame() const
    {
        return u.inlineCallFrame;
    }

}

namespace WTF {

    template<> struct VectorTraits<JSC::Register> : VectorTraitsBase<true, JSC::Register> { };

}
# 32 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/MarkStack.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/VTableSpectrum.h" 1
# 32 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/VTableSpectrum.h"
namespace JSC {

class JSCell;

class VTableSpectrum {
public:
    VTableSpectrum();
    ~VTableSpectrum();

    void countVPtr(void*);
    void count(JSCell*);

    void dump(FILE* output, const char* comment);

private:
    HashMap<void*, unsigned long> m_map;
};

}
# 33 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/MarkStack.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/WeakReferenceHarvester.h" 1
# 25 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/WeakReferenceHarvester.h"
namespace JSC {

class MarkStack;
class SlotVisitor;

class WeakReferenceHarvester {
public:
    virtual void visitWeakReferences(SlotVisitor&) = 0;

protected:
    WeakReferenceHarvester()
        : m_nextAndFlag(0)
    {
    }

    virtual ~WeakReferenceHarvester() { }

private:
    friend class MarkStack;
    friend class SlotVisitor;

    uintptr_t m_nextAndFlag;
};

}
# 34 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/MarkStack.h" 2







namespace JSC {

    class ConservativeRoots;
    class JSGlobalData;
    class MarkStack;
    class Register;
    template<typename T> class WriteBarrierBase;
    template<typename T> class JITWriteBarrier;

    class MarkStackArray {
    public:
        MarkStackArray();
        ~MarkStackArray();

        void expand();
        void append(const JSCell*);

        const JSCell* removeLast();

        bool isEmpty();

        void shrinkAllocation(size_t);

    private:
        const JSCell** m_data;
        size_t m_top;
        size_t m_capacity;
        size_t m_allocated;
    };

    class MarkStack {
        private: MarkStack(const MarkStack&); MarkStack& operator=(const MarkStack&);
        friend class HeapRootVisitor;

    public:
        static void* allocateStack(size_t);
        static void releaseStack(void*, size_t);

        MarkStack(void* jsArrayVPtr, void* jsFinalObjectVPtr, void* jsStringVPtr);
        ~MarkStack();

        void append(ConservativeRoots&);

        template<typename T> void append(JITWriteBarrier<T>*);
        template<typename T> void append(WriteBarrierBase<T>*);
        void appendValues(WriteBarrierBase<Unknown>*, size_t count);

        template<typename T>
        void appendUnbarrieredPointer(T**);

        bool addOpaqueRoot(void*);
        bool containsOpaqueRoot(void*);
        int opaqueRootCount();

        void reset();

        size_t visitCount() const { return m_visitCount; }





        void addWeakReferenceHarvester(WeakReferenceHarvester* weakReferenceHarvester)
        {
            if (weakReferenceHarvester->m_nextAndFlag & 1)
                return;
            weakReferenceHarvester->m_nextAndFlag = reinterpret_cast<uintptr_t>(m_firstWeakReferenceHarvester) | 1;
            m_firstWeakReferenceHarvester = weakReferenceHarvester;
        }

    protected:
        static void validate(JSCell*);

        void append(JSValue*);
        void append(JSValue*, size_t count);
        void append(JSCell**);

        void internalAppend(JSCell*);
        void internalAppend(JSValue);

        MarkStackArray m_stack;
        void* m_jsArrayVPtr;
        void* m_jsFinalObjectVPtr;
        void* m_jsStringVPtr;
        HashSet<void*> m_opaqueRoots;
        WeakReferenceHarvester* m_firstWeakReferenceHarvester;






    protected:
        size_t m_visitCount;
    };

    inline MarkStack::MarkStack(void* jsArrayVPtr, void* jsFinalObjectVPtr, void* jsStringVPtr)
        : m_jsArrayVPtr(jsArrayVPtr)
        , m_jsFinalObjectVPtr(jsFinalObjectVPtr)
        , m_jsStringVPtr(jsStringVPtr)
        , m_firstWeakReferenceHarvester(0)




        , m_visitCount(0)
    {
    }

    inline MarkStack::~MarkStack()
    {
        ((void)0);
    }

    inline bool MarkStack::addOpaqueRoot(void* root)
    {
        return m_opaqueRoots.add(root).second;
    }

    inline bool MarkStack::containsOpaqueRoot(void* root)
    {
        return m_opaqueRoots.contains(root);
    }

    inline int MarkStack::opaqueRootCount()
    {
        return m_opaqueRoots.size();
    }

    inline void* MarkStack::allocateStack(size_t size)
    {
        return OSAllocator::reserveAndCommit(size);
    }

    inline void MarkStack::releaseStack(void* addr, size_t size)
    {
        OSAllocator::decommitAndRelease(addr, size);
    }

    inline void MarkStackArray::append(const JSCell* cell)
    {
        if (m_top == m_capacity)
            expand();
        m_data[m_top++] = cell;
    }

    inline const JSCell* MarkStackArray::removeLast()
    {
        ((void)0);
        return m_data[--m_top];
    }

    inline bool MarkStackArray::isEmpty()
    {
        return !m_top;
    }

    inline __attribute__((__always_inline__)) void MarkStack::append(JSValue* slot, size_t count)
    {
        for (size_t i = 0; i < count; ++i) {
            JSValue& value = slot[i];
            if (!value)
                continue;
            internalAppend(value);
        }
    }

    template<typename T>
    inline void MarkStack::appendUnbarrieredPointer(T** slot)
    {
        ((void)0);
        JSCell* cell = *slot;
        if (cell)
            internalAppend(cell);
    }

    inline __attribute__((__always_inline__)) void MarkStack::append(JSValue* slot)
    {
        ((void)0);
        internalAppend(*slot);
    }

    inline __attribute__((__always_inline__)) void MarkStack::append(JSCell** slot)
    {
        ((void)0);
        internalAppend(*slot);
    }

    inline __attribute__((__always_inline__)) void MarkStack::internalAppend(JSValue value)
    {
        ((void)0);
        if (!value.isCell())
            return;
        internalAppend(value.asCell());
    }

    class SlotVisitor;

}
# 30 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/SlotVisitor.h" 2

namespace JSC {

class SlotVisitor : public MarkStack {
    friend class HeapRootVisitor;
public:
    SlotVisitor(void* jsArrayVPtr, void* jsFinalObjectVPtr, void* jsStringVPtr);

    void drain();
    void harvestWeakReferences();
};

inline SlotVisitor::SlotVisitor(void* jsArrayVPtr, void* jsFinalObjectVPtr, void* jsStringVPtr)
    : MarkStack(jsArrayVPtr, jsFinalObjectVPtr, jsStringVPtr)
{
}

}
# 33 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/Heap.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/WriteBarrierSupport.h" 1
# 29 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/WriteBarrierSupport.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/SamplingCounter.h" 1
# 35 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/SamplingCounter.h"
namespace JSC {





class AbstractSamplingCounter {
    friend class DeletableSamplingCounter;
public:
    void count(uint32_t count = 1)
    {
        m_counter += count;
    }

    static void dump();

    int64_t* addressOfCounter() { return &m_counter; }

protected:

    void init(const char* name)
    {
        m_counter = 0;
        m_name = name;



        m_next = s_abstractSamplingCounterChain;
        s_abstractSamplingCounterChain->m_referer = &m_next;

        s_abstractSamplingCounterChain = this;
        m_referer = &s_abstractSamplingCounterChain;
    }

    int64_t m_counter;
    const char* m_name;
    AbstractSamplingCounter* m_next;


    AbstractSamplingCounter** m_referer;

    static AbstractSamplingCounter s_abstractSamplingCounterChainEnd;
    static AbstractSamplingCounter* s_abstractSamplingCounterChain;
    static bool s_completed;
};
# 174 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/SamplingCounter.h"
}
# 30 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/WriteBarrierSupport.h" 2


namespace JSC {





enum WriteBarrierUseKind {



    WriteBarrierForPropertyAccess,



    WriteBarrierForVariableAccess,





    WriteBarrierForGenericAccess
};

class WriteBarrierCounters {
private:
    WriteBarrierCounters() { }

public:
# 84 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/WriteBarrierSupport.h"
    static char usesWithBarrierFromCpp;
    static char usesWithoutBarrierFromCpp;


    static void countWriteBarrier()
    {



    }
};

}
# 34 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/Heap.h" 2




namespace JSC {

    class GCActivityCallback;
    class GlobalCodeBlock;
    class Heap;
    class HeapRootVisitor;
    class JSCell;
    class JSGlobalData;
    class JSValue;
    class LiveObjectIterator;
    class MarkedArgumentBuffer;
    class RegisterFile;
    class UString;
    class WeakGCHandlePool;
    class SlotVisitor;

    typedef std::pair<JSValue, UString> ValueStringPair;
    typedef HashCountedSet<JSCell*> ProtectCountSet;
    typedef HashCountedSet<const char*> TypeCountSet;

    enum OperationInProgress { NoOperation, Allocation, Collection };


    enum HeapSize { SmallHeap, LargeHeap };

    class Heap {
        private: Heap(const Heap&); Heap& operator=(const Heap&);
    public:
        friend class JIT;
        static Heap* heap(JSValue);
        static Heap* heap(JSCell*);

        static bool isMarked(const void*);
        static bool testAndSetMarked(const void*);
        static void setMarked(const void*);

        static void writeBarrier(const JSCell*, JSValue);
        static void writeBarrier(const JSCell*, JSCell*);
        static uint8_t* addressOfCardFor(JSCell*);

        Heap(JSGlobalData*, HeapSize);
        ~Heap();
        void destroy();

        JSGlobalData* globalData() const { return m_globalData; }
        AllocationSpace& objectSpace() { return m_objectSpace; }
        MachineThreads& machineThreads() { return m_machineThreads; }

        GCActivityCallback* activityCallback();
        void setActivityCallback(PassOwnPtr<GCActivityCallback>);


        inline bool isBusy();

        MarkedSpace::SizeClass& sizeClassForObject(size_t bytes) { return m_objectSpace.sizeClassFor(bytes); }
        void* allocate(size_t);

        typedef void (*Finalizer)(JSCell*);
        void addFinalizer(JSCell*, Finalizer);

        void notifyIsSafeToCollect() { m_isSafeToCollect = true; }
        void collectAllGarbage();

        void reportExtraMemoryCost(size_t cost);

        void protect(JSValue);
        bool unprotect(JSValue);

        void addJettisonedCodeBlock(PassOwnPtr<CodeBlock>);

        size_t size();
        size_t capacity();
        size_t objectCount();
        size_t globalObjectCount();
        size_t protectedObjectCount();
        size_t protectedGlobalObjectCount();
        PassOwnPtr<TypeCountSet> protectedObjectTypeCounts();
        PassOwnPtr<TypeCountSet> objectTypeCounts();

        void pushTempSortVector(Vector<ValueStringPair>*);
        void popTempSortVector(Vector<ValueStringPair>*);

        HashSet<MarkedArgumentBuffer*>& markListSet() { if (!m_markListSet) m_markListSet = new HashSet<MarkedArgumentBuffer*>; return *m_markListSet; }

        template<typename Functor> typename Functor::ReturnType forEachProtectedCell(Functor&);
        template<typename Functor> typename Functor::ReturnType forEachProtectedCell();

        HandleHeap* handleHeap() { return &m_handleHeap; }
        HandleStack* handleStack() { return &m_handleStack; }

        void getConservativeRegisterRoots(HashSet<JSCell*>& roots);

    private:
        friend class MarkedBlock;
        friend class AllocationSpace;

        static const size_t minExtraCost = 256;
        static const size_t maxExtraCost = 1024 * 1024;

        class FinalizerOwner : public WeakHandleOwner {
            virtual void finalize(Handle<Unknown>, void* context);
        };

        bool isValidAllocation(size_t);
        void reportExtraMemoryCostSlowCase(size_t);




        void canonicalizeCellLivenessData();

        void resetAllocator();
        void freeBlocks(MarkedBlock*);

        void clearMarks();
        void markRoots(bool fullGC);
        void markProtectedObjects(HeapRootVisitor&);
        void markTempSortVectors(HeapRootVisitor&);
        void harvestWeakReferences();

        enum SweepToggle { DoNotSweep, DoSweep };
        void collect(SweepToggle);
        void shrink();
        void releaseFreeBlocks();
        void sweep();

        RegisterFile& registerFile();

        void waitForRelativeTimeWhileHoldingLock(double relative);
        void waitForRelativeTime(double relative);
        void blockFreeingThreadMain();
        static void* blockFreeingThreadStartFunc(void* heap);

        const HeapSize m_heapSize;
        const size_t m_minBytesPerCycle;
        size_t m_lastFullGCSize;

        OperationInProgress m_operationInProgress;
        AllocationSpace m_objectSpace;

        DoublyLinkedList<MarkedBlock> m_freeBlocks;
        size_t m_numberOfFreeBlocks;

        ThreadIdentifier m_blockFreeingThread;
        Mutex m_freeBlockLock;
        ThreadCondition m_freeBlockCondition;
        bool m_blockFreeingThreadShouldQuit;





        size_t m_extraCost;

        ProtectCountSet m_protectedValues;
        Vector<Vector<ValueStringPair>* > m_tempSortingVectors;
        HashSet<MarkedArgumentBuffer*>* m_markListSet;

        OwnPtr<GCActivityCallback> m_activityCallback;

        MachineThreads m_machineThreads;
        SlotVisitor m_slotVisitor;
        HandleHeap m_handleHeap;
        HandleStack m_handleStack;
        JettisonedCodeBlocks m_jettisonedCodeBlocks;
        FinalizerOwner m_finalizerOwner;

        bool m_isSafeToCollect;

        JSGlobalData* m_globalData;
    };

    bool Heap::isBusy()
    {
        return m_operationInProgress != NoOperation;
    }

    inline Heap* Heap::heap(JSCell* cell)
    {
        return MarkedBlock::blockFor(cell)->heap();
    }

    inline Heap* Heap::heap(JSValue v)
    {
        if (!v.isCell())
            return 0;
        return heap(v.asCell());
    }

    inline bool Heap::isMarked(const void* cell)
    {
        return MarkedBlock::blockFor(cell)->isMarked(cell);
    }

    inline bool Heap::testAndSetMarked(const void* cell)
    {
        return MarkedBlock::blockFor(cell)->testAndSetMarked(cell);
    }

    inline void Heap::setMarked(const void* cell)
    {
        MarkedBlock::blockFor(cell)->setMarked(cell);
    }
# 266 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/Heap.h"
    inline void Heap::writeBarrier(const JSCell*, JSCell*)
    {
        WriteBarrierCounters::countWriteBarrier();
    }

    inline void Heap::writeBarrier(const JSCell*, JSValue)
    {
        WriteBarrierCounters::countWriteBarrier();
    }


    inline void Heap::reportExtraMemoryCost(size_t cost)
    {
        if (cost > minExtraCost)
            reportExtraMemoryCostSlowCase(cost);
    }

    template<typename Functor> inline typename Functor::ReturnType Heap::forEachProtectedCell(Functor& functor)
    {
        ProtectCountSet::iterator end = m_protectedValues.end();
        for (ProtectCountSet::iterator it = m_protectedValues.begin(); it != end; ++it)
            functor(it->first);
        m_handleHeap.forEachStrongHandle(functor, m_protectedValues);

        return functor.returnValue();
    }

    template<typename Functor> inline typename Functor::ReturnType Heap::forEachProtectedCell()
    {
        Functor functor;
        return forEachProtectedCell(functor);
    }

    inline void* Heap::allocate(size_t bytes)
    {
        ((void)0);
        return m_objectSpace.allocate(bytes);
    }

}
# 37 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSGlobalData.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/Strong.h" 1
# 33 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/Strong.h"
namespace JSC {

class JSGlobalData;


template <typename T> class Strong : public Handle<T> {
    using Handle<T>::slot;
    using Handle<T>::setSlot;

public:
    typedef typename Handle<T>::ExternalType ExternalType;

    Strong()
        : Handle<T>()
    {
    }

    Strong(JSGlobalData&, ExternalType = ExternalType());

    Strong(JSGlobalData&, Handle<T>);

    Strong(const Strong& other)
        : Handle<T>()
    {
        if (!other.slot())
            return;
        setSlot(HandleHeap::heapFor(other.slot())->allocate());
        set(other.get());
    }

    template <typename U> Strong(const Strong<U>& other)
        : Handle<T>()
    {
        if (!other.slot())
            return;
        setSlot(HandleHeap::heapFor(other.slot())->allocate());
        set(other.get());
    }

    enum HashTableDeletedValueTag { HashTableDeletedValue };
    bool isHashTableDeletedValue() const { return slot() == hashTableDeletedValue(); }
    Strong(HashTableDeletedValueTag)
        : Handle<T>(hashTableDeletedValue())
    {
    }

    ~Strong()
    {
        clear();
    }

    void swap(Strong& other)
    {
        Handle<T>::swap(other);
    }

    void set(JSGlobalData&, ExternalType);

    template <typename U> Strong& operator=(const Strong<U>& other)
    {
        if (!other.slot()) {
            clear();
            return *this;
        }

        set(*HandleHeap::heapFor(other.slot())->globalData(), other.get());
        return *this;
    }

    Strong& operator=(const Strong& other)
    {
        if (!other.slot()) {
            clear();
            return *this;
        }

        set(*HandleHeap::heapFor(other.slot())->globalData(), other.get());
        return *this;
    }

    void clear()
    {
        if (!slot())
            return;
        HandleHeap::heapFor(slot())->deallocate(slot());
        setSlot(0);
    }

private:
    static HandleSlot hashTableDeletedValue() { return reinterpret_cast<HandleSlot>(-1); }

    void set(ExternalType externalType)
    {
        ((void)0);
        JSValue value = HandleTypes<T>::toJSValue(externalType);
        HandleHeap::heapFor(slot())->writeBarrier(slot(), value);
        *slot() = value;
    }
};

template<class T> inline void swap(Strong<T>& a, Strong<T>& b)
{
    a.swap(b);
}

}

namespace WTF {

template<typename T> struct VectorTraits<JSC::Strong<T> > : SimpleClassVectorTraits {
    static const bool canCompareWithMemcmp = false;
};

template<typename P> struct HashTraits<JSC::Strong<P> > : SimpleClassHashTraits<JSC::Strong<P> > { };

}
# 38 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSGlobalData.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/jit/JITStubs.h" 1
# 33 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/jit/JITStubs.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/CallData.h" 1
# 34 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/CallData.h"
namespace JSC {

    class ArgList;
    class ExecState;
    class FunctionExecutable;
    class JSObject;
    class ScopeChainNode;

    enum CallType {
        CallTypeNone,
        CallTypeHost,
        CallTypeJS
    };

    typedef EncodedJSValue ( *NativeFunction)(ExecState*);

    union CallData {
        struct {
            NativeFunction function;
        } native;
        struct {
            FunctionExecutable* functionExecutable;
            ScopeChainNode* scopeChain;
        } js;
    };

    JSValue call(ExecState*, JSValue functionObject, CallType, const CallData&, JSValue thisValue, const ArgList&);

}
# 34 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/jit/JITStubs.h" 2

# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/MacroAssemblerCodeRef.h" 1
# 68 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/MacroAssemblerCodeRef.h"
namespace JSC {





class FunctionPtr {
public:
    FunctionPtr()
        : m_value(0)
    {
    }

    template<typename returnType>
    FunctionPtr(returnType(*value)())
        : m_value((void*)value)
    {
        ((void)0);
    }

    template<typename returnType, typename argType1>
    FunctionPtr(returnType(*value)(argType1))
        : m_value((void*)value)
    {
        ((void)0);
    }

    template<typename returnType, typename argType1, typename argType2>
    FunctionPtr(returnType(*value)(argType1, argType2))
        : m_value((void*)value)
    {
        ((void)0);
    }

    template<typename returnType, typename argType1, typename argType2, typename argType3>
    FunctionPtr(returnType(*value)(argType1, argType2, argType3))
        : m_value((void*)value)
    {
        ((void)0);
    }

    template<typename returnType, typename argType1, typename argType2, typename argType3, typename argType4>
    FunctionPtr(returnType(*value)(argType1, argType2, argType3, argType4))
        : m_value((void*)value)
    {
        ((void)0);
    }
# 154 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/MacroAssemblerCodeRef.h"
    template<typename FunctionType>
    explicit FunctionPtr(FunctionType* value)



        : m_value((void*)value)
    {
        ((void)0);
    }

    void* value() const { return m_value; }
    void* executableAddress() const { return m_value; }


private:
    void* m_value;
};







class ReturnAddressPtr {
public:
    ReturnAddressPtr()
        : m_value(0)
    {
    }

    explicit ReturnAddressPtr(void* value)
        : m_value(value)
    {
        ((void)0);
    }

    explicit ReturnAddressPtr(FunctionPtr function)
        : m_value(function.value())
    {
        ((void)0);
    }

    void* value() const { return m_value; }

private:
    void* m_value;
};




class MacroAssemblerCodePtr {
public:
    MacroAssemblerCodePtr()
        : m_value(0)
    {
    }

    explicit MacroAssemblerCodePtr(void* value)




        : m_value(value)

    {
        ((void)0);
    }

    explicit MacroAssemblerCodePtr(ReturnAddressPtr ra)
        : m_value(ra.value())
    {
        ((void)0);
    }

    void* executableAddress() const { return m_value; }




    void* dataLocation() const { ((void)0); return m_value; }


    bool operator!() const
    {
        return !m_value;
    }

private:
    void* m_value;
};






class MacroAssemblerCodeRef {
private:


    explicit MacroAssemblerCodeRef(MacroAssemblerCodePtr codePtr)
        : m_codePtr(codePtr)
    {
        ((void)0);
    }

public:
    MacroAssemblerCodeRef()
    {
    }

    MacroAssemblerCodeRef(PassRefPtr<ExecutableMemoryHandle> executableMemory)
        : m_codePtr(executableMemory->start())
        , m_executableMemory(executableMemory)
    {
        ((void)0);
        ((void)0);
        ((void)0);
    }




    static MacroAssemblerCodeRef createSelfManagedCodeRef(MacroAssemblerCodePtr codePtr)
    {
        return MacroAssemblerCodeRef(codePtr);
    }

    ExecutableMemoryHandle* executableMemory() const
    {
        return m_executableMemory.get();
    }

    MacroAssemblerCodePtr code() const
    {
        return m_codePtr;
    }

    size_t size() const
    {
        if (!m_executableMemory)
            return 0;
        return m_executableMemory->sizeInBytes();
    }

    bool operator!() const { return !m_codePtr; }

private:
    MacroAssemblerCodePtr m_codePtr;
    RefPtr<ExecutableMemoryHandle> m_executableMemory;
};

}
# 36 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/jit/JITStubs.h" 2

# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/jit/ThunkGenerators.h" 1
# 30 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/jit/ThunkGenerators.h"
namespace JSC {
    class ExecutablePool;
    class JSGlobalData;
    class NativeExecutable;
    class MacroAssemblerCodeRef;

    typedef MacroAssemblerCodeRef (*ThunkGenerator)(JSGlobalData*);
    MacroAssemblerCodeRef charCodeAtThunkGenerator(JSGlobalData*);
    MacroAssemblerCodeRef charAtThunkGenerator(JSGlobalData*);
    MacroAssemblerCodeRef fromCharCodeThunkGenerator(JSGlobalData*);
    MacroAssemblerCodeRef absThunkGenerator(JSGlobalData*);
    MacroAssemblerCodeRef ceilThunkGenerator(JSGlobalData*);
    MacroAssemblerCodeRef expThunkGenerator(JSGlobalData*);
    MacroAssemblerCodeRef floorThunkGenerator(JSGlobalData*);
    MacroAssemblerCodeRef logThunkGenerator(JSGlobalData*);
    MacroAssemblerCodeRef roundThunkGenerator(JSGlobalData*);
    MacroAssemblerCodeRef sqrtThunkGenerator(JSGlobalData*);
    MacroAssemblerCodeRef powThunkGenerator(JSGlobalData*);
}
# 38 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/jit/JITStubs.h" 2




namespace JSC {

    struct StructureStubInfo;

    class CodeBlock;
    class ExecutablePool;
    class FunctionExecutable;
    class Identifier;
    class JSGlobalData;
    class JSGlobalObject;
    class JSObject;
    class JSPropertyNameIterator;
    class JSValue;
    class JSValueEncodedAsPointer;
    class NativeExecutable;
    class Profiler;
    class PropertySlot;
    class PutPropertySlot;
    class RegisterFile;
    class RegExp;

    template <typename T> class Weak;

    union JITStubArg {
        void* asPointer;
        EncodedJSValue asEncodedJSValue;
        int32_t asInt32;

        JSValue jsValue() { return JSValue::decode(asEncodedJSValue); }
        JSObject* jsObject() { return static_cast<JSObject*>(asPointer); }
        Identifier& identifier() { return *static_cast<Identifier*>(asPointer); }
        int32_t int32() { return asInt32; }
        CodeBlock* codeBlock() { return static_cast<CodeBlock*>(asPointer); }
        FunctionExecutable* function() { return static_cast<FunctionExecutable*>(asPointer); }
        RegExp* regExp() { return static_cast<RegExp*>(asPointer); }
        JSPropertyNameIterator* propertyNameIterator() { return static_cast<JSPropertyNameIterator*>(asPointer); }
        JSGlobalObject* globalObject() { return static_cast<JSGlobalObject*>(asPointer); }
        JSString* jsString() { return static_cast<JSString*>(asPointer); }
        ReturnAddressPtr returnAddress() { return ReturnAddressPtr(asPointer); }
    };

    struct TrampolineStructure {
        MacroAssemblerCodePtr ctiStringLengthTrampoline;
        MacroAssemblerCodePtr ctiVirtualCallLink;
        MacroAssemblerCodePtr ctiVirtualConstructLink;
        MacroAssemblerCodePtr ctiVirtualCall;
        MacroAssemblerCodePtr ctiVirtualConstruct;
        MacroAssemblerCodePtr ctiNativeCall;
        MacroAssemblerCodePtr ctiNativeConstruct;
        MacroAssemblerCodePtr ctiSoftModulo;
    };


    struct JITStackFrame {
        void* reserved;
        JITStubArg args[6];
        void* padding[2];

        void* code;
        RegisterFile* registerFile;
        CallFrame* callFrame;
        void* unused1;
        Profiler** enabledProfilerReference;
        JSGlobalData* globalData;

        void* savedRBX;
        void* savedR15;
        void* savedR14;
        void* savedR13;
        void* savedR12;
        void* savedRBP;
        void* savedRIP;


        ReturnAddressPtr* returnAddressSlot() { return reinterpret_cast<ReturnAddressPtr*>(this) - 1; }
    };
# 277 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/jit/JITStubs.h"
    extern "C" void ctiVMThrowTrampoline();
    extern "C" void ctiOpThrowNotCaught();
    extern "C" EncodedJSValue ctiTrampoline(void* code, RegisterFile*, CallFrame*, void* , Profiler**, JSGlobalData*);

    class JITThunks {
    public:
        JITThunks(JSGlobalData*);
        ~JITThunks();

        static void tryCacheGetByID(CallFrame*, CodeBlock*, ReturnAddressPtr returnAddress, JSValue baseValue, const Identifier& propertyName, const PropertySlot&, StructureStubInfo* stubInfo);
        static void tryCachePutByID(CallFrame*, CodeBlock*, ReturnAddressPtr returnAddress, JSValue baseValue, const PutPropertySlot&, StructureStubInfo* stubInfo, bool direct);

        MacroAssemblerCodePtr ctiStringLengthTrampoline() { return m_trampolineStructure.ctiStringLengthTrampoline; }
        MacroAssemblerCodePtr ctiVirtualCallLink() { return m_trampolineStructure.ctiVirtualCallLink; }
        MacroAssemblerCodePtr ctiVirtualConstructLink() { return m_trampolineStructure.ctiVirtualConstructLink; }
        MacroAssemblerCodePtr ctiVirtualCall() { return m_trampolineStructure.ctiVirtualCall; }
        MacroAssemblerCodePtr ctiVirtualConstruct() { return m_trampolineStructure.ctiVirtualConstruct; }
        MacroAssemblerCodePtr ctiNativeCall() { return m_trampolineStructure.ctiNativeCall; }
        MacroAssemblerCodePtr ctiNativeConstruct() { return m_trampolineStructure.ctiNativeConstruct; }
        MacroAssemblerCodePtr ctiSoftModulo() { return m_trampolineStructure.ctiSoftModulo; }

        MacroAssemblerCodeRef ctiStub(JSGlobalData*, ThunkGenerator);

        NativeExecutable* hostFunctionStub(JSGlobalData*, NativeFunction, NativeFunction constructor);
        NativeExecutable* hostFunctionStub(JSGlobalData*, NativeFunction, ThunkGenerator, DFG::Intrinsic);

        void clearHostFunctionStubs();

    private:
        typedef HashMap<ThunkGenerator, MacroAssemblerCodeRef> CTIStubMap;
        CTIStubMap m_ctiStubMap;
        typedef HashMap<NativeFunction, Weak<NativeExecutable> > HostFunctionStubMap;
        OwnPtr<HostFunctionStubMap> m_hostFunctionStubMap;
        RefPtr<ExecutableMemoryHandle> m_executableMemory;

        TrampolineStructure m_trampolineStructure;
    };

extern "C" {
    EncodedJSValue cti_op_add(void** args);
    EncodedJSValue cti_op_bitand(void** args);
    EncodedJSValue cti_op_bitnot(void** args);
    EncodedJSValue cti_op_bitor(void** args);
    EncodedJSValue cti_op_bitxor(void** args);
    EncodedJSValue cti_op_call_NotJSFunction(void** args);
    EncodedJSValue cti_op_call_eval(void** args);
    EncodedJSValue cti_op_construct_NotJSConstruct(void** args);
    EncodedJSValue cti_op_create_this(void** args);
    EncodedJSValue cti_op_convert_this(void** args);
    EncodedJSValue cti_op_create_arguments(void** args);
    EncodedJSValue cti_op_create_arguments_no_params(void** args);
    EncodedJSValue cti_op_del_by_id(void** args);
    EncodedJSValue cti_op_del_by_val(void** args);
    EncodedJSValue cti_op_div(void** args);
    EncodedJSValue cti_op_get_by_id(void** args);
    EncodedJSValue cti_op_get_by_id_array_fail(void** args);
    EncodedJSValue cti_op_get_by_id_custom_stub(void** args);
    EncodedJSValue cti_op_get_by_id_generic(void** args);
    EncodedJSValue cti_op_get_by_id_getter_stub(void** args);
    EncodedJSValue cti_op_get_by_id_method_check(void** args);
    EncodedJSValue cti_op_get_by_id_method_check_update(void** args);
    EncodedJSValue cti_op_get_by_id_proto_fail(void** args);
    EncodedJSValue cti_op_get_by_id_proto_list(void** args);
    EncodedJSValue cti_op_get_by_id_proto_list_full(void** args);
    EncodedJSValue cti_op_get_by_id_self_fail(void** args);
    EncodedJSValue cti_op_get_by_id_string_fail(void** args);
    EncodedJSValue cti_op_get_by_val(void** args);
    EncodedJSValue cti_op_get_by_val_byte_array(void** args);
    EncodedJSValue cti_op_get_by_val_string(void** args);
    EncodedJSValue cti_op_in(void** args);
    EncodedJSValue cti_op_instanceof(void** args);
    EncodedJSValue cti_op_is_boolean(void** args);
    EncodedJSValue cti_op_is_function(void** args);
    EncodedJSValue cti_op_is_number(void** args);
    EncodedJSValue cti_op_is_object(void** args);
    EncodedJSValue cti_op_is_string(void** args);
    EncodedJSValue cti_op_is_undefined(void** args);
    EncodedJSValue cti_op_less(void** args);
    EncodedJSValue cti_op_lesseq(void** args);
    EncodedJSValue cti_op_greater(void** args);
    EncodedJSValue cti_op_greatereq(void** args);
    EncodedJSValue cti_op_lshift(void** args);
    EncodedJSValue cti_op_mod(void** args);
    EncodedJSValue cti_op_mul(void** args);
    EncodedJSValue cti_op_negate(void** args);
    EncodedJSValue cti_op_not(void** args);
    EncodedJSValue cti_op_nstricteq(void** args);
    EncodedJSValue cti_op_post_dec(void** args);
    EncodedJSValue cti_op_post_inc(void** args);
    EncodedJSValue cti_op_pre_dec(void** args);
    EncodedJSValue cti_op_pre_inc(void** args);
    EncodedJSValue cti_op_resolve(void** args);
    EncodedJSValue cti_op_resolve_base(void** args);
    EncodedJSValue cti_op_resolve_base_strict_put(void** args);
    EncodedJSValue cti_op_ensure_property_exists(void** args);
    EncodedJSValue cti_op_resolve_global(void** args);
    EncodedJSValue cti_op_resolve_global_dynamic(void** args);
    EncodedJSValue cti_op_resolve_skip(void** args);
    EncodedJSValue cti_op_resolve_with_base(void** args);
    EncodedJSValue cti_op_resolve_with_this(void** args);
    EncodedJSValue cti_op_rshift(void** args);
    EncodedJSValue cti_op_strcat(void** args);
    EncodedJSValue cti_op_stricteq(void** args);
    EncodedJSValue cti_op_sub(void** args);
    EncodedJSValue cti_op_to_jsnumber(void** args);
    EncodedJSValue cti_op_to_primitive(void** args);
    EncodedJSValue cti_op_typeof(void** args);
    EncodedJSValue cti_op_urshift(void** args);
    EncodedJSValue cti_to_object(void** args);
    JSObject* cti_op_new_array(void** args);
    JSObject* cti_op_new_array_buffer(void** args);
    JSObject* cti_op_new_func(void** args);
    JSObject* cti_op_new_func_exp(void** args);
    JSObject* cti_op_new_object(void** args);
    JSObject* cti_op_new_regexp(void** args);
    JSObject* cti_op_push_activation(void** args);
    JSObject* cti_op_push_new_scope(void** args);
    JSObject* cti_op_push_scope(void** args);
    JSObject* cti_op_put_by_id_transition_realloc(void** args);
    JSPropertyNameIterator* cti_op_get_pnames(void** args);
    int cti_op_eq(void** args);
    int cti_op_eq_strings(void** args);
    int cti_op_jless(void** args);
    int cti_op_jlesseq(void** args);
    int cti_op_jgreater(void** args);
    int cti_op_jgreatereq(void** args);
    int cti_op_jtrue(void** args);
    int cti_op_load_varargs(void** args);
    int cti_timeout_check(void** args);
    int cti_has_property(void** args);
    void cti_op_check_has_instance(void** args);
    void cti_op_debug(void** args);
    void cti_op_end(void** args);
    void cti_op_jmp_scopes(void** args);
    void cti_op_pop_scope(void** args);
    void cti_op_profile_did_call(void** args);
    void cti_op_profile_will_call(void** args);
    void cti_op_put_by_id(void** args);
    void cti_op_put_by_id_fail(void** args);
    void cti_op_put_by_id_generic(void** args);
    void cti_op_put_by_id_direct(void** args);
    void cti_op_put_by_id_direct_fail(void** args);
    void cti_op_put_by_id_direct_generic(void** args);
    void cti_op_put_by_index(void** args);
    void cti_op_put_by_val(void** args);
    void cti_op_put_by_val_byte_array(void** args);
    void cti_op_put_getter(void** args);
    void cti_op_put_setter(void** args);
    void cti_op_tear_off_activation(void** args);
    void cti_op_tear_off_arguments(void** args);
    void cti_op_throw_reference_error(void** args);

    void cti_optimize_from_loop(void** args);
    void cti_optimize_from_ret(void** args);

    void* cti_op_call_arityCheck(void** args);
    void* cti_op_construct_arityCheck(void** args);
    void* cti_op_call_jitCompile(void** args);
    void* cti_op_construct_jitCompile(void** args);
    void* cti_op_switch_char(void** args);
    void* cti_op_switch_imm(void** args);
    void* cti_op_switch_string(void** args);
    void* cti_op_throw(void** args);
    void* cti_register_file_check(void** args);
    void* cti_vm_lazyLinkCall(void** args);
    void* cti_vm_lazyLinkConstruct(void** args);
    void* cti_vm_throw(void** args);
}

}
# 39 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSGlobalData.h" 2

# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/NumericStrings.h" 1
# 29 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/NumericStrings.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/UString.h" 1
# 28 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/UString.h"
namespace JSC {

class UString {
public:

    UString() { }


    UString(const UChar* characters, unsigned length);


    UString(const UChar*);


    UString(const char* characters, unsigned length);


    UString(const char* characters);


    UString(StringImpl* impl) : m_impl(impl) { }
    UString(PassRefPtr<StringImpl> impl) : m_impl(impl) { }
    UString(RefPtr<StringImpl> impl) : m_impl(impl) { }


    inline __attribute__((__always_inline__)) ~UString() { }

    void swap(UString& o) { m_impl.swap(o.m_impl); }

    template<size_t inlineCapacity>
    static UString adopt(Vector<UChar, inlineCapacity>& vector) { return StringImpl::adopt(vector); }

    bool isNull() const { return !m_impl; }
    bool isEmpty() const { return !m_impl || !m_impl->length(); }

    StringImpl* impl() const { return m_impl.get(); }

    unsigned length() const
    {
        if (!m_impl)
            return 0;
        return m_impl->length();
    }

    const UChar* characters() const
    {
        if (!m_impl)
            return 0;
        return m_impl->characters();
    }

    bool is8Bit() const { return false; }

    CString ascii() const;
    CString latin1() const;
    CString utf8(bool strict = false) const;

    UChar operator[](unsigned index) const
    {
        if (!m_impl || index >= m_impl->length())
            return 0;
        return m_impl->characters()[index];
    }

    static UString number(int);
    static UString number(unsigned);
    static UString number(long);
    static UString number(long long);
    static UString number(double);


    size_t find(UChar c, unsigned start = 0) const
        { return m_impl ? m_impl->find(c, start) : notFound; }
    size_t find(const UString& str, unsigned start = 0) const
        { return m_impl ? m_impl->find(str.impl(), start) : notFound; }
    size_t find(const char* str, unsigned start = 0) const
        { return m_impl ? m_impl->find(str, start) : notFound; }


    size_t reverseFind(UChar c, unsigned start = (2147483647 *2U +1U)) const
        { return m_impl ? m_impl->reverseFind(c, start) : notFound; }
    size_t reverseFind(const UString& str, unsigned start = (2147483647 *2U +1U)) const
        { return m_impl ? m_impl->reverseFind(str.impl(), start) : notFound; }

    UString substringSharingImpl(unsigned pos, unsigned len = (2147483647 *2U +1U)) const;

private:
    RefPtr<StringImpl> m_impl;
};

inline __attribute__((__always_inline__)) bool operator==(const UString& s1, const UString& s2)
{
    StringImpl* rep1 = s1.impl();
    StringImpl* rep2 = s2.impl();
    unsigned size1 = 0;
    unsigned size2 = 0;

    if (rep1 == rep2)
        return true;

    if (rep1)
        size1 = rep1->length();

    if (rep2)
        size2 = rep2->length();

    if (size1 != size2)
        return false;

    if (!size1)
        return true;




    const UChar* d1 = rep1->characters();
    const UChar* d2 = rep2->characters();

    if (d1 == d2)
        return true;


    switch (size1) {
    case 1:
        return d1[0] == d2[0];
    case 2:
        return (d1[0] == d2[0]) & (d1[1] == d2[1]);
    default:
        return memcmp(d1, d2, size1 * sizeof(UChar)) == 0;
    }
}


inline bool operator!=(const UString& s1, const UString& s2)
{
    return !JSC::operator==(s1, s2);
}

bool operator<(const UString& s1, const UString& s2);
bool operator>(const UString& s1, const UString& s2);

bool operator==(const UString& s1, const char* s2);

inline bool operator!=(const UString& s1, const char* s2)
{
    return !JSC::operator==(s1, s2);
}

inline bool operator==(const char *s1, const UString& s2)
{
    return operator==(s2, s1);
}

inline bool operator!=(const char *s1, const UString& s2)
{
    return !JSC::operator==(s1, s2);
}

inline int codePointCompare(const UString& s1, const UString& s2)
{
    return codePointCompare(s1.impl(), s2.impl());
}

struct UStringHash {
    static unsigned hash(StringImpl* key) { return key->hash(); }
    static bool equal(const StringImpl* a, const StringImpl* b)
    {
        if (a == b)
            return true;
        if (!a || !b)
            return false;

        unsigned aLength = a->length();
        unsigned bLength = b->length();
        if (aLength != bLength)
            return false;
# 217 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/UString.h"
        const uint32_t* aChars = reinterpret_cast<const uint32_t*>(a->characters());
        const uint32_t* bChars = reinterpret_cast<const uint32_t*>(b->characters());

        unsigned halfLength = aLength >> 1;
        for (unsigned i = 0; i != halfLength; ++i)
            if (*aChars++ != *bChars++)
                return false;

        if (aLength & 1 && *reinterpret_cast<const uint16_t*>(aChars) != *reinterpret_cast<const uint16_t*>(bChars))
            return false;

        return true;

    }

    static unsigned hash(const RefPtr<StringImpl>& key) { return key->hash(); }
    static bool equal(const RefPtr<StringImpl>& a, const RefPtr<StringImpl>& b)
    {
        return equal(a.get(), b.get());
    }

    static unsigned hash(const UString& key) { return key.impl()->hash(); }
    static bool equal(const UString& a, const UString& b)
    {
        return equal(a.impl(), b.impl());
    }

    static const bool safeToCompareToEmptyOrDeleted = false;
};

}

namespace WTF {


template<typename T> struct DefaultHash;
template<> struct DefaultHash<JSC::UString> {
    typedef JSC::UStringHash Hash;
};

template <> struct VectorTraits<JSC::UString> : SimpleClassVectorTraits { };

}
# 30 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/NumericStrings.h" 2



namespace JSC {

    class NumericStrings {
    public:
        UString add(double d)
        {
            CacheEntry<double>& entry = lookup(d);
            if (d == entry.key && !entry.value.isNull())
                return entry.value;
            entry.key = d;
            entry.value = UString::number(d);
            return entry.value;
        }

        UString add(int i)
        {
            if (static_cast<unsigned>(i) < cacheSize)
                return lookupSmallString(static_cast<unsigned>(i));
            CacheEntry<int>& entry = lookup(i);
            if (i == entry.key && !entry.value.isNull())
                return entry.value;
            entry.key = i;
            entry.value = UString::number(i);
            return entry.value;
        }

        UString add(unsigned i)
        {
            if (i < cacheSize)
                return lookupSmallString(static_cast<unsigned>(i));
            CacheEntry<unsigned>& entry = lookup(i);
            if (i == entry.key && !entry.value.isNull())
                return entry.value;
            entry.key = i;
            entry.value = UString::number(i);
            return entry.value;
        }
    private:
        static const size_t cacheSize = 64;

        template<typename T>
        struct CacheEntry {
            T key;
            UString value;
        };

        CacheEntry<double>& lookup(double d) { return doubleCache[WTF::FloatHash<double>::hash(d) & (cacheSize - 1)]; }
        CacheEntry<int>& lookup(int i) { return intCache[WTF::IntHash<int>::hash(i) & (cacheSize - 1)]; }
        CacheEntry<unsigned>& lookup(unsigned i) { return unsignedCache[WTF::IntHash<unsigned>::hash(i) & (cacheSize - 1)]; }
        const UString& lookupSmallString(unsigned i)
        {
            ((void)0);
            if (smallIntCache[i].isNull())
                smallIntCache[i] = UString::number(i);
            return smallIntCache[i];
        }

        FixedArray<CacheEntry<double>, cacheSize> doubleCache;
        FixedArray<CacheEntry<int>, cacheSize> intCache;
        FixedArray<CacheEntry<unsigned>, cacheSize> unsignedCache;
        FixedArray<UString, cacheSize> smallIntCache;
    };

}
# 41 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSGlobalData.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/SmallStrings.h" 1
# 33 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/SmallStrings.h"
namespace JSC {

    class HeapRootVisitor;
    class JSGlobalData;
    class JSString;
    class SmallStringsStorage;
    class SlotVisitor;

    static const unsigned maxSingleCharacterString = 0xFF;

    class SmallStrings {
        private: SmallStrings(const SmallStrings&); SmallStrings& operator=(const SmallStrings&);
    public:
        SmallStrings();
        ~SmallStrings();

        JSString* emptyString(JSGlobalData* globalData)
        {
            if (!m_emptyString)
                createEmptyString(globalData);
            return m_emptyString;
        }

        JSString* singleCharacterString(JSGlobalData* globalData, unsigned char character)
        {
            if (!m_singleCharacterStrings[character])
                createSingleCharacterString(globalData, character);
            return m_singleCharacterStrings[character];
        }

        StringImpl* singleCharacterStringRep(unsigned char character);

        void finalizeSmallStrings();
        void clear();

        unsigned count() const;

        JSString** singleCharacterStrings() { return &m_singleCharacterStrings[0]; }

    private:
        static const unsigned singleCharacterStringCount = maxSingleCharacterString + 1;

        void createEmptyString(JSGlobalData*);
        void createSingleCharacterString(JSGlobalData*, unsigned char);

        JSString* m_emptyString;
        JSString* m_singleCharacterStrings[singleCharacterStringCount];
        OwnPtr<SmallStringsStorage> m_storage;
    };

}
# 42 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSGlobalData.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/Terminator.h" 1
# 32 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/Terminator.h"
namespace JSC {

class Terminator {
public:
    Terminator() : m_shouldTerminate(false) { }

    void terminateSoon() { m_shouldTerminate = true; }
    bool shouldTerminate() const { return m_shouldTerminate; }

private:
    bool m_shouldTerminate;
};

}
# 43 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSGlobalData.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/TimeoutChecker.h" 1
# 34 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/TimeoutChecker.h"
namespace JSC {

    class ExecState;

    class TimeoutChecker {
    public:
        TimeoutChecker();

        void setTimeoutInterval(unsigned timeoutInterval) { m_timeoutInterval = timeoutInterval; }
        unsigned timeoutInterval() const { return m_timeoutInterval; }

        unsigned ticksUntilNextCheck() { return m_ticksUntilNextCheck; }

        void start()
        {
            if (!m_startCount)
                reset();
            ++m_startCount;
        }

        void stop()
        {
            ((void)0);
            --m_startCount;
        }

        void reset();

        bool didTimeOut(ExecState*);

    private:
        unsigned m_timeoutInterval;
        unsigned m_timeAtLastCheck;
        unsigned m_timeExecuting;
        unsigned m_startCount;
        unsigned m_ticksUntilNextCheck;
    };

}
# 44 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSGlobalData.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/WeakRandom.h" 1
# 56 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/WeakRandom.h"
namespace JSC {

class WeakRandom {
public:
    WeakRandom(unsigned seed)
        : m_low(seed ^ 0x49616E42)
        , m_high(seed)
    {
    }

    double get()
    {
        return advance() / ((2147483647 *2U +1U) + 1.0);
    }

    unsigned getUint32()
    {
        return advance();
    }

private:
    unsigned advance()
    {
        m_high = (m_high << 16) + (m_high >> 16);
        m_high += m_low;
        m_low += m_high;
        return m_high;
    }

    unsigned m_low;
    unsigned m_high;
};

}
# 45 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSGlobalData.h" 2
# 1 "./wtf/BumpPointerAllocator.h" 1
# 31 "./wtf/BumpPointerAllocator.h"
namespace WTF {



class BumpPointerPool {
public:
# 45 "./wtf/BumpPointerAllocator.h"
    BumpPointerPool* ensureCapacity(size_t size)
    {
        void* allocationEnd = static_cast<char*>(m_current) + size;
        ((void)0);
        if (allocationEnd <= static_cast<void*>(this))
            return this;
        return ensureCapacityCrossPool(this, size);
    }



    void* alloc(size_t size)
    {
        void* current = m_current;
        void* allocationEnd = static_cast<char*>(current) + size;
        ((void)0);
        ((void)0);
        m_current = allocationEnd;
        return current;
    }
# 79 "./wtf/BumpPointerAllocator.h"
    BumpPointerPool* dealloc(void* position)
    {
        if ((position >= m_start) && (position <= static_cast<void*>(this))) {
            ((void)0);
            m_current = position;
            return this;
        }
        return deallocCrossPool(this, position);
    }

private:

    void* operator new(size_t size, const PageAllocation& allocation)
    {
        ((void)0);
        return reinterpret_cast<char*>(reinterpret_cast<intptr_t>(allocation.base()) + allocation.size()) - size;
    }

    BumpPointerPool(const PageAllocation& allocation)
        : m_current(allocation.base())
        , m_start(allocation.base())
        , m_next(0)
        , m_previous(0)
        , m_allocation(allocation)
    {
    }

    static BumpPointerPool* create(size_t minimumCapacity = 0)
    {

        minimumCapacity += sizeof(BumpPointerPool);
        if (minimumCapacity < sizeof(BumpPointerPool))
            return 0;

        size_t poolSize = 0x1000;
        while (poolSize < minimumCapacity) {
            poolSize <<= 1;

            ((void)0);
            if (!poolSize)
                return 0;
        }

        PageAllocation allocation = PageAllocation::allocate(poolSize);
        if (!!allocation)
            return new(allocation) BumpPointerPool(allocation);
        return 0;
    }

    void shrink()
    {
        ((void)0);
        m_current = m_start;
        while (m_next) {
            BumpPointerPool* nextNext = m_next->m_next;
            m_next->destroy();
            m_next = nextNext;
        }
    }

    void destroy()
    {
        m_allocation.deallocate();
    }

    static BumpPointerPool* ensureCapacityCrossPool(BumpPointerPool* previousPool, size_t size)
    {

        ((void)0);
        ((void)0);
        ((void)0);
        BumpPointerPool* pool = previousPool->m_next;

        while (true) {
            if (!pool) {

                pool = BumpPointerPool::create(size);
                previousPool->m_next = pool;
                pool->m_previous = previousPool;
                return pool;
            }


            void* current = pool->m_current;
            void* allocationEnd = static_cast<char*>(current) + size;
            ((void)0);
            if (allocationEnd <= static_cast<void*>(pool))
                return pool;
        }
    }

    static BumpPointerPool* deallocCrossPool(BumpPointerPool* pool, void* position)
    {

        ((void)0);

        while (true) {

            pool->m_current = pool->m_start;
            pool = pool->m_previous;


            if (!pool)
                do { WTFReportBacktrace(); *(int *)(uintptr_t)0xbbadbeef = 0; __builtin_trap(); } while (false);

            if ((position >= pool->m_start) && (position <= static_cast<void*>(pool))) {
                ((void)0);
                pool->m_current = position;
                return pool;
            }
        }
    }

    void* m_current;
    void* m_start;
    BumpPointerPool* m_next;
    BumpPointerPool* m_previous;
    PageAllocation m_allocation;

    friend class BumpPointerAllocator;
};
# 216 "./wtf/BumpPointerAllocator.h"
class BumpPointerAllocator {
public:
    BumpPointerAllocator()
        : m_head(0)
    {
    }

    ~BumpPointerAllocator()
    {
        if (m_head)
            m_head->destroy();
    }

    BumpPointerPool* startAllocator()
    {
        if (!m_head)
            m_head = BumpPointerPool::create();
        return m_head;
    }

    void stopAllocator()
    {
        if (m_head)
            m_head->shrink();
    }

private:
    BumpPointerPool* m_head;
};

}

using WTF::BumpPointerAllocator;
# 46 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSGlobalData.h" 2



# 1 "./wtf/ThreadSpecific.h" 1
# 56 "./wtf/ThreadSpecific.h"
namespace WTF {







template<typename T> class ThreadSpecific {
    private: ThreadSpecific(const ThreadSpecific&); ThreadSpecific& operator=(const ThreadSpecific&);
public:
    ThreadSpecific();
    T* operator->();
    operator T*();
    T& operator*();

private:
# 81 "./wtf/ThreadSpecific.h"
    ~ThreadSpecific();

    T* get();
    void set(T*);
    void static destroy(void* ptr);


    struct Data {
        private: Data(const Data&); Data& operator=(const Data&);
    public:
        Data(T* value, ThreadSpecific<T>* owner) : value(value), owner(owner) {}




        T* value;
        ThreadSpecific<T>* owner;



    };



    pthread_key_t m_key;







};


template<typename T>
inline ThreadSpecific<T>::ThreadSpecific()
{
    int error = pthread_key_create(&m_key, destroy);
    if (error)
        do { WTFReportBacktrace(); *(int *)(uintptr_t)0xbbadbeef = 0; __builtin_trap(); } while (false);
}

template<typename T>
inline T* ThreadSpecific<T>::get()
{
    Data* data = static_cast<Data*>(pthread_getspecific(m_key));
    return data ? data->value : 0;
}

template<typename T>
inline void ThreadSpecific<T>::set(T* ptr)
{
    ((void)0);
    pthread_setspecific(m_key, new Data(ptr, this));
}
# 239 "./wtf/ThreadSpecific.h"
template<typename T>
inline void ThreadSpecific<T>::destroy(void* ptr)
{
    Data* data = static_cast<Data*>(ptr);




    pthread_setspecific(data->owner->m_key, ptr);
# 257 "./wtf/ThreadSpecific.h"
    data->value->~T();
    fastFree(data->value);


    pthread_setspecific(data->owner->m_key, 0);
# 273 "./wtf/ThreadSpecific.h"
    delete data;

}

template<typename T>
inline ThreadSpecific<T>::operator T*()
{
    T* ptr = static_cast<T*>(get());
    if (!ptr) {


        ptr = static_cast<T*>(fastZeroedMalloc(sizeof(T)));
        set(ptr);
        new (ptr) T;
    }
    return ptr;
}

template<typename T>
inline T* ThreadSpecific<T>::operator->()
{
    return operator T*();
}

template<typename T>
inline T& ThreadSpecific<T>::operator*()
{
    return *operator T*();
}

}
# 50 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSGlobalData.h" 2
# 1 "./wtf/WTFThreadData.h" 1
# 33 "./wtf/WTFThreadData.h"
# 1 "./wtf/StackBounds.h" 1
# 30 "./wtf/StackBounds.h"
namespace WTF {

class StackBounds {


    const static size_t s_defaultAvailabilityDelta = 4096;

public:
    StackBounds()
        : m_origin(0)
        , m_bound(0)
    {
    }

    static StackBounds currentThreadStackBounds()
    {
        StackBounds bounds;
        bounds.initialize();
        bounds.checkConsistency();
        return bounds;
    }

    void* origin() const
    {
        ((void)0);
        return m_origin;
    }

    void* current() const
    {
        checkConsistency();
        void* currentPosition = &currentPosition;
        return currentPosition;
    }

    void* recursionLimit(size_t minAvailableDelta = s_defaultAvailabilityDelta) const
    {
        checkConsistency();
        return isGrowingDownward()
            ? static_cast<char*>(m_bound) + minAvailableDelta
            : static_cast<char*>(m_bound) - minAvailableDelta;
    }

    bool recursionCheck(size_t minAvailableDelta = s_defaultAvailabilityDelta) const
    {
        checkConsistency();
        return isGrowingDownward()
            ? current() >= recursionLimit(minAvailableDelta)
            : current() <= recursionLimit(minAvailableDelta);
    }

private:
    void initialize();


    bool isGrowingDownward() const
    {
        ((void)0);



        return true;

    }

    void checkConsistency() const
    {







    }

    void* m_origin;
    void* m_bound;
};

}

using WTF::StackBounds;
# 34 "./wtf/WTFThreadData.h" 2
# 1 "./wtf/text/StringHash.h" 1
# 32 "./wtf/text/StringHash.h"
namespace WTF {
# 42 "./wtf/text/StringHash.h"
    struct StringHash {
        static unsigned hash(StringImpl* key) { return key->hash(); }
        static bool equal(const StringImpl* a, const StringImpl* b)
        {
            if (a == b)
                return true;
            if (!a || !b)
                return false;

            unsigned aLength = a->length();
            unsigned bLength = b->length();
            if (aLength != bLength)
                return false;
# 68 "./wtf/text/StringHash.h"
            const uint32_t* aChars = reinterpret_cast<const uint32_t*>(a->characters());
            const uint32_t* bChars = reinterpret_cast<const uint32_t*>(b->characters());

            unsigned halfLength = aLength >> 1;
            for (unsigned i = 0; i != halfLength; ++i)
                if (*aChars++ != *bChars++)
                    return false;

            if (aLength & 1 && *reinterpret_cast<const uint16_t*>(aChars) != *reinterpret_cast<const uint16_t*>(bChars))
                return false;

            return true;

        }

        static unsigned hash(const RefPtr<StringImpl>& key) { return key->hash(); }
        static bool equal(const RefPtr<StringImpl>& a, const RefPtr<StringImpl>& b)
        {
            return equal(a.get(), b.get());
        }

        static unsigned hash(const String& key) { return key.impl()->hash(); }
        static bool equal(const String& a, const String& b)
        {
            return equal(a.impl(), b.impl());
        }

        static const bool safeToCompareToEmptyOrDeleted = false;
    };

    class CaseFoldingHash {
    public:
        template<typename T> static inline UChar foldCase(T ch)
        {
            return WTF::Unicode::foldCase(ch);
        }

        static unsigned hash(const UChar* data, unsigned length)
        {
            return StringHasher::computeHash<UChar, foldCase<UChar> >(data, length);
        }

        static unsigned hash(StringImpl* str)
        {
            return hash(str->characters(), str->length());
        }

        static unsigned hash(const char* data, unsigned length)
        {
            return StringHasher::computeHash<char, foldCase<char> >(data, length);
        }

        static bool equal(const StringImpl* a, const StringImpl* b)
        {
            if (a == b)
                return true;
            if (!a || !b)
                return false;
            unsigned length = a->length();
            if (length != b->length())
                return false;
            return WTF::Unicode::umemcasecmp(a->characters(), b->characters(), length) == 0;
        }

        static unsigned hash(const RefPtr<StringImpl>& key)
        {
            return hash(key.get());
        }

        static bool equal(const RefPtr<StringImpl>& a, const RefPtr<StringImpl>& b)
        {
            return equal(a.get(), b.get());
        }

        static unsigned hash(const String& key)
        {
            return hash(key.impl());
        }
        static unsigned hash(const AtomicString& key)
        {
            return hash(key.impl());
        }
        static bool equal(const String& a, const String& b)
        {
            return equal(a.impl(), b.impl());
        }
        static bool equal(const AtomicString& a, const AtomicString& b)
        {
            return (a == b) || equal(a.impl(), b.impl());
        }

        static const bool safeToCompareToEmptyOrDeleted = false;
    };




    struct AlreadyHashed : IntHash<unsigned> {
        static unsigned hash(unsigned key) { return key; }





        static unsigned avoidDeletedValue(unsigned hash)
        {
            ((void)0);
            unsigned newHash = hash | (!(hash + 1) << 31);
            ((void)0);
            ((void)0);
            return newHash;
        }
    };

}

using WTF::StringHash;
using WTF::CaseFoldingHash;
using WTF::AlreadyHashed;
# 35 "./wtf/WTFThreadData.h" 2





namespace JSC {

typedef HashMap<const char*, RefPtr<StringImpl>, PtrHash<const char*> > LiteralIdentifierTable;

class IdentifierTable {
    public: void* operator new(size_t, void* p) { return p; } void* operator new[](size_t, void* p) { return p; } void* operator new(size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNew); return p; } void operator delete(void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNew); ::WTF::fastFree(p); } void* operator new[](size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNewArray); return p; } void operator delete[](void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNewArray); ::WTF::fastFree(p); } private: typedef int ThisIsHereToForceASemicolonAfterThisMacro;
public:
    ~IdentifierTable();

    std::pair<HashSet<StringImpl*>::iterator, bool> add(StringImpl* value);
    template<typename U, typename V>
    std::pair<HashSet<StringImpl*>::iterator, bool> add(U value);

    bool remove(StringImpl* r)
    {
        HashSet<StringImpl*>::iterator iter = m_table.find(r);
        if (iter == m_table.end())
            return false;
        m_table.remove(iter);
        return true;
    }

    LiteralIdentifierTable& literalTable() { return m_literalTable; }

private:
    HashSet<StringImpl*> m_table;
    LiteralIdentifierTable m_literalTable;
};

}


namespace WTF {

class AtomicStringTable;

typedef void (*AtomicStringTableDestructor)(AtomicStringTable*);

class WTFThreadData {
    private: WTFThreadData(const WTFThreadData&); WTFThreadData& operator=(const WTFThreadData&);
public:
    WTFThreadData();
    ~WTFThreadData();

    AtomicStringTable* atomicStringTable()
    {
        return m_atomicStringTable;
    }


    JSC::IdentifierTable* currentIdentifierTable()
    {
        return m_currentIdentifierTable;
    }

    JSC::IdentifierTable* setCurrentIdentifierTable(JSC::IdentifierTable* identifierTable)
    {
        JSC::IdentifierTable* oldIdentifierTable = m_currentIdentifierTable;
        m_currentIdentifierTable = identifierTable;
        return oldIdentifierTable;
    }

    void resetCurrentIdentifierTable()
    {
        m_currentIdentifierTable = m_defaultIdentifierTable;
    }

    const StackBounds& stack() const
    {
        return m_stackBounds;
    }


private:
    AtomicStringTable* m_atomicStringTable;
    AtomicStringTableDestructor m_atomicStringTableDestructor;


    JSC::IdentifierTable* m_defaultIdentifierTable;
    JSC::IdentifierTable* m_currentIdentifierTable;
    StackBounds m_stackBounds;


    static ThreadSpecific<WTFThreadData>* staticData;
    friend WTFThreadData& wtfThreadData();
    friend class AtomicStringTable;
};

inline WTFThreadData& wtfThreadData()
{






    if (!WTFThreadData::staticData)
        WTFThreadData::staticData = new ThreadSpecific<WTFThreadData>;
    return **WTFThreadData::staticData;
}

}

using WTF::WTFThreadData;
using WTF::wtfThreadData;
# 51 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSGlobalData.h" 2




struct OpaqueJSClass;
struct OpaqueJSClassContextData;

namespace JSC {

    class CodeBlock;
    class CommonIdentifiers;
    class HandleStack;
    class IdentifierTable;
    class Interpreter;
    class JSGlobalObject;
    class JSObject;
    class Lexer;
    class NativeExecutable;
    class Parser;
    class RegExpCache;
    class Stringifier;
    class Structure;
    class UString;




    struct HashTable;
    struct Instruction;

    struct DSTOffsetCache {
        DSTOffsetCache()
        {
            reset();
        }

        void reset()
        {
            offset = 0.0;
            start = 0.0;
            end = -1.0;
            increment = 0.0;
        }

        double offset;
        double start;
        double end;
        double increment;
    };

    enum ThreadStackType {
        ThreadStackTypeLarge,
        ThreadStackTypeSmall
    };

    class JSGlobalData : public RefCounted<JSGlobalData> {
    public:
# 116 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSGlobalData.h"
        enum GlobalDataType { Default, APIContextGroup, APIShared };

        struct ClientData {
            virtual ~ClientData() = 0;
        };

        bool isSharedInstance() { return globalDataType == APIShared; }
        bool usingAPI() { return globalDataType != Default; }
        static bool sharedInstanceExists();
        static JSGlobalData& sharedInstance();

        static PassRefPtr<JSGlobalData> create(ThreadStackType, HeapSize = SmallHeap);
        static PassRefPtr<JSGlobalData> createLeaked(ThreadStackType, HeapSize = SmallHeap);
        static PassRefPtr<JSGlobalData> createContextGroup(ThreadStackType, HeapSize = SmallHeap);
        ~JSGlobalData();

        void makeUsableFromMultipleThreads() { heap.machineThreads().makeUsableFromMultipleThreads(); }

        GlobalDataType globalDataType;
        ClientData* clientData;
        CallFrame* topCallFrame;

        const HashTable* arrayConstructorTable;
        const HashTable* arrayPrototypeTable;
        const HashTable* booleanPrototypeTable;
        const HashTable* dateTable;
        const HashTable* dateConstructorTable;
        const HashTable* errorPrototypeTable;
        const HashTable* globalObjectTable;
        const HashTable* jsonTable;
        const HashTable* mathTable;
        const HashTable* numberConstructorTable;
        const HashTable* numberPrototypeTable;
        const HashTable* objectConstructorTable;
        const HashTable* objectPrototypeTable;
        const HashTable* regExpTable;
        const HashTable* regExpConstructorTable;
        const HashTable* regExpPrototypeTable;
        const HashTable* stringTable;
        const HashTable* stringConstructorTable;

        Strong<Structure> structureStructure;
        Strong<Structure> debuggerActivationStructure;
        Strong<Structure> activationStructure;
        Strong<Structure> interruptedExecutionErrorStructure;
        Strong<Structure> terminatedExecutionErrorStructure;
        Strong<Structure> staticScopeStructure;
        Strong<Structure> strictEvalActivationStructure;
        Strong<Structure> stringStructure;
        Strong<Structure> notAnObjectStructure;
        Strong<Structure> propertyNameIteratorStructure;
        Strong<Structure> getterSetterStructure;
        Strong<Structure> apiWrapperStructure;
        Strong<Structure> scopeChainNodeStructure;
        Strong<Structure> executableStructure;
        Strong<Structure> nativeExecutableStructure;
        Strong<Structure> evalExecutableStructure;
        Strong<Structure> programExecutableStructure;
        Strong<Structure> functionExecutableStructure;
        Strong<Structure> regExpStructure;
        Strong<Structure> structureChainStructure;

        static void storeVPtrs();
        static void* jsFinalObjectVPtr;
        static void* jsArrayVPtr;
        static void* jsByteArrayVPtr;
        static void* jsStringVPtr;
        static void* jsFunctionVPtr;

        IdentifierTable* identifierTable;
        CommonIdentifiers* propertyNames;
        const MarkedArgumentBuffer* emptyList;
        SmallStrings smallStrings;
        NumericStrings numericStrings;
        DateInstanceCache dateInstanceCache;
        Vector<CodeBlock*> codeBlocksBeingCompiled;
        void startedCompiling(CodeBlock* codeBlock)
        {
            codeBlocksBeingCompiled.append(codeBlock);
        }

        void finishedCompiling(CodeBlock* codeBlock)
        {
            ((void)codeBlock);
            codeBlocksBeingCompiled.removeLast();
        }


        ExecutableAllocator executableAllocator;





        bool canUseJIT() { return true; }




        const StackBounds& stack()
        {
            return (globalDataType == Default)
                ? m_stack
                : wtfThreadData().stack();
        }

        Lexer* lexer;
        Parser* parser;
        Interpreter* interpreter;

        OwnPtr<JITThunks> jitStubs;
        MacroAssemblerCodeRef getCTIStub(ThunkGenerator generator)
        {
            return jitStubs->ctiStub(this, generator);
        }
        NativeExecutable* getHostFunction(NativeFunction, ThunkGenerator, DFG::Intrinsic);

        NativeExecutable* getHostFunction(NativeFunction, NativeFunction constructor);

        TimeoutChecker timeoutChecker;
        Terminator terminator;
        Heap heap;

        JSValue exception;

        ReturnAddressPtr exceptionLocation;
        JSValue hostCallReturnValue;




        Vector<void*> scratchBuffers;
        size_t sizeOfLastScratchBuffer;

        void* scratchBufferForSize(size_t size)
        {
            if (!size)
                return 0;

            if (size > sizeOfLastScratchBuffer) {




                sizeOfLastScratchBuffer = size * 2;

                scratchBuffers.append(fastMalloc(sizeOfLastScratchBuffer));
            }

            return scratchBuffers.last();
        }



        HashMap<OpaqueJSClass*, OpaqueJSClassContextData*> opaqueJSClassData;

        JSGlobalObject* dynamicGlobalObject;

        HashSet<JSObject*> stringRecursionCheckVisitedObjects;

        double cachedUTCOffset;
        DSTOffsetCache dstOffsetCache;

        UString cachedDateString;
        double cachedDateStringValue;

        int maxReentryDepth;

        RegExpCache* m_regExpCache;
        BumpPointerAllocator m_regExpAllocator;
# 296 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSGlobalData.h"
        CachedTranscendentalFunction<sin> cachedSin;

        void resetDateCache();

        void startSampling();
        void stopSampling();
        void dumpSampleData(ExecState* exec);
        void recompileAllJSFunctions();
        RegExpCache* regExpCache() { return m_regExpCache; }



        void dumpRegExpTrace();
        void clearBuiltinStructures();

        bool isCollectorBusy() { return heap.isBusy(); }
        void releaseExecutableMemory();
# 323 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSGlobalData.h"
    private:
        JSGlobalData(GlobalDataType, ThreadStackType, HeapSize);
        static JSGlobalData*& sharedInstanceInternal();
        void createNativeThunk();



        StackBounds m_stack;



    };
# 348 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSGlobalData.h"
}
# 27 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/CallFrame.h" 2

# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/RegisterFile.h" 1
# 38 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/RegisterFile.h"
namespace JSC {

    class ConservativeRoots;
    class JettisonedCodeBlocks;

    class RegisterFile {
        private: RegisterFile(const RegisterFile&); RegisterFile& operator=(const RegisterFile&);
    public:
        enum CallFrameHeaderEntry {
            CallFrameHeaderSize = 6,

            ArgumentCount = -6,
            CallerFrame = -5,
            Callee = -4,
            ScopeChain = -3,
            ReturnPC = -2,
            CodeBlock = -1,
        };

        enum { ProgramCodeThisRegister = -CallFrameHeaderSize - 1 };

        static const size_t defaultCapacity = 512 * 1024;
        static const size_t commitSize = 16 * 1024;

        static const ptrdiff_t maxExcessCapacity = 8 * 1024;

        RegisterFile(size_t capacity = defaultCapacity);
        ~RegisterFile();

        void gatherConservativeRoots(ConservativeRoots&);
        void gatherConservativeRoots(ConservativeRoots&, JettisonedCodeBlocks&);

        Register* begin() const { return static_cast<Register*>(m_reservation.base()); }
        Register* end() const { return m_end; }
        size_t size() const { return end() - begin(); }

        bool grow(Register* newEnd);
        void shrink(Register* newEnd);

        static size_t committedByteCount();
        static void initializeThreading();

        Register* const * addressOfEnd() const
        {
            return &m_end;
        }

    private:
        void releaseExcessCapacity();
        void addToCommittedByteCount(long);
        Register* m_end;
        Register* m_commitEnd;
        PageReservation m_reservation;
    };

    inline RegisterFile::RegisterFile(size_t capacity)
        : m_end(0)
    {
        ((void)0);

        m_reservation = PageReservation::reserve(roundUpAllocationSize(capacity * sizeof(Register), commitSize), OSAllocator::JSVMStackPages);
        m_end = static_cast<Register*>(m_reservation.base());
        m_commitEnd = static_cast<Register*>(m_reservation.base());
    }

    inline void RegisterFile::shrink(Register* newEnd)
    {
        if (newEnd >= m_end)
            return;
        m_end = newEnd;
        if (m_end == m_reservation.base() && (m_commitEnd - begin()) >= maxExcessCapacity)
            releaseExcessCapacity();
    }

    inline bool RegisterFile::grow(Register* newEnd)
    {
        if (newEnd <= m_end)
            return true;

        if (newEnd <= m_commitEnd) {
            m_end = newEnd;
            return true;
        }

        long delta = roundUpAllocationSize(reinterpret_cast<char*>(newEnd) - reinterpret_cast<char*>(m_commitEnd), commitSize);
        if (reinterpret_cast<char*>(m_commitEnd) + delta > static_cast<char*>(m_reservation.base()) + m_reservation.size())
            return false;

        m_reservation.commit(m_commitEnd, delta);
        addToCommittedByteCount(delta);
        m_commitEnd = reinterpret_cast<Register*>(reinterpret_cast<char*>(m_commitEnd) + delta);
        m_end = newEnd;
        return true;
    }

}
# 29 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/CallFrame.h" 2

namespace JSC {

    class Arguments;
    class JSActivation;
    class Interpreter;
    class ScopeChainNode;



    class ExecState : private Register {
    public:
        JSValue calleeAsValue() const { return this[RegisterFile::Callee].jsValue(); }
        JSObject* callee() const { return this[RegisterFile::Callee].function(); }
        CodeBlock* codeBlock() const { return this[RegisterFile::CodeBlock].Register::codeBlock(); }
        ScopeChainNode* scopeChain() const
        {
            ((void)0);
            return this[RegisterFile::ScopeChain].Register::scopeChain();
        }


        JSGlobalObject* dynamicGlobalObject();



        inline JSGlobalObject* lexicalGlobalObject() const;



        inline JSObject* globalThisValue() const;

        inline JSGlobalData& globalData() const;






        void clearException() { globalData().exception = JSValue(); }
        JSValue exception() const { return globalData().exception; }
        bool hadException() const { return globalData().exception; }

        const CommonIdentifiers& propertyNames() const { return *globalData().propertyNames; }
        const MarkedArgumentBuffer& emptyList() const { return *globalData().emptyList; }
        Interpreter* interpreter() { return globalData().interpreter; }
        Heap* heap() { return &globalData().heap; }



        static const HashTable* arrayConstructorTable(CallFrame* callFrame) { return callFrame->globalData().arrayConstructorTable; }
        static const HashTable* arrayPrototypeTable(CallFrame* callFrame) { return callFrame->globalData().arrayPrototypeTable; }
        static const HashTable* booleanPrototypeTable(CallFrame* callFrame) { return callFrame->globalData().booleanPrototypeTable; }
        static const HashTable* dateTable(CallFrame* callFrame) { return callFrame->globalData().dateTable; }
        static const HashTable* dateConstructorTable(CallFrame* callFrame) { return callFrame->globalData().dateConstructorTable; }
        static const HashTable* errorPrototypeTable(CallFrame* callFrame) { return callFrame->globalData().errorPrototypeTable; }
        static const HashTable* globalObjectTable(CallFrame* callFrame) { return callFrame->globalData().globalObjectTable; }
        static const HashTable* jsonTable(CallFrame* callFrame) { return callFrame->globalData().jsonTable; }
        static const HashTable* mathTable(CallFrame* callFrame) { return callFrame->globalData().mathTable; }
        static const HashTable* numberConstructorTable(CallFrame* callFrame) { return callFrame->globalData().numberConstructorTable; }
        static const HashTable* numberPrototypeTable(CallFrame* callFrame) { return callFrame->globalData().numberPrototypeTable; }
        static const HashTable* objectConstructorTable(CallFrame* callFrame) { return callFrame->globalData().objectConstructorTable; }
        static const HashTable* objectPrototypeTable(CallFrame* callFrame) { return callFrame->globalData().objectPrototypeTable; }
        static const HashTable* regExpTable(CallFrame* callFrame) { return callFrame->globalData().regExpTable; }
        static const HashTable* regExpConstructorTable(CallFrame* callFrame) { return callFrame->globalData().regExpConstructorTable; }
        static const HashTable* regExpPrototypeTable(CallFrame* callFrame) { return callFrame->globalData().regExpPrototypeTable; }
        static const HashTable* stringTable(CallFrame* callFrame) { return callFrame->globalData().stringTable; }
        static const HashTable* stringConstructorTable(CallFrame* callFrame) { return callFrame->globalData().stringConstructorTable; }

        static CallFrame* create(Register* callFrameBase) { return static_cast<CallFrame*>(callFrameBase); }
        Register* registers() { return this; }

        CallFrame& operator=(const Register& r) { *static_cast<Register*>(this) = r; return *this; }

        CallFrame* callerFrame() const { return this[RegisterFile::CallerFrame].callFrame(); }

        ReturnAddressPtr returnPC() const { return ReturnAddressPtr(this[RegisterFile::ReturnPC].vPC()); }


        InlineCallFrame* inlineCallFrame() const { return this[RegisterFile::ReturnPC].inlineCallFrame(); }





        void setCallerFrame(CallFrame* callerFrame) { static_cast<Register*>(this)[RegisterFile::CallerFrame] = callerFrame; }
        void setScopeChain(ScopeChainNode* scopeChain) { static_cast<Register*>(this)[RegisterFile::ScopeChain] = scopeChain; }

        inline __attribute__((__always_inline__)) void init(CodeBlock* codeBlock, Instruction* vPC, ScopeChainNode* scopeChain,
            CallFrame* callerFrame, int argc, JSObject* callee)
        {
            ((void)0);
            ((void)0);

            setCodeBlock(codeBlock);
            setScopeChain(scopeChain);
            setCallerFrame(callerFrame);
            setReturnPC(vPC);
            setArgumentCountIncludingThis(argc);
            setCallee(callee);
        }


        inline Register& r(int);

        inline Register& uncheckedR(int);


        int hostThisRegister() { return -RegisterFile::CallFrameHeaderSize - argumentCountIncludingThis(); }
        JSValue hostThisValue() { return this[hostThisRegister()].jsValue(); }
        size_t argumentCount() const { return argumentCountIncludingThis() - 1; }
        size_t argumentCountIncludingThis() const { return this[RegisterFile::ArgumentCount].i(); }
        JSValue argument(int argumentNumber)
        {
            int argumentIndex = -RegisterFile::CallFrameHeaderSize - this[RegisterFile::ArgumentCount].i() + argumentNumber + 1;
            if (argumentIndex >= -RegisterFile::CallFrameHeaderSize)
                return jsUndefined();
            return this[argumentIndex].jsValue();
        }

        static CallFrame* noCaller() { return reinterpret_cast<CallFrame*>(HostCallFrameFlag); }

        bool hasHostCallFrameFlag() const { return reinterpret_cast<intptr_t>(this) & HostCallFrameFlag; }
        CallFrame* addHostCallFrameFlag() const { return reinterpret_cast<CallFrame*>(reinterpret_cast<intptr_t>(this) | HostCallFrameFlag); }
        CallFrame* removeHostCallFrameFlag() { return reinterpret_cast<CallFrame*>(reinterpret_cast<intptr_t>(this) & ~HostCallFrameFlag); }

        void setArgumentCountIncludingThis(int count) { static_cast<Register*>(this)[RegisterFile::ArgumentCount] = Register::withInt(count); }
        void setCallee(JSObject* callee) { static_cast<Register*>(this)[RegisterFile::Callee] = Register::withCallee(callee); }
        void setCodeBlock(CodeBlock* codeBlock) { static_cast<Register*>(this)[RegisterFile::CodeBlock] = codeBlock; }
        void setReturnPC(void* value) { static_cast<Register*>(this)[RegisterFile::ReturnPC] = (Instruction*)value; }


        bool isInlineCallFrame();

        void setInlineCallFrame(InlineCallFrame* inlineCallFrame) { static_cast<Register*>(this)[RegisterFile::ReturnPC] = inlineCallFrame; }



        CallFrame* trueCallerFrame();






    private:
        static const intptr_t HostCallFrameFlag = 1;




        bool isInlineCallFrameSlow();
        CallFrame* trueCallerFrameSlow();

        ExecState();
        ~ExecState();
    };

}
# 26 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/ArgList.h" 2

# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/WriteBarrier.h" 1
# 34 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/WriteBarrier.h"
namespace JSC {

class JSCell;
class JSGlobalData;
class JSGlobalObject;

template<class T> class WriteBarrierBase;
template<> class WriteBarrierBase<JSValue>;

void slowValidateCell(JSCell*);
void slowValidateCell(JSGlobalObject*);
# 62 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/WriteBarrier.h"
template<class T> inline void validateCell(T)
{
}



template <typename T> class WriteBarrierBase {
public:
    void set(JSGlobalData& globalData, const JSCell* owner, T* value)
    {
        ((void)0);
        validateCell(value);
        setEarlyValue(globalData, owner, value);
    }

    void setMayBeNull(JSGlobalData& globalData, const JSCell* owner, T* value)
    {
        if (value)
            validateCell(value);
        setEarlyValue(globalData, owner, value);
    }



    void setEarlyValue(JSGlobalData&, const JSCell* owner, T* value)
    {
        this->m_cell = reinterpret_cast<JSCell*>(value);
        Heap::writeBarrier(owner, this->m_cell);
    }

    T* get() const
    {
        if (m_cell)
            validateCell(m_cell);
        return reinterpret_cast<T*>(m_cell);
    }

    T* operator*() const
    {
        ((void)0);
        validateCell<T>(static_cast<T*>(m_cell));
        return static_cast<T*>(m_cell);
    }

    T* operator->() const
    {
        ((void)0);
        validateCell(static_cast<T*>(m_cell));
        return static_cast<T*>(m_cell);
    }

    void clear() { m_cell = 0; }

    JSCell** slot() { return &m_cell; }

    typedef T* (WriteBarrierBase::*UnspecifiedBoolType);
    operator UnspecifiedBoolType*() const { return m_cell ? reinterpret_cast<UnspecifiedBoolType*>(1) : 0; }

    bool operator!() const { return !m_cell; }

    void setWithoutWriteBarrier(T* value)
    {



        this->m_cell = reinterpret_cast<JSCell*>(value);
    }





private:
    JSCell* m_cell;
};

template <> class WriteBarrierBase<Unknown> {
public:
    void set(JSGlobalData&, const JSCell* owner, JSValue value)
    {
        m_value = JSValue::encode(value);
        Heap::writeBarrier(owner, value);
    }

    void setWithoutWriteBarrier(JSValue value)
    {
        m_value = JSValue::encode(value);
    }

    JSValue get() const
    {
        return JSValue::decode(m_value);
    }
    void clear() { m_value = JSValue::encode(JSValue()); }
    void setUndefined() { m_value = JSValue::encode(jsUndefined()); }
    bool isNumber() const { return get().isNumber(); }
    bool isObject() const { return get().isObject(); }
    bool isNull() const { return get().isNull(); }
    bool isGetterSetter() const { return get().isGetterSetter(); }

    JSValue* slot()
    {
        union {
            EncodedJSValue* v;
            JSValue* slot;
        } u;
        u.v = &m_value;
        return u.slot;
    }

    typedef JSValue (WriteBarrierBase::*UnspecifiedBoolType);
    operator UnspecifiedBoolType*() const { return get() ? reinterpret_cast<UnspecifiedBoolType*>(1) : 0; }
    bool operator!() const { return !get(); }

private:
    EncodedJSValue m_value;
};

template <typename T> class WriteBarrier : public WriteBarrierBase<T> {
public:
    WriteBarrier()
    {
        this->setWithoutWriteBarrier(0);
    }

    WriteBarrier(JSGlobalData& globalData, const JSCell* owner, T* value)
    {
        this->set(globalData, owner, value);
    }

    enum MayBeNullTag { MayBeNull };
    WriteBarrier(JSGlobalData& globalData, const JSCell* owner, T* value, MayBeNullTag)
    {
        this->setMayBeNull(globalData, owner, value);
    }
};

template <> class WriteBarrier<Unknown> : public WriteBarrierBase<Unknown> {
public:
    WriteBarrier()
    {
        this->setWithoutWriteBarrier(JSValue());
    }

    WriteBarrier(JSGlobalData& globalData, const JSCell* owner, JSValue value)
    {
        this->set(globalData, owner, value);
    }
};

template <typename U, typename V> inline bool operator==(const WriteBarrierBase<U>& lhs, const WriteBarrierBase<V>& rhs)
{
    return lhs.get() == rhs.get();
}



template<typename T> inline void MarkStack::append(WriteBarrierBase<T>* slot)
{
    internalAppend(*slot->slot());
}

inline __attribute__((__always_inline__)) void MarkStack::appendValues(WriteBarrierBase<Unknown>* barriers, size_t count)
{
    append(barriers->slot(), count);
}

}
# 28 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/ArgList.h" 2



namespace JSC {

    class SlotVisitor;

    class MarkedArgumentBuffer {
        private: MarkedArgumentBuffer(const MarkedArgumentBuffer&); MarkedArgumentBuffer& operator=(const MarkedArgumentBuffer&);
    private:
        static const unsigned inlineCapacity = 8;
        typedef Vector<Register, inlineCapacity> VectorType;
        typedef HashSet<MarkedArgumentBuffer*> ListSet;

    public:
        typedef VectorType::iterator iterator;
        typedef VectorType::const_iterator const_iterator;



        MarkedArgumentBuffer()
            : m_isUsingInlineBuffer(true)
            , m_markSet(0)



        {
            m_buffer = m_vector.data();
            m_size = 0;
        }


        MarkedArgumentBuffer(Register* buffer, size_t size)
            : m_buffer(buffer)
            , m_size(size)
            , m_isUsingInlineBuffer(true)
            , m_markSet(0)



        {
        }

        void initialize(WriteBarrier<Unknown>* buffer, size_t size)
        {
            ((void)0);
            ((void)0);

            m_buffer = reinterpret_cast<Register*>(buffer);
            m_size = size;



        }

        ~MarkedArgumentBuffer()
        {
            if (m_markSet)
                m_markSet->remove(this);
        }

        size_t size() const { return m_size; }
        bool isEmpty() const { return !m_size; }

        JSValue at(size_t i) const
        {
            if (i < m_size)
                return m_buffer[i].jsValue();
            return jsUndefined();
        }

        void clear()
        {
            m_vector.clear();
            m_buffer = 0;
            m_size = 0;
        }

        void append(JSValue v)
        {
            ((void)0);

            if (m_isUsingInlineBuffer && m_size < inlineCapacity) {
                m_vector.uncheckedAppend(v);
                ++m_size;
            } else {


                slowAppend(v);
                ++m_size;
                m_isUsingInlineBuffer = false;
            }
        }

        void removeLast()
        {
            ((void)0);
            m_size--;
            m_vector.removeLast();
        }

        JSValue last()
        {
            ((void)0);
            return m_buffer[m_size - 1].jsValue();
        }

        iterator begin() { return m_buffer; }
        iterator end() { return m_buffer + m_size; }

        const_iterator begin() const { return m_buffer; }
        const_iterator end() const { return m_buffer + m_size; }

        static void markLists(HeapRootVisitor&, ListSet&);

    private:
        void slowAppend(JSValue);

        Register* m_buffer;
        size_t m_size;
        bool m_isUsingInlineBuffer;

        VectorType m_vector;
        ListSet* m_markSet;




    private:

        friend class JSGlobalData;

        void* operator new(size_t size)
        {
            return fastMalloc(size);
        }
        void operator delete(void* p)
        {
            fastFree(p);
        }

        void* operator new[](size_t);
        void operator delete[](void*);

        void* operator new(size_t, void*);
        void operator delete(void*, size_t);
    };

    class ArgList {
        friend class JIT;
    public:
        typedef JSValue* iterator;
        typedef const JSValue* const_iterator;

        ArgList()
            : m_args(0)
            , m_argCount(0)
        {
        }

        ArgList(ExecState* exec)
            : m_args(reinterpret_cast<JSValue*>(&exec[exec->hostThisRegister() + 1]))
            , m_argCount(exec->argumentCount())
        {
        }

        ArgList(JSValue* args, unsigned argCount)
            : m_args(args)
            , m_argCount(argCount)
        {
        }

        ArgList(Register* args, int argCount)
            : m_args(reinterpret_cast<JSValue*>(args))
            , m_argCount(argCount)
        {
            ((void)0);
        }

        ArgList(const MarkedArgumentBuffer& args)
            : m_args(reinterpret_cast<JSValue*>(const_cast<Register*>(args.begin())))
            , m_argCount(args.size())
        {
        }

        JSValue at(size_t idx) const
        {
            if (idx < m_argCount)
                return m_args[idx];
            return jsUndefined();
        }

        bool isEmpty() const { return !m_argCount; }

        size_t size() const { return m_argCount; }

        iterator begin() { return m_args; }
        iterator end() { return m_args + m_argCount; }

        const_iterator begin() const { return m_args; }
        const_iterator end() const { return m_args + m_argCount; }

        void getSlice(int startIndex, ArgList& result) const;
    private:
        JSValue* m_args;
        size_t m_argCount;
    };

}
# 33 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Interpreter.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSCell.h" 1
# 28 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSCell.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/ConstructData.h" 1
# 35 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/ConstructData.h"
namespace JSC {

    class ArgList;
    class ExecState;
    class FunctionExecutable;
    class JSObject;
    class ScopeChainNode;

    enum ConstructType {
        ConstructTypeNone,
        ConstructTypeHost,
        ConstructTypeJS
    };

    union ConstructData {
        struct {
            NativeFunction function;
        } native;
        struct {
            FunctionExecutable* functionExecutable;
            ScopeChainNode* scopeChain;
        } js;
    };

    JSObject* construct(ExecState*, JSValue constructor, ConstructType, const ConstructData&, const ArgList&);

}
# 29 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSCell.h" 2

# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSLock.h" 1
# 27 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSLock.h"
namespace JSC {
# 51 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSLock.h"
    class ExecState;
    class JSGlobalData;

    enum JSLockBehavior { SilenceAssertionsOnly, LockForReal };

    class JSLock {
        private: JSLock(const JSLock&); JSLock& operator=(const JSLock&);
    public:
        JSLock(ExecState*);
        JSLock(JSGlobalData*);

        JSLock(JSLockBehavior lockBehavior)
            : m_lockBehavior(lockBehavior)
        {


            if (lockBehavior == SilenceAssertionsOnly)
                return;

            lock(lockBehavior);
        }

        ~JSLock()
        {


            if (m_lockBehavior == SilenceAssertionsOnly)
                return;

            unlock(m_lockBehavior);
        }

        static void lock(JSLockBehavior);
        static void unlock(JSLockBehavior);
        static void lock(ExecState*);
        static void unlock(ExecState*);

        static intptr_t lockCount();
        static bool currentThreadIsHoldingLock();

        JSLockBehavior m_lockBehavior;

        class DropAllLocks {
            private: DropAllLocks(const DropAllLocks&); DropAllLocks& operator=(const DropAllLocks&);
        public:
            DropAllLocks(ExecState* exec);
            DropAllLocks(JSLockBehavior);
            ~DropAllLocks();

        private:
            intptr_t m_lockCount;
            JSLockBehavior m_lockBehavior;
        };
    };

}
# 31 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSCell.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSValueInlineMethods.h" 1
# 31 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSValueInlineMethods.h"
namespace JSC {

    inline __attribute__((__always_inline__)) int32_t JSValue::toInt32(ExecState* exec) const
    {
        if (isInt32())
            return asInt32();
        return JSC::toInt32(toNumber(exec));
    }

    inline uint32_t JSValue::toUInt32(ExecState* exec) const
    {

        return toInt32(exec);
    }

    inline bool JSValue::isUInt32() const
    {
        return isInt32() && asInt32() >= 0;
    }

    inline uint32_t JSValue::asUInt32() const
    {
        ((void)0);
        return asInt32();
    }

    inline double JSValue::asNumber() const
    {
        ((void)0);
        return isInt32() ? asInt32() : asDouble();
    }

    inline JSValue jsNaN()
    {
        return JSValue(std::numeric_limits<double>::quiet_NaN());
    }

    inline JSValue::JSValue(char i)
    {
        *this = JSValue(static_cast<int32_t>(i));
    }

    inline JSValue::JSValue(unsigned char i)
    {
        *this = JSValue(static_cast<int32_t>(i));
    }

    inline JSValue::JSValue(short i)
    {
        *this = JSValue(static_cast<int32_t>(i));
    }

    inline JSValue::JSValue(unsigned short i)
    {
        *this = JSValue(static_cast<int32_t>(i));
    }

    inline JSValue::JSValue(unsigned i)
    {
        if (static_cast<int32_t>(i) < 0) {
            *this = JSValue(EncodeAsDouble, static_cast<double>(i));
            return;
        }
        *this = JSValue(static_cast<int32_t>(i));
    }

    inline JSValue::JSValue(long i)
    {
        if (static_cast<int32_t>(i) != i) {
            *this = JSValue(EncodeAsDouble, static_cast<double>(i));
            return;
        }
        *this = JSValue(static_cast<int32_t>(i));
    }

    inline JSValue::JSValue(unsigned long i)
    {
        if (static_cast<uint32_t>(i) != i) {
            *this = JSValue(EncodeAsDouble, static_cast<double>(i));
            return;
        }
        *this = JSValue(static_cast<uint32_t>(i));
    }

    inline JSValue::JSValue(long long i)
    {
        if (static_cast<int32_t>(i) != i) {
            *this = JSValue(EncodeAsDouble, static_cast<double>(i));
            return;
        }
        *this = JSValue(static_cast<int32_t>(i));
    }

    inline JSValue::JSValue(unsigned long long i)
    {
        if (static_cast<uint32_t>(i) != i) {
            *this = JSValue(EncodeAsDouble, static_cast<double>(i));
            return;
        }
        *this = JSValue(static_cast<uint32_t>(i));
    }

    inline JSValue::JSValue(double d)
    {
        const int32_t asInt32 = static_cast<int32_t>(d);
        if (asInt32 != d || (!asInt32 && signbit(d))) {
            *this = JSValue(EncodeAsDouble, d);
            return;
        }
        *this = JSValue(static_cast<int32_t>(d));
    }
# 324 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSValueInlineMethods.h"
    inline EncodedJSValue JSValue::encode(JSValue value)
    {
        return value.u.ptr;
    }

    inline JSValue JSValue::decode(EncodedJSValue ptr)
    {
        return JSValue(reinterpret_cast<JSCell*>(ptr));
    }


    inline JSValue::JSValue()
    {
        u.asInt64 = 0x0ll;
    }


    inline JSValue::JSValue(HashTableDeletedValueTag)
    {
        u.asInt64 = 0x4ll;
    }

    inline JSValue::JSValue(JSCell* ptr)
    {
        u.ptr = ptr;
    }

    inline JSValue::JSValue(const JSCell* ptr)
    {
        u.ptr = const_cast<JSCell*>(ptr);
    }

    inline JSValue::operator bool() const
    {
        return u.ptr;
    }

    inline bool JSValue::operator==(const JSValue& other) const
    {
        return u.ptr == other.u.ptr;
    }

    inline bool JSValue::operator!=(const JSValue& other) const
    {
        return u.ptr != other.u.ptr;
    }

    inline bool JSValue::isUndefined() const
    {
        return asValue() == JSValue(JSUndefined);
    }

    inline bool JSValue::isNull() const
    {
        return asValue() == JSValue(JSNull);
    }

    inline bool JSValue::isTrue() const
    {
        return asValue() == JSValue(JSTrue);
    }

    inline bool JSValue::isFalse() const
    {
        return asValue() == JSValue(JSFalse);
    }

    inline bool JSValue::asBoolean() const
    {
        ((void)0);
        return asValue() == JSValue(JSTrue);
    }

    inline int32_t JSValue::asInt32() const
    {
        ((void)0);
        return static_cast<int32_t>(u.asInt64);
    }

    inline bool JSValue::isDouble() const
    {
        return isNumber() && !isInt32();
    }

    inline JSValue::JSValue(JSNullTag)
    {
        u.asInt64 = (0x2ll);
    }

    inline JSValue::JSValue(JSUndefinedTag)
    {
        u.asInt64 = (0x2ll | 0x8ll);
    }

    inline JSValue::JSValue(JSTrueTag)
    {
        u.asInt64 = (0x2ll | 0x4ll | true);
    }

    inline JSValue::JSValue(JSFalseTag)
    {
        u.asInt64 = (0x2ll | 0x4ll | false);
    }

    inline bool JSValue::isUndefinedOrNull() const
    {

        return (u.asInt64 & ~0x8ll) == (0x2ll);
    }

    inline bool JSValue::isBoolean() const
    {
        return (u.asInt64 & ~1) == (0x2ll | 0x4ll | false);
    }

    inline bool JSValue::isCell() const
    {
        return !(u.asInt64 & (0xffff000000000000ll | 0x2ll));
    }

    inline bool JSValue::isInt32() const
    {
        return (u.asInt64 & 0xffff000000000000ll) == 0xffff000000000000ll;
    }

    inline intptr_t reinterpretDoubleToIntptr(double value)
    {
        return bitwise_cast<intptr_t>(value);
    }
    inline double reinterpretIntptrToDouble(intptr_t value)
    {
        return bitwise_cast<double>(value);
    }

    inline __attribute__((__always_inline__)) JSValue::JSValue(EncodeAsDoubleTag, double d)
    {
        u.asInt64 = reinterpretDoubleToIntptr(d) + 0x1000000000000ll;
    }

    inline JSValue::JSValue(int i)
    {
        u.asInt64 = 0xffff000000000000ll | static_cast<uint32_t>(i);
    }

    inline double JSValue::asDouble() const
    {
        return reinterpretIntptrToDouble(u.asInt64 - 0x1000000000000ll);
    }

    inline bool JSValue::isNumber() const
    {
        return u.asInt64 & 0xffff000000000000ll;
    }

    inline __attribute__((__always_inline__)) JSCell* JSValue::asCell() const
    {
        ((void)0);
        return u.ptr;
    }



}
# 32 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSCell.h" 2




namespace JSC {

    class JSGlobalObject;
    class Structure;

    class JSCell {
        friend class JSValue;
        friend class MarkedBlock;

    public:
        enum CreatingEarlyCellTag { CreatingEarlyCell };
        JSCell(CreatingEarlyCellTag);

        enum VPtrStealingHackType { VPtrStealingHack };
        explicit JSCell(VPtrStealingHackType) { }

    public:
        void* operator new(size_t, void* placementNewDestination) { return placementNewDestination; }

    protected:
        JSCell(JSGlobalData&, Structure*);
        virtual ~JSCell();

    public:

        bool isString() const;
        bool isObject() const;
        bool isGetterSetter() const;
        bool inherits(const ClassInfo*) const;
        bool isAPIValueWrapper() const;

        Structure* structure() const;
        void setStructure(JSGlobalData&, Structure*);
        void clearStructure() { m_structure.clear(); }


        bool getString(ExecState* exec, UString&) const;
        UString getString(ExecState* exec) const;
        JSObject* getObject();
        const JSObject* getObject() const;

        static CallType getCallData(JSCell*, CallData&);
        static ConstructType getConstructData(JSCell*, ConstructData&);


        JSValue toPrimitive(ExecState*, PreferredPrimitiveType) const;
        bool getPrimitiveNumber(ExecState*, double& number, JSValue&) const;
        bool toBoolean(ExecState*) const;
        double toNumber(ExecState*) const;
        UString toString(ExecState*) const;
        JSObject* toObject(ExecState*, JSGlobalObject*) const;

        static void visitChildren(JSCell*, SlotVisitor&);


        const ClassInfo* classInfo() const;
        const MethodTable* methodTable() const;
        static void put(JSCell*, ExecState*, const Identifier& propertyName, JSValue, PutPropertySlot&);
        static void putByIndex(JSCell*, ExecState*, unsigned propertyName, JSValue);

        static bool deleteProperty(JSCell*, ExecState*, const Identifier& propertyName);
        static bool deletePropertyByIndex(JSCell*, ExecState*, unsigned propertyName);

        virtual JSObject* toThisObject(ExecState*) const;

        void* vptr() const { ((void)0); return *reinterpret_cast<void* const*>(this); }
        void setVPtr(void* vptr) { *reinterpret_cast<void**>(this) = vptr; ((void)0); }
        void zap() { *reinterpret_cast<uintptr_t**>(this) = 0; }
        bool isZapped() const { return !*reinterpret_cast<uintptr_t* const*>(this); }





        bool fastGetOwnPropertySlot(ExecState*, const Identifier& propertyName, PropertySlot&);
        JSValue fastGetOwnProperty(ExecState*, const UString&);

        static ptrdiff_t structureOffset()
        {
            return (reinterpret_cast<ptrdiff_t>(&(reinterpret_cast<JSCell*>(0x4000)->m_structure)) - 0x4000);
        }

        void* structureAddress()
        {
            return &m_structure;
        }





    protected:

        void finishCreation(JSGlobalData&);
        void finishCreation(JSGlobalData&, Structure*, CreatingEarlyCellTag);


        static bool getOwnPropertySlot(JSCell*, ExecState*, const Identifier& propertyName, PropertySlot&);
        static bool getOwnPropertySlotByIndex(JSCell*, ExecState*, unsigned propertyName, PropertySlot&);

    private:
        WriteBarrier<Structure> m_structure;
    };

    inline JSCell::JSCell(JSGlobalData& globalData, Structure* structure)
        : m_structure(globalData, this, structure)
    {
    }

    inline JSCell::JSCell(CreatingEarlyCellTag)
    {
    }

    inline void JSCell::finishCreation(JSGlobalData& globalData)
    {




        (void)globalData;

        ((void)0);
    }

    inline void JSCell::finishCreation(JSGlobalData& globalData, Structure* structure, CreatingEarlyCellTag)
    {





            m_structure.setEarlyValue(globalData, this, structure);

        ((void)0);
    }

    inline JSCell::~JSCell()
    {
    }

    inline Structure* JSCell::structure() const
    {
        return m_structure.get();
    }

    inline void JSCell::visitChildren(JSCell* cell, SlotVisitor& visitor)
    {
        JSCell* thisObject = static_cast<JSCell*>(cell);
        visitor.append(&thisObject->m_structure);
    }



    inline bool JSValue::isString() const
    {
        return isCell() && asCell()->isString();
    }

    inline bool JSValue::isPrimitive() const
    {
        return !isCell() || asCell()->isString();
    }

    inline bool JSValue::isGetterSetter() const
    {
        return isCell() && asCell()->isGetterSetter();
    }

    inline bool JSValue::isObject() const
    {
        return isCell() && asCell()->isObject();
    }

    inline bool JSValue::getString(ExecState* exec, UString& s) const
    {
        return isCell() && asCell()->getString(exec, s);
    }

    inline UString JSValue::getString(ExecState* exec) const
    {
        return isCell() ? asCell()->getString(exec) : UString();
    }

    template <typename Base> UString HandleConverter<Base, Unknown>::getString(ExecState* exec) const
    {
        return jsValue().getString(exec);
    }

    inline JSObject* JSValue::getObject() const
    {
        return isCell() ? asCell()->getObject() : 0;
    }

    inline __attribute__((__always_inline__)) bool JSValue::getUInt32(uint32_t& v) const
    {
        if (isInt32()) {
            int32_t i = asInt32();
            v = static_cast<uint32_t>(i);
            return i >= 0;
        }
        if (isDouble()) {
            double d = asDouble();
            v = static_cast<uint32_t>(d);
            return v == d;
        }
        return false;
    }

    inline JSValue JSValue::toPrimitive(ExecState* exec, PreferredPrimitiveType preferredType) const
    {
        return isCell() ? asCell()->toPrimitive(exec, preferredType) : asValue();
    }

    inline bool JSValue::getPrimitiveNumber(ExecState* exec, double& number, JSValue& value)
    {
        if (isInt32()) {
            number = asInt32();
            value = *this;
            return true;
        }
        if (isDouble()) {
            number = asDouble();
            value = *this;
            return true;
        }
        if (isCell())
            return asCell()->getPrimitiveNumber(exec, number, value);
        if (isTrue()) {
            number = 1.0;
            value = *this;
            return true;
        }
        if (isFalse() || isNull()) {
            number = 0.0;
            value = *this;
            return true;
        }
        ((void)0);
        number = std::numeric_limits<double>::quiet_NaN();
        value = *this;
        return true;
    }

    inline __attribute__((__always_inline__)) double JSValue::toNumber(ExecState* exec) const
    {
        if (isInt32())
            return asInt32();
        if (isDouble())
            return asDouble();
        return toNumberSlowCase(exec);
    }

    inline JSObject* JSValue::toObject(ExecState* exec) const
    {
        return isCell() ? asCell()->toObject(exec, exec->lexicalGlobalObject()) : toObjectSlowCase(exec, exec->lexicalGlobalObject());
    }

    inline JSObject* JSValue::toObject(ExecState* exec, JSGlobalObject* globalObject) const
    {
        return isCell() ? asCell()->toObject(exec, globalObject) : toObjectSlowCase(exec, globalObject);
    }

    inline JSObject* JSValue::toThisObject(ExecState* exec) const
    {
        return isCell() ? asCell()->toThisObject(exec) : toThisObjectSlowCase(exec);
    }

    template <typename T> void* allocateCell(Heap& heap)
    {





        JSCell* result = static_cast<JSCell*>(heap.allocate(sizeof(T)));
        result->clearStructure();
        return result;
    }

    inline bool isZapped(const JSCell* cell)
    {
        return cell->isZapped();
    }

}
# 34 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Interpreter.h" 2

# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSObject.h" 1
# 27 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSObject.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/ClassInfo.h" 1
# 29 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/ClassInfo.h"
namespace JSC {

    class HashEntry;
    struct HashTable;

    struct MethodTable {
        typedef void (*VisitChildrenFunctionPtr)(JSCell*, SlotVisitor&);
        VisitChildrenFunctionPtr visitChildren;

        typedef CallType (*GetCallDataFunctionPtr)(JSCell*, CallData&);
        GetCallDataFunctionPtr getCallData;

        typedef ConstructType (*GetConstructDataFunctionPtr)(JSCell*, ConstructData&);
        GetConstructDataFunctionPtr getConstructData;

        typedef void (*PutFunctionPtr)(JSCell*, ExecState*, const Identifier& propertyName, JSValue, PutPropertySlot&);
        PutFunctionPtr put;

        typedef void (*PutByIndexFunctionPtr)(JSCell*, ExecState*, unsigned propertyName, JSValue);
        PutByIndexFunctionPtr putByIndex;

        typedef bool (*DeletePropertyFunctionPtr)(JSCell*, ExecState*, const Identifier&);
        DeletePropertyFunctionPtr deleteProperty;

        typedef bool (*DeletePropertyByIndexFunctionPtr)(JSCell*, ExecState*, unsigned);
        DeletePropertyByIndexFunctionPtr deletePropertyByIndex;

        typedef bool (*GetOwnPropertySlotFunctionPtr)(JSCell*, ExecState*, const Identifier&, PropertySlot&);
        GetOwnPropertySlotFunctionPtr getOwnPropertySlot;

        typedef bool (*GetOwnPropertySlotByIndexFunctionPtr)(JSCell*, ExecState*, unsigned, PropertySlot&);
        GetOwnPropertySlotByIndexFunctionPtr getOwnPropertySlotByIndex;
    };
# 76 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/ClassInfo.h"
    struct ClassInfo {



        const char* className;





        const ClassInfo* parentClass;




        const HashTable* propHashTable(ExecState* exec) const
        {
            if (classPropHashTableGetterFunction)
                return classPropHashTableGetterFunction(exec);
            return staticPropHashTable;
        }

        bool isSubClassOf(const ClassInfo* other) const
        {
            for (const ClassInfo* ci = this; ci; ci = ci->parentClass) {
                if (ci == other)
                    return true;
            }
            return false;
        }

        bool hasStaticProperties() const
        {
            for (const ClassInfo* ci = this; ci; ci = ci->parentClass) {
                if (ci->staticPropHashTable || ci->classPropHashTableGetterFunction)
                    return true;
            }
            return false;
        }

        const HashTable* staticPropHashTable;
        typedef const HashTable* (*ClassPropHashTableGetterFunction)(ExecState*);
        const ClassPropHashTableGetterFunction classPropHashTableGetterFunction;

        MethodTable methodTable;

        size_t cellSize;
    };

}
# 28 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSObject.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/CommonIdentifiers.h" 1
# 24 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/CommonIdentifiers.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/Identifier.h" 1
# 27 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/Identifier.h"
# 1 "./wtf/text/CString.h" 1
# 33 "./wtf/text/CString.h"
namespace WTF {

class CStringBuffer : public RefCounted<CStringBuffer> {
public:
    const char* data() { return m_vector.data(); }
    size_t length() { return m_vector.size(); }

private:
    friend class CString;

    static PassRefPtr<CStringBuffer> create(size_t length) { return adoptRef(new CStringBuffer(length)); }
    CStringBuffer(size_t length) : m_vector(length) { }
    char* mutableData() { return m_vector.data(); }

    Vector<char> m_vector;
};



class CString {
public:
    CString() { }
    CString(const char*);
    CString(const char*, size_t length);
    CString(CStringBuffer* buffer) : m_buffer(buffer) { }
    static CString newUninitialized(size_t length, char*& characterBuffer);

    const char* data() const
    {
        return m_buffer ? m_buffer->data() : 0;
    }
    char* mutableData();
    size_t length() const
    {
        return m_buffer ? m_buffer->length() - 1 : 0;
    }

    bool isNull() const { return !m_buffer; }

    CStringBuffer* buffer() const { return m_buffer.get(); }

private:
    void copyBufferIfNeeded();
    void init(const char*, size_t length);
    RefPtr<CStringBuffer> m_buffer;
};

bool operator==(const CString& a, const CString& b);
inline bool operator!=(const CString& a, const CString& b) { return !(a == b); }

}

using WTF::CString;
# 28 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/Identifier.h" 2

namespace JSC {

    class ExecState;

    class Identifier {
        friend class Structure;
    public:
        Identifier() { }

        Identifier(ExecState* exec, const char* s) : m_string(add(exec, s)) { }
        Identifier(ExecState* exec, const UChar* s, int length) : m_string(add(exec, s, length)) { }
        Identifier(ExecState* exec, StringImpl* rep) : m_string(add(exec, rep)) { }
        Identifier(ExecState* exec, const UString& s) : m_string(add(exec, s.impl())) { }

        Identifier(JSGlobalData* globalData, const char* s) : m_string(add(globalData, s)) { }
        Identifier(JSGlobalData* globalData, const UChar* s, int length) : m_string(add(globalData, s, length)) { }
        Identifier(JSGlobalData* globalData, StringImpl* rep) : m_string(add(globalData, rep)) { }
        Identifier(JSGlobalData* globalData, const UString& s) : m_string(add(globalData, s.impl())) { }

        const UString& ustring() const { return m_string; }
        StringImpl* impl() const { return m_string.impl(); }

        const UChar* characters() const { return m_string.characters(); }
        int length() const { return m_string.length(); }

        CString ascii() const { return m_string.ascii(); }

        static Identifier from(ExecState* exec, unsigned y);
        static Identifier from(ExecState* exec, int y);
        static Identifier from(ExecState* exec, double y);
        static Identifier from(JSGlobalData*, unsigned y);
        static Identifier from(JSGlobalData*, int y);
        static Identifier from(JSGlobalData*, double y);

        static uint32_t toUInt32(const UString&, bool& ok);
        uint32_t toUInt32(bool& ok) const { return toUInt32(m_string, ok); }
        unsigned toArrayIndex(bool& ok) const;

        bool isNull() const { return m_string.isNull(); }
        bool isEmpty() const { return m_string.isEmpty(); }

        friend bool operator==(const Identifier&, const Identifier&);
        friend bool operator!=(const Identifier&, const Identifier&);

        friend bool operator==(const Identifier&, const char*);
        friend bool operator!=(const Identifier&, const char*);

        static bool equal(const StringImpl*, const char*);
        static bool equal(const StringImpl*, const UChar*, unsigned length);
        static bool equal(const StringImpl* a, const StringImpl* b) { return ::equal(a, b); }

        static PassRefPtr<StringImpl> add(ExecState*, const char*);
        static PassRefPtr<StringImpl> add(JSGlobalData*, const char*);

    private:
        UString m_string;

        static bool equal(const Identifier& a, const Identifier& b) { return a.m_string.impl() == b.m_string.impl(); }
        static bool equal(const Identifier& a, const char* b) { return equal(a.m_string.impl(), b); }

        static PassRefPtr<StringImpl> add(ExecState*, const UChar*, int length);
        static PassRefPtr<StringImpl> add(JSGlobalData*, const UChar*, int length);

        static PassRefPtr<StringImpl> add(ExecState* exec, StringImpl* r)
        {



            if (r->isIdentifier())
                return r;
            return addSlowCase(exec, r);
        }
        static PassRefPtr<StringImpl> add(JSGlobalData* globalData, StringImpl* r)
        {



            if (r->isIdentifier())
                return r;
            return addSlowCase(globalData, r);
        }

        static PassRefPtr<StringImpl> addSlowCase(ExecState*, StringImpl* r);
        static PassRefPtr<StringImpl> addSlowCase(JSGlobalData*, StringImpl* r);

        static void checkCurrentIdentifierTable(ExecState*);
        static void checkCurrentIdentifierTable(JSGlobalData*);
    };

    inline bool operator==(const Identifier& a, const Identifier& b)
    {
        return Identifier::equal(a, b);
    }

    inline bool operator!=(const Identifier& a, const Identifier& b)
    {
        return !Identifier::equal(a, b);
    }

    inline bool operator==(const Identifier& a, const char* b)
    {
        return Identifier::equal(a, b);
    }

    inline bool operator!=(const Identifier& a, const char* b)
    {
        return !Identifier::equal(a, b);
    }

    inline bool Identifier::equal(const StringImpl* r, const char* s)
    {
        return WTF::equal(r, s);
    }

    inline bool Identifier::equal(const StringImpl* r, const UChar* s, unsigned length)
    {
        return WTF::equal(r, s, length);
    }

    IdentifierTable* createIdentifierTable();
    void deleteIdentifierTable(IdentifierTable*);

    struct IdentifierRepHash : PtrHash<RefPtr<StringImpl> > {
        static unsigned hash(const RefPtr<StringImpl>& key) { return key->existingHash(); }
        static unsigned hash(StringImpl* key) { return key->existingHash(); }
    };

    struct IdentifierMapIndexHashTraits {
        typedef int TraitType;
        typedef IdentifierMapIndexHashTraits StorageTraits;
        static int emptyValue() { return std::numeric_limits<int>::max(); }
        static const bool emptyValueIsZero = false;
        static const bool needsDestruction = false;
        static const bool needsRef = false;
    };

    typedef HashMap<RefPtr<StringImpl>, int, IdentifierRepHash, HashTraits<RefPtr<StringImpl> >, IdentifierMapIndexHashTraits> IdentifierMap;

}
# 25 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/CommonIdentifiers.h" 2
# 127 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/CommonIdentifiers.h"
namespace JSC {

    class CommonIdentifiers {
        private: CommonIdentifiers(const CommonIdentifiers&); CommonIdentifiers& operator=(const CommonIdentifiers&); public: void* operator new(size_t, void* p) { return p; } void* operator new[](size_t, void* p) { return p; } void* operator new(size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNew); return p; } void operator delete(void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNew); ::WTF::fastFree(p); } void* operator new[](size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNewArray); return p; } void operator delete[](void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNewArray); ::WTF::fastFree(p); } private: typedef int ThisIsHereToForceASemicolonAfterThisMacro;
    private:
        CommonIdentifiers(JSGlobalData*);
        friend class JSGlobalData;

    public:
        const Identifier nullIdentifier;
        const Identifier emptyIdentifier;
        const Identifier underscoreProto;
        const Identifier thisIdentifier;
        const Identifier useStrictIdentifier;



        const Identifier nullKeyword; const Identifier trueKeyword; const Identifier falseKeyword; const Identifier breakKeyword; const Identifier caseKeyword; const Identifier catchKeyword; const Identifier constKeyword; const Identifier defaultKeyword; const Identifier finallyKeyword; const Identifier forKeyword; const Identifier instanceofKeyword; const Identifier newKeyword; const Identifier varKeyword; const Identifier continueKeyword; const Identifier functionKeyword; const Identifier returnKeyword; const Identifier voidKeyword; const Identifier deleteKeyword; const Identifier ifKeyword; const Identifier thisKeyword; const Identifier doKeyword; const Identifier whileKeyword; const Identifier elseKeyword; const Identifier inKeyword; const Identifier switchKeyword; const Identifier throwKeyword; const Identifier tryKeyword; const Identifier typeofKeyword; const Identifier withKeyword; const Identifier debuggerKeyword; const Identifier classKeyword; const Identifier enumKeyword; const Identifier exportKeyword; const Identifier extendsKeyword; const Identifier importKeyword; const Identifier superKeyword; const Identifier implementsKeyword; const Identifier interfaceKeyword; const Identifier letKeyword; const Identifier packageKeyword; const Identifier privateKeyword; const Identifier protectedKeyword; const Identifier publicKeyword; const Identifier staticKeyword; const Identifier yieldKeyword;



        const Identifier __defineGetter__; const Identifier __defineSetter__; const Identifier __lookupGetter__; const Identifier __lookupSetter__; const Identifier apply; const Identifier arguments; const Identifier bind; const Identifier call; const Identifier callee; const Identifier caller; const Identifier compile; const Identifier configurable; const Identifier constructor; const Identifier enumerable; const Identifier eval; const Identifier exec; const Identifier fromCharCode; const Identifier global; const Identifier get; const Identifier hasOwnProperty; const Identifier ignoreCase; const Identifier index; const Identifier input; const Identifier isArray; const Identifier isPrototypeOf; const Identifier length; const Identifier message; const Identifier multiline; const Identifier name; const Identifier now; const Identifier parse; const Identifier propertyIsEnumerable; const Identifier prototype; const Identifier set; const Identifier source; const Identifier test; const Identifier toExponential; const Identifier toFixed; const Identifier toISOString; const Identifier toJSON; const Identifier toLocaleString; const Identifier toPrecision; const Identifier toString; const Identifier UTC; const Identifier value; const Identifier valueOf; const Identifier writable; const Identifier displayName; const Identifier undefined;

    };

}
# 29 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSObject.h" 2


# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/PropertySlot.h" 1
# 30 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/PropertySlot.h"
namespace JSC {

    class ExecState;
    class JSObject;





    class PropertySlot {
    public:
        enum CachedPropertyType {
            Uncacheable,
            Getter,
            Custom,
            Value
        };

        PropertySlot()
            : m_cachedPropertyType(Uncacheable)
        {
            clearBase();
            clearOffset();
            clearValue();
        }

        explicit PropertySlot(const JSValue base)
            : m_slotBase(base)
            , m_cachedPropertyType(Uncacheable)
        {
            clearOffset();
            clearValue();
        }

        typedef JSValue (*GetValueFunc)(ExecState*, JSValue slotBase, const Identifier&);
        typedef JSValue (*GetIndexValueFunc)(ExecState*, JSValue slotBase, unsigned);

        JSValue getValue(ExecState* exec, const Identifier& propertyName) const
        {
            if (m_getValue == 0)
                return m_value;
            if (m_getValue == reinterpret_cast<GetValueFunc>(2))
                return m_getIndexValue(exec, slotBase(), index());
            if (m_getValue == reinterpret_cast<GetValueFunc>(3))
                return functionGetter(exec);
            return m_getValue(exec, slotBase(), propertyName);
        }

        JSValue getValue(ExecState* exec, unsigned propertyName) const
        {
            if (m_getValue == 0)
                return m_value;
            if (m_getValue == reinterpret_cast<GetValueFunc>(2))
                return m_getIndexValue(exec, m_slotBase, m_data.index);
            if (m_getValue == reinterpret_cast<GetValueFunc>(3))
                return functionGetter(exec);
            return m_getValue(exec, slotBase(), Identifier::from(exec, propertyName));
        }

        CachedPropertyType cachedPropertyType() const { return m_cachedPropertyType; }
        bool isCacheable() const { return m_cachedPropertyType != Uncacheable; }
        bool isCacheableValue() const { return m_cachedPropertyType == Value; }
        size_t cachedOffset() const
        {
            ((void)0);
            return m_offset;
        }

        void setValue(JSValue slotBase, JSValue value)
        {
            ((void)0);
            clearOffset();
            m_getValue = 0;
            m_slotBase = slotBase;
            m_value = value;
        }

        void setValue(JSValue slotBase, JSValue value, size_t offset)
        {
            ((void)0);
            m_getValue = 0;
            m_slotBase = slotBase;
            m_value = value;
            m_offset = offset;
            m_cachedPropertyType = Value;
        }

        void setValue(JSValue value)
        {
            ((void)0);
            clearBase();
            clearOffset();
            m_getValue = 0;
            m_value = value;
        }

        void setCustom(JSValue slotBase, GetValueFunc getValue)
        {
            ((void)0);
            ((void)0);
            m_getValue = getValue;
            m_getIndexValue = 0;
            m_slotBase = slotBase;
        }

        void setCacheableCustom(JSValue slotBase, GetValueFunc getValue)
        {
            ((void)0);
            ((void)0);
            m_getValue = getValue;
            m_getIndexValue = 0;
            m_slotBase = slotBase;
            m_cachedPropertyType = Custom;
        }

        void setCustomIndex(JSValue slotBase, unsigned index, GetIndexValueFunc getIndexValue)
        {
            ((void)0);
            ((void)0);
            m_getValue = reinterpret_cast<GetValueFunc>(2);
            m_getIndexValue = getIndexValue;
            m_slotBase = slotBase;
            m_data.index = index;
        }

        void setGetterSlot(JSObject* getterFunc)
        {
            ((void)0);
            m_thisValue = m_slotBase;
            m_getValue = reinterpret_cast<GetValueFunc>(3);
            m_data.getterFunc = getterFunc;
        }

        void setCacheableGetterSlot(JSValue slotBase, JSObject* getterFunc, unsigned offset)
        {
            ((void)0);
            m_getValue = reinterpret_cast<GetValueFunc>(3);
            m_thisValue = m_slotBase;
            m_slotBase = slotBase;
            m_data.getterFunc = getterFunc;
            m_offset = offset;
            m_cachedPropertyType = Getter;
        }

        void setUndefined()
        {
            setValue(jsUndefined());
        }

        JSValue slotBase() const
        {
            return m_slotBase;
        }

        void setBase(JSValue base)
        {
            ((void)0);
            ((void)0);
            m_slotBase = base;
        }

        void clearBase()
        {



        }

        void clearValue()
        {



        }

        void clearOffset()
        {


            m_offset = 0;
            m_cachedPropertyType = Uncacheable;
        }

        unsigned index() const { return m_data.index; }

        GetValueFunc customGetter() const
        {
            ((void)0);
            return m_getValue;
        }
    private:
        JSValue functionGetter(ExecState*) const;

        GetValueFunc m_getValue;
        GetIndexValueFunc m_getIndexValue;

        JSValue m_slotBase;
        union {
            JSObject* getterFunc;
            unsigned index;
        } m_data;

        JSValue m_value;
        JSValue m_thisValue;

        size_t m_offset;
        CachedPropertyType m_cachedPropertyType;
    };

}
# 32 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSObject.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/PutPropertySlot.h" 1
# 32 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/PutPropertySlot.h"
namespace JSC {

    class JSObject;
    class JSFunction;

    class PutPropertySlot {
    public:
        enum Type { Uncachable, ExistingProperty, NewProperty };

        PutPropertySlot(bool isStrictMode = false)
            : m_type(Uncachable)
            , m_base(0)
            , m_isStrictMode(isStrictMode)
        {
        }

        void setExistingProperty(JSObject* base, size_t offset)
        {
            m_type = ExistingProperty;
            m_base = base;
            m_offset = offset;
        }

        void setNewProperty(JSObject* base, size_t offset)
        {
            m_type = NewProperty;
            m_base = base;
            m_offset = offset;
        }

        Type type() const { return m_type; }
        JSObject* base() const { return m_base; }

        bool isStrictMode() const { return m_isStrictMode; }
        bool isCacheable() const { return m_type != Uncachable; }
        size_t cachedOffset() const {
            ((void)0);
            return m_offset;
        }

    private:
        Type m_type;
        JSObject* m_base;
        size_t m_offset;
        bool m_isStrictMode;
    };

}
# 33 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSObject.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/ScopeChain.h" 1
# 25 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/ScopeChain.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/Structure.h" 1
# 32 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/Structure.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSType.h" 1
# 24 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSType.h"
namespace JSC {

enum JSType {
    UnspecifiedType = 0,
    UndefinedType = 1,
    BooleanType = 2,
    NumberType = 3,
    NullType = 4,
    StringType = 5,
    LeafType = 6,


    CompoundType = 7,
    GetterSetterType = 8,
    APIValueWrapperType = 9,


    ObjectType = 10,
    FinalObjectType = 11,
    JSFunctionType = 12,
    NumberObjectType = 13,
};

}
# 33 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/Structure.h" 2

# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/PropertyMapHashTable.h" 1
# 48 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/PropertyMapHashTable.h"
namespace JSC {

inline bool isPowerOf2(unsigned v)
{


    return !(v & (v - 1)) && v;
}

inline unsigned nextPowerOf2(unsigned v)
{



    v--;
    v |= v >> 1;
    v |= v >> 2;
    v |= v >> 4;
    v |= v >> 8;
    v |= v >> 16;
    v++;

    return v;
}

struct PropertyMapEntry {
    StringImpl* key;
    unsigned offset;
    unsigned attributes;
    WriteBarrier<JSCell> specificValue;

    PropertyMapEntry(JSGlobalData& globalData, JSCell* owner, StringImpl* key, unsigned offset, unsigned attributes, JSCell* specificValue)
        : key(key)
        , offset(offset)
        , attributes(attributes)
        , specificValue(globalData, owner, specificValue, WriteBarrier<JSCell>::MayBeNull)
    {
    }
};

class PropertyTable {
    public: void* operator new(size_t, void* p) { return p; } void* operator new[](size_t, void* p) { return p; } void* operator new(size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNew); return p; } void operator delete(void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNew); ::WTF::fastFree(p); } void* operator new[](size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNewArray); return p; } void operator delete[](void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNewArray); ::WTF::fastFree(p); } private: typedef int ThisIsHereToForceASemicolonAfterThisMacro;



    template<typename T>
    class ordered_iterator {
    public:
        ordered_iterator<T>& operator++()
        {
            m_valuePtr = skipDeletedEntries(m_valuePtr + 1);
            return *this;
        }

        bool operator==(const ordered_iterator<T>& other)
        {
            return m_valuePtr == other.m_valuePtr;
        }

        bool operator!=(const ordered_iterator<T>& other)
        {
            return m_valuePtr != other.m_valuePtr;
        }

        T& operator*()
        {
            return *m_valuePtr;
        }

        T* operator->()
        {
            return m_valuePtr;
        }

        ordered_iterator(T* valuePtr)
            : m_valuePtr(valuePtr)
        {
        }

    private:
        T* m_valuePtr;
    };

public:
    typedef StringImpl* KeyType;
    typedef PropertyMapEntry ValueType;


    typedef ordered_iterator<ValueType> iterator;
    typedef ordered_iterator<const ValueType> const_iterator;




    typedef std::pair<ValueType*, unsigned> find_iterator;


    explicit PropertyTable(unsigned initialCapacity);
    PropertyTable(JSGlobalData&, JSCell*, const PropertyTable&);
    PropertyTable(JSGlobalData&, JSCell*, unsigned initialCapacity, const PropertyTable&);
    ~PropertyTable();


    iterator begin();
    iterator end();
    const_iterator begin() const;
    const_iterator end() const;


    find_iterator find(const KeyType&);
    find_iterator findWithString(const KeyType&);

    std::pair<find_iterator, bool> add(const ValueType& entry);

    void remove(const find_iterator& iter);
    void remove(const KeyType& key);


    unsigned size() const;


    bool isEmpty() const;


    unsigned propertyStorageSize() const;


    void clearDeletedOffsets();
    bool hasDeletedOffset();
    unsigned getDeletedOffset();
    void addDeletedOffset(unsigned offset);


    PassOwnPtr<PropertyTable> copy(JSGlobalData&, JSCell* owner, unsigned newCapacity);






private:
    PropertyTable(const PropertyTable&);

    void reinsert(const ValueType& entry);


    void rehash(unsigned newCapacity);


    unsigned tableCapacity() const;
# 206 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/PropertyMapHashTable.h"
    unsigned deletedEntryIndex() const;


    template<typename T>
    static T* skipDeletedEntries(T* valuePtr);


    ValueType* table();
    const ValueType* table() const;


    unsigned usedCount() const;


    size_t dataSize();


    static unsigned sizeForCapacity(unsigned capacity);


    bool canInsert();

    unsigned m_indexSize;
    unsigned m_indexMask;
    unsigned* m_index;
    unsigned m_keyCount;
    unsigned m_deletedCount;
    OwnPtr< Vector<unsigned> > m_deletedOffsets;

    static const unsigned MinimumTableSize = 16;
    static const unsigned EmptyEntryIndex = 0;
};

inline PropertyTable::PropertyTable(unsigned initialCapacity)
    : m_indexSize(sizeForCapacity(initialCapacity))
    , m_indexMask(m_indexSize - 1)
    , m_index(static_cast<unsigned*>(fastZeroedMalloc(dataSize())))
    , m_keyCount(0)
    , m_deletedCount(0)
{
    ((void)0);
}

inline PropertyTable::PropertyTable(JSGlobalData&, JSCell* owner, const PropertyTable& other)
    : m_indexSize(other.m_indexSize)
    , m_indexMask(other.m_indexMask)
    , m_index(static_cast<unsigned*>(fastMalloc(dataSize())))
    , m_keyCount(other.m_keyCount)
    , m_deletedCount(other.m_deletedCount)
{
    ((void)0);

    memcpy(m_index, other.m_index, dataSize());

    iterator end = this->end();
    for (iterator iter = begin(); iter != end; ++iter) {
        iter->key->ref();
        Heap::writeBarrier(owner, iter->specificValue.get());
    }


    Vector<unsigned>* otherDeletedOffsets = other.m_deletedOffsets.get();
    if (otherDeletedOffsets)
        m_deletedOffsets = adoptPtr(new Vector<unsigned>(*otherDeletedOffsets));
}

inline PropertyTable::PropertyTable(JSGlobalData&, JSCell* owner, unsigned initialCapacity, const PropertyTable& other)
    : m_indexSize(sizeForCapacity(initialCapacity))
    , m_indexMask(m_indexSize - 1)
    , m_index(static_cast<unsigned*>(fastZeroedMalloc(dataSize())))
    , m_keyCount(0)
    , m_deletedCount(0)
{
    ((void)0);
    ((void)0);

    const_iterator end = other.end();
    for (const_iterator iter = other.begin(); iter != end; ++iter) {
        ((void)0);
        reinsert(*iter);
        iter->key->ref();
        Heap::writeBarrier(owner, iter->specificValue.get());
    }


    Vector<unsigned>* otherDeletedOffsets = other.m_deletedOffsets.get();
    if (otherDeletedOffsets)
        m_deletedOffsets = adoptPtr(new Vector<unsigned>(*otherDeletedOffsets));
}

inline PropertyTable::~PropertyTable()
{
    iterator end = this->end();
    for (iterator iter = begin(); iter != end; ++iter)
        iter->key->deref();

    fastFree(m_index);
}

inline PropertyTable::iterator PropertyTable::begin()
{
    return iterator(skipDeletedEntries(table()));
}

inline PropertyTable::iterator PropertyTable::end()
{
    return iterator(table() + usedCount());
}

inline PropertyTable::const_iterator PropertyTable::begin() const
{
    return const_iterator(skipDeletedEntries(table()));
}

inline PropertyTable::const_iterator PropertyTable::end() const
{
    return const_iterator(table() + usedCount());
}

inline PropertyTable::find_iterator PropertyTable::find(const KeyType& key)
{
    ((void)0);
    ((void)0);
    unsigned hash = key->existingHash();
    unsigned step = 0;





    while (true) {
        unsigned entryIndex = m_index[hash & m_indexMask];
        if (entryIndex == EmptyEntryIndex)
            return std::make_pair((ValueType*)0, hash & m_indexMask);
        if (key == table()[entryIndex - 1].key)
            return std::make_pair(&table()[entryIndex - 1], hash & m_indexMask);





        if (!step)
            step = WTF::doubleHash(key->existingHash()) | 1;
        hash += step;




    }
}

inline PropertyTable::find_iterator PropertyTable::findWithString(const KeyType& key)
{
    ((void)0);
    ((void)0);
    unsigned hash = key->hash();
    unsigned step = 0;





    while (true) {
        unsigned entryIndex = m_index[hash & m_indexMask];
        if (entryIndex == EmptyEntryIndex)
            return std::make_pair((ValueType*)0, hash & m_indexMask);
        if (equal(key, table()[entryIndex - 1].key))
            return std::make_pair(&table()[entryIndex - 1], hash & m_indexMask);





        if (!step)
            step = WTF::doubleHash(key->existingHash()) | 1;
        hash += step;




    }
}

inline std::pair<PropertyTable::find_iterator, bool> PropertyTable::add(const ValueType& entry)
{

    find_iterator iter = find(entry.key);
    if (iter.first)
        return std::make_pair(iter, false);


    entry.key->ref();


    if (!canInsert()) {
        rehash(m_keyCount + 1);
        iter = find(entry.key);
        ((void)0);
    }


    unsigned entryIndex = usedCount() + 1;
    m_index[iter.second] = entryIndex;
    iter.first = &table()[entryIndex - 1];
    *iter.first = entry;

    ++m_keyCount;
    return std::make_pair(iter, true);
}

inline void PropertyTable::remove(const find_iterator& iter)
{

    if (!iter.first)
        return;







    m_index[iter.second] = deletedEntryIndex();
    iter.first->key->deref();
    iter.first->key = ((StringImpl*)1);

    ((void)0);
    --m_keyCount;
    ++m_deletedCount;

    if (m_deletedCount * 4 >= m_indexSize)
        rehash(m_keyCount);
}

inline void PropertyTable::remove(const KeyType& key)
{
    remove(find(key));
}


inline unsigned PropertyTable::size() const
{
    return m_keyCount;
}

inline bool PropertyTable::isEmpty() const
{
    return !m_keyCount;
}

inline unsigned PropertyTable::propertyStorageSize() const
{
    return size() + (m_deletedOffsets ? m_deletedOffsets->size() : 0);
}

inline void PropertyTable::clearDeletedOffsets()
{
    m_deletedOffsets.clear();
}

inline bool PropertyTable::hasDeletedOffset()
{
    return m_deletedOffsets && !m_deletedOffsets->isEmpty();
}

inline unsigned PropertyTable::getDeletedOffset()
{
    unsigned offset = m_deletedOffsets->last();
    m_deletedOffsets->removeLast();
    return offset;
}

inline void PropertyTable::addDeletedOffset(unsigned offset)
{
    if (!m_deletedOffsets)
        m_deletedOffsets = adoptPtr(new Vector<unsigned>);
    m_deletedOffsets->append(offset);
}

inline PassOwnPtr<PropertyTable> PropertyTable::copy(JSGlobalData& globalData, JSCell* owner, unsigned newCapacity)
{
    ((void)0);



    if (sizeForCapacity(newCapacity) == m_indexSize)
        return adoptPtr(new PropertyTable(globalData, owner, *this));
    return adoptPtr(new PropertyTable(globalData, owner, newCapacity, *this));
}
# 506 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/PropertyMapHashTable.h"
inline void PropertyTable::reinsert(const ValueType& entry)
{


    ((void)0);
    find_iterator iter = find(entry.key);
    ((void)0);

    unsigned entryIndex = usedCount() + 1;
    m_index[iter.second] = entryIndex;
    table()[entryIndex - 1] = entry;

    ++m_keyCount;
}

inline void PropertyTable::rehash(unsigned newCapacity)
{
    unsigned* oldEntryIndices = m_index;
    iterator iter = this->begin();
    iterator end = this->end();

    m_indexSize = sizeForCapacity(newCapacity);
    m_indexMask = m_indexSize - 1;
    m_keyCount = 0;
    m_deletedCount = 0;
    m_index = static_cast<unsigned*>(fastZeroedMalloc(dataSize()));

    for (; iter != end; ++iter) {
        ((void)0);
        reinsert(*iter);
    }

    fastFree(oldEntryIndices);
}

inline unsigned PropertyTable::tableCapacity() const { return m_indexSize >> 1; }

inline unsigned PropertyTable::deletedEntryIndex() const { return tableCapacity() + 1; }

template<typename T>
inline T* PropertyTable::skipDeletedEntries(T* valuePtr)
{
    while (valuePtr->key == ((StringImpl*)1))
        ++valuePtr;
    return valuePtr;
}

inline PropertyTable::ValueType* PropertyTable::table()
{

    return reinterpret_cast<ValueType*>(m_index + m_indexSize);
}

inline const PropertyTable::ValueType* PropertyTable::table() const
{

    return reinterpret_cast<const ValueType*>(m_index + m_indexSize);
}

inline unsigned PropertyTable::usedCount() const
{

    return m_keyCount + m_deletedCount;
}

inline size_t PropertyTable::dataSize()
{

    return m_indexSize * sizeof(unsigned) + ((tableCapacity()) + 1) * sizeof(ValueType);
}

inline unsigned PropertyTable::sizeForCapacity(unsigned capacity)
{
    if (capacity < 8)
        return MinimumTableSize;
    return nextPowerOf2(capacity + 1) * 2;
}

inline bool PropertyTable::canInsert()
{
    return usedCount() < tableCapacity();
}

}
# 35 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/Structure.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/PropertyNameArray.h" 1
# 30 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/PropertyNameArray.h"
namespace JSC {

    class Structure;
    class StructureChain;


    class PropertyNameArrayData : public RefCounted<PropertyNameArrayData> {
    public:
        typedef Vector<Identifier, 20> PropertyNameVector;

        static PassRefPtr<PropertyNameArrayData> create() { return adoptRef(new PropertyNameArrayData); }

        PropertyNameVector& propertyNameVector() { return m_propertyNameVector; }

    private:
        PropertyNameArrayData()
        {
        }

        PropertyNameVector m_propertyNameVector;
    };


    class PropertyNameArray {
    public:
        PropertyNameArray(JSGlobalData* globalData)
            : m_data(PropertyNameArrayData::create())
            , m_globalData(globalData)
            , m_shouldCache(true)
        {
        }

        PropertyNameArray(ExecState* exec)
            : m_data(PropertyNameArrayData::create())
            , m_globalData(&exec->globalData())
            , m_shouldCache(true)
        {
        }

        JSGlobalData* globalData() { return m_globalData; }

        void add(const Identifier& identifier) { add(identifier.impl()); }
        void add(StringImpl*);
        void addKnownUnique(StringImpl* identifier) { m_data->propertyNameVector().append(Identifier(m_globalData, identifier)); }

        Identifier& operator[](unsigned i) { return m_data->propertyNameVector()[i]; }
        const Identifier& operator[](unsigned i) const { return m_data->propertyNameVector()[i]; }

        void setData(PassRefPtr<PropertyNameArrayData> data) { m_data = data; }
        PropertyNameArrayData* data() { return m_data.get(); }
        PassRefPtr<PropertyNameArrayData> releaseData() { return m_data.release(); }


        typedef PropertyNameArrayData::PropertyNameVector::const_iterator const_iterator;
        size_t size() const { return m_data->propertyNameVector().size(); }
        const_iterator begin() const { return m_data->propertyNameVector().begin(); }
        const_iterator end() const { return m_data->propertyNameVector().end(); }

    private:
        typedef HashSet<StringImpl*, PtrHash<StringImpl*> > IdentifierSet;

        RefPtr<PropertyNameArrayData> m_data;
        IdentifierSet m_set;
        JSGlobalData* m_globalData;
        bool m_shouldCache;
    };

}
# 36 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/Structure.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/Protect.h" 1
# 28 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/Protect.h"
namespace JSC {

    inline void gcProtect(JSCell* val)
    {
        Heap::heap(val)->protect(val);
    }

    inline void gcUnprotect(JSCell* val)
    {
        Heap::heap(val)->unprotect(val);
    }

    inline void gcProtectNullTolerant(JSCell* val)
    {
        if (val)
            gcProtect(val);
    }

    inline void gcUnprotectNullTolerant(JSCell* val)
    {
        if (val)
            gcUnprotect(val);
    }

    inline void gcProtect(JSValue value)
    {
        if (value && value.isCell())
            gcProtect(value.asCell());
    }

    inline void gcUnprotect(JSValue value)
    {
        if (value && value.isCell())
            gcUnprotect(value.asCell());
    }

}
# 37 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/Structure.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/StructureTransitionTable.h" 1
# 30 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/StructureTransitionTable.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/WeakGCMap.h" 1
# 33 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/WeakGCMap.h"
namespace JSC {



template <typename KeyType, typename MappedType> struct DefaultWeakGCMapFinalizerCallback {
    static void* finalizerContextFor(KeyType key)
    {
        return reinterpret_cast<void*>(key);
    }

    static KeyType keyForFinalizer(void* context, typename HandleTypes<MappedType>::ExternalType)
    {
        return reinterpret_cast<KeyType>(context);
    }
};

template<typename KeyType, typename MappedType, typename FinalizerCallback = DefaultWeakGCMapFinalizerCallback<KeyType, MappedType>, typename HashArg = typename DefaultHash<KeyType>::Hash, typename KeyTraitsArg = HashTraits<KeyType> >
class WeakGCMap : private WeakHandleOwner {
    public: void* operator new(size_t, void* p) { return p; } void* operator new[](size_t, void* p) { return p; } void* operator new(size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNew); return p; } void operator delete(void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNew); ::WTF::fastFree(p); } void* operator new[](size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNewArray); return p; } void operator delete[](void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNewArray); ::WTF::fastFree(p); } private: typedef int ThisIsHereToForceASemicolonAfterThisMacro;
    private: WeakGCMap(const WeakGCMap&); WeakGCMap& operator=(const WeakGCMap&);

    typedef HashMap<KeyType, HandleSlot, HashArg, KeyTraitsArg> MapType;
    typedef typename HandleTypes<MappedType>::ExternalType ExternalType;
    typedef typename MapType::iterator map_iterator;

public:

    struct iterator {
        friend class WeakGCMap;
        iterator(map_iterator iter)
            : m_iterator(iter)
        {
        }

        std::pair<KeyType, ExternalType> get() const { return std::make_pair(m_iterator->first, HandleTypes<MappedType>::getFromSlot(m_iterator->second)); }
        std::pair<KeyType, HandleSlot> getSlot() const { return *m_iterator; }

        iterator& operator++() { ++m_iterator; return *this; }




        bool operator==(const iterator& other) const { return m_iterator == other.m_iterator; }
        bool operator!=(const iterator& other) const { return m_iterator != other.m_iterator; }

    private:
        map_iterator m_iterator;
    };

    WeakGCMap()
    {
    }

    bool isEmpty() { return m_map.isEmpty(); }
    void clear()
    {
        map_iterator end = m_map.end();
        for (map_iterator ptr = m_map.begin(); ptr != end; ++ptr)
            HandleHeap::heapFor(ptr->second)->deallocate(ptr->second);
        m_map.clear();
    }

    bool contains(const KeyType& key) const
    {
        return m_map.contains(key);
    }

    iterator find(const KeyType& key)
    {
        return m_map.find(key);
    }

    void remove(iterator iter)
    {
        ((void)0);
        HandleSlot slot = iter.m_iterator->second;
        ((void)0);
        HandleHeap::heapFor(slot)->deallocate(slot);
        m_map.remove(iter.m_iterator);
    }

    ExternalType get(const KeyType& key) const
    {
        return HandleTypes<MappedType>::getFromSlot(m_map.get(key));
    }

    HandleSlot getSlot(const KeyType& key) const
    {
        return m_map.get(key);
    }

    pair<iterator, bool> add(JSGlobalData& globalData, const KeyType& key, ExternalType value)
    {
        pair<typename MapType::iterator, bool> iter = m_map.add(key, 0);
        if (iter.second) {
            HandleSlot slot = globalData.heap.handleHeap()->allocate();
            iter.first->second = slot;
            HandleHeap::heapFor(slot)->makeWeak(slot, this, FinalizerCallback::finalizerContextFor(key));
            HandleHeap::heapFor(slot)->writeBarrier(slot, value);
            *slot = value;
        }
        return iter;
    }

    void set(iterator iter, ExternalType value)
    {
        HandleSlot slot = iter.m_iterator->second;
        ((void)0);
        HandleHeap::heapFor(slot)->writeBarrier(slot, value);
        *slot = value;
    }

    void set(JSGlobalData& globalData, const KeyType& key, ExternalType value)
    {
        pair<typename MapType::iterator, bool> iter = m_map.add(key, 0);
        HandleSlot slot = iter.first->second;
        if (iter.second) {
            slot = globalData.heap.handleHeap()->allocate();
            HandleHeap::heapFor(slot)->makeWeak(slot, this, key);
            iter.first->second = slot;
        }
        HandleHeap::heapFor(slot)->writeBarrier(slot, value);
        *slot = value;
    }

    ExternalType take(const KeyType& key)
    {
        HandleSlot slot = m_map.take(key);
        if (!slot)
            return HashTraits<ExternalType>::emptyValue();
        ExternalType result = HandleTypes<MappedType>::getFromSlot(slot);
        HandleHeap::heapFor(slot)->deallocate(slot);
        return result;
    }

    size_t size() { return m_map.size(); }

    iterator begin() { return iterator(m_map.begin()); }
    iterator end() { return iterator(m_map.end()); }

    ~WeakGCMap()
    {
        clear();
    }

private:
    virtual void finalize(Handle<Unknown> handle, void* context)
    {
        HandleSlot slot = m_map.take(FinalizerCallback::keyForFinalizer(context, HandleTypes<MappedType>::getFromSlot(handle.slot())));
        ((void)0);
        HandleHeap::heapFor(slot)->deallocate(slot);
    }

    MapType m_map;
};

}
# 31 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/StructureTransitionTable.h" 2





namespace JSC {

class Structure;

class StructureTransitionTable {
    static const intptr_t UsingSingleSlotFlag = 1;

    struct Hash {
        typedef std::pair<RefPtr<StringImpl>, unsigned> Key;
        static unsigned hash(const Key& p)
        {
            return p.first->existingHash();
        }

        static bool equal(const Key& a, const Key& b)
        {
            return a == b;
        }

        static const bool safeToCompareToEmptyOrDeleted = true;
    };

    struct HashTraits {
        typedef WTF::HashTraits<RefPtr<StringImpl> > FirstTraits;
        typedef WTF::GenericHashTraits<unsigned> SecondTraits;
        typedef std::pair<FirstTraits::TraitType, SecondTraits::TraitType > TraitType;

        static const bool emptyValueIsZero = FirstTraits::emptyValueIsZero && SecondTraits::emptyValueIsZero;
        static TraitType emptyValue() { return std::make_pair(FirstTraits::emptyValue(), SecondTraits::emptyValue()); }

        static const bool needsDestruction = FirstTraits::needsDestruction || SecondTraits::needsDestruction;

        static const int minimumTableSize = FirstTraits::minimumTableSize;

        static void constructDeletedValue(TraitType& slot) { FirstTraits::constructDeletedValue(slot.first); }
        static bool isDeletedValue(const TraitType& value) { return FirstTraits::isDeletedValue(value.first); }
    };

    struct WeakGCMapFinalizerCallback {
        static void* finalizerContextFor(Hash::Key)
        {
            return 0;
        }

        static inline Hash::Key keyForFinalizer(void* context, Structure* structure)
        {
            return keyForWeakGCMapFinalizer(context, structure);
        }
    };

    typedef WeakGCMap<Hash::Key, Structure, WeakGCMapFinalizerCallback, Hash, HashTraits> TransitionMap;

    static Hash::Key keyForWeakGCMapFinalizer(void* context, Structure*);

public:
    StructureTransitionTable()
        : m_data(UsingSingleSlotFlag)
    {
    }

    ~StructureTransitionTable()
    {
        if (!isUsingSingleSlot()) {
            delete map();
            return;
        }

        HandleSlot slot = this->slot();
        if (!slot)
            return;
        HandleHeap::heapFor(slot)->deallocate(slot);
    }

    inline void add(JSGlobalData&, Structure*);
    inline bool contains(StringImpl* rep, unsigned attributes) const;
    inline Structure* get(StringImpl* rep, unsigned attributes) const;

private:
    bool isUsingSingleSlot() const
    {
        return m_data & UsingSingleSlotFlag;
    }

    TransitionMap* map() const
    {
        ((void)0);
        return reinterpret_cast<TransitionMap*>(m_data);
    }

    HandleSlot slot() const
    {
        ((void)0);
        return reinterpret_cast<HandleSlot>(m_data & ~UsingSingleSlotFlag);
    }

    void setMap(TransitionMap* map)
    {
        ((void)0);

        if (HandleSlot slot = this->slot())
            HandleHeap::heapFor(slot)->deallocate(slot);


        m_data = reinterpret_cast<intptr_t>(map);

        ((void)0);
    }

    Structure* singleTransition() const
    {
        ((void)0);
        if (HandleSlot slot = this->slot()) {
            if (*slot)
                return reinterpret_cast<Structure*>(slot->asCell());
        }
        return 0;
    }

    void setSingleTransition(JSGlobalData& globalData, Structure* structure)
    {
        ((void)0);
        HandleSlot slot = this->slot();
        if (!slot) {
            slot = globalData.heap.handleHeap()->allocate();
            HandleHeap::heapFor(slot)->makeWeak(slot, 0, 0);
            m_data = reinterpret_cast<intptr_t>(slot) | UsingSingleSlotFlag;
        }
        HandleHeap::heapFor(slot)->writeBarrier(slot, reinterpret_cast<JSCell*>(structure));
        *slot = reinterpret_cast<JSCell*>(structure);
    }

    intptr_t m_data;
};

}
# 38 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/Structure.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSTypeInfo.h" 1
# 35 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSTypeInfo.h"
namespace JSC {

    static const unsigned MasqueradesAsUndefined = 1;
    static const unsigned ImplementsHasInstance = 1 << 1;
    static const unsigned OverridesHasInstance = 1 << 2;
    static const unsigned ImplementsDefaultHasInstance = 1 << 3;
    static const unsigned IsEnvironmentRecord = 1 << 4;
    static const unsigned OverridesGetOwnPropertySlot = 1 << 5;
    static const unsigned OverridesVisitChildren = 1 << 6;
    static const unsigned OverridesGetPropertyNames = 1 << 7;
    static const unsigned ProhibitsPropertyCaching = 1 << 8;

    class TypeInfo {
    public:
        TypeInfo(JSType type, unsigned flags = 0)
            : m_type(type)
            , m_flags(flags & 0xff)
            , m_flags2(flags >> 8)
        {
            ((void)0);
            ((void)0);
            ((void)0);

            ((void)0);

            if ((m_flags & (ImplementsHasInstance | OverridesHasInstance)) == ImplementsHasInstance)
                m_flags |= ImplementsDefaultHasInstance;
        }

        JSType type() const { return static_cast<JSType>(m_type); }
        bool isObject() const { return type() >= ObjectType; }
        bool isFinalObject() const { return type() == FinalObjectType; }
        bool isNumberObject() const { return type() == NumberObjectType; }

        bool masqueradesAsUndefined() const { return isSetOnFlags1(MasqueradesAsUndefined); }
        bool implementsHasInstance() const { return isSetOnFlags1(ImplementsHasInstance); }
        bool isEnvironmentRecord() const { return isSetOnFlags1(IsEnvironmentRecord); }
        bool overridesHasInstance() const { return isSetOnFlags1(OverridesHasInstance); }
        bool implementsDefaultHasInstance() const { return isSetOnFlags1(ImplementsDefaultHasInstance); }
        bool overridesGetOwnPropertySlot() const { return isSetOnFlags1(OverridesGetOwnPropertySlot); }
        bool overridesVisitChildren() const { return isSetOnFlags1(OverridesVisitChildren); }
        bool overridesGetPropertyNames() const { return isSetOnFlags1(OverridesGetPropertyNames); }
        bool prohibitsPropertyCaching() const { return isSetOnFlags2(ProhibitsPropertyCaching); }

        static ptrdiff_t flagsOffset()
        {
            return (reinterpret_cast<ptrdiff_t>(&(reinterpret_cast<TypeInfo*>(0x4000)->m_flags)) - 0x4000);
        }

        static ptrdiff_t typeOffset()
        {
            return (reinterpret_cast<ptrdiff_t>(&(reinterpret_cast<TypeInfo*>(0x4000)->m_type)) - 0x4000);
        }

    private:
        bool isSetOnFlags1(unsigned flag) const { ((void)0); return m_flags & flag; }
        bool isSetOnFlags2(unsigned flag) const { ((void)0); return m_flags2 & (flag >> 8); }

        unsigned char m_type;
        unsigned char m_flags;
        unsigned char m_flags2;
    };

}
# 39 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/Structure.h" 2

# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/Weak.h" 1
# 34 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/heap/Weak.h"
namespace JSC {


template <typename T> class Weak : public Handle<T> {
    using Handle<T>::slot;
    using Handle<T>::setSlot;

public:
    typedef typename Handle<T>::ExternalType ExternalType;

    Weak()
        : Handle<T>()
    {
    }

    Weak(JSGlobalData& globalData, ExternalType value = ExternalType(), WeakHandleOwner* weakOwner = 0, void* context = 0)
        : Handle<T>(globalData.heap.handleHeap()->allocate())
    {
        HandleHeap::heapFor(slot())->makeWeak(slot(), weakOwner, context);
        set(value);
    }

    enum AdoptTag { Adopt };
    template<typename U> Weak(AdoptTag, Handle<U> handle)
        : Handle<T>(handle.slot())
    {
        validateCell(get());
    }

    Weak(const Weak& other)
        : Handle<T>()
    {
        if (!other.slot())
            return;
        setSlot(HandleHeap::heapFor(other.slot())->copyWeak(other.slot()));
    }

    template <typename U> Weak(const Weak<U>& other)
        : Handle<T>()
    {
        if (!other.slot())
            return;
        setSlot(HandleHeap::heapFor(other.slot())->copyWeak(other.slot()));
    }

    enum HashTableDeletedValueTag { HashTableDeletedValue };
    bool isHashTableDeletedValue() const { return slot() == hashTableDeletedValue(); }
    Weak(HashTableDeletedValueTag)
        : Handle<T>(hashTableDeletedValue())
    {
    }

    ~Weak()
    {
        clear();
    }

    void swap(Weak& other)
    {
        Handle<T>::swap(other);
    }

    ExternalType get() const { return HandleTypes<T>::getFromSlot(slot()); }

    void clear()
    {
        if (!slot())
            return;
        HandleHeap::heapFor(slot())->deallocate(slot());
        setSlot(0);
    }

    void set(JSGlobalData& globalData, ExternalType value, WeakHandleOwner* weakOwner = 0, void* context = 0)
    {
        if (!slot()) {
            setSlot(globalData.heap.handleHeap()->allocate());
            HandleHeap::heapFor(slot())->makeWeak(slot(), weakOwner, context);
        }
        ((void)0);
        set(value);
    }

    template <typename U> Weak& operator=(const Weak<U>& other)
    {
        clear();
        if (other.slot())
            setSlot(HandleHeap::heapFor(other.slot())->copyWeak(other.slot()));
        return *this;
    }

    Weak& operator=(const Weak& other)
    {
        clear();
        if (other.slot())
            setSlot(HandleHeap::heapFor(other.slot())->copyWeak(other.slot()));
        return *this;
    }

    HandleSlot leakHandle()
    {
        ((void)0);
        HandleSlot result = slot();
        setSlot(0);
        return result;
    }

private:
    static HandleSlot hashTableDeletedValue() { return reinterpret_cast<HandleSlot>(-1); }

    void set(ExternalType externalType)
    {
        ((void)0);
        JSValue value = HandleTypes<T>::toJSValue(externalType);
        HandleHeap::heapFor(slot())->writeBarrier(slot(), value);
        *slot() = value;
    }
};

template<class T> inline void swap(Weak<T>& a, Weak<T>& b)
{
    a.swap(b);
}

}

namespace WTF {

template<typename T> struct VectorTraits<JSC::Weak<T> > : SimpleClassVectorTraits {
    static const bool canCompareWithMemcmp = false;
};

template<typename P> struct HashTraits<JSC::Weak<P> > : SimpleClassHashTraits<JSC::Weak<P> > { };

}
# 41 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/Structure.h" 2





namespace JSC {

    class PropertyNameArray;
    class PropertyNameArrayData;
    class StructureChain;
    class SlotVisitor;

    enum EnumerationMode {
        ExcludeDontEnumProperties,
        IncludeDontEnumProperties
    };

    class Structure : public JSCell {
    public:
        friend class StructureTransitionTable;

        typedef JSCell Base;

        static Structure* create(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue prototype, const TypeInfo& typeInfo, const ClassInfo* classInfo)
        {
            ((void)0);
            ((void)0);
            Structure* structure = new (allocateCell<Structure>(globalData.heap)) Structure(globalData, globalObject, prototype, typeInfo, classInfo);
            structure->finishCreation(globalData);
            return structure;
        }

    protected:
        void finishCreation(JSGlobalData& globalData)
        {
            Base::finishCreation(globalData);
            ((void)0);
            ((void)0);
        }

        void finishCreation(JSGlobalData& globalData, CreatingEarlyCellTag)
        {
            Base::finishCreation(globalData, this, CreatingEarlyCell);
            ((void)0);
            ((void)0);
            ((void)0);
        }

    public:
        static void dumpStatistics();

        static Structure* addPropertyTransition(JSGlobalData&, Structure*, const Identifier& propertyName, unsigned attributes, JSCell* specificValue, size_t& offset);
        static Structure* addPropertyTransitionToExistingStructure(Structure*, const Identifier& propertyName, unsigned attributes, JSCell* specificValue, size_t& offset);
        static Structure* removePropertyTransition(JSGlobalData&, Structure*, const Identifier& propertyName, size_t& offset);
        static Structure* changePrototypeTransition(JSGlobalData&, Structure*, JSValue prototype);
        static Structure* despecifyFunctionTransition(JSGlobalData&, Structure*, const Identifier&);
        static Structure* getterSetterTransition(JSGlobalData&, Structure*);
        static Structure* toCacheableDictionaryTransition(JSGlobalData&, Structure*);
        static Structure* toUncacheableDictionaryTransition(JSGlobalData&, Structure*);
        static Structure* sealTransition(JSGlobalData&, Structure*);
        static Structure* freezeTransition(JSGlobalData&, Structure*);
        static Structure* preventExtensionsTransition(JSGlobalData&, Structure*);

        bool isSealed(JSGlobalData&);
        bool isFrozen(JSGlobalData&);
        bool isExtensible() const { return !m_preventExtensions; }
        bool didTransition() const { return m_didTransition; }

        Structure* flattenDictionaryStructure(JSGlobalData&, JSObject*);

        ~Structure();


        size_t addPropertyWithoutTransition(JSGlobalData&, const Identifier& propertyName, unsigned attributes, JSCell* specificValue);
        size_t removePropertyWithoutTransition(JSGlobalData&, const Identifier& propertyName);
        void setPrototypeWithoutTransition(JSGlobalData& globalData, JSValue prototype) { m_prototype.set(globalData, this, prototype); }

        bool isDictionary() const { return m_dictionaryKind != NoneDictionaryKind; }
        bool isUncacheableDictionary() const { return m_dictionaryKind == UncachedDictionaryKind; }


        const TypeInfo& typeInfo() const { ((void)0); return m_typeInfo; }
        bool isObject() const { return typeInfo().isObject(); }


        JSGlobalObject* globalObject() const { return m_globalObject.get(); }
        void setGlobalObject(JSGlobalData& globalData, JSGlobalObject* globalObject) { m_globalObject.set(globalData, this, globalObject); }

        JSValue storedPrototype() const { return m_prototype.get(); }
        JSValue prototypeForLookup(ExecState*) const;
        StructureChain* prototypeChain(ExecState*) const;
        static void visitChildren(JSCell*, SlotVisitor&);

        Structure* previousID() const { ((void)0); return m_previous.get(); }
        bool transitivelyTransitionedFrom(Structure* structureToFind);

        void growPropertyStorageCapacity();
        unsigned propertyStorageCapacity() const { ((void)0); return m_propertyStorageCapacity; }
        unsigned propertyStorageSize() const { ((void)0); return (m_propertyTable ? m_propertyTable->propertyStorageSize() : static_cast<unsigned>(m_offset + 1)); }
        bool isUsingInlineStorage() const;

        size_t get(JSGlobalData&, const Identifier& propertyName);
        size_t get(JSGlobalData&, const UString& name);
        size_t get(JSGlobalData&, StringImpl* propertyName, unsigned& attributes, JSCell*& specificValue);
        size_t get(JSGlobalData& globalData, const Identifier& propertyName, unsigned& attributes, JSCell*& specificValue)
        {
            ((void)0);
            ((void)0);
            return get(globalData, propertyName.impl(), attributes, specificValue);
        }

        bool hasGetterSetterProperties() const { return m_hasGetterSetterProperties; }
        void setHasGetterSetterProperties(bool hasGetterSetterProperties) { m_hasGetterSetterProperties = hasGetterSetterProperties; }

        bool hasNonEnumerableProperties() const { return m_hasNonEnumerableProperties; }

        bool isEmpty() const { return m_propertyTable ? m_propertyTable->isEmpty() : m_offset == noOffset; }

        void despecifyDictionaryFunction(JSGlobalData&, const Identifier& propertyName);
        void disableSpecificFunctionTracking() { m_specificFunctionThrashCount = maxSpecificFunctionThrashCount; }

        void setEnumerationCache(JSGlobalData&, JSPropertyNameIterator* enumerationCache);
        JSPropertyNameIterator* enumerationCache();
        void getPropertyNames(JSGlobalData&, PropertyNameArray&, EnumerationMode mode);

        bool staticFunctionsReified()
        {
            return m_staticFunctionReified;
        }

        void setStaticFunctionsReified()
        {
            m_staticFunctionReified = true;
        }

        const ClassInfo* classInfo() const { return m_classInfo; }

        static ptrdiff_t prototypeOffset()
        {
            return (reinterpret_cast<ptrdiff_t>(&(reinterpret_cast<Structure*>(0x4000)->m_prototype)) - 0x4000);
        }

        static ptrdiff_t typeInfoFlagsOffset()
        {
            return (reinterpret_cast<ptrdiff_t>(&(reinterpret_cast<Structure*>(0x4000)->m_typeInfo)) - 0x4000) + TypeInfo::flagsOffset();
        }

        static ptrdiff_t typeInfoTypeOffset()
        {
            return (reinterpret_cast<ptrdiff_t>(&(reinterpret_cast<Structure*>(0x4000)->m_typeInfo)) - 0x4000) + TypeInfo::typeOffset();
        }

        static Structure* createStructure(JSGlobalData& globalData)
        {
            ((void)0);
            Structure* structure = new (allocateCell<Structure>(globalData.heap)) Structure(globalData);
            structure->finishCreation(globalData, CreatingEarlyCell);
            return structure;
        }

        static const ClassInfo s_info;

    private:
        Structure(JSGlobalData&, JSGlobalObject*, JSValue prototype, const TypeInfo&, const ClassInfo*);
        Structure(JSGlobalData&);
        Structure(JSGlobalData&, const Structure*);

        static Structure* create(JSGlobalData& globalData, const Structure* structure)
        {
            ((void)0);
            Structure* newStructure = new (allocateCell<Structure>(globalData.heap)) Structure(globalData, structure);
            newStructure->finishCreation(globalData);
            return newStructure;
        }

        typedef enum {
            NoneDictionaryKind = 0,
            CachedDictionaryKind = 1,
            UncachedDictionaryKind = 2
        } DictionaryKind;
        static Structure* toDictionaryTransition(JSGlobalData&, Structure*, DictionaryKind);

        size_t putSpecificValue(JSGlobalData&, const Identifier& propertyName, unsigned attributes, JSCell* specificValue);
        size_t remove(const Identifier& propertyName);

        void createPropertyMap(unsigned keyCount = 0);
        void checkConsistency();

        bool despecifyFunction(JSGlobalData&, const Identifier&);
        void despecifyAllFunctions(JSGlobalData&);

        PassOwnPtr<PropertyTable> copyPropertyTable(JSGlobalData&, Structure* owner);
        void materializePropertyMap(JSGlobalData&);
        void materializePropertyMapIfNecessary(JSGlobalData& globalData)
        {
            ((void)0);
            if (!m_propertyTable && m_previous)
                materializePropertyMap(globalData);
        }

        int transitionCount() const
        {

            return m_offset == noOffset ? 0 : m_offset + 1;
        }

        bool isValid(ExecState*, StructureChain* cachedPrototypeChain) const;

        void pin();

        static const int s_maxTransitionLength = 64;

        static const int noOffset = -1;

        static const unsigned maxSpecificFunctionThrashCount = 3;

        TypeInfo m_typeInfo;

        WriteBarrier<JSGlobalObject> m_globalObject;
        WriteBarrier<Unknown> m_prototype;
        mutable WriteBarrier<StructureChain> m_cachedPrototypeChain;

        WriteBarrier<Structure> m_previous;
        RefPtr<StringImpl> m_nameInPrevious;
        WriteBarrier<JSCell> m_specificValueInPrevious;

        const ClassInfo* m_classInfo;

        StructureTransitionTable m_transitionTable;

        WriteBarrier<JSPropertyNameIterator> m_enumerationCache;

        OwnPtr<PropertyTable> m_propertyTable;

        uint32_t m_propertyStorageCapacity;


        int m_offset;

        unsigned m_dictionaryKind : 2;
        bool m_isPinnedPropertyTable : 1;
        bool m_hasGetterSetterProperties : 1;
        bool m_hasNonEnumerableProperties : 1;






        unsigned m_attributesInPrevious : 7;

        unsigned m_specificFunctionThrashCount : 2;
        unsigned m_preventExtensions : 1;
        unsigned m_didTransition : 1;
        unsigned m_staticFunctionReified;
    };

    inline size_t Structure::get(JSGlobalData& globalData, const Identifier& propertyName)
    {
        ((void)0);
        materializePropertyMapIfNecessary(globalData);
        if (!m_propertyTable)
            return notFound;

        PropertyMapEntry* entry = m_propertyTable->find(propertyName.impl()).first;
        return entry ? entry->offset : notFound;
    }

    inline size_t Structure::get(JSGlobalData& globalData, const UString& name)
    {
        ((void)0);
        materializePropertyMapIfNecessary(globalData);
        if (!m_propertyTable)
            return notFound;

        PropertyMapEntry* entry = m_propertyTable->findWithString(name.impl()).first;
        return entry ? entry->offset : notFound;
    }

    inline bool JSCell::isObject() const
    {
        return m_structure->isObject();
    }

    inline bool JSCell::isString() const
    {
        return m_structure->typeInfo().type() == StringType;
    }

    inline bool JSCell::isGetterSetter() const
    {
        return m_structure->typeInfo().type() == GetterSetterType;
    }

    inline bool JSCell::isAPIValueWrapper() const
    {
        return m_structure->typeInfo().type() == APIValueWrapperType;
    }

    inline void JSCell::setStructure(JSGlobalData& globalData, Structure* structure)
    {
        ((void)0);
        m_structure.set(globalData, this, structure);
    }

    inline const ClassInfo* JSCell::classInfo() const
    {



        return m_structure->classInfo();

    }

    inline __attribute__((__always_inline__)) void MarkStack::internalAppend(JSCell* cell)
    {
        ((void)0);



        m_visitCount++;
        if (Heap::testAndSetMarked(cell) || !cell->structure())
            return;
        m_stack.append(cell);
    }

    inline StructureTransitionTable::Hash::Key StructureTransitionTable::keyForWeakGCMapFinalizer(void*, Structure* structure)
    {



        return Hash::Key(structure->m_nameInPrevious.get(), +structure->m_attributesInPrevious);
    }

    inline bool Structure::transitivelyTransitionedFrom(Structure* structureToFind)
    {
        for (Structure* current = this; current; current = current->previousID()) {
            if (current == structureToFind)
                return true;
        }
        return false;
    }

}
# 26 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/ScopeChain.h" 2


namespace JSC {

    class JSGlobalData;
    class JSGlobalObject;
    class JSObject;
    class ScopeChainIterator;
    class SlotVisitor;

    class ScopeChainNode : public JSCell {
    private:
        ScopeChainNode(ScopeChainNode* next, JSObject* object, JSGlobalData* globalData, JSGlobalObject* globalObject, JSObject* globalThis)
            : JSCell(*globalData, globalData->scopeChainNodeStructure.get())
            , globalData(globalData)
            , next(*globalData, this, next, WriteBarrier<ScopeChainNode>::MayBeNull)
            , object(*globalData, this, object)
            , globalObject(*globalData, this, globalObject)
            , globalThis(*globalData, this, globalThis)
        {
        }

        virtual ~ScopeChainNode();

    protected:
        void finishCreation(JSGlobalData* globalData, JSGlobalObject* globalObject)
        {
            Base::finishCreation(*globalData);
            ((void)globalObject);
        }

    public:
        typedef JSCell Base;

        static ScopeChainNode* create(ExecState* exec, ScopeChainNode* next, JSObject* object, JSGlobalData* globalData, JSGlobalObject* globalObject, JSObject* globalThis)
        {
            ScopeChainNode* node = new (allocateCell<ScopeChainNode>(*exec->heap())) ScopeChainNode(next, object, globalData, globalObject, globalThis);
            node->finishCreation(globalData, globalObject);
            return node;
        }
        static ScopeChainNode* create(ScopeChainNode* next, JSObject* object, JSGlobalData* globalData, JSGlobalObject* globalObject, JSObject* globalThis)
        {
            ScopeChainNode* node = new (allocateCell<ScopeChainNode>(globalData->heap)) ScopeChainNode(next, object, globalData, globalObject, globalThis);
            node->finishCreation(globalData, globalObject);
            return node;
        }

        JSGlobalData* globalData;
        WriteBarrier<ScopeChainNode> next;
        WriteBarrier<JSObject> object;
        WriteBarrier<JSGlobalObject> globalObject;
        WriteBarrier<JSObject> globalThis;

        ScopeChainNode* push(JSObject*);
        ScopeChainNode* pop();

        ScopeChainIterator begin();
        ScopeChainIterator end();

        int localDepth();





        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue proto) { return Structure::create(globalData, globalObject, proto, TypeInfo(CompoundType, StructureFlags), &s_info); }
        static void visitChildren(JSCell*, SlotVisitor&);
        static const ClassInfo s_info;

    private:
        static const unsigned StructureFlags = OverridesVisitChildren;
    };

    inline ScopeChainNode* ScopeChainNode::push(JSObject* o)
    {
        ((void)0);
        return ScopeChainNode::create(this, o, globalData, globalObject.get(), globalThis.get());
    }

    inline ScopeChainNode* ScopeChainNode::pop()
    {
        ((void)0);
        return next.get();
    }

    class ScopeChainIterator {
    public:
        ScopeChainIterator(ScopeChainNode* node)
            : m_node(node)
        {
        }

        WriteBarrier<JSObject> const & operator*() const { return m_node->object; }
        WriteBarrier<JSObject> const * operator->() const { return &(operator*()); }

        ScopeChainIterator& operator++() { m_node = m_node->next.get(); return *this; }



        bool operator==(const ScopeChainIterator& other) const { return m_node == other.m_node; }
        bool operator!=(const ScopeChainIterator& other) const { return m_node != other.m_node; }

    private:
        ScopeChainNode* m_node;
    };

    inline ScopeChainIterator ScopeChainNode::begin()
    {
        return ScopeChainIterator(this);
    }

    inline ScopeChainIterator ScopeChainNode::end()
    {
        return ScopeChainIterator(0);
    }

    inline __attribute__((__always_inline__)) JSGlobalData& ExecState::globalData() const
    {
        ((void)0);
        return *scopeChain()->globalData;
    }

    inline __attribute__((__always_inline__)) JSGlobalObject* ExecState::lexicalGlobalObject() const
    {
        return scopeChain()->globalObject.get();
    }

    inline __attribute__((__always_inline__)) JSObject* ExecState::globalThisValue() const
    {
        return scopeChain()->globalThis.get();
    }

    inline __attribute__((__always_inline__)) ScopeChainNode* Register::scopeChain() const
    {
        return static_cast<ScopeChainNode*>(jsValue().asCell());
    }

    inline __attribute__((__always_inline__)) Register& Register::operator=(ScopeChainNode* scopeChain)
    {
        *this = JSValue(scopeChain);
        return *this;
    }

}
# 34 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSObject.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/StorageBarrier.h" 1
# 32 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/StorageBarrier.h"
namespace JSC {

typedef WriteBarrierBase<Unknown>* PropertyStorage;
typedef const WriteBarrierBase<Unknown>* ConstPropertyStorage;

class StorageBarrier {
public:
    enum UncheckedTag { Unchecked };
    StorageBarrier(JSGlobalData& globalData, JSCell* owner, PropertyStorage storage)
    {
        set(globalData, owner, storage);
    }

    StorageBarrier(PropertyStorage storage, UncheckedTag)
    {
        set(storage, Unchecked);
    }

    void set(JSGlobalData&, JSCell*, PropertyStorage newStorage)
    {
        m_storage = newStorage;
    }

    void set(PropertyStorage newStorage, UncheckedTag)
    {
        m_storage = newStorage;
    }

    WriteBarrierBase<Unknown>* operator->() const { return m_storage; }
    WriteBarrierBase<Unknown>* operator->() { return m_storage; }
    WriteBarrierBase<Unknown> operator*() const { return *m_storage; }
    WriteBarrierBase<Unknown> operator*() { return *m_storage; }
    const WriteBarrierBase<Unknown>& operator[](size_t i) const { return m_storage[i]; }
    WriteBarrierBase<Unknown>& operator[](size_t i) { return m_storage[i]; }

    ConstPropertyStorage get() const { return m_storage; }
    PropertyStorage get() { return m_storage; }

private:
    PropertyStorage m_storage;
};

}
# 35 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSObject.h" 2


# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSString.h" 1
# 29 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSString.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/PropertyDescriptor.h" 1
# 31 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/PropertyDescriptor.h"
namespace JSC {
    class PropertyDescriptor {
    public:
        PropertyDescriptor()
            : m_attributes(defaultAttributes)
            , m_seenAttributes(0)
        {
        }
        bool writable() const;
        bool enumerable() const;
        bool configurable() const;
        bool isDataDescriptor() const;
        bool isGenericDescriptor() const;
        bool isAccessorDescriptor() const;
        unsigned attributes() const { return m_attributes; }
        JSValue value() const { return m_value; }
        JSValue getter() const;
        JSValue setter() const;
        void setUndefined();
        void setDescriptor(JSValue value, unsigned attributes);
        void setAccessorDescriptor(JSValue getter, JSValue setter, unsigned attributes);
        void setWritable(bool);
        void setEnumerable(bool);
        void setConfigurable(bool);
        void setValue(JSValue value) { m_value = value; }
        void setSetter(JSValue);
        void setGetter(JSValue);
        bool isEmpty() const { return !(m_value || m_getter || m_setter || m_seenAttributes); }
        bool writablePresent() const { return m_seenAttributes & WritablePresent; }
        bool enumerablePresent() const { return m_seenAttributes & EnumerablePresent; }
        bool configurablePresent() const { return m_seenAttributes & ConfigurablePresent; }
        bool setterPresent() const { return m_setter; }
        bool getterPresent() const { return m_getter; }
        bool equalTo(ExecState* exec, const PropertyDescriptor& other) const;
        bool attributesEqual(const PropertyDescriptor& other) const;
        unsigned attributesWithOverride(const PropertyDescriptor& other) const;
    private:
        static unsigned defaultAttributes;
        bool operator==(const PropertyDescriptor&){ return false; }
        enum { WritablePresent = 1, EnumerablePresent = 2, ConfigurablePresent = 4};

        JSValue m_value;
        JSValue m_getter;
        JSValue m_setter;
        unsigned m_attributes;
        unsigned m_seenAttributes;
    };
}
# 30 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSString.h" 2



namespace JSC {

    class JSString;

    JSString* jsEmptyString(JSGlobalData*);
    JSString* jsEmptyString(ExecState*);
    JSString* jsString(JSGlobalData*, const UString&);
    JSString* jsString(ExecState*, const UString&);

    JSString* jsSingleCharacterString(JSGlobalData*, UChar);
    JSString* jsSingleCharacterString(ExecState*, UChar);
    JSString* jsSingleCharacterSubstring(ExecState*, const UString&, unsigned offset);
    JSString* jsSubstring(JSGlobalData*, const UString&, unsigned offset, unsigned length);
    JSString* jsSubstring(ExecState*, const UString&, unsigned offset, unsigned length);



    JSString* jsNontrivialString(JSGlobalData*, const UString&);
    JSString* jsNontrivialString(ExecState*, const UString&);
    JSString* jsNontrivialString(JSGlobalData*, const char*);
    JSString* jsNontrivialString(ExecState*, const char*);




    JSString* jsOwnedString(JSGlobalData*, const UString&);
    JSString* jsOwnedString(ExecState*, const UString&);

    JSString* jsStringBuilder(JSGlobalData*);

    class JSString : public JSCell {
    public:
        friend class JIT;
        friend class JSGlobalData;
        friend class SpecializedThunkJIT;
        friend struct ThunkHelpers;
        friend JSString* jsStringBuilder(JSGlobalData*);

        typedef JSCell Base;

        class RopeBuilder {
        public:
            RopeBuilder(JSGlobalData& globalData)
                : m_globalData(globalData)
                , m_jsString(jsStringBuilder(&globalData))
                , m_index(0)
            {
            }

            void append(JSString* jsString)
            {
                if (m_index == JSString::s_maxInternalRopeLength)
                    expand();
                m_jsString->m_fibers[m_index++].set(m_globalData, m_jsString, jsString);
                m_jsString->m_length += jsString->m_length;
            }

            JSString* release()
            {
                JSString* tmp = m_jsString;
                m_jsString = 0;
                return tmp;
            }

            unsigned length() { return m_jsString->m_length; }

        private:
            void expand();

            JSGlobalData& m_globalData;
            JSString* m_jsString;
            size_t m_index;
        };

    private:
        JSString(JSGlobalData& globalData, PassRefPtr<StringImpl> value)
            : JSCell(globalData, globalData.stringStructure.get())
            , m_value(value)
        {
        }

        JSString(JSGlobalData& globalData)
            : JSCell(globalData, globalData.stringStructure.get())
        {
        }

        void finishCreation(JSGlobalData& globalData)
        {
            Base::finishCreation(globalData);
            m_length = 0;
        }

        void finishCreation(JSGlobalData& globalData, size_t length)
        {
            ((void)0);
            Base::finishCreation(globalData);
            m_length = length;
        }

        void finishCreation(JSGlobalData& globalData, size_t length, size_t cost)
        {
            ((void)0);
            Base::finishCreation(globalData);
            m_length = length;
            Heap::heap(this)->reportExtraMemoryCost(cost);
        }

        void finishCreation(JSGlobalData& globalData, JSString* s1, JSString* s2)
        {
            Base::finishCreation(globalData);
            m_length = s1->length() + s2->length();
            m_fibers[0].set(globalData, this, s1);
            m_fibers[1].set(globalData, this, s2);
        }

        void finishCreation(JSGlobalData& globalData, JSString* s1, JSString* s2, JSString* s3)
        {
            Base::finishCreation(globalData);
            m_length = s1->length() + s2->length() + s3->length();
            m_fibers[0].set(globalData, this, s1);
            m_fibers[1].set(globalData, this, s2);
            m_fibers[2].set(globalData, this, s3);
        }

        static JSString* createNull(JSGlobalData& globalData)
        {
            JSString* newString = new (allocateCell<JSString>(globalData.heap)) JSString(globalData);
            newString->finishCreation(globalData);
            return newString;
        }

    public:
        static JSString* create(JSGlobalData& globalData, PassRefPtr<StringImpl> value)
        {
            ((void)0);
            size_t length = value->length();
            size_t cost = value->cost();
            JSString* newString = new (allocateCell<JSString>(globalData.heap)) JSString(globalData, value);
            newString->finishCreation(globalData, length, cost);
            return newString;
        }
        static JSString* create(JSGlobalData& globalData, JSString* s1, JSString* s2)
        {
            JSString* newString = new (allocateCell<JSString>(globalData.heap)) JSString(globalData);
            newString->finishCreation(globalData, s1, s2);
            return newString;
        }
        static JSString* create(JSGlobalData& globalData, JSString* s1, JSString* s2, JSString* s3)
        {
            JSString* newString = new (allocateCell<JSString>(globalData.heap)) JSString(globalData);
            newString->finishCreation(globalData, s1, s2, s3);
            return newString;
        }
        static JSString* createHasOtherOwner(JSGlobalData& globalData, PassRefPtr<StringImpl> value)
        {
            ((void)0);
            size_t length = value->length();
            JSString* newString = new (allocateCell<JSString>(globalData.heap)) JSString(globalData, value);
            newString->finishCreation(globalData, length);
            return newString;
        }

        virtual ~JSString();

        const UString& value(ExecState* exec) const
        {
            if (isRope())
                resolveRope(exec);
            return m_value;
        }
        const UString& tryGetValue() const
        {
            if (isRope())
                resolveRope(0);
            return m_value;
        }
        unsigned length() { return m_length; }

        JSValue toPrimitive(ExecState*, PreferredPrimitiveType) const;
        bool toBoolean(ExecState*) const;
        bool getPrimitiveNumber(ExecState*, double& number, JSValue&) const;
        JSObject* toObject(ExecState*, JSGlobalObject*) const;
        UString toString(ExecState*) const;
        double toNumber(ExecState*) const;

        bool getStringPropertySlot(ExecState*, const Identifier& propertyName, PropertySlot&);
        bool getStringPropertySlot(ExecState*, unsigned propertyName, PropertySlot&);
        bool getStringPropertyDescriptor(ExecState*, const Identifier& propertyName, PropertyDescriptor&);

        bool canGetIndex(unsigned i) { return i < m_length; }
        JSString* getIndex(ExecState*, unsigned);
        JSString* getIndexSlowCase(ExecState*, unsigned);

        JSValue replaceCharacter(ExecState*, UChar, const UString& replacement);

        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue proto)
        {
            return Structure::create(globalData, globalObject, proto, TypeInfo(StringType, OverridesGetOwnPropertySlot), &s_info);
        }

        static size_t offsetOfLength() { return (reinterpret_cast<ptrdiff_t>(&(reinterpret_cast<JSString*>(0x4000)->m_length)) - 0x4000); }
        static size_t offsetOfValue() { return (reinterpret_cast<ptrdiff_t>(&(reinterpret_cast<JSString*>(0x4000)->m_value)) - 0x4000); }

        static const ClassInfo s_info;

        static void visitChildren(JSCell*, SlotVisitor&);

    private:
        JSString(VPtrStealingHackType)
            : JSCell(VPtrStealingHack)
        {
        }

        void resolveRope(ExecState*) const;
        void resolveRopeSlowCase(ExecState*, UChar*) const;
        void outOfMemory(ExecState*) const;

        virtual JSObject* toThisObject(ExecState*) const;


        static bool getOwnPropertySlot(JSCell*, ExecState*, const Identifier& propertyName, PropertySlot&);
        static bool getOwnPropertySlotByIndex(JSCell*, ExecState*, unsigned propertyName, PropertySlot&);
        virtual bool getOwnPropertyDescriptor(ExecState*, const Identifier&, PropertyDescriptor&);

        static const unsigned s_maxInternalRopeLength = 3;


        unsigned m_length;
        mutable UString m_value;
        mutable FixedArray<WriteBarrier<JSString>, s_maxInternalRopeLength> m_fibers;

        bool isRope() const { return m_value.isNull(); }
        UString& string() { ((void)0); return m_value; }

        friend JSValue jsString(ExecState*, JSString*, JSString*);
        friend JSValue jsString(ExecState*, Register*, unsigned count);
        friend JSValue jsStringFromArguments(ExecState*, JSValue thisValue);
        friend JSString* jsSubstring(ExecState*, JSString*, unsigned offset, unsigned length);
    };

    JSString* asString(JSValue);
# 282 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSString.h"
    inline JSString* fixupVPtr(JSGlobalData*, JSString* string) { return string; }


    inline JSString* asString(JSValue value)
    {
        ((void)0);
        return static_cast<JSString*>(value.asCell());
    }

    inline JSString* jsEmptyString(JSGlobalData* globalData)
    {
        return globalData->smallStrings.emptyString(globalData);
    }

    inline JSString* jsSingleCharacterString(JSGlobalData* globalData, UChar c)
    {
        if (c <= maxSingleCharacterString)
            return globalData->smallStrings.singleCharacterString(globalData, c);
        return fixupVPtr(globalData, JSString::create(*globalData, UString(&c, 1).impl()));
    }

    inline JSString* jsSingleCharacterSubstring(ExecState* exec, const UString& s, unsigned offset)
    {
        JSGlobalData* globalData = &exec->globalData();
        ((void)0);
        UChar c = s[offset];
        if (c <= maxSingleCharacterString)
            return globalData->smallStrings.singleCharacterString(globalData, c);
        return fixupVPtr(globalData, JSString::create(*globalData, StringImpl::create(s.impl(), offset, 1)));
    }

    inline JSString* jsNontrivialString(JSGlobalData* globalData, const char* s)
    {
        ((void)0);
        ((void)0);
        ((void)0);
        return fixupVPtr(globalData, JSString::create(*globalData, UString(s).impl()));
    }

    inline JSString* jsNontrivialString(JSGlobalData* globalData, const UString& s)
    {
        ((void)0);
        return fixupVPtr(globalData, JSString::create(*globalData, s.impl()));
    }

    inline JSString* JSString::getIndex(ExecState* exec, unsigned i)
    {
        ((void)0);
        if (isRope())
            return getIndexSlowCase(exec, i);
        ((void)0);
        return jsSingleCharacterSubstring(exec, m_value, i);
    }

    inline JSString* jsString(JSGlobalData* globalData, const UString& s)
    {
        int size = s.length();
        if (!size)
            return globalData->smallStrings.emptyString(globalData);
        if (size == 1) {
            UChar c = s[0];
            if (c <= maxSingleCharacterString)
                return globalData->smallStrings.singleCharacterString(globalData, c);
        }
        return fixupVPtr(globalData, JSString::create(*globalData, s.impl()));
    }

    inline JSString* jsSubstring(ExecState* exec, JSString* s, unsigned offset, unsigned length)
    {
        ((void)0);
        ((void)0);
        ((void)0);
        JSGlobalData* globalData = &exec->globalData();
        if (!length)
            return globalData->smallStrings.emptyString(globalData);
        return jsSubstring(globalData, s->value(exec), offset, length);
    }

    inline JSString* jsSubstring(JSGlobalData* globalData, const UString& s, unsigned offset, unsigned length)
    {
        ((void)0);
        ((void)0);
        ((void)0);
        if (!length)
            return globalData->smallStrings.emptyString(globalData);
        if (length == 1) {
            UChar c = s[offset];
            if (c <= maxSingleCharacterString)
                return globalData->smallStrings.singleCharacterString(globalData, c);
        }
        return fixupVPtr(globalData, JSString::createHasOtherOwner(*globalData, StringImpl::create(s.impl(), offset, length)));
    }

    inline JSString* jsOwnedString(JSGlobalData* globalData, const UString& s)
    {
        int size = s.length();
        if (!size)
            return globalData->smallStrings.emptyString(globalData);
        if (size == 1) {
            UChar c = s[0];
            if (c <= maxSingleCharacterString)
                return globalData->smallStrings.singleCharacterString(globalData, c);
        }
        return fixupVPtr(globalData, JSString::createHasOtherOwner(*globalData, s.impl()));
    }

    inline JSString* jsStringBuilder(JSGlobalData* globalData)
    {
        return fixupVPtr(globalData, JSString::createNull(*globalData));
    }

    inline JSString* jsEmptyString(ExecState* exec) { return jsEmptyString(&exec->globalData()); }
    inline JSString* jsString(ExecState* exec, const UString& s) { return jsString(&exec->globalData(), s); }
    inline JSString* jsSingleCharacterString(ExecState* exec, UChar c) { return jsSingleCharacterString(&exec->globalData(), c); }
    inline JSString* jsSubstring(ExecState* exec, const UString& s, unsigned offset, unsigned length) { return jsSubstring(&exec->globalData(), s, offset, length); }
    inline JSString* jsNontrivialString(ExecState* exec, const UString& s) { return jsNontrivialString(&exec->globalData(), s); }
    inline JSString* jsNontrivialString(ExecState* exec, const char* s) { return jsNontrivialString(&exec->globalData(), s); }
    inline JSString* jsOwnedString(ExecState* exec, const UString& s) { return jsOwnedString(&exec->globalData(), s); }

    inline __attribute__((__always_inline__)) bool JSString::getStringPropertySlot(ExecState* exec, const Identifier& propertyName, PropertySlot& slot)
    {
        if (propertyName == exec->propertyNames().length) {
            slot.setValue(jsNumber(m_length));
            return true;
        }

        bool isStrictUInt32;
        unsigned i = propertyName.toUInt32(isStrictUInt32);
        if (isStrictUInt32 && i < m_length) {
            slot.setValue(getIndex(exec, i));
            return true;
        }

        return false;
    }

    inline __attribute__((__always_inline__)) bool JSString::getStringPropertySlot(ExecState* exec, unsigned propertyName, PropertySlot& slot)
    {
        if (propertyName < m_length) {
            slot.setValue(getIndex(exec, propertyName));
            return true;
        }

        return false;
    }

    inline bool isJSString(JSGlobalData* globalData, JSValue v) { return v.isCell() && v.asCell()->vptr() == globalData->jsStringVPtr; }

    inline bool JSCell::toBoolean(ExecState* exec) const
    {
        if (isString())
            return static_cast<const JSString*>(this)->toBoolean(exec);
        return !structure()->typeInfo().masqueradesAsUndefined();
    }



    inline bool JSValue::toBoolean(ExecState* exec) const
    {
        if (isInt32())
            return asInt32();
        if (isDouble())
            return asDouble() > 0.0 || asDouble() < 0.0;
        if (isCell())
            return asCell()->toBoolean(exec);
        return isTrue();
    }

    inline UString JSValue::toString(ExecState* exec) const
    {
        if (isString())
            return static_cast<JSString*>(asCell())->value(exec);
        if (isInt32())
            return exec->globalData().numericStrings.add(asInt32());
        if (isDouble())
            return exec->globalData().numericStrings.add(asDouble());
        if (isTrue())
            return "true";
        if (isFalse())
            return "false";
        if (isNull())
            return "null";
        if (isUndefined())
            return "undefined";
        ((void)0);
        return asCell()->toString(exec);
    }

}
# 38 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSObject.h" 2


namespace JSC {

    inline JSCell* getJSFunction(JSValue value)
    {
        if (value.isCell() && (value.asCell()->structure()->typeInfo().type() == JSFunctionType))
            return value.asCell();
        return 0;
    }

    class GetterSetter;
    class HashEntry;
    class InternalFunction;
    class MarkedBlock;
    class PropertyDescriptor;
    class PropertyNameArray;
    class Structure;
    struct HashTable;

    JSObject* throwTypeError(ExecState*, const UString&);
    extern const char* StrictModeReadonlyPropertyWriteError;



    enum Attribute {
        None = 0,
        ReadOnly = 1 << 1,
        DontEnum = 1 << 2,
        DontDelete = 1 << 3,
        Function = 1 << 4,
        Getter = 1 << 5,
        Setter = 1 << 6
    };

    class JSObject : public JSCell {
        friend class BatchedTransitionOptimizer;
        friend class JIT;
        friend class JSCell;
        friend class MarkedBlock;
        friend bool setUpStaticFunctionSlot(ExecState* exec, const HashEntry* entry, JSObject* thisObj, const Identifier& propertyName, PropertySlot& slot);

    public:
        typedef JSCell Base;

        static void visitChildren(JSCell*, SlotVisitor&);

        virtual UString className() const;

        static void finalize(JSCell*);

        JSValue prototype() const;
        void setPrototype(JSGlobalData&, JSValue prototype);
        bool setPrototypeWithCycleCheck(JSGlobalData&, JSValue prototype);

        Structure* inheritorID(JSGlobalData&);

        JSValue get(ExecState*, const Identifier& propertyName) const;
        JSValue get(ExecState*, unsigned propertyName) const;

        bool getPropertySlot(ExecState*, const Identifier& propertyName, PropertySlot&);
        bool getPropertySlot(ExecState*, unsigned propertyName, PropertySlot&);
        bool getPropertyDescriptor(ExecState*, const Identifier& propertyName, PropertyDescriptor&);

        static bool getOwnPropertySlot(JSCell*, ExecState*, const Identifier& propertyName, PropertySlot&);
        static bool getOwnPropertySlotByIndex(JSCell*, ExecState*, unsigned propertyName, PropertySlot&);
        virtual bool getOwnPropertyDescriptor(ExecState*, const Identifier&, PropertyDescriptor&);

        static void put(JSCell*, ExecState*, const Identifier& propertyName, JSValue, PutPropertySlot&);
        static void putByIndex(JSCell*, ExecState*, unsigned propertyName, JSValue);

        virtual void putWithAttributes(JSGlobalData*, const Identifier& propertyName, JSValue value, unsigned attributes, bool checkReadOnly, PutPropertySlot& slot);
        virtual void putWithAttributes(JSGlobalData*, const Identifier& propertyName, JSValue value, unsigned attributes);
        virtual void putWithAttributes(JSGlobalData*, unsigned propertyName, JSValue value, unsigned attributes);
        virtual void putWithAttributes(ExecState*, const Identifier& propertyName, JSValue value, unsigned attributes, bool checkReadOnly, PutPropertySlot& slot);
        virtual void putWithAttributes(ExecState*, const Identifier& propertyName, JSValue value, unsigned attributes);
        virtual void putWithAttributes(ExecState*, unsigned propertyName, JSValue value, unsigned attributes);

        bool propertyIsEnumerable(ExecState*, const Identifier& propertyName) const;

        bool hasProperty(ExecState*, const Identifier& propertyName) const;
        bool hasProperty(ExecState*, unsigned propertyName) const;
        bool hasOwnProperty(ExecState*, const Identifier& propertyName) const;

        static bool deleteProperty(JSCell*, ExecState*, const Identifier& propertyName);
        static bool deletePropertyByIndex(JSCell*, ExecState*, unsigned propertyName);

        virtual JSValue defaultValue(ExecState*, PreferredPrimitiveType) const;

        virtual bool hasInstance(ExecState*, JSValue, JSValue prototypeProperty);

        virtual void getPropertyNames(ExecState*, PropertyNameArray&, EnumerationMode mode = ExcludeDontEnumProperties);
        virtual void getOwnPropertyNames(ExecState*, PropertyNameArray&, EnumerationMode mode = ExcludeDontEnumProperties);

        JSValue toPrimitive(ExecState*, PreferredPrimitiveType = NoPreference) const;
        bool toBoolean(ExecState*) const;
        bool getPrimitiveNumber(ExecState*, double& number, JSValue&) const;
        double toNumber(ExecState*) const;
        UString toString(ExecState*) const;

        virtual JSObject* toThisObject(ExecState*) const;
        virtual JSObject* unwrappedObject();

        bool getPropertySpecificValue(ExecState* exec, const Identifier& propertyName, JSCell*& specificFunction) const;


        JSValue getDirect(JSGlobalData& globalData, const Identifier& propertyName) const
        {
            size_t offset = structure()->get(globalData, propertyName);
            return offset != WTF::notFound ? getDirectOffset(offset) : JSValue();
        }

        WriteBarrierBase<Unknown>* getDirectLocation(JSGlobalData& globalData, const Identifier& propertyName)
        {
            size_t offset = structure()->get(globalData, propertyName);
            return offset != WTF::notFound ? locationForOffset(offset) : 0;
        }

        WriteBarrierBase<Unknown>* getDirectLocation(JSGlobalData& globalData, const Identifier& propertyName, unsigned& attributes)
        {
            JSCell* specificFunction;
            size_t offset = structure()->get(globalData, propertyName, attributes, specificFunction);
            return offset != WTF::notFound ? locationForOffset(offset) : 0;
        }

        size_t offsetForLocation(WriteBarrierBase<Unknown>* location) const
        {
            return location - propertyStorage();
        }

        void transitionTo(JSGlobalData&, Structure*);

        void removeDirect(JSGlobalData&, const Identifier& propertyName);
        bool hasCustomProperties() { return structure()->didTransition(); }
        bool hasGetterSetterProperties() { return structure()->hasGetterSetterProperties(); }

        bool putDirect(JSGlobalData&, const Identifier& propertyName, JSValue, unsigned attr, bool checkReadOnly, PutPropertySlot&);
        void putDirect(JSGlobalData&, const Identifier& propertyName, JSValue, unsigned attr = 0);
        bool putDirect(JSGlobalData&, const Identifier& propertyName, JSValue, PutPropertySlot&);

        void putDirectWithoutTransition(JSGlobalData&, const Identifier& propertyName, JSValue, unsigned attr = 0);


        JSValue getDirectOffset(size_t offset) const { return propertyStorage()[offset].get(); }
        void putDirectOffset(JSGlobalData& globalData, size_t offset, JSValue value) { propertyStorage()[offset].set(globalData, this, value); }
        void putUndefinedAtDirectOffset(size_t offset) { propertyStorage()[offset].setUndefined(); }

        void fillGetterPropertySlot(PropertySlot&, WriteBarrierBase<Unknown>* location);
        void initializeGetterSetterProperty(ExecState*, const Identifier&, GetterSetter*, unsigned attributes);

        virtual void defineGetter(ExecState*, const Identifier& propertyName, JSObject* getterFunction, unsigned attributes = 0);
        virtual void defineSetter(ExecState*, const Identifier& propertyName, JSObject* setterFunction, unsigned attributes = 0);
        virtual JSValue lookupGetter(ExecState*, const Identifier& propertyName);
        virtual JSValue lookupSetter(ExecState*, const Identifier& propertyName);
        virtual bool defineOwnProperty(ExecState*, const Identifier& propertyName, PropertyDescriptor&, bool shouldThrow);

        virtual bool isGlobalObject() const { return false; }
        virtual bool isVariableObject() const { return false; }
        virtual bool isActivationObject() const { return false; }
        virtual bool isErrorInstance() const { return false; }

        void seal(JSGlobalData&);
        void freeze(JSGlobalData&);
        void preventExtensions(JSGlobalData&);
        bool isSealed(JSGlobalData& globalData) { return structure()->isSealed(globalData); }
        bool isFrozen(JSGlobalData& globalData) { return structure()->isFrozen(globalData); }
        bool isExtensible() { return structure()->isExtensible(); }

        bool staticFunctionsReified() { return structure()->staticFunctionsReified(); }
        void reifyStaticFunctionsForDelete(ExecState* exec);

        void allocatePropertyStorage(JSGlobalData&, size_t oldSize, size_t newSize);
        bool isUsingInlineStorage() const { return static_cast<const void*>(m_propertyStorage.get()) == static_cast<const void*>(this + 1); }

        void* addressOfPropertyStorage()
        {
            return &m_propertyStorage;
        }

        static const unsigned baseExternalStorageCapacity = 16;

        void flattenDictionaryObject(JSGlobalData& globalData)
        {
            structure()->flattenDictionaryStructure(globalData, this);
        }

        JSGlobalObject* globalObject() const
        {
            ((void)0);
            ((void)0);
            return structure()->globalObject();
        }

        static size_t offsetOfInlineStorage();
        static size_t offsetOfPropertyStorage();
        static size_t offsetOfInheritorID();

        static const ClassInfo s_info;

    protected:
        void finishCreation(JSGlobalData& globalData, PropertyStorage inlineStorage)
        {
            Base::finishCreation(globalData);
            ((void)0);
            ((void)0);
            ((void)0);
            ((void)0);
            ((void)inlineStorage);
            ((void)0);
        }

        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue prototype)
        {
            return Structure::create(globalData, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), &s_info);
        }

        static const unsigned StructureFlags = 0;



        JSObject(JSGlobalData&, Structure*, PropertyStorage inlineStorage);
        JSObject(VPtrStealingHackType, PropertyStorage inlineStorage)
            : JSCell(VPtrStealingHack)
            , m_propertyStorage(inlineStorage, StorageBarrier::Unchecked)
        {
        }

    private:

        using JSCell::isAPIValueWrapper;
        using JSCell::isGetterSetter;
        void getObject();
        void getString(ExecState* exec);
        void isObject();
        void isString();

        ConstPropertyStorage propertyStorage() const { return m_propertyStorage.get(); }
        PropertyStorage propertyStorage() { return m_propertyStorage.get(); }

        const WriteBarrierBase<Unknown>* locationForOffset(size_t offset) const
        {
            return &propertyStorage()[offset];
        }

        WriteBarrierBase<Unknown>* locationForOffset(size_t offset)
        {
            return &propertyStorage()[offset];
        }

        bool putDirectInternal(JSGlobalData&, const Identifier& propertyName, JSValue, unsigned attr, bool checkReadOnly, PutPropertySlot&, JSCell*);

        bool inlineGetOwnPropertySlot(ExecState*, const Identifier& propertyName, PropertySlot&);

        const HashEntry* findPropertyHashEntry(ExecState*, const Identifier& propertyName) const;
        Structure* createInheritorID(JSGlobalData&);

        StorageBarrier m_propertyStorage;
        WriteBarrier<Structure> m_inheritorID;
    };
# 307 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSObject.h"
typedef int dummyfinal_storage_is_at_least_as_large_as_non_final [((4 >= 2)) ? 1 : -1];




    class JSNonFinalObject : public JSObject {
        friend class JSObject;

    public:
        typedef JSObject Base;

        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue prototype)
        {
            return Structure::create(globalData, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), &s_info);
        }

    protected:
        explicit JSNonFinalObject(VPtrStealingHackType)
            : JSObject(VPtrStealingHack, m_inlineStorage)
        {
        }

        explicit JSNonFinalObject(JSGlobalData& globalData, Structure* structure)
            : JSObject(globalData, structure, m_inlineStorage)
        {
        }

        void finishCreation(JSGlobalData& globalData)
        {
            Base::finishCreation(globalData, m_inlineStorage);
            ((void)0);
            ((void)0);
        }

    private:
        WriteBarrier<Unknown> m_inlineStorage[2];
    };



    class JSFinalObject : public JSObject {
        friend class JSObject;

    public:
        typedef JSObject Base;

        explicit JSFinalObject(VPtrStealingHackType)
            : JSObject(VPtrStealingHack, m_inlineStorage)
        {
        }

        static JSFinalObject* create(ExecState* exec, Structure* structure)
        {
            JSFinalObject* finalObject = new (allocateCell<JSFinalObject>(*exec->heap())) JSFinalObject(exec->globalData(), structure);
            finalObject->finishCreation(exec->globalData());
            return finalObject;
        }

        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue prototype)
        {
            return Structure::create(globalData, globalObject, prototype, TypeInfo(FinalObjectType, StructureFlags), &s_info);
        }

        static const ClassInfo s_info;

    protected:
        void finishCreation(JSGlobalData& globalData)
        {
            Base::finishCreation(globalData, m_inlineStorage);
            ((void)0);
            ((void)0);
        }

    private:
        explicit JSFinalObject(JSGlobalData& globalData, Structure* structure)
            : JSObject(globalData, structure, m_inlineStorage)
        {
        }

        static const unsigned StructureFlags = JSObject::StructureFlags;

        WriteBarrierBase<Unknown> m_inlineStorage[4];
    };

inline size_t JSObject::offsetOfInlineStorage()
{
    ((void)0);
    return (reinterpret_cast<ptrdiff_t>(&(reinterpret_cast<JSFinalObject*>(0x4000)->m_inlineStorage)) - 0x4000);
}

inline size_t JSObject::offsetOfPropertyStorage()
{
    return (reinterpret_cast<ptrdiff_t>(&(reinterpret_cast<JSObject*>(0x4000)->m_propertyStorage)) - 0x4000);
}

inline size_t JSObject::offsetOfInheritorID()
{
    return (reinterpret_cast<ptrdiff_t>(&(reinterpret_cast<JSObject*>(0x4000)->m_inheritorID)) - 0x4000);
}

inline JSObject* constructEmptyObject(ExecState* exec, Structure* structure)
{
    return JSFinalObject::create(exec, structure);
}

inline CallType getCallData(JSValue value, CallData& callData)
{
    CallType result = value.isCell() ? value.asCell()->methodTable()->getCallData(value.asCell(), callData) : CallTypeNone;
    ((void)0);
    return result;
}

inline ConstructType getConstructData(JSValue value, ConstructData& constructData)
{
    ConstructType result = value.isCell() ? value.asCell()->methodTable()->getConstructData(value.asCell(), constructData) : ConstructTypeNone;
    ((void)0);
    return result;
}

inline Structure* createEmptyObjectStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue prototype)
{
    return JSFinalObject::createStructure(globalData, globalObject, prototype);
}

inline JSObject* asObject(JSCell* cell)
{
    ((void)0);
    return static_cast<JSObject*>(cell);
}

inline JSObject* asObject(JSValue value)
{
    return asObject(value.asCell());
}

inline JSObject::JSObject(JSGlobalData& globalData, Structure* structure, PropertyStorage inlineStorage)
    : JSCell(globalData, structure)
    , m_propertyStorage(globalData, this, inlineStorage)
{
}

inline JSValue JSObject::prototype() const
{
    return structure()->storedPrototype();
}

inline bool JSObject::setPrototypeWithCycleCheck(JSGlobalData& globalData, JSValue prototype)
{
    JSValue nextPrototypeValue = prototype;
    while (nextPrototypeValue && nextPrototypeValue.isObject()) {
        JSObject* nextPrototype = asObject(nextPrototypeValue)->unwrappedObject();
        if (nextPrototype == this)
            return false;
        nextPrototypeValue = nextPrototype->prototype();
    }
    setPrototype(globalData, prototype);
    return true;
}

inline void JSObject::setPrototype(JSGlobalData& globalData, JSValue prototype)
{
    ((void)0);
    setStructure(globalData, Structure::changePrototypeTransition(globalData, structure(), prototype));
}

inline Structure* JSObject::inheritorID(JSGlobalData& globalData)
{
    if (m_inheritorID) {
        ((void)0);
        return m_inheritorID.get();
    }
    return createInheritorID(globalData);
}

inline bool Structure::isUsingInlineStorage() const
{
    return propertyStorageCapacity() < JSObject::baseExternalStorageCapacity;
}

inline bool JSCell::inherits(const ClassInfo* info) const
{
    return classInfo()->isSubClassOf(info);
}

inline const MethodTable* JSCell::methodTable() const
{
    return &classInfo()->methodTable;
}


inline bool JSValue::inherits(const ClassInfo* classInfo) const
{
    return isCell() && asCell()->inherits(classInfo);
}

inline __attribute__((__always_inline__)) bool JSObject::inlineGetOwnPropertySlot(ExecState* exec, const Identifier& propertyName, PropertySlot& slot)
{
    if (WriteBarrierBase<Unknown>* location = getDirectLocation(exec->globalData(), propertyName)) {
        if (structure()->hasGetterSetterProperties() && location->isGetterSetter())
            fillGetterPropertySlot(slot, location);
        else
            slot.setValue(this, location->get(), offsetForLocation(location));
        return true;
    }


    if (propertyName == exec->propertyNames().underscoreProto) {
        slot.setValue(prototype());
        return true;
    }

    return false;
}




inline __attribute__((__always_inline__)) bool JSObject::getOwnPropertySlot(JSCell* cell, ExecState* exec, const Identifier& propertyName, PropertySlot& slot)
{
    return static_cast<JSObject*>(cell)->inlineGetOwnPropertySlot(exec, propertyName, slot);
}

inline __attribute__((__always_inline__)) bool JSCell::fastGetOwnPropertySlot(ExecState* exec, const Identifier& propertyName, PropertySlot& slot)
{
    if (!structure()->typeInfo().overridesGetOwnPropertySlot())
        return asObject(this)->inlineGetOwnPropertySlot(exec, propertyName, slot);
    return methodTable()->getOwnPropertySlot(this, exec, propertyName, slot);
}





inline __attribute__((__always_inline__)) JSValue JSCell::fastGetOwnProperty(ExecState* exec, const UString& name)
{
    if (!structure()->typeInfo().overridesGetOwnPropertySlot() && !structure()->hasGetterSetterProperties()) {
        size_t offset = name.impl()->hasHash()
            ? structure()->get(exec->globalData(), Identifier(exec, name))
            : structure()->get(exec->globalData(), name);
        if (offset != WTF::notFound)
            return asObject(this)->locationForOffset(offset)->get();
    }
    return JSValue();
}



inline __attribute__((__always_inline__)) bool JSObject::getPropertySlot(ExecState* exec, const Identifier& propertyName, PropertySlot& slot)
{
    JSObject* object = this;
    while (true) {
        if (object->fastGetOwnPropertySlot(exec, propertyName, slot))
            return true;
        JSValue prototype = object->prototype();
        if (!prototype.isObject())
            return false;
        object = asObject(prototype);
    }
}

inline __attribute__((__always_inline__)) bool JSObject::getPropertySlot(ExecState* exec, unsigned propertyName, PropertySlot& slot)
{
    JSObject* object = this;
    while (true) {
        if (object->methodTable()->getOwnPropertySlotByIndex(object, exec, propertyName, slot))
            return true;
        JSValue prototype = object->prototype();
        if (!prototype.isObject())
            return false;
        object = asObject(prototype);
    }
}

inline JSValue JSObject::get(ExecState* exec, const Identifier& propertyName) const
{
    PropertySlot slot(this);
    if (const_cast<JSObject*>(this)->getPropertySlot(exec, propertyName, slot))
        return slot.getValue(exec, propertyName);

    return jsUndefined();
}

inline JSValue JSObject::get(ExecState* exec, unsigned propertyName) const
{
    PropertySlot slot(this);
    if (const_cast<JSObject*>(this)->getPropertySlot(exec, propertyName, slot))
        return slot.getValue(exec, propertyName);

    return jsUndefined();
}

inline bool JSObject::putDirectInternal(JSGlobalData& globalData, const Identifier& propertyName, JSValue value, unsigned attributes, bool checkReadOnly, PutPropertySlot& slot, JSCell* specificFunction)
{
    ((void)0);
    ((void)0);

    if (structure()->isDictionary()) {
        unsigned currentAttributes;
        JSCell* currentSpecificFunction;
        size_t offset = structure()->get(globalData, propertyName, currentAttributes, currentSpecificFunction);
        if (offset != WTF::notFound) {


            if (currentSpecificFunction && (specificFunction != currentSpecificFunction))
                structure()->despecifyDictionaryFunction(globalData, propertyName);
            if (checkReadOnly && currentAttributes & ReadOnly)
                return false;

            putDirectOffset(globalData, offset, value);






            if (!currentSpecificFunction || (specificFunction != currentSpecificFunction))
                slot.setExistingProperty(this, offset);
            return true;
        }

        if (checkReadOnly && !isExtensible())
            return false;

        size_t currentCapacity = structure()->propertyStorageCapacity();
        offset = structure()->addPropertyWithoutTransition(globalData, propertyName, attributes, specificFunction);
        if (currentCapacity != structure()->propertyStorageCapacity())
            allocatePropertyStorage(globalData, currentCapacity, structure()->propertyStorageCapacity());

        ((void)0);
        putDirectOffset(globalData, offset, value);

        if (!specificFunction)
            slot.setNewProperty(this, offset);
        return true;
    }

    size_t offset;
    size_t currentCapacity = structure()->propertyStorageCapacity();
    if (Structure* structure = Structure::addPropertyTransitionToExistingStructure(this->structure(), propertyName, attributes, specificFunction, offset)) {
        if (currentCapacity != structure->propertyStorageCapacity())
            allocatePropertyStorage(globalData, currentCapacity, structure->propertyStorageCapacity());

        ((void)0);
        setStructure(globalData, structure);
        putDirectOffset(globalData, offset, value);


        if (!specificFunction)
            slot.setNewProperty(this, offset);
        return true;
    }

    unsigned currentAttributes;
    JSCell* currentSpecificFunction;
    offset = structure()->get(globalData, propertyName, currentAttributes, currentSpecificFunction);
    if (offset != WTF::notFound) {
        if (checkReadOnly && currentAttributes & ReadOnly)
            return false;
# 675 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSObject.h"
        if (currentSpecificFunction) {

            if (specificFunction == currentSpecificFunction) {
                putDirectOffset(globalData, offset, value);
                return true;
            }

            setStructure(globalData, Structure::despecifyFunctionTransition(globalData, structure(), propertyName));
        }


        slot.setExistingProperty(this, offset);
        putDirectOffset(globalData, offset, value);
        return true;
    }

    if (checkReadOnly && !isExtensible())
        return false;

    Structure* structure = Structure::addPropertyTransition(globalData, this->structure(), propertyName, attributes, specificFunction, offset);

    if (currentCapacity != structure->propertyStorageCapacity())
        allocatePropertyStorage(globalData, currentCapacity, structure->propertyStorageCapacity());

    ((void)0);
    setStructure(globalData, structure);
    putDirectOffset(globalData, offset, value);


    if (!specificFunction)
        slot.setNewProperty(this, offset);
    return true;
}

inline bool JSObject::putDirect(JSGlobalData& globalData, const Identifier& propertyName, JSValue value, unsigned attributes, bool checkReadOnly, PutPropertySlot& slot)
{
    ((void)0);
    ((void)0);

    return putDirectInternal(globalData, propertyName, value, attributes, checkReadOnly, slot, getJSFunction(value));
}

inline void JSObject::putDirect(JSGlobalData& globalData, const Identifier& propertyName, JSValue value, unsigned attributes)
{
    PutPropertySlot slot;
    putDirectInternal(globalData, propertyName, value, attributes, false, slot, getJSFunction(value));
}

inline bool JSObject::putDirect(JSGlobalData& globalData, const Identifier& propertyName, JSValue value, PutPropertySlot& slot)
{
    return putDirectInternal(globalData, propertyName, value, 0, false, slot, getJSFunction(value));
}

inline void JSObject::putDirectWithoutTransition(JSGlobalData& globalData, const Identifier& propertyName, JSValue value, unsigned attributes)
{
    size_t currentCapacity = structure()->propertyStorageCapacity();
    size_t offset = structure()->addPropertyWithoutTransition(globalData, propertyName, attributes, getJSFunction(value));
    if (currentCapacity != structure()->propertyStorageCapacity())
        allocatePropertyStorage(globalData, currentCapacity, structure()->propertyStorageCapacity());
    putDirectOffset(globalData, offset, value);
}

inline void JSObject::transitionTo(JSGlobalData& globalData, Structure* newStructure)
{
    if (structure()->propertyStorageCapacity() != newStructure->propertyStorageCapacity())
        allocatePropertyStorage(globalData, structure()->propertyStorageCapacity(), newStructure->propertyStorageCapacity());
    setStructure(globalData, newStructure);
}

inline JSValue JSObject::toPrimitive(ExecState* exec, PreferredPrimitiveType preferredType) const
{
    return defaultValue(exec, preferredType);
}

inline JSValue JSValue::get(ExecState* exec, const Identifier& propertyName) const
{
    PropertySlot slot(asValue());
    return get(exec, propertyName, slot);
}

inline JSValue JSValue::get(ExecState* exec, const Identifier& propertyName, PropertySlot& slot) const
{
    if (__builtin_expect((!isCell()), 0)) {
        JSObject* prototype = synthesizePrototype(exec);
        if (propertyName == exec->propertyNames().underscoreProto)
            return prototype;
        if (!prototype->getPropertySlot(exec, propertyName, slot))
            return jsUndefined();
        return slot.getValue(exec, propertyName);
    }
    JSCell* cell = asCell();
    while (true) {
        if (cell->fastGetOwnPropertySlot(exec, propertyName, slot))
            return slot.getValue(exec, propertyName);
        JSValue prototype = asObject(cell)->prototype();
        if (!prototype.isObject())
            return jsUndefined();
        cell = asObject(prototype);
    }
}

inline JSValue JSValue::get(ExecState* exec, unsigned propertyName) const
{
    PropertySlot slot(asValue());
    return get(exec, propertyName, slot);
}

inline JSValue JSValue::get(ExecState* exec, unsigned propertyName, PropertySlot& slot) const
{
    if (__builtin_expect((!isCell()), 0)) {
        JSObject* prototype = synthesizePrototype(exec);
        if (!prototype->getPropertySlot(exec, propertyName, slot))
            return jsUndefined();
        return slot.getValue(exec, propertyName);
    }
    JSCell* cell = const_cast<JSCell*>(asCell());
    while (true) {
        if (cell->methodTable()->getOwnPropertySlotByIndex(cell, exec, propertyName, slot))
            return slot.getValue(exec, propertyName);
        JSValue prototype = asObject(cell)->prototype();
        if (!prototype.isObject())
            return jsUndefined();
        cell = prototype.asCell();
    }
}

inline void JSValue::put(ExecState* exec, const Identifier& propertyName, JSValue value, PutPropertySlot& slot)
{
    if (__builtin_expect((!isCell()), 0)) {
        JSObject* thisObject = synthesizeObject(exec);
        thisObject->methodTable()->put(thisObject, exec, propertyName, value, slot);
        return;
    }
    asCell()->methodTable()->put(asCell(), exec, propertyName, value, slot);
}

inline void JSValue::putDirect(ExecState* exec, const Identifier& propertyName, JSValue value, PutPropertySlot& slot)
{
    ((void)0);
    if (!asObject(asCell())->putDirect(exec->globalData(), propertyName, value, slot) && slot.isStrictMode())
        throwTypeError(exec, StrictModeReadonlyPropertyWriteError);
}

inline void JSValue::put(ExecState* exec, unsigned propertyName, JSValue value)
{
    if (__builtin_expect((!isCell()), 0)) {
        JSObject* thisObject = synthesizeObject(exec);
        thisObject->methodTable()->putByIndex(thisObject, exec, propertyName, value);
        return;
    }
    asCell()->methodTable()->putByIndex(asCell(), exec, propertyName, value);
}



inline __attribute__((__always_inline__)) JSObject* Register::function() const
{
    if (!jsValue())
        return 0;
    return asObject(jsValue());
}

inline __attribute__((__always_inline__)) Register Register::withCallee(JSObject* callee)
{
    Register r;
    r = JSValue(callee);
    return r;
}

}
# 36 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Interpreter.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/Opcode.h" 1
# 38 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/Opcode.h"
namespace JSC {
# 203 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/Opcode.h"
        typedef enum { op_enter, op_create_activation, op_init_lazy_reg, op_create_arguments, op_create_this, op_get_callee, op_convert_this, op_new_object, op_new_array, op_new_array_buffer, op_new_regexp, op_mov, op_not, op_eq, op_eq_null, op_neq, op_neq_null, op_stricteq, op_nstricteq, op_less, op_lesseq, op_greater, op_greatereq, op_pre_inc, op_pre_dec, op_post_inc, op_post_dec, op_to_jsnumber, op_negate, op_add, op_mul, op_div, op_mod, op_sub, op_lshift, op_rshift, op_urshift, op_bitand, op_bitxor, op_bitor, op_bitnot, op_check_has_instance, op_instanceof, op_typeof, op_is_undefined, op_is_boolean, op_is_number, op_is_string, op_is_object, op_is_function, op_in, op_resolve, op_resolve_skip, op_resolve_global, op_resolve_global_dynamic, op_get_scoped_var, op_put_scoped_var, op_get_global_var, op_put_global_var, op_resolve_base, op_ensure_property_exists, op_resolve_with_base, op_resolve_with_this, op_get_by_id, op_get_by_id_self, op_get_by_id_proto, op_get_by_id_chain, op_get_by_id_getter_self, op_get_by_id_getter_proto, op_get_by_id_getter_chain, op_get_by_id_custom_self, op_get_by_id_custom_proto, op_get_by_id_custom_chain, op_get_by_id_generic, op_get_array_length, op_get_string_length, op_get_arguments_length, op_put_by_id, op_put_by_id_transition, op_put_by_id_replace, op_put_by_id_generic, op_del_by_id, op_get_by_val, op_get_argument_by_val, op_get_by_pname, op_put_by_val, op_del_by_val, op_put_by_index, op_put_getter, op_put_setter, op_jmp, op_jtrue, op_jfalse, op_jeq_null, op_jneq_null, op_jneq_ptr, op_jless, op_jlesseq, op_jgreater, op_jgreatereq, op_jnless, op_jnlesseq, op_jngreater, op_jngreatereq, op_jmp_scopes, op_loop, op_loop_if_true, op_loop_if_false, op_loop_if_less, op_loop_if_lesseq, op_loop_if_greater, op_loop_if_greatereq, op_loop_hint, op_switch_imm, op_switch_char, op_switch_string, op_new_func, op_new_func_exp, op_call, op_call_eval, op_call_varargs, op_load_varargs, op_tear_off_activation, op_tear_off_arguments, op_ret, op_call_put_result, op_ret_object_or_this, op_method_check, op_construct, op_strcat, op_to_primitive, op_get_pnames, op_next_pname, op_push_scope, op_pop_scope, op_push_new_scope, op_catch, op_throw, op_throw_reference_error, op_jsr, op_sret, op_debug, op_profile_will_call, op_profile_did_call, op_end, } OpcodeID;


    const int numOpcodeIDs = op_end + 1;


         const int op_enter_length = 1; const int op_create_activation_length = 2; const int op_init_lazy_reg_length = 2; const int op_create_arguments_length = 2; const int op_create_this_length = 3; const int op_get_callee_length = 2; const int op_convert_this_length = 2; const int op_new_object_length = 2; const int op_new_array_length = 4; const int op_new_array_buffer_length = 4; const int op_new_regexp_length = 3; const int op_mov_length = 3; const int op_not_length = 3; const int op_eq_length = 4; const int op_eq_null_length = 3; const int op_neq_length = 4; const int op_neq_null_length = 3; const int op_stricteq_length = 4; const int op_nstricteq_length = 4; const int op_less_length = 4; const int op_lesseq_length = 4; const int op_greater_length = 4; const int op_greatereq_length = 4; const int op_pre_inc_length = 2; const int op_pre_dec_length = 2; const int op_post_inc_length = 3; const int op_post_dec_length = 3; const int op_to_jsnumber_length = 3; const int op_negate_length = 3; const int op_add_length = 5; const int op_mul_length = 5; const int op_div_length = 5; const int op_mod_length = 4; const int op_sub_length = 5; const int op_lshift_length = 4; const int op_rshift_length = 4; const int op_urshift_length = 4; const int op_bitand_length = 5; const int op_bitxor_length = 5; const int op_bitor_length = 5; const int op_bitnot_length = 3; const int op_check_has_instance_length = 2; const int op_instanceof_length = 5; const int op_typeof_length = 3; const int op_is_undefined_length = 3; const int op_is_boolean_length = 3; const int op_is_number_length = 3; const int op_is_string_length = 3; const int op_is_object_length = 3; const int op_is_function_length = 3; const int op_in_length = 4; const int op_resolve_length = 3; const int op_resolve_skip_length = 4; const int op_resolve_global_length = 5; const int op_resolve_global_dynamic_length = 6; const int op_get_scoped_var_length = 4; const int op_put_scoped_var_length = 4; const int op_get_global_var_length = 3; const int op_put_global_var_length = 3; const int op_resolve_base_length = 4; const int op_ensure_property_exists_length = 3; const int op_resolve_with_base_length = 4; const int op_resolve_with_this_length = 4; const int op_get_by_id_length = 8; const int op_get_by_id_self_length = 8; const int op_get_by_id_proto_length = 8; const int op_get_by_id_chain_length = 8; const int op_get_by_id_getter_self_length = 8; const int op_get_by_id_getter_proto_length = 8; const int op_get_by_id_getter_chain_length = 8; const int op_get_by_id_custom_self_length = 8; const int op_get_by_id_custom_proto_length = 8; const int op_get_by_id_custom_chain_length = 8; const int op_get_by_id_generic_length = 8; const int op_get_array_length_length = 8; const int op_get_string_length_length = 8; const int op_get_arguments_length_length = 4; const int op_put_by_id_length = 9; const int op_put_by_id_transition_length = 9; const int op_put_by_id_replace_length = 9; const int op_put_by_id_generic_length = 9; const int op_del_by_id_length = 4; const int op_get_by_val_length = 4; const int op_get_argument_by_val_length = 4; const int op_get_by_pname_length = 7; const int op_put_by_val_length = 4; const int op_del_by_val_length = 4; const int op_put_by_index_length = 4; const int op_put_getter_length = 4; const int op_put_setter_length = 4; const int op_jmp_length = 2; const int op_jtrue_length = 3; const int op_jfalse_length = 3; const int op_jeq_null_length = 3; const int op_jneq_null_length = 3; const int op_jneq_ptr_length = 4; const int op_jless_length = 4; const int op_jlesseq_length = 4; const int op_jgreater_length = 4; const int op_jgreatereq_length = 4; const int op_jnless_length = 4; const int op_jnlesseq_length = 4; const int op_jngreater_length = 4; const int op_jngreatereq_length = 4; const int op_jmp_scopes_length = 3; const int op_loop_length = 2; const int op_loop_if_true_length = 3; const int op_loop_if_false_length = 3; const int op_loop_if_less_length = 4; const int op_loop_if_lesseq_length = 4; const int op_loop_if_greater_length = 4; const int op_loop_if_greatereq_length = 4; const int op_loop_hint_length = 1; const int op_switch_imm_length = 4; const int op_switch_char_length = 4; const int op_switch_string_length = 4; const int op_new_func_length = 4; const int op_new_func_exp_length = 3; const int op_call_length = 4; const int op_call_eval_length = 4; const int op_call_varargs_length = 4; const int op_load_varargs_length = 4; const int op_tear_off_activation_length = 3; const int op_tear_off_arguments_length = 2; const int op_ret_length = 2; const int op_call_put_result_length = 2; const int op_ret_object_or_this_length = 3; const int op_method_check_length = 1; const int op_construct_length = 4; const int op_strcat_length = 4; const int op_to_primitive_length = 3; const int op_get_pnames_length = 6; const int op_next_pname_length = 7; const int op_push_scope_length = 2; const int op_pop_scope_length = 1; const int op_push_new_scope_length = 4; const int op_catch_length = 2; const int op_throw_length = 2; const int op_throw_reference_error_length = 2; const int op_jsr_length = 3; const int op_sret_length = 2; const int op_debug_length = 4; const int op_profile_will_call_length = 2; const int op_profile_did_call_length = 2; const int op_end_length = 2;;





        const int opcodeLengths[numOpcodeIDs] = { 1, 2, 2, 2, 3, 2, 2, 2, 4, 4, 3, 3, 3, 4, 3, 4, 3, 4, 4, 4, 4, 4, 4, 2, 2, 3, 3, 3, 3, 5, 5, 5, 4, 5, 4, 4, 4, 5, 5, 5, 3, 2, 5, 3, 3, 3, 3, 3, 3, 3, 4, 3, 4, 5, 6, 4, 4, 3, 3, 4, 3, 4, 4, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 9, 9, 9, 9, 4, 4, 4, 7, 4, 4, 4, 4, 4, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 2, 3, 3, 4, 4, 4, 4, 1, 4, 4, 4, 4, 3, 4, 4, 4, 4, 3, 2, 2, 2, 3, 1, 4, 4, 3, 6, 7, 2, 1, 4, 2, 2, 2, 3, 2, 4, 2, 2, 2, };



        typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_enter <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_create_activation <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_init_lazy_reg <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_create_arguments <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_create_this <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_get_callee <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_convert_this <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_new_object <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_new_array <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_new_array_buffer <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_new_regexp <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_mov <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_not <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_eq <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_eq_null <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_neq <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_neq_null <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_stricteq <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_nstricteq <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_less <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_lesseq <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_greater <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_greatereq <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_pre_inc <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_pre_dec <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_post_inc <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_post_dec <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_to_jsnumber <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_negate <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_add <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_mul <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_div <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_mod <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_sub <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_lshift <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_rshift <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_urshift <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_bitand <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_bitxor <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_bitor <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_bitnot <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_check_has_instance <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_instanceof <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_typeof <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_is_undefined <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_is_boolean <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_is_number <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_is_string <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_is_object <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_is_function <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_in <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_resolve <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_resolve_skip <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_resolve_global <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_resolve_global_dynamic <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_get_scoped_var <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_put_scoped_var <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_get_global_var <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_put_global_var <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_resolve_base <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_ensure_property_exists <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_resolve_with_base <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_resolve_with_this <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_get_by_id <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_get_by_id_self <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_get_by_id_proto <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_get_by_id_chain <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_get_by_id_getter_self <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_get_by_id_getter_proto <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_get_by_id_getter_chain <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_get_by_id_custom_self <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_get_by_id_custom_proto <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_get_by_id_custom_chain <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_get_by_id_generic <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_get_array_length <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_get_string_length <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_get_arguments_length <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_put_by_id <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_put_by_id_transition <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_put_by_id_replace <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_put_by_id_generic <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_del_by_id <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_get_by_val <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_get_argument_by_val <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_get_by_pname <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_put_by_val <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_del_by_val <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_put_by_index <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_put_getter <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_put_setter <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_jmp <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_jtrue <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_jfalse <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_jeq_null <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_jneq_null <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_jneq_ptr <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_jless <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_jlesseq <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_jgreater <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_jgreatereq <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_jnless <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_jnlesseq <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_jngreater <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_jngreatereq <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_jmp_scopes <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_loop <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_loop_if_true <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_loop_if_false <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_loop_if_less <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_loop_if_lesseq <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_loop_if_greater <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_loop_if_greatereq <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_loop_hint <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_switch_imm <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_switch_char <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_switch_string <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_new_func <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_new_func_exp <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_call <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_call_eval <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_call_varargs <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_load_varargs <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_tear_off_activation <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_tear_off_arguments <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_ret <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_call_put_result <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_ret_object_or_this <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_method_check <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_construct <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_strcat <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_to_primitive <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_get_pnames <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_next_pname <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_push_scope <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_pop_scope <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_push_new_scope <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_catch <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_throw <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_throw_reference_error <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_jsr <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_sret <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_debug <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_profile_will_call <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_profile_did_call <= op_end) ? 1 : -1]; typedef int dummyASSERT_THAT_JS_OPCODE_IDS_ARE_VALID [(op_end <= op_end) ? 1 : -1];;
# 229 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/Opcode.h"
    typedef OpcodeID Opcode;
# 266 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/Opcode.h"
    inline size_t opcodeLength(OpcodeID opcode)
    {
        switch (opcode) {

             case op_enter: return op_enter_length; case op_create_activation: return op_create_activation_length; case op_init_lazy_reg: return op_init_lazy_reg_length; case op_create_arguments: return op_create_arguments_length; case op_create_this: return op_create_this_length; case op_get_callee: return op_get_callee_length; case op_convert_this: return op_convert_this_length; case op_new_object: return op_new_object_length; case op_new_array: return op_new_array_length; case op_new_array_buffer: return op_new_array_buffer_length; case op_new_regexp: return op_new_regexp_length; case op_mov: return op_mov_length; case op_not: return op_not_length; case op_eq: return op_eq_length; case op_eq_null: return op_eq_null_length; case op_neq: return op_neq_length; case op_neq_null: return op_neq_null_length; case op_stricteq: return op_stricteq_length; case op_nstricteq: return op_nstricteq_length; case op_less: return op_less_length; case op_lesseq: return op_lesseq_length; case op_greater: return op_greater_length; case op_greatereq: return op_greatereq_length; case op_pre_inc: return op_pre_inc_length; case op_pre_dec: return op_pre_dec_length; case op_post_inc: return op_post_inc_length; case op_post_dec: return op_post_dec_length; case op_to_jsnumber: return op_to_jsnumber_length; case op_negate: return op_negate_length; case op_add: return op_add_length; case op_mul: return op_mul_length; case op_div: return op_div_length; case op_mod: return op_mod_length; case op_sub: return op_sub_length; case op_lshift: return op_lshift_length; case op_rshift: return op_rshift_length; case op_urshift: return op_urshift_length; case op_bitand: return op_bitand_length; case op_bitxor: return op_bitxor_length; case op_bitor: return op_bitor_length; case op_bitnot: return op_bitnot_length; case op_check_has_instance: return op_check_has_instance_length; case op_instanceof: return op_instanceof_length; case op_typeof: return op_typeof_length; case op_is_undefined: return op_is_undefined_length; case op_is_boolean: return op_is_boolean_length; case op_is_number: return op_is_number_length; case op_is_string: return op_is_string_length; case op_is_object: return op_is_object_length; case op_is_function: return op_is_function_length; case op_in: return op_in_length; case op_resolve: return op_resolve_length; case op_resolve_skip: return op_resolve_skip_length; case op_resolve_global: return op_resolve_global_length; case op_resolve_global_dynamic: return op_resolve_global_dynamic_length; case op_get_scoped_var: return op_get_scoped_var_length; case op_put_scoped_var: return op_put_scoped_var_length; case op_get_global_var: return op_get_global_var_length; case op_put_global_var: return op_put_global_var_length; case op_resolve_base: return op_resolve_base_length; case op_ensure_property_exists: return op_ensure_property_exists_length; case op_resolve_with_base: return op_resolve_with_base_length; case op_resolve_with_this: return op_resolve_with_this_length; case op_get_by_id: return op_get_by_id_length; case op_get_by_id_self: return op_get_by_id_self_length; case op_get_by_id_proto: return op_get_by_id_proto_length; case op_get_by_id_chain: return op_get_by_id_chain_length; case op_get_by_id_getter_self: return op_get_by_id_getter_self_length; case op_get_by_id_getter_proto: return op_get_by_id_getter_proto_length; case op_get_by_id_getter_chain: return op_get_by_id_getter_chain_length; case op_get_by_id_custom_self: return op_get_by_id_custom_self_length; case op_get_by_id_custom_proto: return op_get_by_id_custom_proto_length; case op_get_by_id_custom_chain: return op_get_by_id_custom_chain_length; case op_get_by_id_generic: return op_get_by_id_generic_length; case op_get_array_length: return op_get_array_length_length; case op_get_string_length: return op_get_string_length_length; case op_get_arguments_length: return op_get_arguments_length_length; case op_put_by_id: return op_put_by_id_length; case op_put_by_id_transition: return op_put_by_id_transition_length; case op_put_by_id_replace: return op_put_by_id_replace_length; case op_put_by_id_generic: return op_put_by_id_generic_length; case op_del_by_id: return op_del_by_id_length; case op_get_by_val: return op_get_by_val_length; case op_get_argument_by_val: return op_get_argument_by_val_length; case op_get_by_pname: return op_get_by_pname_length; case op_put_by_val: return op_put_by_val_length; case op_del_by_val: return op_del_by_val_length; case op_put_by_index: return op_put_by_index_length; case op_put_getter: return op_put_getter_length; case op_put_setter: return op_put_setter_length; case op_jmp: return op_jmp_length; case op_jtrue: return op_jtrue_length; case op_jfalse: return op_jfalse_length; case op_jeq_null: return op_jeq_null_length; case op_jneq_null: return op_jneq_null_length; case op_jneq_ptr: return op_jneq_ptr_length; case op_jless: return op_jless_length; case op_jlesseq: return op_jlesseq_length; case op_jgreater: return op_jgreater_length; case op_jgreatereq: return op_jgreatereq_length; case op_jnless: return op_jnless_length; case op_jnlesseq: return op_jnlesseq_length; case op_jngreater: return op_jngreater_length; case op_jngreatereq: return op_jngreatereq_length; case op_jmp_scopes: return op_jmp_scopes_length; case op_loop: return op_loop_length; case op_loop_if_true: return op_loop_if_true_length; case op_loop_if_false: return op_loop_if_false_length; case op_loop_if_less: return op_loop_if_less_length; case op_loop_if_lesseq: return op_loop_if_lesseq_length; case op_loop_if_greater: return op_loop_if_greater_length; case op_loop_if_greatereq: return op_loop_if_greatereq_length; case op_loop_hint: return op_loop_hint_length; case op_switch_imm: return op_switch_imm_length; case op_switch_char: return op_switch_char_length; case op_switch_string: return op_switch_string_length; case op_new_func: return op_new_func_length; case op_new_func_exp: return op_new_func_exp_length; case op_call: return op_call_length; case op_call_eval: return op_call_eval_length; case op_call_varargs: return op_call_varargs_length; case op_load_varargs: return op_load_varargs_length; case op_tear_off_activation: return op_tear_off_activation_length; case op_tear_off_arguments: return op_tear_off_arguments_length; case op_ret: return op_ret_length; case op_call_put_result: return op_call_put_result_length; case op_ret_object_or_this: return op_ret_object_or_this_length; case op_method_check: return op_method_check_length; case op_construct: return op_construct_length; case op_strcat: return op_strcat_length; case op_to_primitive: return op_to_primitive_length; case op_get_pnames: return op_get_pnames_length; case op_next_pname: return op_next_pname_length; case op_push_scope: return op_push_scope_length; case op_pop_scope: return op_pop_scope_length; case op_push_new_scope: return op_push_new_scope_length; case op_catch: return op_catch_length; case op_throw: return op_throw_length; case op_throw_reference_error: return op_throw_reference_error_length; case op_jsr: return op_jsr_length; case op_sret: return op_sret_length; case op_debug: return op_debug_length; case op_profile_will_call: return op_profile_will_call_length; case op_profile_did_call: return op_profile_did_call_length; case op_end: return op_end_length;

        }
        ((void)0);
        return 0;
    }

}
# 37 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Interpreter.h" 2




namespace JSC {

    class CodeBlock;
    class EvalExecutable;
    class FunctionExecutable;
    class JSFunction;
    class JSGlobalObject;
    class ProgramExecutable;
    class Register;
    class ScopeChainNode;
    class SamplingTool;
    struct CallFrameClosure;
    struct HandlerInfo;
    struct Instruction;

    enum DebugHookID {
        WillExecuteProgram,
        DidExecuteProgram,
        DidEnterCallFrame,
        DidReachBreakpoint,
        WillLeaveCallFrame,
        WillExecuteStatement
    };

    class TopCallFrameSetter {
    public:
        TopCallFrameSetter(JSGlobalData& global, CallFrame* callFrame)
            : globalData(global)
            , oldCallFrame(global.topCallFrame)
        {
            global.topCallFrame = callFrame;
        }

        ~TopCallFrameSetter()
        {
            globalData.topCallFrame = oldCallFrame;
        }
    private:
        JSGlobalData& globalData;
        CallFrame* oldCallFrame;
    };

    enum { MaxLargeThreadReentryDepth = 256, MaxSmallThreadReentryDepth = 32 };

    class Interpreter {
        public: void* operator new(size_t, void* p) { return p; } void* operator new[](size_t, void* p) { return p; } void* operator new(size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNew); return p; } void operator delete(void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNew); ::WTF::fastFree(p); } void* operator new[](size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNewArray); return p; } void operator delete[](void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNewArray); ::WTF::fastFree(p); } private: typedef int ThisIsHereToForceASemicolonAfterThisMacro;
        friend class JIT;
        friend class CachedCall;
    public:
        Interpreter();

        RegisterFile& registerFile() { return m_registerFile; }

        Opcode getOpcode(OpcodeID id)
        {



                return id;

        }

        OpcodeID getOpcodeID(Opcode opcode)
        {




                return opcode;

        }

        bool isOpcode(Opcode);

        JSValue execute(ProgramExecutable*, CallFrame*, ScopeChainNode*, JSObject* thisObj);
        JSValue executeCall(CallFrame*, JSObject* function, CallType, const CallData&, JSValue thisValue, const ArgList&);
        JSObject* executeConstruct(CallFrame*, JSObject* function, ConstructType, const ConstructData&, const ArgList&);
        JSValue execute(EvalExecutable* evalNode, CallFrame*, JSValue thisValue, ScopeChainNode*);

        JSValue retrieveArguments(CallFrame*, JSFunction*) const;
                          JSValue retrieveCaller(CallFrame*, JSFunction*) const;
                          void retrieveLastCaller(CallFrame*, int& lineNumber, intptr_t& sourceID, UString& sourceURL, JSValue& function) const;

        void getArgumentsData(CallFrame*, JSFunction*&, ptrdiff_t& firstParameterIndex, Register*& argv, int& argc);

        SamplingTool* sampler() { return m_sampler.get(); }

        __attribute__((__noinline__)) JSValue callEval(CallFrame*, RegisterFile*, Register* argv, int argc, int registerOffset);
        __attribute__((__noinline__)) HandlerInfo* throwException(CallFrame*&, JSValue&, unsigned bytecodeOffset);
        __attribute__((__noinline__)) void debug(CallFrame*, DebugHookID, int firstLine, int lastLine);

        void dumpSampleData(ExecState* exec);
        void startSampling();
        void stopSampling();
    private:
        enum ExecutionFlag { Normal, InitializeAndReturn };

        CallFrameClosure prepareForRepeatCall(FunctionExecutable*, CallFrame*, JSFunction*, int argCount, ScopeChainNode*);
        void endRepeatCall(CallFrameClosure&);
        JSValue execute(CallFrameClosure&);

        JSValue execute(EvalExecutable*, CallFrame*, JSValue thisValue, int globalRegisterOffset, ScopeChainNode*);
# 160 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Interpreter.h"
        __attribute__((__noinline__)) bool unwindCallFrame(CallFrame*&, JSValue, unsigned& bytecodeOffset, CodeBlock*&);

        static inline __attribute__((__always_inline__)) CallFrame* slideRegisterWindowForCall(CodeBlock*, RegisterFile*, CallFrame*, size_t registerOffset, int argc);

        static CallFrame* findFunctionCallFrame(CallFrame*, JSFunction*);

        JSValue privateExecute(ExecutionFlag, RegisterFile*, CallFrame*);

        void dumpCallFrame(CallFrame*);
        void dumpRegisters(CallFrame*);

        bool isCallBytecode(Opcode opcode) { return opcode == getOpcode(op_call) || opcode == getOpcode(op_construct) || opcode == getOpcode(op_call_eval); }

        void enableSampler();
        int m_sampleEntryDepth;
        OwnPtr<SamplingTool> m_sampler;

        int m_reentryDepth;

        RegisterFile m_registerFile;





    };


    inline bool isValidThisObject(JSValue thisValue, ExecState* exec)
    {
        return !thisValue.isObject() || thisValue.toThisObject(exec) == thisValue;
    }

}
# 32 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Interpreter.cpp" 2

# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/Arguments.h" 1
# 27 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/Arguments.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/CodeOrigin.h" 1
# 33 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/CodeOrigin.h"
namespace JSC {

struct InlineCallFrame;
class ExecutableBase;

struct CodeOrigin {
    uint32_t bytecodeIndex;
    InlineCallFrame* inlineCallFrame;

    CodeOrigin()
        : bytecodeIndex(std::numeric_limits<uint32_t>::max())
        , inlineCallFrame(0)
    {
    }

    explicit CodeOrigin(uint32_t bytecodeIndex)
        : bytecodeIndex(bytecodeIndex)
        , inlineCallFrame(0)
    {
    }

    explicit CodeOrigin(uint32_t bytecodeIndex, InlineCallFrame* inlineCallFrame)
        : bytecodeIndex(bytecodeIndex)
        , inlineCallFrame(inlineCallFrame)
    {
    }

    bool isSet() const { return bytecodeIndex != std::numeric_limits<uint32_t>::max(); }



    unsigned inlineDepth() const;

    static unsigned inlineDepthForCallFrame(InlineCallFrame*);

    bool operator==(const CodeOrigin& other) const;





};

struct InlineCallFrame {
    WriteBarrier<ExecutableBase> executable;
    unsigned stackOffset;
    unsigned calleeVR;
    CodeOrigin caller;
    unsigned numArgumentsIncludingThis : 31;
    bool isCall : 1;
};

struct CodeOriginAtCallReturnOffset {
    CodeOrigin codeOrigin;
    unsigned callReturnOffset;
};

inline unsigned CodeOrigin::inlineDepthForCallFrame(InlineCallFrame* inlineCallFrame)
{
    unsigned result = 1;
    for (InlineCallFrame* current = inlineCallFrame; current; current = current->caller.inlineCallFrame)
        result++;
    return result;
}

inline unsigned CodeOrigin::inlineDepth() const
{
    return inlineDepthForCallFrame(inlineCallFrame);
}

inline bool CodeOrigin::operator==(const CodeOrigin& other) const
{
    return bytecodeIndex == other.bytecodeIndex
        && inlineCallFrame == other.inlineCallFrame;
}
# 122 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/CodeOrigin.h"
inline unsigned getCallReturnOffsetForCodeOrigin(CodeOriginAtCallReturnOffset* data)
{
    return data->callReturnOffset;
}

}
# 28 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/Arguments.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSActivation.h" 1
# 32 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSActivation.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/CodeBlock.h" 1
# 34 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/CodeBlock.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/jit/CompactJITCodeMap.h" 1
# 40 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/jit/CompactJITCodeMap.h"
namespace JSC {
# 58 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/jit/CompactJITCodeMap.h"
struct BytecodeAndMachineOffset {
    BytecodeAndMachineOffset() { }

    BytecodeAndMachineOffset(unsigned bytecodeIndex, unsigned machineCodeOffset)
        : m_bytecodeIndex(bytecodeIndex)
        , m_machineCodeOffset(machineCodeOffset)
    {
    }

    unsigned m_bytecodeIndex;
    unsigned m_machineCodeOffset;

    static inline unsigned getBytecodeIndex(BytecodeAndMachineOffset* mapping)
    {
        return mapping->m_bytecodeIndex;
    }

    static inline unsigned getMachineCodeOffset(BytecodeAndMachineOffset* mapping)
    {
        return mapping->m_machineCodeOffset;
    }
};

class CompactJITCodeMap {
    public: void* operator new(size_t, void* p) { return p; } void* operator new[](size_t, void* p) { return p; } void* operator new(size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNew); return p; } void operator delete(void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNew); ::WTF::fastFree(p); } void* operator new[](size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNewArray); return p; } void operator delete[](void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNewArray); ::WTF::fastFree(p); } private: typedef int ThisIsHereToForceASemicolonAfterThisMacro;
public:
    ~CompactJITCodeMap()
    {
        if (m_buffer)
            fastFree(m_buffer);
    }

    unsigned numberOfEntries() const
    {
        return m_numberOfEntries;
    }

    void decode(Vector<BytecodeAndMachineOffset>& result) const;

private:
    CompactJITCodeMap(uint8_t* buffer, unsigned size, unsigned numberOfEntries)
        : m_buffer(buffer)



        , m_numberOfEntries(numberOfEntries)
    {
        (void)size;
    }

    uint8_t at(unsigned index) const
    {
        ((void)0);
        return m_buffer[index];
    }

    unsigned decodeNumber(unsigned& index) const
    {
        uint8_t headValue = at(index++);
        if (!(headValue & 128))
            return headValue;
        if (!(headValue & 64))
            return (static_cast<unsigned>(headValue & ~128) << 8) | at(index++);
        unsigned second = at(index++);
        unsigned third = at(index++);
        unsigned fourth = at(index++);
        return (static_cast<unsigned>(headValue & ~(128 + 64)) << 24) | (second << 16) | (third << 8) | fourth;
    }

    uint8_t* m_buffer;



    unsigned m_numberOfEntries;

public:
    class Encoder {
        private: Encoder(const Encoder&); Encoder& operator=(const Encoder&);
    public:
        Encoder();
        ~Encoder();

        void ensureCapacityFor(unsigned numberOfEntriesToAdd);
        void append(unsigned bytecodeIndex, unsigned machineCodeOffset);
        PassOwnPtr<CompactJITCodeMap> finish();

    private:
        void appendByte(uint8_t value);
        void encodeNumber(uint32_t value);

        uint8_t* m_buffer;
        unsigned m_size;
        unsigned m_capacity;
        unsigned m_numberOfEntries;

        unsigned m_previousBytecodeIndex;
        unsigned m_previousMachineCodeOffset;
    };

    class Decoder {
        private: Decoder(const Decoder&); Decoder& operator=(const Decoder&);
    public:
        Decoder(const CompactJITCodeMap*);

        unsigned numberOfEntriesRemaining() const;
        void read(unsigned& bytecodeIndex, unsigned& machineCodeOffset);

    private:
        const CompactJITCodeMap* m_jitCodeMap;
        unsigned m_previousBytecodeIndex;
        unsigned m_previousMachineCodeOffset;
        unsigned m_numberOfEntriesRemaining;
        unsigned m_bufferIndex;
    };

private:
    friend class Encoder;
    friend class Decoder;
};

inline void CompactJITCodeMap::decode(Vector<BytecodeAndMachineOffset>& result) const
{
    Decoder decoder(this);
    result.resize(decoder.numberOfEntriesRemaining());
    for (unsigned i = 0; i < result.size(); ++i)
        decoder.read(result[i].m_bytecodeIndex, result[i].m_machineCodeOffset);

    ((void)0);
}

inline CompactJITCodeMap::Encoder::Encoder()
    : m_buffer(0)
    , m_size(0)
    , m_capacity(0)
    , m_numberOfEntries(0)
    , m_previousBytecodeIndex(0)
    , m_previousMachineCodeOffset(0)
{
}

inline CompactJITCodeMap::Encoder::~Encoder()
{
    if (m_buffer)
        fastFree(m_buffer);
}

inline void CompactJITCodeMap::Encoder::append(unsigned bytecodeIndex, unsigned machineCodeOffset)
{
    ((void)0);
    ((void)0);
    ensureCapacityFor(1);
    encodeNumber(bytecodeIndex - m_previousBytecodeIndex);
    encodeNumber(machineCodeOffset - m_previousMachineCodeOffset);
    m_previousBytecodeIndex = bytecodeIndex;
    m_previousMachineCodeOffset = machineCodeOffset;
    m_numberOfEntries++;
}

inline PassOwnPtr<CompactJITCodeMap> CompactJITCodeMap::Encoder::finish()
{
    m_capacity = m_size;
    m_buffer = static_cast<uint8_t*>(fastRealloc(m_buffer, m_capacity));
    OwnPtr<CompactJITCodeMap> result = adoptPtr(new CompactJITCodeMap(m_buffer, m_size, m_numberOfEntries));
    m_buffer = 0;
    m_size = 0;
    m_capacity = 0;
    m_numberOfEntries = 0;
    m_previousBytecodeIndex = 0;
    m_previousMachineCodeOffset = 0;
    return result.release();
}

inline void CompactJITCodeMap::Encoder::appendByte(uint8_t value)
{
    ((void)0);
    m_buffer[m_size++] = value;
}

inline void CompactJITCodeMap::Encoder::encodeNumber(uint32_t value)
{
    ((void)0);
    ((void)0);
    if (value <= 127) {
        uint8_t headValue = static_cast<uint8_t>(value);
        ((void)0);
        appendByte(headValue);
    } else if (value <= 16383) {
        uint8_t headValue = static_cast<uint8_t>(value >> 8);
        ((void)0);
        ((void)0);
        appendByte(headValue | 128);
        appendByte(static_cast<uint8_t>(value));
    } else {
        uint8_t headValue = static_cast<uint8_t>(value >> 24);
        ((void)0);
        ((void)0);
        appendByte(headValue | 128 | 64);
        appendByte(static_cast<uint8_t>(value >> 16));
        appendByte(static_cast<uint8_t>(value >> 8));
        appendByte(static_cast<uint8_t>(value));
    }
}

inline void CompactJITCodeMap::Encoder::ensureCapacityFor(unsigned numberOfEntriesToAdd)
{
    unsigned capacityNeeded = m_size + numberOfEntriesToAdd * 2 * 4;
    if (capacityNeeded > m_capacity) {
        m_capacity = capacityNeeded * 2;
        m_buffer = static_cast<uint8_t*>(fastRealloc(m_buffer, m_capacity));
    }
}

inline CompactJITCodeMap::Decoder::Decoder(const CompactJITCodeMap* jitCodeMap)
    : m_jitCodeMap(jitCodeMap)
    , m_previousBytecodeIndex(0)
    , m_previousMachineCodeOffset(0)
    , m_numberOfEntriesRemaining(jitCodeMap->m_numberOfEntries)
    , m_bufferIndex(0)
{
}

inline unsigned CompactJITCodeMap::Decoder::numberOfEntriesRemaining() const
{
    ((void)0);
    return m_numberOfEntriesRemaining;
}

inline void CompactJITCodeMap::Decoder::read(unsigned& bytecodeIndex, unsigned& machineCodeOffset)
{
    ((void)0);

    m_previousBytecodeIndex += m_jitCodeMap->decodeNumber(m_bufferIndex);
    m_previousMachineCodeOffset += m_jitCodeMap->decodeNumber(m_bufferIndex);
    bytecodeIndex = m_previousBytecodeIndex;
    machineCodeOffset = m_previousMachineCodeOffset;
    m_numberOfEntriesRemaining--;
}

}
# 35 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/CodeBlock.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/dfg/DFGOSREntry.h" 1
# 29 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/dfg/DFGOSREntry.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/dfg/DFGAbstractValue.h" 1
# 33 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/dfg/DFGAbstractValue.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/dfg/DFGStructureSet.h" 1
# 33 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/dfg/DFGStructureSet.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/PredictedType.h" 1
# 34 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/PredictedType.h"
namespace JSC {

class Structure;

typedef uint16_t PredictedType;
static const PredictedType PredictNone = 0x0000;
static const PredictedType PredictFinalObject = 0x0001;
static const PredictedType PredictArray = 0x0002;
static const PredictedType PredictByteArray = 0x0004;
static const PredictedType PredictObjectOther = 0x0010;
static const PredictedType PredictObjectMask = 0x003f;
static const PredictedType PredictString = 0x0040;
static const PredictedType PredictCellOther = 0x0080;
static const PredictedType PredictCell = 0x00ff;
static const PredictedType PredictInt32 = 0x0100;
static const PredictedType PredictDouble = 0x0200;
static const PredictedType PredictNumber = 0x0300;
static const PredictedType PredictBoolean = 0x0400;
static const PredictedType PredictOther = 0x4000;
static const PredictedType PredictTop = 0x7fff;

typedef bool (*PredictionChecker)(PredictedType);

inline bool isCellPrediction(PredictedType value)
{
    return !!(value & PredictCell) && !(value & ~PredictCell);
}

inline bool isObjectPrediction(PredictedType value)
{
    return !!(value & PredictObjectMask) && !(value & ~PredictObjectMask);
}

inline bool isFinalObjectPrediction(PredictedType value)
{
    return value == PredictFinalObject;
}

inline bool isFinalObjectOrOtherPrediction(PredictedType value)
{
    return !!(value & (PredictFinalObject | PredictOther)) && !(value & ~(PredictFinalObject | PredictOther));
}

inline bool isStringPrediction(PredictedType value)
{
    return value == PredictString;
}

inline bool isArrayPrediction(PredictedType value)
{
    return value == PredictArray;
}

inline bool isByteArrayPrediction(PredictedType value)
{
    return value == PredictByteArray;
}

inline bool isArrayOrOtherPrediction(PredictedType value)
{
    return !!(value & (PredictArray | PredictOther)) && !(value & ~(PredictArray | PredictOther));
}

inline bool isInt32Prediction(PredictedType value)
{
    return value == PredictInt32;
}

inline bool isDoublePrediction(PredictedType value)
{
    return value == PredictDouble;
}

inline bool isNumberPrediction(PredictedType value)
{
    return !!(value & PredictNumber) && !(value & ~PredictNumber);
}

inline bool isBooleanPrediction(PredictedType value)
{
    return value == PredictBoolean;
}

inline bool isOtherPrediction(PredictedType value)
{
    return value == PredictOther;
}
# 130 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/PredictedType.h"
inline PredictedType mergePredictions(PredictedType left, PredictedType right)
{
    return left | right;
}

template<typename T>
inline bool mergePrediction(T& left, PredictedType right)
{
    PredictedType newPrediction = static_cast<T>(mergePredictions(static_cast<PredictedType>(left), right));
    bool result = newPrediction != static_cast<PredictedType>(left);
    left = newPrediction;
    return result;
}

PredictedType predictionFromClassInfo(const ClassInfo*);
PredictedType predictionFromStructure(Structure*);
PredictedType predictionFromCell(JSCell*);
PredictedType predictionFromValue(JSValue);

}
# 34 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/dfg/DFGStructureSet.h" 2



namespace JSC {

class Structure;

namespace DFG {

class StructureAbstractValue;

class StructureSet {
public:
    StructureSet() { }

    StructureSet(Structure* structure)
    {
        m_structures.append(structure);
    }

    void clear()
    {
        m_structures.clear();
    }

    void add(Structure* structure)
    {
        ((void)0);
        m_structures.append(structure);
    }

    bool addAll(const StructureSet& other)
    {
        bool changed = false;
        for (size_t i = 0; i < other.size(); ++i) {
            if (contains(other[i]))
                continue;
            add(other[i]);
            changed = true;
        }
        return changed;
    }

    void remove(Structure* structure)
    {
        for (size_t i = 0; i < m_structures.size(); ++i) {
            if (m_structures[i] != structure)
                continue;

            m_structures[i] = m_structures.last();
            m_structures.removeLast();
            return;
        }
    }

    bool contains(Structure* structure) const
    {
        for (size_t i = 0; i < m_structures.size(); ++i) {
            if (m_structures[i] == structure)
                return true;
        }
        return false;
    }

    bool isSubsetOf(const StructureSet& other) const
    {
        for (size_t i = 0; i < m_structures.size(); ++i) {
            if (!other.contains(m_structures[i]))
                return false;
        }
        return true;
    }

    bool isSupersetOf(const StructureSet& other) const
    {
        return other.isSubsetOf(*this);
    }

    size_t size() const { return m_structures.size(); }

    Structure* at(size_t i) const { return m_structures.at(i); }

    Structure* operator[](size_t i) const { return at(i); }

    Structure* last() const { return m_structures.last(); }

    PredictedType predictionFromStructures() const
    {
        PredictedType result = PredictNone;

        for (size_t i = 0; i < m_structures.size(); ++i)
            mergePrediction(result, predictionFromStructure(m_structures[i]));

        return result;
    }

    bool operator==(const StructureSet& other) const
    {
        if (m_structures.size() != other.m_structures.size())
            return false;

        for (size_t i = 0; i < m_structures.size(); ++i) {
            if (!other.contains(m_structures[i]))
                return false;
        }

        return true;
    }
# 156 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/dfg/DFGStructureSet.h"
private:
    friend class StructureAbstractValue;

    Vector<Structure*, 2> m_structures;
};

} }
# 34 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/dfg/DFGAbstractValue.h" 2



namespace JSC { namespace DFG {

class StructureAbstractValue {
public:
    StructureAbstractValue()
        : m_structure(0)
    {
    }

    StructureAbstractValue(Structure* structure)
        : m_structure(structure)
    {
    }

    StructureAbstractValue(const StructureSet& set)
    {
        switch (set.size()) {
        case 0:
            m_structure = 0;
            break;

        case 1:
            m_structure = set[0];
            break;

        default:
            m_structure = topValue();
            break;
        }
    }

    void clear()
    {
        m_structure = 0;
    }

    void makeTop()
    {
        m_structure = topValue();
    }

    static StructureAbstractValue top()
    {
        StructureAbstractValue value;
        value.makeTop();
        return value;
    }

    void add(Structure* structure)
    {
        ((void)0);
        if (m_structure)
            makeTop();
        else
            m_structure = structure;
    }

    bool addAll(const StructureSet& other)
    {
        if (isTop() || !other.size())
            return false;
        if (other.size() > 1) {
            makeTop();
            return true;
        }
        if (!m_structure) {
            m_structure = other[0];
            return true;
        }
        if (m_structure == other[0])
            return false;
        makeTop();
        return true;
    }

    bool addAll(const StructureAbstractValue& other)
    {
        if (!other.m_structure)
            return false;
        if (isTop())
            return false;
        if (other.isTop()) {
            makeTop();
            return true;
        }
        if (m_structure) {
            if (m_structure == other.m_structure)
                return false;
            makeTop();
            return true;
        }
        m_structure = other.m_structure;
        return true;
    }

    bool contains(Structure* structure) const
    {
        if (isTop())
            return true;
        if (m_structure == structure)
            return true;
        return false;
    }

    bool isSubsetOf(const StructureSet& other) const
    {
        if (isTop())
            return false;
        if (!m_structure)
            return true;
        return other.contains(m_structure);
    }

    bool doesNotContainAnyOtherThan(Structure* structure) const
    {
        if (isTop())
            return false;
        if (!m_structure)
            return true;
        return m_structure == structure;
    }

    bool isSupersetOf(const StructureSet& other) const
    {
        if (isTop())
            return true;
        if (!other.size())
            return true;
        if (other.size() > 1)
            return false;
        return m_structure == other[0];
    }

    bool isSubsetOf(const StructureAbstractValue& other) const
    {
        if (other.isTop())
            return true;
        if (isTop())
            return false;
        if (m_structure) {
            if (other.m_structure)
                return m_structure == other.m_structure;
            return false;
        }
        return true;
    }

    bool isSupersetOf(const StructureAbstractValue& other) const
    {
        return other.isSubsetOf(*this);
    }

    void filter(const StructureSet& other)
    {
        if (!m_structure)
            return;

        if (isTop()) {
            switch (other.size()) {
            case 0:
                m_structure = 0;
                return;

            case 1:
                m_structure = other[0];
                return;

            default:
                return;
            }
        }

        if (other.contains(m_structure))
            return;

        m_structure = 0;
    }

    void filter(const StructureAbstractValue& other)
    {
        if (isTop()) {
            m_structure = other.m_structure;
            return;
        }
        if (m_structure == other.m_structure)
            return;
        if (other.isTop())
            return;
        m_structure = 0;
    }

    void filter(PredictedType other)
    {
        if (!(other & PredictCell)) {
            clear();
            return;
        }

        if (isClearOrTop())
            return;

        if (!(predictionFromStructure(m_structure) & other))
            m_structure = 0;
    }

    bool isClear() const
    {
        return !m_structure;
    }

    bool isTop() const { return m_structure == topValue(); }

    bool isClearOrTop() const { return m_structure <= topValue(); }
    bool isNeitherClearNorTop() const { return !isClearOrTop(); }

    size_t size() const
    {
        ((void)0);
        return !!m_structure;
    }

    Structure* at(size_t i) const
    {
        ((void)0);
        ((void)0);
        ((void)i);
        return m_structure;
    }

    Structure* operator[](size_t i) const
    {
        return at(i);
    }

    Structure* last() const
    {
        return at(0);
    }

    PredictedType predictionFromStructures() const
    {
        if (isTop())
            return PredictCell;
        if (isClear())
            return PredictNone;
        return predictionFromStructure(m_structure);
    }

    bool operator==(const StructureAbstractValue& other) const
    {
        return m_structure == other.m_structure;
    }
# 305 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/dfg/DFGAbstractValue.h"
private:
    static Structure* topValue() { return reinterpret_cast<Structure*>(1); }


    Structure* m_structure;
};

struct AbstractValue {
    AbstractValue()
        : m_type(PredictNone)
    {
    }

    void clear()
    {
        m_type = PredictNone;
        m_structure.clear();
        checkConsistency();
    }

    bool isClear()
    {
        return m_type == PredictNone && m_structure.isClear();
    }

    void makeTop()
    {
        m_type = PredictTop;
        m_structure.makeTop();
        checkConsistency();
    }

    void clobberStructures()
    {
        if (m_type & PredictCell)
            m_structure.makeTop();
        else
            ((void)0);
        checkConsistency();
    }

    bool isTop() const
    {
        return m_type == PredictTop && m_structure.isTop();
    }

    static AbstractValue top()
    {
        AbstractValue result;
        result.makeTop();
        return result;
    }

    void set(JSValue value)
    {
        m_structure.clear();
        if (value.isCell())
            m_structure.add(value.asCell()->structure());

        m_type = predictionFromValue(value);

        checkConsistency();
    }

    void set(Structure* structure)
    {
        m_structure.clear();
        m_structure.add(structure);

        m_type = predictionFromStructure(structure);

        checkConsistency();
    }

    void set(PredictedType type)
    {
        if (type & PredictCell)
            m_structure.makeTop();
        else
            m_structure.clear();
        m_type = type;
        checkConsistency();
    }

    bool operator==(const AbstractValue& other) const
    {
        return m_type == other.m_type && m_structure == other.m_structure;
    }

    bool merge(const AbstractValue& other)
    {
        bool result = mergePrediction(m_type, other.m_type) | m_structure.addAll(other.m_structure);
        checkConsistency();
        return result;
    }

    void merge(PredictedType type)
    {
        mergePrediction(m_type, type);

        if (type & PredictCell)
            m_structure.makeTop();

        checkConsistency();
    }

    void filter(const StructureSet& other)
    {
        m_type &= other.predictionFromStructures();
        m_structure.filter(other);






        m_structure.filter(m_type);
        checkConsistency();
    }

    void filter(PredictedType type)
    {
        if (type == PredictTop)
            return;
        m_type &= type;





        m_structure.filter(m_type);
        checkConsistency();
    }

    bool validate(JSValue value) const
    {
        if (isTop())
            return true;

        if (mergePredictions(m_type, predictionFromValue(value)) != m_type)
            return false;

        if (m_structure.isTop())
            return true;

        if (value.isCell()) {
            ((void)0);
            return m_structure.contains(value.asCell()->structure());
        }

        return true;
    }

    void checkConsistency() const
    {
        if (!(m_type & PredictCell))
            ((void)0);





    }
# 478 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/dfg/DFGAbstractValue.h"
    StructureAbstractValue m_structure;
    PredictedType m_type;
};

} }
# 30 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/dfg/DFGOSREntry.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/dfg/DFGOperands.h" 1
# 35 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/dfg/DFGOperands.h"
namespace JSC { namespace DFG {


inline bool operandIsArgument(int operand) { return operand < 0; }

template<typename T> struct OperandValueTraits;

template<typename T>
struct OperandValueTraits {
    static T defaultValue() { return T(); }
};

template<typename T, typename Traits = OperandValueTraits<T> >
class Operands {
public:
    Operands() { }

    explicit Operands(size_t numArguments, size_t numLocals)
    {
        m_arguments.fill(Traits::defaultValue(), numArguments);
        m_locals.fill(Traits::defaultValue(), numLocals);
    }

    size_t numberOfArguments() const { return m_arguments.size(); }
    size_t numberOfLocals() const { return m_locals.size(); }

    T& argument(size_t idx) { return m_arguments[idx]; }
    const T& argument(size_t idx) const { return m_arguments[idx]; }

    T& local(size_t idx) { return m_locals[idx]; }
    const T& local(size_t idx) const { return m_locals[idx]; }

    void ensureLocals(size_t size)
    {
        if (size <= m_locals.size())
            return;

        size_t oldSize = m_locals.size();
        m_locals.resize(size);
        for (size_t i = oldSize; i < m_locals.size(); ++i)
            m_locals[i] = Traits::defaultValue();
    }

    void setLocal(size_t idx, const T& value)
    {
        ensureLocals(idx + 1);

        m_locals[idx] = value;
    }

    T getLocal(size_t idx)
    {
        if (idx >= m_locals.size())
            return Traits::defaultValue();
        return m_locals[idx];
    }

    void setArgumentFirstTime(size_t idx, const T& value)
    {
        ((void)0);
        argument(idx) = value;
    }

    void setLocalFirstTime(size_t idx, const T& value)
    {
        ((void)0);
        setLocal(idx, value);
    }

    T& operand(int operand)
    {
        if (operandIsArgument(operand)) {
            int argument = operand + m_arguments.size() + RegisterFile::CallFrameHeaderSize;
            return m_arguments[argument];
        }

        return m_locals[operand];
    }

    const T& operand(int operand) const { return const_cast<const T&>(const_cast<Operands*>(this)->operand(operand)); }

    void setOperand(int operand, const T& value)
    {
        if (operandIsArgument(operand)) {
            int argument = operand + m_arguments.size() + RegisterFile::CallFrameHeaderSize;
            m_arguments[argument] = value;
            return;
        }

        setLocal(operand, value);
    }

    void clear()
    {
        for (size_t i = 0; i < m_arguments.size(); ++i)
            m_arguments[i] = Traits::defaultValue();
        for (size_t i = 0; i < m_locals.size(); ++i)
            m_locals[i] = Traits::defaultValue();
    }

private:
    Vector<T, 8> m_arguments;
    Vector<T, 16> m_locals;
};

template<typename T>
void dumpOperands(Operands<T>& operands, FILE* out)
{
    for (size_t argument = 0; argument < operands.numberOfArguments(); ++argument) {
        if (argument)
            fprintf(out, " ");
        operands.argument(argument).dump(out);
    }
    fprintf(out, " : ");
    for (size_t local = 0; local < operands.numberOfLocals(); ++local) {
        if (local)
            fprintf(out, " ");
        operands.local(local).dump(out);
    }
}

} }
# 31 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/dfg/DFGOSREntry.h" 2

namespace JSC {

class ExecState;
class CodeBlock;

namespace DFG {


struct OSREntryData {
    unsigned m_bytecodeIndex;
    unsigned m_machineCodeOffset;
    Operands<AbstractValue> m_expectedValues;
};

inline unsigned getOSREntryDataBytecodeIndex(OSREntryData* osrEntryData)
{
    return osrEntryData->m_bytecodeIndex;
}

void* prepareOSREntry(ExecState*, CodeBlock*, unsigned bytecodeIndex);




} }
# 36 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/CodeBlock.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/EvalCodeCache.h" 1
# 32 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/EvalCodeCache.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/Executable.h" 1
# 30 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/Executable.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSFunction.h" 1
# 29 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSFunction.h"
namespace JSC {

    class ExecutableBase;
    class FunctionExecutable;
    class FunctionPrototype;
    class JSActivation;
    class JSGlobalObject;
    class NativeExecutable;
    class VPtrHackExecutable;
    namespace DFG {
    class JITCodeGenerator;
    class JITCompiler;
    }

    EncodedJSValue callHostFunctionAsConstructor(ExecState*);

    void createDescriptorForThrowingProperty(ExecState*, PropertyDescriptor&, const char* message);

    class JSFunction : public JSNonFinalObject {
        friend class JIT;
        friend class DFG::JITCodeGenerator;
        friend class DFG::JITCompiler;
        friend class JSGlobalData;

    public:
        typedef JSNonFinalObject Base;

        static JSFunction* create(ExecState*, JSGlobalObject*, int length, const Identifier& name, NativeFunction nativeFunction, NativeFunction nativeConstructor = callHostFunctionAsConstructor);
        static JSFunction* create(ExecState*, JSGlobalObject*, int length, const Identifier& name, NativeExecutable* nativeExecutable);

        static JSFunction* create(ExecState* exec, FunctionExecutable* executable, ScopeChainNode* scopeChain)
        {
            JSFunction* function = new (allocateCell<JSFunction>(*exec->heap())) JSFunction(exec, executable, scopeChain);
            ((void)0);
            function->finishCreation(exec, executable, scopeChain);
            return function;
        }

        virtual ~JSFunction();

        const UString& name(ExecState*);
        const UString displayName(ExecState*);
        const UString calculatedDisplayName(ExecState*);

        ScopeChainNode* scope()
        {
            ((void)0);
            return m_scopeChain.get();
        }





        ScopeChainNode* scopeUnchecked()
        {
            return m_scopeChain.get();
        }
        void setScope(JSGlobalData& globalData, ScopeChainNode* scopeChain)
        {
            ((void)0);
            m_scopeChain.set(globalData, this, scopeChain);
        }

        ExecutableBase* executable() const { return m_executable.get(); }


        inline bool isHostFunction() const;
        FunctionExecutable* jsExecutable() const;

        static const ClassInfo s_info;

        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue prototype)
        {
            ((void)0);
            return Structure::create(globalData, globalObject, prototype, TypeInfo(JSFunctionType, StructureFlags), &s_info);
        }

        NativeFunction nativeFunction();
        NativeFunction nativeConstructor();

        static ConstructType getConstructData(JSCell*, ConstructData&);
        static CallType getCallData(JSCell*, CallData&);

        static inline size_t offsetOfScopeChain()
        {
            return (reinterpret_cast<ptrdiff_t>(&(reinterpret_cast<JSFunction*>(0x4000)->m_scopeChain)) - 0x4000);
        }

        static inline size_t offsetOfExecutable()
        {
            return (reinterpret_cast<ptrdiff_t>(&(reinterpret_cast<JSFunction*>(0x4000)->m_executable)) - 0x4000);
        }

    protected:
        const static unsigned StructureFlags = OverridesGetOwnPropertySlot | ImplementsHasInstance | OverridesVisitChildren | OverridesGetPropertyNames | JSObject::StructureFlags;

        JSFunction(ExecState*, JSGlobalObject*, Structure*);
        JSFunction(ExecState*, FunctionExecutable*, ScopeChainNode*);

        void finishCreation(ExecState*, NativeExecutable*, int length, const Identifier& name);
        void finishCreation(ExecState*, FunctionExecutable*, ScopeChainNode*);

        static bool getOwnPropertySlot(JSCell*, ExecState*, const Identifier&, PropertySlot&);
        virtual bool getOwnPropertyDescriptor(ExecState*, const Identifier&, PropertyDescriptor&);
        virtual void getOwnPropertyNames(ExecState*, PropertyNameArray&, EnumerationMode = ExcludeDontEnumProperties);

        static void put(JSCell*, ExecState*, const Identifier& propertyName, JSValue, PutPropertySlot&);

        static bool deleteProperty(JSCell*, ExecState*, const Identifier& propertyName);

        static void visitChildren(JSCell*, SlotVisitor&);

    private:
        explicit JSFunction(VPtrStealingHackType);

        bool isHostFunctionNonInline() const;

        static JSValue argumentsGetter(ExecState*, JSValue, const Identifier&);
        static JSValue callerGetter(ExecState*, JSValue, const Identifier&);
        static JSValue lengthGetter(ExecState*, JSValue, const Identifier&);

        WriteBarrier<ExecutableBase> m_executable;
        WriteBarrier<ScopeChainNode> m_scopeChain;
    };

    JSFunction* asFunction(JSValue);

    inline JSFunction* asFunction(JSValue value)
    {
        ((void)0);
        return static_cast<JSFunction*>(asObject(value));
    }

}
# 31 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/Executable.h" 2

# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/parser/Nodes.h" 1
# 29 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/parser/Nodes.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/Error.h" 1
# 26 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/Error.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/InternalFunction.h" 1
# 30 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/InternalFunction.h"
namespace JSC {

    class FunctionPrototype;

    class InternalFunction : public JSNonFinalObject {
    public:
        typedef JSNonFinalObject Base;

        static const ClassInfo s_info;

        const UString& name(ExecState*);
        const UString displayName(ExecState*);
        const UString calculatedDisplayName(ExecState*);

        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue proto)
        {
            return Structure::create(globalData, globalObject, proto, TypeInfo(ObjectType, StructureFlags), &s_info);
        }

    protected:
        static const unsigned StructureFlags = ImplementsHasInstance | JSObject::StructureFlags;


        InternalFunction(VPtrStealingHackType);

        InternalFunction(JSGlobalObject*, Structure*);

        void finishCreation(JSGlobalData&, const Identifier& name);

        static CallType getCallData(JSCell*, CallData&);

    private:
        virtual void vtableAnchor();
    };

    InternalFunction* asInternalFunction(JSValue);

    inline InternalFunction* asInternalFunction(JSValue value)
    {
        ((void)0);
        return static_cast<InternalFunction*>(asObject(value));
    }

}
# 27 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/Error.h" 2



namespace JSC {

    class ExecState;
    class JSGlobalData;
    class JSGlobalObject;
    class JSObject;
    class SourceCode;
    class Structure;
    class UString;


    JSObject* createError(JSGlobalObject*, const UString&);
    JSObject* createEvalError(JSGlobalObject*, const UString&);
    JSObject* createRangeError(JSGlobalObject*, const UString&);
    JSObject* createReferenceError(JSGlobalObject*, const UString&);
    JSObject* createSyntaxError(JSGlobalObject*, const UString&);
    JSObject* createTypeError(JSGlobalObject*, const UString&);
    JSObject* createURIError(JSGlobalObject*, const UString&);

    JSObject* createError(ExecState*, const UString&);
    JSObject* createEvalError(ExecState*, const UString&);
    JSObject* createRangeError(ExecState*, const UString&);
    JSObject* createReferenceError(ExecState*, const UString&);
    JSObject* createSyntaxError(ExecState*, const UString&);
    JSObject* createTypeError(ExecState*, const UString&);
    JSObject* createURIError(ExecState*, const UString&);


    bool hasErrorInfo(ExecState*, JSObject* error);
    JSObject* addErrorInfo(JSGlobalData*, JSObject* error, int line, const SourceCode&);

    JSObject* addErrorInfo(ExecState*, JSObject* error, int line, const SourceCode&);


    JSValue throwError(ExecState*, JSValue);
    JSObject* throwError(ExecState*, JSObject*);


    JSObject* throwTypeError(ExecState*);
    JSObject* throwSyntaxError(ExecState*);


    inline EncodedJSValue throwVMError(ExecState* exec, JSValue error) { return JSValue::encode(throwError(exec, error)); }
    inline EncodedJSValue throwVMTypeError(ExecState* exec) { return JSValue::encode(throwTypeError(exec)); }

    JSValue createTypeErrorFunction(ExecState* exec, const UString& message);

    class StrictModeTypeErrorFunction : public InternalFunction {
    private:
        StrictModeTypeErrorFunction(JSGlobalObject* globalObject, Structure* structure, const UString& message)
            : InternalFunction(globalObject, structure)
            , m_message(message)
        {
        }

    public:
        typedef InternalFunction Base;

        static StrictModeTypeErrorFunction* create(ExecState* exec, JSGlobalObject* globalObject, Structure* structure, const UString& message)
        {
            StrictModeTypeErrorFunction* function = new (allocateCell<StrictModeTypeErrorFunction>(*exec->heap())) StrictModeTypeErrorFunction(globalObject, structure, message);
            function->finishCreation(exec->globalData(), exec->globalData().propertyNames->emptyIdentifier);
            return function;
        }

        static EncodedJSValue constructThrowTypeError(ExecState* exec)
        {
            throwTypeError(exec, static_cast<StrictModeTypeErrorFunction*>(exec->callee())->m_message);
            return JSValue::encode(jsNull());
        }

        static ConstructType getConstructData(JSCell*, ConstructData& constructData)
        {
            constructData.native.function = constructThrowTypeError;
            return ConstructTypeHost;
        }

        static EncodedJSValue callThrowTypeError(ExecState* exec)
        {
            throwTypeError(exec, static_cast<StrictModeTypeErrorFunction*>(exec->callee())->m_message);
            return JSValue::encode(jsNull());
        }

        static CallType getCallData(JSCell*, CallData& callData)
        {
            callData.native.function = callThrowTypeError;
            return CallTypeHost;
        }

        static const ClassInfo s_info;

        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue prototype)
        {
            return Structure::create(globalData, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), &s_info);
        }

    private:
        UString m_message;
    };

}
# 30 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/parser/Nodes.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/jit/JITCode.h" 1
# 33 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/jit/JITCode.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/profiler/Profiler.h" 1
# 32 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/profiler/Profiler.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/profiler/Profile.h" 1
# 29 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/profiler/Profile.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/profiler/ProfileNode.h" 1
# 32 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/profiler/ProfileNode.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/profiler/CallIdentifier.h" 1
# 34 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/profiler/CallIdentifier.h"
namespace JSC {

    struct CallIdentifier {
        public: void* operator new(size_t, void* p) { return p; } void* operator new[](size_t, void* p) { return p; } void* operator new(size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNew); return p; } void operator delete(void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNew); ::WTF::fastFree(p); } void* operator new[](size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNewArray); return p; } void operator delete[](void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNewArray); ::WTF::fastFree(p); } private: typedef int ThisIsHereToForceASemicolonAfterThisMacro;
    public:
        UString m_name;
        UString m_url;
        unsigned m_lineNumber;

        CallIdentifier()
            : m_lineNumber(0)
        {
        }

        CallIdentifier(const UString& name, const UString& url, int lineNumber)
            : m_name(name)
            , m_url(!url.isNull() ? url : "")
            , m_lineNumber(lineNumber)
        {
        }

        inline bool operator==(const CallIdentifier& ci) const { return ci.m_lineNumber == m_lineNumber && ci.m_name == m_name && ci.m_url == m_url; }
        inline bool operator!=(const CallIdentifier& ci) const { return !(*this == ci); }

        struct Hash {
            static unsigned hash(const CallIdentifier& key)
            {
                unsigned hashCodes[3] = {
                    key.m_name.impl()->hash(),
                    key.m_url.impl()->hash(),
                    key.m_lineNumber
                };
                return StringHasher::hashMemory<sizeof(hashCodes)>(hashCodes);
            }

            static bool equal(const CallIdentifier& a, const CallIdentifier& b) { return a == b; }
            static const bool safeToCompareToEmptyOrDeleted = true;
        };

        unsigned hash() const { return Hash::hash(*this); }





    };

}

namespace WTF {

    template<> struct DefaultHash<JSC::CallIdentifier> { typedef JSC::CallIdentifier::Hash Hash; };

    template<> struct HashTraits<JSC::CallIdentifier> : GenericHashTraits<JSC::CallIdentifier> {
        static void constructDeletedValue(JSC::CallIdentifier& slot)
        {
            new (&slot) JSC::CallIdentifier(JSC::UString(), JSC::UString(), std::numeric_limits<unsigned>::max());
        }
        static bool isDeletedValue(const JSC::CallIdentifier& value)
        {
            return value.m_name.isNull() && value.m_url.isNull() && value.m_lineNumber == std::numeric_limits<unsigned>::max();
        }
    };

}
# 33 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/profiler/ProfileNode.h" 2





namespace JSC {

    class ExecState;
    class ProfileNode;

    typedef Vector<RefPtr<ProfileNode> >::const_iterator StackIterator;
    typedef HashCountedSet<StringImpl*> FunctionCallHashCount;

    class ProfileNode : public RefCounted<ProfileNode> {
    public:
        static PassRefPtr<ProfileNode> create(ExecState* callerCallFrame, const CallIdentifier& callIdentifier, ProfileNode* headNode, ProfileNode* parentNode)
        {
            return adoptRef(new ProfileNode(callerCallFrame, callIdentifier, headNode, parentNode));
        }
        static PassRefPtr<ProfileNode> create(ExecState* callerCallFrame, ProfileNode* headNode, ProfileNode* node)
        {
            return adoptRef(new ProfileNode(callerCallFrame, headNode, node));
        }

        bool operator==(ProfileNode* node) { return m_callIdentifier == node->callIdentifier(); }

        ProfileNode* willExecute(ExecState* callerCallFrame, const CallIdentifier&);
        ProfileNode* didExecute();

        void stopProfiling();


        ExecState* callerCallFrame() const { return m_callerCallFrame; }
        const CallIdentifier& callIdentifier() const { return m_callIdentifier; }
        const UString& functionName() const { return m_callIdentifier.m_name; }
        const UString& url() const { return m_callIdentifier.m_url; }
        unsigned lineNumber() const { return m_callIdentifier.m_lineNumber; }


        ProfileNode* head() const { return m_head; }
        void setHead(ProfileNode* head) { m_head = head; }
        ProfileNode* parent() const { return m_parent; }
        void setParent(ProfileNode* parent) { m_parent = parent; }
        ProfileNode* nextSibling() const { return m_nextSibling; }
        void setNextSibling(ProfileNode* nextSibling) { m_nextSibling = nextSibling; }


        double startTime() const { return m_startTime; }
        void setStartTime(double startTime) { m_startTime = startTime; }
        double totalTime() const { return m_visibleTotalTime; }
        double actualTotalTime() const { return m_actualTotalTime; }
        void setTotalTime(double time) { m_actualTotalTime = time; m_visibleTotalTime = time; }
        void setActualTotalTime(double time) { m_actualTotalTime = time; }
        void setVisibleTotalTime(double time) { m_visibleTotalTime = time; }
        double selfTime() const { return m_visibleSelfTime; }
        double actualSelfTime() const { return m_actualSelfTime; }
        void setSelfTime(double time) {m_actualSelfTime = time; m_visibleSelfTime = time; }
        void setActualSelfTime(double time) { m_actualSelfTime = time; }
        void setVisibleSelfTime(double time) { m_visibleSelfTime = time; }

        double totalPercent() const { return (m_visibleTotalTime / (m_head ? m_head->totalTime() : totalTime())) * 100.0; }
        double selfPercent() const { return (m_visibleSelfTime / (m_head ? m_head->totalTime() : totalTime())) * 100.0; }

        unsigned numberOfCalls() const { return m_numberOfCalls; }
        void setNumberOfCalls(unsigned number) { m_numberOfCalls = number; }


        const Vector<RefPtr<ProfileNode> >& children() const { return m_children; }
        ProfileNode* firstChild() const { return m_children.size() ? m_children.first().get() : 0; }
        ProfileNode* lastChild() const { return m_children.size() ? m_children.last().get() : 0; }
        ProfileNode* findChild(ProfileNode*) const;
        void removeChild(ProfileNode*);
        void addChild(PassRefPtr<ProfileNode> prpChild);
        void insertNode(PassRefPtr<ProfileNode> prpNode);


        bool visible() const { return m_visible; }
        void setVisible(bool visible) { m_visible = visible; }

        static void setTreeVisible(ProfileNode*, bool visible);


        ProfileNode* traverseNextNodePostOrder() const;
        ProfileNode* traverseNextNodePreOrder(bool processChildren = true) const;


        void calculateVisibleTotalTime();
        bool focus(const CallIdentifier&);
        void exclude(const CallIdentifier&);
        void restore();

        void endAndRecordCall();







    private:
        ProfileNode(ExecState* callerCallFrame, const CallIdentifier&, ProfileNode* headNode, ProfileNode* parentNode);
        ProfileNode(ExecState* callerCallFrame, ProfileNode* headNode, ProfileNode* nodeToCopy);

        void startTimer();
        void resetChildrensSiblings();

        RefPtr<ProfileNode>* childrenBegin() { return m_children.begin(); }
        RefPtr<ProfileNode>* childrenEnd() { return m_children.end(); }


        static inline bool totalTimeDescendingComparator(const RefPtr<ProfileNode>& a, const RefPtr<ProfileNode>& b) { return a->totalTime() > b->totalTime(); }
        static inline bool totalTimeAscendingComparator(const RefPtr<ProfileNode>& a, const RefPtr<ProfileNode>& b) { return a->totalTime() < b->totalTime(); }
        static inline bool selfTimeDescendingComparator(const RefPtr<ProfileNode>& a, const RefPtr<ProfileNode>& b) { return a->selfTime() > b->selfTime(); }
        static inline bool selfTimeAscendingComparator(const RefPtr<ProfileNode>& a, const RefPtr<ProfileNode>& b) { return a->selfTime() < b->selfTime(); }
        static inline bool callsDescendingComparator(const RefPtr<ProfileNode>& a, const RefPtr<ProfileNode>& b) { return a->numberOfCalls() > b->numberOfCalls(); }
        static inline bool callsAscendingComparator(const RefPtr<ProfileNode>& a, const RefPtr<ProfileNode>& b) { return a->numberOfCalls() < b->numberOfCalls(); }
        static inline bool functionNameDescendingComparator(const RefPtr<ProfileNode>& a, const RefPtr<ProfileNode>& b) { return a->functionName() > b->functionName(); }
        static inline bool functionNameAscendingComparator(const RefPtr<ProfileNode>& a, const RefPtr<ProfileNode>& b) { return a->functionName() < b->functionName(); }

        ExecState* m_callerCallFrame;
        CallIdentifier m_callIdentifier;
        ProfileNode* m_head;
        ProfileNode* m_parent;
        ProfileNode* m_nextSibling;

        double m_startTime;
        double m_actualTotalTime;
        double m_visibleTotalTime;
        double m_actualSelfTime;
        double m_visibleSelfTime;
        unsigned m_numberOfCalls;

        bool m_visible;

        Vector<RefPtr<ProfileNode> > m_children;
    };

}
# 30 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/profiler/Profile.h" 2




namespace JSC {

    class Profile : public RefCounted<Profile> {
    public:
        static PassRefPtr<Profile> create(const UString& title, unsigned uid);
        virtual ~Profile();

        const UString& title() const { return m_title; }
        ProfileNode* head() const { return m_head.get(); }
        void setHead(PassRefPtr<ProfileNode> head) { m_head = head; }
        double totalTime() const { return m_head->totalTime(); }
        unsigned int uid() const { return m_uid; }

        void forEach(void (ProfileNode::*)());

        void focus(const ProfileNode*);
        void exclude(const ProfileNode*);
        void restoreAll();






    protected:
        Profile(const UString& title, unsigned uid);

    private:
        void removeProfileStart();
        void removeProfileEnd();

        UString m_title;
        RefPtr<ProfileNode> m_head;
        unsigned int m_uid;
    };

}
# 33 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/profiler/Profiler.h" 2




namespace JSC {

    class ExecState;
    class JSGlobalData;
    class JSGlobalObject;
    class JSObject;
    class JSValue;
    class ProfileGenerator;
    class UString;
    struct CallIdentifier;

    class Profiler {
        public: void* operator new(size_t, void* p) { return p; } void* operator new[](size_t, void* p) { return p; } void* operator new(size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNew); return p; } void operator delete(void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNew); ::WTF::fastFree(p); } void* operator new[](size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNewArray); return p; } void operator delete[](void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNewArray); ::WTF::fastFree(p); } private: typedef int ThisIsHereToForceASemicolonAfterThisMacro;
    public:
        static Profiler** enabledProfilerReference()
        {
            return &s_sharedEnabledProfilerReference;
        }

                          static Profiler* profiler();
        static CallIdentifier createCallIdentifier(ExecState* exec, JSValue, const UString& sourceURL, int lineNumber);

                          void startProfiling(ExecState*, const UString& title);
                          PassRefPtr<Profile> stopProfiling(ExecState*, const UString& title);
        void stopProfiling(JSGlobalObject*);

        void willExecute(ExecState* callerCallFrame, JSValue function);
        void willExecute(ExecState* callerCallFrame, const UString& sourceURL, int startingLineNumber);
        void didExecute(ExecState* callerCallFrame, JSValue function);
        void didExecute(ExecState* callerCallFrame, const UString& sourceURL, int startingLineNumber);

        void exceptionUnwind(ExecState* handlerCallFrame);

        const Vector<RefPtr<ProfileGenerator> >& currentProfiles() { return m_currentProfiles; };

    private:
        Vector<RefPtr<ProfileGenerator> > m_currentProfiles;
        static Profiler* s_sharedProfiler;
        static Profiler* s_sharedEnabledProfilerReference;
    };

}
# 34 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/jit/JITCode.h" 2


namespace JSC {


    class JSGlobalData;
    class RegisterFile;


    class JITCode {

        typedef MacroAssemblerCodeRef CodeRef;
        typedef MacroAssemblerCodePtr CodePtr;



    public:
        enum JITType { HostCallThunk, BaselineJIT, DFGJIT };

        static JITType bottomTierJIT()
        {
            return BaselineJIT;
        }

        static JITType topTierJIT()
        {
            return DFGJIT;
        }

        static JITType nextTierJIT(JITType jitType)
        {
            ((void)jitType);
            return DFGJIT;
        }


        JITCode()
        {
        }

        JITCode(const CodeRef ref, JITType jitType)
            : m_ref(ref)
            , m_jitType(jitType)
        {
        }

        bool operator !() const
        {
            return !m_ref;
        }

        CodePtr addressForCall()
        {
            return m_ref.code();
        }




        unsigned offsetOf(void* pointerIntoCode)
        {
            intptr_t result = reinterpret_cast<intptr_t>(pointerIntoCode) - reinterpret_cast<intptr_t>(m_ref.code().executableAddress());
            ((void)0);
            return static_cast<unsigned>(result);
        }


        inline JSValue execute(RegisterFile* registerFile, CallFrame* callFrame, JSGlobalData* globalData)
        {
            JSValue result = JSValue::decode(ctiTrampoline(m_ref.code().executableAddress(), registerFile, callFrame, 0, Profiler::enabledProfilerReference(), globalData));
            return globalData->exception ? jsNull() : result;
        }

        void* start()
        {
            return m_ref.code().dataLocation();
        }

        size_t size()
        {
            ((void)0);
            return m_ref.size();
        }

        ExecutableMemoryHandle* getExecutableMemory()
        {
            return m_ref.executableMemory();
        }

        JITType jitType()
        {
            return m_jitType;
        }



        static JITCode HostFunction(CodeRef code)
        {
            return JITCode(code, HostCallThunk);
        }

        void clear()
        {
            m_ref.~CodeRef();
            new (&m_ref) CodeRef();
        }

    private:
        JITCode(PassRefPtr<ExecutableMemoryHandle> executableMemory, JITType jitType)
            : m_ref(executableMemory)
            , m_jitType(jitType)
        {
        }

        CodeRef m_ref;
        JITType m_jitType;

    };

};
# 31 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/parser/Nodes.h" 2

# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/parser/ParserArena.h" 1
# 30 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/parser/ParserArena.h"
# 1 "./wtf/SegmentedVector.h" 1
# 34 "./wtf/SegmentedVector.h"
namespace WTF {


    template <typename T, size_t SegmentSize> class SegmentedVector;
    template <typename T, size_t SegmentSize> class SegmentedVectorIterator {
    private:
        friend class SegmentedVector<T, SegmentSize>;
    public:
        typedef SegmentedVectorIterator<T, SegmentSize> Iterator;

        ~SegmentedVectorIterator() { }

        T& operator*() const { return m_vector.m_segments.at(m_segment)->at(m_index); }
        T* operator->() const { return &m_vector.m_segments.at(m_segment)->at(m_index); }


        Iterator& operator++()
        {
            ((void)0);
            ++m_index;
            if (m_index >= m_vector.m_segments.at(m_segment)->size()) {
                if (m_segment + 1 < m_vector.m_segments.size()) {
                    ((void)0);
                    ++m_segment;
                    m_index = 0;
                } else {

                    m_segment = 0;
                    m_index = SegmentSize;
                }
            }
            return *this;
        }

        bool operator==(const Iterator& other) const
        {
            return m_index == other.m_index && m_segment == other.m_segment && &m_vector == &other.m_vector;
        }

        bool operator!=(const Iterator& other) const
        {
            return m_index != other.m_index || m_segment != other.m_segment || &m_vector != &other.m_vector;
        }

        SegmentedVectorIterator& operator=(const SegmentedVectorIterator<T, SegmentSize>& other)
        {
            m_vector = other.m_vector;
            m_segment = other.m_segment;
            m_index = other.m_index;
            return *this;
        }

    private:
        SegmentedVectorIterator(SegmentedVector<T, SegmentSize>& vector, size_t segment, size_t index)
            : m_vector(vector)
            , m_segment(segment)
            , m_index(index)
        {
        }

        SegmentedVector<T, SegmentSize>& m_vector;
        size_t m_segment;
        size_t m_index;
    };




    template <typename T, size_t SegmentSize> class SegmentedVector {
        friend class SegmentedVectorIterator<T, SegmentSize>;
    public:
        typedef SegmentedVectorIterator<T, SegmentSize> Iterator;

        SegmentedVector()
            : m_size(0)
        {
            m_segments.append(&m_inlineSegment);
        }

        ~SegmentedVector()
        {
            deleteAllSegments();
        }

        size_t size() const { return m_size; }
        bool isEmpty() const { return !size(); }

        T& at(size_t index)
        {
            if (index < SegmentSize)
                return m_inlineSegment[index];
            return segmentFor(index)->at(subscriptFor(index));
        }

        T& operator[](size_t index)
        {
            return at(index);
        }

        T& last()
        {
            return at(size() - 1);
        }

        template <typename U> void append(const U& value)
        {
            ++m_size;

            if (m_size <= SegmentSize) {
                m_inlineSegment.uncheckedAppend(value);
                return;
            }

            if (!segmentExistsFor(m_size - 1))
                m_segments.append(new Segment);
            segmentFor(m_size - 1)->uncheckedAppend(value);
        }

        T& alloc()
        {
            append<T>(T());
            return last();
        }

        void removeLast()
        {
            if (m_size <= SegmentSize)
                m_inlineSegment.removeLast();
            else
                segmentFor(m_size - 1)->removeLast();
            --m_size;
        }

        void grow(size_t size)
        {
            ((void)0);
            ensureSegmentsFor(size);
            m_size = size;
        }

        void clear()
        {
            deleteAllSegments();
            m_segments.resize(1);
            m_inlineSegment.clear();
            m_size = 0;
        }

        Iterator begin()
        {
            return Iterator(*this, 0, m_size ? 0 : SegmentSize);
        }

        Iterator end()
        {
            return Iterator(*this, 0, SegmentSize);
        }

    private:
        typedef Vector<T, SegmentSize> Segment;

        void deleteAllSegments()
        {


            for (size_t i = 1; i < m_segments.size(); i++)
                delete m_segments[i];
        }

        bool segmentExistsFor(size_t index)
        {
            return index / SegmentSize < m_segments.size();
        }

        Segment* segmentFor(size_t index)
        {
            return m_segments[index / SegmentSize];
        }

        size_t subscriptFor(size_t index)
        {
            return index % SegmentSize;
        }

        void ensureSegmentsFor(size_t size)
        {
            size_t segmentCount = m_size / SegmentSize;
            if (m_size % SegmentSize)
                ++segmentCount;
            segmentCount = std::max<size_t>(segmentCount, 1);

            size_t neededSegmentCount = size / SegmentSize;
            if (size % SegmentSize)
                ++neededSegmentCount;


            size_t end = neededSegmentCount - 1;
            for (size_t i = segmentCount - 1; i < end; ++i)
                ensureSegment(i, SegmentSize);


            ensureSegment(end, subscriptFor(size - 1) + 1);
        }

        void ensureSegment(size_t segmentIndex, size_t size)
        {
            ((void)0);
            if (segmentIndex == m_segments.size())
                m_segments.append(new Segment);
            m_segments[segmentIndex]->grow(size);
        }

        size_t m_size;
        Segment m_inlineSegment;
        Vector<Segment*, 32> m_segments;
    };

}

using WTF::SegmentedVector;
# 31 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/parser/ParserArena.h" 2

namespace JSC {

    class ParserArenaDeletable;
    class ParserArenaRefCounted;

    class IdentifierArena {
        public: void* operator new(size_t, void* p) { return p; } void* operator new[](size_t, void* p) { return p; } void* operator new(size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNew); return p; } void operator delete(void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNew); ::WTF::fastFree(p); } void* operator new[](size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNewArray); return p; } void operator delete[](void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNewArray); ::WTF::fastFree(p); } private: typedef int ThisIsHereToForceASemicolonAfterThisMacro;
    public:
        IdentifierArena()
        {
            clear();
        }

        inline __attribute__((__always_inline__)) const Identifier& makeIdentifier(JSGlobalData*, const UChar* characters, size_t length);
        const Identifier& makeNumericIdentifier(JSGlobalData*, double number);

        bool isEmpty() const { return m_identifiers.isEmpty(); }

    public:
        static const int MaximumCachableCharacter = 128;
        typedef SegmentedVector<Identifier, 64> IdentifierVector;
        void clear()
        {
            m_identifiers.clear();
            for (int i = 0; i < MaximumCachableCharacter; i++)
                m_shortIdentifiers[i] = 0;
            for (int i = 0; i < MaximumCachableCharacter; i++)
                m_recentIdentifiers[i] = 0;
        }

    private:
        IdentifierVector m_identifiers;
        FixedArray<Identifier*, MaximumCachableCharacter> m_shortIdentifiers;
        FixedArray<Identifier*, MaximumCachableCharacter> m_recentIdentifiers;
    };

    inline __attribute__((__always_inline__)) const Identifier& IdentifierArena::makeIdentifier(JSGlobalData* globalData, const UChar* characters, size_t length)
    {
        if (characters[0] >= MaximumCachableCharacter) {
            m_identifiers.append(Identifier(globalData, characters, length));
            return m_identifiers.last();
        }
        if (length == 1) {
            if (Identifier* ident = m_shortIdentifiers[characters[0]])
                return *ident;
            m_identifiers.append(Identifier(globalData, characters, length));
            m_shortIdentifiers[characters[0]] = &m_identifiers.last();
            return m_identifiers.last();
        }
        Identifier* ident = m_recentIdentifiers[characters[0]];
        if (ident && Identifier::equal(ident->impl(), characters, length))
            return *ident;
        m_identifiers.append(Identifier(globalData, characters, length));
        m_recentIdentifiers[characters[0]] = &m_identifiers.last();
        return m_identifiers.last();
    }

    inline const Identifier& IdentifierArena::makeNumericIdentifier(JSGlobalData* globalData, double number)
    {
        m_identifiers.append(Identifier(globalData, UString::number(number)));
        return m_identifiers.last();
    }

    class ParserArena {
        private: ParserArena(const ParserArena&); ParserArena& operator=(const ParserArena&);
    public:
        ParserArena();
        ~ParserArena();

        void swap(ParserArena& otherArena)
        {
            std::swap(m_freeableMemory, otherArena.m_freeableMemory);
            std::swap(m_freeablePoolEnd, otherArena.m_freeablePoolEnd);
            m_identifierArena.swap(otherArena.m_identifierArena);
            m_freeablePools.swap(otherArena.m_freeablePools);
            m_deletableObjects.swap(otherArena.m_deletableObjects);
            m_refCountedObjects.swap(otherArena.m_refCountedObjects);
        }

        void* allocateFreeable(size_t size)
        {
            ((void)0);
            ((void)0);
            size_t alignedSize = alignSize(size);
            ((void)0);
            if (__builtin_expect((static_cast<size_t>(m_freeablePoolEnd - m_freeableMemory) < alignedSize), 0))
                allocateFreeablePool();
            void* block = m_freeableMemory;
            m_freeableMemory += alignedSize;
            return block;
        }

        void* allocateDeletable(size_t size)
        {
            ParserArenaDeletable* deletable = static_cast<ParserArenaDeletable*>(fastMalloc(size));
            m_deletableObjects.append(deletable);
            return deletable;
        }

        void derefWithArena(PassRefPtr<ParserArenaRefCounted>);
        bool contains(ParserArenaRefCounted*) const;
        ParserArenaRefCounted* last() const;
        void removeLast();

        bool isEmpty() const;
        void reset();

        IdentifierArena& identifierArena() { return *m_identifierArena; }

    private:
        static const size_t freeablePoolSize = 8000;

        static size_t alignSize(size_t size)
        {
            return (size + sizeof(WTF::AllocAlignmentInteger) - 1) & ~(sizeof(WTF::AllocAlignmentInteger) - 1);
        }

        void* freeablePool();
        void allocateFreeablePool();
        void deallocateObjects();

        char* m_freeableMemory;
        char* m_freeablePoolEnd;

        OwnPtr<IdentifierArena> m_identifierArena;
        Vector<void*> m_freeablePools;
        Vector<ParserArenaDeletable*> m_deletableObjects;
        Vector<RefPtr<ParserArenaRefCounted> > m_refCountedObjects;
    };

}
# 33 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/parser/Nodes.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/parser/ResultType.h" 1
# 29 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/parser/ResultType.h"
namespace JSC {

    struct ResultType {
        friend struct OperandTypes;

        typedef char Type;
        static const Type TypeReusable = 1;
        static const Type TypeInt32 = 2;

        static const Type TypeMaybeNumber = 0x04;
        static const Type TypeMaybeString = 0x08;
        static const Type TypeMaybeNull = 0x10;
        static const Type TypeMaybeBool = 0x20;
        static const Type TypeMaybeOther = 0x40;

        static const Type TypeBits = TypeMaybeNumber | TypeMaybeString | TypeMaybeNull | TypeMaybeBool | TypeMaybeOther;

        explicit ResultType(Type type)
            : m_type(type)
        {
        }

        bool isReusable()
        {
            return m_type & TypeReusable;
        }

        bool isInt32()
        {
            return m_type & TypeInt32;
        }

        bool definitelyIsNumber()
        {
            return (m_type & TypeBits) == TypeMaybeNumber;
        }

        bool definitelyIsString()
        {
            return (m_type & TypeBits) == TypeMaybeString;
        }

        bool mightBeNumber()
        {
            return m_type & TypeMaybeNumber;
        }

        bool isNotNumber()
        {
            return !mightBeNumber();
        }

        static ResultType nullType()
        {
            return ResultType(TypeMaybeNull);
        }

        static ResultType booleanType()
        {
            return ResultType(TypeMaybeBool);
        }

        static ResultType numberType()
        {
            return ResultType(TypeMaybeNumber);
        }

        static ResultType numberTypeCanReuse()
        {
            return ResultType(TypeReusable | TypeMaybeNumber);
        }

        static ResultType numberTypeCanReuseIsInt32()
        {
            return ResultType(TypeReusable | TypeInt32 | TypeMaybeNumber);
        }

        static ResultType stringOrNumberTypeCanReuse()
        {
            return ResultType(TypeReusable | TypeMaybeNumber | TypeMaybeString);
        }

        static ResultType stringType()
        {
            return ResultType(TypeMaybeString);
        }

        static ResultType unknownType()
        {
            return ResultType(TypeBits);
        }

        static ResultType forAdd(ResultType op1, ResultType op2)
        {
            if (op1.definitelyIsNumber() && op2.definitelyIsNumber())
                return numberTypeCanReuse();
            if (op1.definitelyIsString() || op2.definitelyIsString())
                return stringType();
            return stringOrNumberTypeCanReuse();
        }

        static ResultType forBitOp()
        {
            return numberTypeCanReuseIsInt32();
        }

    private:
        Type m_type;
    };

    struct OperandTypes
    {
        OperandTypes(ResultType first = ResultType::unknownType(), ResultType second = ResultType::unknownType())
        {


            m_u.i = 0;
            m_u.rds.first = first.m_type;
            m_u.rds.second = second.m_type;
        }

        union {
            struct {
                ResultType::Type first;
                ResultType::Type second;
            } rds;
            int i;
        } m_u;

        ResultType first()
        {
            return ResultType(m_u.rds.first);
        }

        ResultType second()
        {
            return ResultType(m_u.rds.second);
        }

        int toInt()
        {
            return m_u.i;
        }
        static OperandTypes fromInt(int value)
        {
            OperandTypes types;
            types.m_u.i = value;
            return types;
        }
    };

}
# 34 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/parser/Nodes.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/parser/SourceCode.h" 1
# 32 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/parser/SourceCode.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/parser/SourceProvider.h" 1
# 32 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/parser/SourceProvider.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/parser/SourceProviderCache.h" 1
# 29 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/parser/SourceProviderCache.h"
namespace JSC {

class SourceProviderCacheItem;

class SourceProviderCache {
public:
    SourceProviderCache() : m_contentByteSize(0) {}
                      ~SourceProviderCache();

                      void clear();
                      unsigned byteSize() const;
    void add(int sourcePosition, PassOwnPtr<SourceProviderCacheItem>, unsigned size);
    const SourceProviderCacheItem* get(int sourcePosition) const { return m_map.get(sourcePosition); }

private:
    HashMap<int, SourceProviderCacheItem*> m_map;
    unsigned m_contentByteSize;
};

}
# 33 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/parser/SourceProvider.h" 2




# 1 "./wtf/text/TextPosition.h" 1
# 30 "./wtf/text/TextPosition.h"
namespace WTF {




class OrdinalNumber {
public:
    static OrdinalNumber fromZeroBasedInt(int zeroBasedInt) { return OrdinalNumber(zeroBasedInt); }
    static OrdinalNumber fromOneBasedInt(int oneBasedInt) { return OrdinalNumber(oneBasedInt - 1); }
    OrdinalNumber() { }

    int zeroBasedInt() const { return m_zeroBasedValue; }
    int oneBasedInt() const { return m_zeroBasedValue + 1; }

    bool operator==(OrdinalNumber other) { return m_zeroBasedValue == other.m_zeroBasedValue; }
    bool operator!=(OrdinalNumber other) { return !((*this) == other); }

    static OrdinalNumber first() { return OrdinalNumber(0); }
    static OrdinalNumber beforeFirst() { return OrdinalNumber(-1); }

private:
    OrdinalNumber(int zeroBasedInt) : m_zeroBasedValue(zeroBasedInt) { }
    int m_zeroBasedValue;
};




class TextPosition {
public:
    TextPosition(OrdinalNumber line, OrdinalNumber column)
        : m_line(line)
        , m_column(column)
    {
    }
    TextPosition() { }
    bool operator==(const TextPosition& other) { return m_line == other.m_line && m_column == other.m_column; }
    bool operator!=(const TextPosition& other) { return !((*this) == other); }


    static TextPosition minimumPosition() { return TextPosition(OrdinalNumber::first(), OrdinalNumber::first()); }


    static TextPosition belowRangePosition() { return TextPosition(OrdinalNumber::beforeFirst(), OrdinalNumber::beforeFirst()); }

    OrdinalNumber m_line;
    OrdinalNumber m_column;
};

}

using WTF::OrdinalNumber;

using WTF::TextPosition;
# 38 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/parser/SourceProvider.h" 2

namespace JSC {

    class SourceProvider : public RefCounted<SourceProvider> {
    public:
        SourceProvider(const UString& url, SourceProviderCache* cache = 0)
            : m_url(url)
            , m_validated(false)
            , m_cache(cache ? cache : new SourceProviderCache)
            , m_cacheOwned(!cache)
        {
            deprecatedTurnOffVerifier();
        }
        virtual ~SourceProvider()
        {
            if (m_cacheOwned)
                delete m_cache;
        }

        virtual UString getRange(int start, int end) const = 0;
        virtual const UChar* data() const = 0;
        virtual int length() const = 0;

        const UString& url() { return m_url; }
        virtual TextPosition startPosition() const { return TextPosition::minimumPosition(); }
        intptr_t asID() { return reinterpret_cast<intptr_t>(this); }

        bool isValid() const { return m_validated; }
        void setValid() { m_validated = true; }

        SourceProviderCache* cache() const { return m_cache; }
        void notifyCacheSizeChanged(int delta) { if (!m_cacheOwned) cacheSizeChanged(delta); }

    private:
        virtual void cacheSizeChanged(int delta) { (void)delta; }

        UString m_url;
        bool m_validated;
        SourceProviderCache* m_cache;
        bool m_cacheOwned;
    };

    class UStringSourceProvider : public SourceProvider {
    public:
        static PassRefPtr<UStringSourceProvider> create(const UString& source, const UString& url)
        {
            return adoptRef(new UStringSourceProvider(source, url));
        }

        UString getRange(int start, int end) const
        {
            return m_source.substringSharingImpl(start, end - start);
        }
        const UChar* data() const { return m_source.characters(); }
        int length() const { return m_source.length(); }

    private:
        UStringSourceProvider(const UString& source, const UString& url)
            : SourceProvider(url)
            , m_source(source)
        {
        }

        UString m_source;
    };

}
# 33 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/parser/SourceCode.h" 2


namespace JSC {

    class SourceCode {
    public:
        SourceCode()
            : m_provider(0)
            , m_startChar(0)
            , m_endChar(0)
            , m_firstLine(0)
        {
        }

        SourceCode(PassRefPtr<SourceProvider> provider, int firstLine = 1)
            : m_provider(provider)
            , m_startChar(0)
            , m_endChar(m_provider->length())
            , m_firstLine(std::max(firstLine, 1))
        {
        }

        SourceCode(PassRefPtr<SourceProvider> provider, int start, int end, int firstLine)
            : m_provider(provider)
            , m_startChar(start)
            , m_endChar(end)
            , m_firstLine(std::max(firstLine, 1))
        {
        }

        UString toString() const
        {
            if (!m_provider)
                return UString();
            return m_provider->getRange(m_startChar, m_endChar);
        }

        bool isNull() const { return !m_provider; }
        SourceProvider* provider() const { return m_provider.get(); }
        int firstLine() const { return m_firstLine; }
        int startOffset() const { return m_startChar; }
        int endOffset() const { return m_endChar; }
        const UChar* data() const { return m_provider->data() + m_startChar; }
        int length() const { return m_endChar - m_startChar; }

    private:
        RefPtr<SourceProvider> m_provider;
        int m_startChar;
        int m_endChar;
        int m_firstLine;
    };

    inline SourceCode makeSource(const UString& source, const UString& url = UString(), int firstLine = 1)
    {
        return SourceCode(UStringSourceProvider::create(source, url), firstLine);
    }

}
# 35 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/parser/Nodes.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/SymbolTable.h" 1
# 34 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/SymbolTable.h"
# 1 "./wtf/AlwaysInline.h" 1
# 35 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/SymbolTable.h" 2

namespace JSC {

    static inline __attribute__((__always_inline__)) int missingSymbolMarker() { return std::numeric_limits<int>::max(); }





    struct SymbolTableEntry {
        SymbolTableEntry()
            : m_bits(0)
        {
        }

        SymbolTableEntry(int index)
        {
            ((void)0);
            pack(index, false, false);
        }

        SymbolTableEntry(int index, unsigned attributes)
        {
            ((void)0);
            pack(index, attributes & ReadOnly, attributes & DontEnum);
        }

        bool isNull() const
        {
            return !m_bits;
        }

        int getIndex() const
        {
            return m_bits >> FlagBits;
        }

        unsigned getAttributes() const
        {
            unsigned attributes = 0;
            if (m_bits & ReadOnlyFlag)
                attributes |= ReadOnly;
            if (m_bits & DontEnumFlag)
                attributes |= DontEnum;
            return attributes;
        }

        void setAttributes(unsigned attributes)
        {
            pack(getIndex(), attributes & ReadOnly, attributes & DontEnum);
        }

        bool isReadOnly() const
        {
            return m_bits & ReadOnlyFlag;
        }

    private:
        static const unsigned ReadOnlyFlag = 0x1;
        static const unsigned DontEnumFlag = 0x2;
        static const unsigned NotNullFlag = 0x4;
        static const unsigned FlagBits = 3;

        void pack(int index, bool readOnly, bool dontEnum)
        {
            m_bits = (index << FlagBits) | NotNullFlag;
            if (readOnly)
                m_bits |= ReadOnlyFlag;
            if (dontEnum)
                m_bits |= DontEnumFlag;
        }

        bool isValidIndex(int index)
        {
            return ((index << FlagBits) >> FlagBits) == index;
        }

        int m_bits;
    };

    struct SymbolTableIndexHashTraits {
        typedef SymbolTableEntry TraitType;
        static SymbolTableEntry emptyValue() { return SymbolTableEntry(); }
        static const bool emptyValueIsZero = true;
        static const bool needsDestruction = false;
    };

    typedef HashMap<RefPtr<StringImpl>, SymbolTableEntry, IdentifierRepHash, HashTraits<RefPtr<StringImpl> >, SymbolTableIndexHashTraits> SymbolTable;

    class SharedSymbolTable : public SymbolTable, public RefCounted<SharedSymbolTable> {
        public: void* operator new(size_t, void* p) { return p; } void* operator new[](size_t, void* p) { return p; } void* operator new(size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNew); return p; } void operator delete(void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNew); ::WTF::fastFree(p); } void* operator new[](size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNewArray); return p; } void operator delete[](void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNewArray); ::WTF::fastFree(p); } private: typedef int ThisIsHereToForceASemicolonAfterThisMacro;
    public:
        static PassRefPtr<SharedSymbolTable> create() { return adoptRef(new SharedSymbolTable); }
    private:
        SharedSymbolTable() { }
    };

}
# 36 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/parser/Nodes.h" 2


namespace JSC {

    class ArgumentListNode;
    class BytecodeGenerator;
    class FunctionBodyNode;
    class Label;
    class PropertyListNode;
    class ReadModifyResolveNode;
    class RegisterID;
    class ScopeChainNode;
    class ScopeNode;

    typedef unsigned CodeFeatures;

    const CodeFeatures NoFeatures = 0;
    const CodeFeatures EvalFeature = 1 << 0;
    const CodeFeatures ClosureFeature = 1 << 1;
    const CodeFeatures AssignFeature = 1 << 2;
    const CodeFeatures ArgumentsFeature = 1 << 3;
    const CodeFeatures WithFeature = 1 << 4;
    const CodeFeatures CatchFeature = 1 << 5;
    const CodeFeatures ThisFeature = 1 << 6;
    const CodeFeatures StrictModeFeature = 1 << 7;
    const CodeFeatures ShadowsArgumentsFeature = 1 << 8;


    const CodeFeatures AllFeatures = EvalFeature | ClosureFeature | AssignFeature | ArgumentsFeature | WithFeature | CatchFeature | ThisFeature | StrictModeFeature | ShadowsArgumentsFeature;

    enum Operator {
        OpEqual,
        OpPlusEq,
        OpMinusEq,
        OpMultEq,
        OpDivEq,
        OpPlusPlus,
        OpMinusMinus,
        OpAndEq,
        OpXOrEq,
        OpOrEq,
        OpModEq,
        OpLShift,
        OpRShift,
        OpURShift
    };

    enum LogicalOperator {
        OpLogicalAnd,
        OpLogicalOr
    };

    typedef HashSet<RefPtr<StringImpl>, IdentifierRepHash> IdentifierSet;

    namespace DeclarationStacks {
        enum VarAttrs { IsConstant = 1, HasInitializer = 2 };
        typedef Vector<std::pair<const Identifier*, unsigned> > VarStack;
        typedef Vector<FunctionBodyNode*> FunctionStack;
    }

    struct SwitchInfo {
        enum SwitchType { SwitchNone, SwitchImmediate, SwitchCharacter, SwitchString };
        uint32_t bytecodeOffset;
        SwitchType switchType;
    };

    class ParserArenaFreeable {
    public:


        void* operator new(size_t, JSGlobalData*);
    };

    class ParserArenaDeletable {
    public:
        virtual ~ParserArenaDeletable() { }



        void* operator new(size_t, JSGlobalData*);
    };

    class ParserArenaRefCounted : public RefCounted<ParserArenaRefCounted> {
    protected:
        ParserArenaRefCounted(JSGlobalData*);

    public:
        virtual ~ParserArenaRefCounted()
        {
            ((void)0);
        }
    };

    class Node : public ParserArenaFreeable {
    protected:
        Node(JSGlobalData*);

    public:
        virtual ~Node() { }

        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* destination = 0) = 0;

        int lineNo() const { return m_line; }

    protected:
        int m_line;
    };

    class ExpressionNode : public Node {
    protected:
        ExpressionNode(JSGlobalData*, ResultType = ResultType::unknownType());

    public:
        virtual bool isNumber() const { return false; }
        virtual bool isString() const { return false; }
        virtual bool isNull() const { return false; }
        virtual bool isPure(BytecodeGenerator&) const { return false; }
        virtual bool isLocation() const { return false; }
        virtual bool isResolveNode() const { return false; }
        virtual bool isBracketAccessorNode() const { return false; }
        virtual bool isDotAccessorNode() const { return false; }
        virtual bool isFuncExprNode() const { return false; }
        virtual bool isCommaNode() const { return false; }
        virtual bool isSimpleArray() const { return false; }
        virtual bool isAdd() const { return false; }
        virtual bool isSubtract() const { return false; }
        virtual bool hasConditionContextCodegen() const { return false; }

        virtual void emitBytecodeInConditionContext(BytecodeGenerator&, Label*, Label*, bool) { ((void)0); }

        virtual ExpressionNode* stripUnaryPlus() { return this; }

        ResultType resultDescriptor() const { return m_resultType; }

    private:
        ResultType m_resultType;
    };

    class StatementNode : public Node {
    protected:
        StatementNode(JSGlobalData*);

    public:
        void setLoc(int firstLine, int lastLine);
        int firstLine() const { return lineNo(); }
        int lastLine() const { return m_lastLine; }

        virtual bool isEmptyStatement() const { return false; }
        virtual bool isReturnNode() const { return false; }
        virtual bool isExprStatement() const { return false; }

        virtual bool isBlock() const { return false; }

    private:
        int m_lastLine;
    };

    class NullNode : public ExpressionNode {
    public:
        NullNode(JSGlobalData*);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        virtual bool isNull() const { return true; }
    };

    class BooleanNode : public ExpressionNode {
    public:
        BooleanNode(JSGlobalData*, bool value);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        virtual bool isPure(BytecodeGenerator&) const { return true; }

        bool m_value;
    };

    class NumberNode : public ExpressionNode {
    public:
        NumberNode(JSGlobalData*, double value);

        double value() const { return m_value; }
        void setValue(double value) { m_value = value; }

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        virtual bool isNumber() const { return true; }
        virtual bool isPure(BytecodeGenerator&) const { return true; }

        double m_value;
    };

    class StringNode : public ExpressionNode {
    public:
        StringNode(JSGlobalData*, const Identifier&);

        const Identifier& value() { return m_value; }

    private:
        virtual bool isPure(BytecodeGenerator&) const { return true; }

        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        virtual bool isString() const { return true; }

        const Identifier& m_value;
    };

    class ThrowableExpressionData {
    public:
        ThrowableExpressionData()
            : m_divot(static_cast<uint32_t>(-1))
            , m_startOffset(static_cast<uint16_t>(-1))
            , m_endOffset(static_cast<uint16_t>(-1))
        {
        }

        ThrowableExpressionData(unsigned divot, unsigned startOffset, unsigned endOffset)
            : m_divot(divot)
            , m_startOffset(startOffset)
            , m_endOffset(endOffset)
        {
        }

        void setExceptionSourceCode(unsigned divot, unsigned startOffset, unsigned endOffset)
        {
            m_divot = divot;
            m_startOffset = startOffset;
            m_endOffset = endOffset;
        }

        uint32_t divot() const { return m_divot; }
        uint16_t startOffset() const { return m_startOffset; }
        uint16_t endOffset() const { return m_endOffset; }

    protected:
        RegisterID* emitThrowReferenceError(BytecodeGenerator&, const UString& message);

    private:
        uint32_t m_divot;
        uint16_t m_startOffset;
        uint16_t m_endOffset;
    };

    class ThrowableSubExpressionData : public ThrowableExpressionData {
    public:
        ThrowableSubExpressionData()
            : m_subexpressionDivotOffset(0)
            , m_subexpressionEndOffset(0)
        {
        }

        ThrowableSubExpressionData(unsigned divot, unsigned startOffset, unsigned endOffset)
            : ThrowableExpressionData(divot, startOffset, endOffset)
            , m_subexpressionDivotOffset(0)
            , m_subexpressionEndOffset(0)
        {
        }

        void setSubexpressionInfo(uint32_t subexpressionDivot, uint16_t subexpressionOffset)
        {
            ((void)0);
            if ((divot() - subexpressionDivot) & ~0xFFFF)
                return;
            m_subexpressionDivotOffset = divot() - subexpressionDivot;
            m_subexpressionEndOffset = subexpressionOffset;
        }

    protected:
        uint16_t m_subexpressionDivotOffset;
        uint16_t m_subexpressionEndOffset;
    };

    class ThrowablePrefixedSubExpressionData : public ThrowableExpressionData {
    public:
        ThrowablePrefixedSubExpressionData()
            : m_subexpressionDivotOffset(0)
            , m_subexpressionStartOffset(0)
        {
        }

        ThrowablePrefixedSubExpressionData(unsigned divot, unsigned startOffset, unsigned endOffset)
            : ThrowableExpressionData(divot, startOffset, endOffset)
            , m_subexpressionDivotOffset(0)
            , m_subexpressionStartOffset(0)
        {
        }

        void setSubexpressionInfo(uint32_t subexpressionDivot, uint16_t subexpressionOffset)
        {
            ((void)0);
            if ((subexpressionDivot - divot()) & ~0xFFFF)
                return;
            m_subexpressionDivotOffset = subexpressionDivot - divot();
            m_subexpressionStartOffset = subexpressionOffset;
        }

    protected:
        uint16_t m_subexpressionDivotOffset;
        uint16_t m_subexpressionStartOffset;
    };

    class RegExpNode : public ExpressionNode, public ThrowableExpressionData {
    public:
        RegExpNode(JSGlobalData*, const Identifier& pattern, const Identifier& flags);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        const Identifier& m_pattern;
        const Identifier& m_flags;
    };

    class ThisNode : public ExpressionNode {
    public:
        ThisNode(JSGlobalData*);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);
    };

    class ResolveNode : public ExpressionNode {
    public:
        ResolveNode(JSGlobalData*, const Identifier&, int startOffset);

        const Identifier& identifier() const { return m_ident; }

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        virtual bool isPure(BytecodeGenerator&) const ;
        virtual bool isLocation() const { return true; }
        virtual bool isResolveNode() const { return true; }

        const Identifier& m_ident;
        int32_t m_startOffset;
    };

    class ElementNode : public ParserArenaFreeable {
    public:
        ElementNode(JSGlobalData*, int elision, ExpressionNode*);
        ElementNode(JSGlobalData*, ElementNode*, int elision, ExpressionNode*);

        int elision() const { return m_elision; }
        ExpressionNode* value() { return m_node; }
        ElementNode* next() { return m_next; }

    private:
        ElementNode* m_next;
        int m_elision;
        ExpressionNode* m_node;
    };

    class ArrayNode : public ExpressionNode {
    public:
        ArrayNode(JSGlobalData*, int elision);
        ArrayNode(JSGlobalData*, ElementNode*);
        ArrayNode(JSGlobalData*, int elision, ElementNode*);

        ArgumentListNode* toArgumentList(JSGlobalData*) const;

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        virtual bool isSimpleArray() const ;

        ElementNode* m_element;
        int m_elision;
        bool m_optional;
    };

    class PropertyNode : public ParserArenaFreeable {
    public:
        enum Type { Constant = 1, Getter = 2, Setter = 4 };

        PropertyNode(JSGlobalData*, const Identifier& name, ExpressionNode* value, Type);
        PropertyNode(JSGlobalData*, double name, ExpressionNode* value, Type);

        const Identifier& name() const { return m_name; }
        Type type() const { return m_type; }

    private:
        friend class PropertyListNode;
        const Identifier& m_name;
        ExpressionNode* m_assign;
        Type m_type;
    };

    class PropertyListNode : public Node {
    public:
        PropertyListNode(JSGlobalData*, PropertyNode*);
        PropertyListNode(JSGlobalData*, PropertyNode*, PropertyListNode*);

        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

    private:
        PropertyNode* m_node;
        PropertyListNode* m_next;
    };

    class ObjectLiteralNode : public ExpressionNode {
    public:
        ObjectLiteralNode(JSGlobalData*);
        ObjectLiteralNode(JSGlobalData*, PropertyListNode*);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        PropertyListNode* m_list;
    };

    class BracketAccessorNode : public ExpressionNode, public ThrowableExpressionData {
    public:
        BracketAccessorNode(JSGlobalData*, ExpressionNode* base, ExpressionNode* subscript, bool subscriptHasAssignments);

        ExpressionNode* base() const { return m_base; }
        ExpressionNode* subscript() const { return m_subscript; }

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        virtual bool isLocation() const { return true; }
        virtual bool isBracketAccessorNode() const { return true; }

        ExpressionNode* m_base;
        ExpressionNode* m_subscript;
        bool m_subscriptHasAssignments;
    };

    class DotAccessorNode : public ExpressionNode, public ThrowableExpressionData {
    public:
        DotAccessorNode(JSGlobalData*, ExpressionNode* base, const Identifier&);

        ExpressionNode* base() const { return m_base; }
        const Identifier& identifier() const { return m_ident; }

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        virtual bool isLocation() const { return true; }
        virtual bool isDotAccessorNode() const { return true; }

        ExpressionNode* m_base;
        const Identifier& m_ident;
    };

    class ArgumentListNode : public Node {
    public:
        ArgumentListNode(JSGlobalData*, ExpressionNode*);
        ArgumentListNode(JSGlobalData*, ArgumentListNode*, ExpressionNode*);

        ArgumentListNode* m_next;
        ExpressionNode* m_expr;

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);
    };

    class ArgumentsNode : public ParserArenaFreeable {
    public:
        ArgumentsNode(JSGlobalData*);
        ArgumentsNode(JSGlobalData*, ArgumentListNode*);

        ArgumentListNode* m_listNode;
    };

    class NewExprNode : public ExpressionNode, public ThrowableExpressionData {
    public:
        NewExprNode(JSGlobalData*, ExpressionNode*);
        NewExprNode(JSGlobalData*, ExpressionNode*, ArgumentsNode*);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        ExpressionNode* m_expr;
        ArgumentsNode* m_args;
    };

    class EvalFunctionCallNode : public ExpressionNode, public ThrowableExpressionData {
    public:
        EvalFunctionCallNode(JSGlobalData*, ArgumentsNode*, unsigned divot, unsigned startOffset, unsigned endOffset);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        ArgumentsNode* m_args;
    };

    class FunctionCallValueNode : public ExpressionNode, public ThrowableExpressionData {
    public:
        FunctionCallValueNode(JSGlobalData*, ExpressionNode*, ArgumentsNode*, unsigned divot, unsigned startOffset, unsigned endOffset);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        ExpressionNode* m_expr;
        ArgumentsNode* m_args;
    };

    class FunctionCallResolveNode : public ExpressionNode, public ThrowableExpressionData {
    public:
        FunctionCallResolveNode(JSGlobalData*, const Identifier&, ArgumentsNode*, unsigned divot, unsigned startOffset, unsigned endOffset);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        const Identifier& m_ident;
        ArgumentsNode* m_args;
        size_t m_index;
        size_t m_scopeDepth;
    };

    class FunctionCallBracketNode : public ExpressionNode, public ThrowableSubExpressionData {
    public:
        FunctionCallBracketNode(JSGlobalData*, ExpressionNode* base, ExpressionNode* subscript, ArgumentsNode*, unsigned divot, unsigned startOffset, unsigned endOffset);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        ExpressionNode* m_base;
        ExpressionNode* m_subscript;
        ArgumentsNode* m_args;
    };

    class FunctionCallDotNode : public ExpressionNode, public ThrowableSubExpressionData {
    public:
        FunctionCallDotNode(JSGlobalData*, ExpressionNode* base, const Identifier&, ArgumentsNode*, unsigned divot, unsigned startOffset, unsigned endOffset);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

    protected:
        ExpressionNode* m_base;
        const Identifier& m_ident;
        ArgumentsNode* m_args;
    };

    class CallFunctionCallDotNode : public FunctionCallDotNode {
    public:
        CallFunctionCallDotNode(JSGlobalData*, ExpressionNode* base, const Identifier&, ArgumentsNode*, unsigned divot, unsigned startOffset, unsigned endOffset);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);
    };

    class ApplyFunctionCallDotNode : public FunctionCallDotNode {
    public:
        ApplyFunctionCallDotNode(JSGlobalData*, ExpressionNode* base, const Identifier&, ArgumentsNode*, unsigned divot, unsigned startOffset, unsigned endOffset);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);
    };

    class PrePostResolveNode : public ExpressionNode, public ThrowableExpressionData {
    public:
        PrePostResolveNode(JSGlobalData*, const Identifier&, unsigned divot, unsigned startOffset, unsigned endOffset);

    protected:
        const Identifier& m_ident;
    };

    class PostfixResolveNode : public PrePostResolveNode {
    public:
        PostfixResolveNode(JSGlobalData*, const Identifier&, Operator, unsigned divot, unsigned startOffset, unsigned endOffset);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        Operator m_operator;
    };

    class PostfixBracketNode : public ExpressionNode, public ThrowableSubExpressionData {
    public:
        PostfixBracketNode(JSGlobalData*, ExpressionNode* base, ExpressionNode* subscript, Operator, unsigned divot, unsigned startOffset, unsigned endOffset);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        ExpressionNode* m_base;
        ExpressionNode* m_subscript;
        Operator m_operator;
    };

    class PostfixDotNode : public ExpressionNode, public ThrowableSubExpressionData {
    public:
        PostfixDotNode(JSGlobalData*, ExpressionNode* base, const Identifier&, Operator, unsigned divot, unsigned startOffset, unsigned endOffset);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        ExpressionNode* m_base;
        const Identifier& m_ident;
        Operator m_operator;
    };

    class PostfixErrorNode : public ExpressionNode, public ThrowableSubExpressionData {
    public:
        PostfixErrorNode(JSGlobalData*, ExpressionNode*, Operator, unsigned divot, unsigned startOffset, unsigned endOffset);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        ExpressionNode* m_expr;
        Operator m_operator;
    };

    class DeleteResolveNode : public ExpressionNode, public ThrowableExpressionData {
    public:
        DeleteResolveNode(JSGlobalData*, const Identifier&, unsigned divot, unsigned startOffset, unsigned endOffset);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        const Identifier& m_ident;
    };

    class DeleteBracketNode : public ExpressionNode, public ThrowableExpressionData {
    public:
        DeleteBracketNode(JSGlobalData*, ExpressionNode* base, ExpressionNode* subscript, unsigned divot, unsigned startOffset, unsigned endOffset);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        ExpressionNode* m_base;
        ExpressionNode* m_subscript;
    };

    class DeleteDotNode : public ExpressionNode, public ThrowableExpressionData {
    public:
        DeleteDotNode(JSGlobalData*, ExpressionNode* base, const Identifier&, unsigned divot, unsigned startOffset, unsigned endOffset);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        ExpressionNode* m_base;
        const Identifier& m_ident;
    };

    class DeleteValueNode : public ExpressionNode {
    public:
        DeleteValueNode(JSGlobalData*, ExpressionNode*);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        ExpressionNode* m_expr;
    };

    class VoidNode : public ExpressionNode {
    public:
        VoidNode(JSGlobalData*, ExpressionNode*);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        ExpressionNode* m_expr;
    };

    class TypeOfResolveNode : public ExpressionNode {
    public:
        TypeOfResolveNode(JSGlobalData*, const Identifier&);

        const Identifier& identifier() const { return m_ident; }

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        const Identifier& m_ident;
    };

    class TypeOfValueNode : public ExpressionNode {
    public:
        TypeOfValueNode(JSGlobalData*, ExpressionNode*);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        ExpressionNode* m_expr;
    };

    class PrefixResolveNode : public PrePostResolveNode {
    public:
        PrefixResolveNode(JSGlobalData*, const Identifier&, Operator, unsigned divot, unsigned startOffset, unsigned endOffset);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        Operator m_operator;
    };

    class PrefixBracketNode : public ExpressionNode, public ThrowablePrefixedSubExpressionData {
    public:
        PrefixBracketNode(JSGlobalData*, ExpressionNode* base, ExpressionNode* subscript, Operator, unsigned divot, unsigned startOffset, unsigned endOffset);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        ExpressionNode* m_base;
        ExpressionNode* m_subscript;
        Operator m_operator;
    };

    class PrefixDotNode : public ExpressionNode, public ThrowablePrefixedSubExpressionData {
    public:
        PrefixDotNode(JSGlobalData*, ExpressionNode* base, const Identifier&, Operator, unsigned divot, unsigned startOffset, unsigned endOffset);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        ExpressionNode* m_base;
        const Identifier& m_ident;
        Operator m_operator;
    };

    class PrefixErrorNode : public ExpressionNode, public ThrowableExpressionData {
    public:
        PrefixErrorNode(JSGlobalData*, ExpressionNode*, Operator, unsigned divot, unsigned startOffset, unsigned endOffset);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        ExpressionNode* m_expr;
        Operator m_operator;
    };

    class UnaryOpNode : public ExpressionNode {
    public:
        UnaryOpNode(JSGlobalData*, ResultType, ExpressionNode*, OpcodeID);

    protected:
        ExpressionNode* expr() { return m_expr; }
        const ExpressionNode* expr() const { return m_expr; }

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        OpcodeID opcodeID() const { return m_opcodeID; }

        ExpressionNode* m_expr;
        OpcodeID m_opcodeID;
    };

    class UnaryPlusNode : public UnaryOpNode {
    public:
        UnaryPlusNode(JSGlobalData*, ExpressionNode*);

    private:
        virtual ExpressionNode* stripUnaryPlus() { return expr(); }
    };

    class NegateNode : public UnaryOpNode {
    public:
        NegateNode(JSGlobalData*, ExpressionNode*);
    };

    class BitwiseNotNode : public UnaryOpNode {
    public:
        BitwiseNotNode(JSGlobalData*, ExpressionNode*);
    };

    class LogicalNotNode : public UnaryOpNode {
    public:
        LogicalNotNode(JSGlobalData*, ExpressionNode*);
    private:
        void emitBytecodeInConditionContext(BytecodeGenerator&, Label* trueTarget, Label* falseTarget, bool fallThroughMeansTrue);
        virtual bool hasConditionContextCodegen() const { return expr()->hasConditionContextCodegen(); }
    };

    class BinaryOpNode : public ExpressionNode {
    public:
        BinaryOpNode(JSGlobalData*, ExpressionNode* expr1, ExpressionNode* expr2, OpcodeID, bool rightHasAssignments);
        BinaryOpNode(JSGlobalData*, ResultType, ExpressionNode* expr1, ExpressionNode* expr2, OpcodeID, bool rightHasAssignments);

        RegisterID* emitStrcat(BytecodeGenerator& generator, RegisterID* destination, RegisterID* lhs = 0, ReadModifyResolveNode* emitExpressionInfoForMe = 0);

        ExpressionNode* lhs() { return m_expr1; };
        ExpressionNode* rhs() { return m_expr2; };

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

    protected:
        OpcodeID opcodeID() const { return m_opcodeID; }

    protected:
        ExpressionNode* m_expr1;
        ExpressionNode* m_expr2;
    private:
        OpcodeID m_opcodeID;
    protected:
        bool m_rightHasAssignments;
    };

    class MultNode : public BinaryOpNode {
    public:
        MultNode(JSGlobalData*, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
    };

    class DivNode : public BinaryOpNode {
    public:
        DivNode(JSGlobalData*, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
    };

    class ModNode : public BinaryOpNode {
    public:
        ModNode(JSGlobalData*, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
    };

    class AddNode : public BinaryOpNode {
    public:
        AddNode(JSGlobalData*, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);

        virtual bool isAdd() const { return true; }
    };

    class SubNode : public BinaryOpNode {
    public:
        SubNode(JSGlobalData*, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);

        virtual bool isSubtract() const { return true; }
    };

    class LeftShiftNode : public BinaryOpNode {
    public:
        LeftShiftNode(JSGlobalData*, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
    };

    class RightShiftNode : public BinaryOpNode {
    public:
        RightShiftNode(JSGlobalData*, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
    };

    class UnsignedRightShiftNode : public BinaryOpNode {
    public:
        UnsignedRightShiftNode(JSGlobalData*, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
    };

    class LessNode : public BinaryOpNode {
    public:
        LessNode(JSGlobalData*, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
    };

    class GreaterNode : public BinaryOpNode {
    public:
        GreaterNode(JSGlobalData*, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
    };

    class LessEqNode : public BinaryOpNode {
    public:
        LessEqNode(JSGlobalData*, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
    };

    class GreaterEqNode : public BinaryOpNode {
    public:
        GreaterEqNode(JSGlobalData*, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
    };

    class ThrowableBinaryOpNode : public BinaryOpNode, public ThrowableExpressionData {
    public:
        ThrowableBinaryOpNode(JSGlobalData*, ResultType, ExpressionNode* expr1, ExpressionNode* expr2, OpcodeID, bool rightHasAssignments);
        ThrowableBinaryOpNode(JSGlobalData*, ExpressionNode* expr1, ExpressionNode* expr2, OpcodeID, bool rightHasAssignments);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);
    };

    class InstanceOfNode : public ThrowableBinaryOpNode {
    public:
        InstanceOfNode(JSGlobalData*, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);
    };

    class InNode : public ThrowableBinaryOpNode {
    public:
        InNode(JSGlobalData*, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
    };

    class EqualNode : public BinaryOpNode {
    public:
        EqualNode(JSGlobalData*, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);
    };

    class NotEqualNode : public BinaryOpNode {
    public:
        NotEqualNode(JSGlobalData*, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
    };

    class StrictEqualNode : public BinaryOpNode {
    public:
        StrictEqualNode(JSGlobalData*, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);
    };

    class NotStrictEqualNode : public BinaryOpNode {
    public:
        NotStrictEqualNode(JSGlobalData*, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
    };

    class BitAndNode : public BinaryOpNode {
    public:
        BitAndNode(JSGlobalData*, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
    };

    class BitOrNode : public BinaryOpNode {
    public:
        BitOrNode(JSGlobalData*, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
    };

    class BitXOrNode : public BinaryOpNode {
    public:
        BitXOrNode(JSGlobalData*, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
    };


    class LogicalOpNode : public ExpressionNode {
    public:
        LogicalOpNode(JSGlobalData*, ExpressionNode* expr1, ExpressionNode* expr2, LogicalOperator);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);
        void emitBytecodeInConditionContext(BytecodeGenerator&, Label* trueTarget, Label* falseTarget, bool fallThroughMeansTrue);
        virtual bool hasConditionContextCodegen() const { return true; }

        ExpressionNode* m_expr1;
        ExpressionNode* m_expr2;
        LogicalOperator m_operator;
    };


    class ConditionalNode : public ExpressionNode {
    public:
        ConditionalNode(JSGlobalData*, ExpressionNode* logical, ExpressionNode* expr1, ExpressionNode* expr2);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        ExpressionNode* m_logical;
        ExpressionNode* m_expr1;
        ExpressionNode* m_expr2;
    };

    class ReadModifyResolveNode : public ExpressionNode, public ThrowableExpressionData {
    public:
        ReadModifyResolveNode(JSGlobalData*, const Identifier&, Operator, ExpressionNode* right, bool rightHasAssignments, unsigned divot, unsigned startOffset, unsigned endOffset);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        const Identifier& m_ident;
        ExpressionNode* m_right;
        size_t m_index;
        Operator m_operator;
        bool m_rightHasAssignments;
    };

    class AssignResolveNode : public ExpressionNode, public ThrowableExpressionData {
    public:
        AssignResolveNode(JSGlobalData*, const Identifier&, ExpressionNode* right, bool rightHasAssignments);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        const Identifier& m_ident;
        ExpressionNode* m_right;
        size_t m_index;
        bool m_rightHasAssignments;
    };

    class ReadModifyBracketNode : public ExpressionNode, public ThrowableSubExpressionData {
    public:
        ReadModifyBracketNode(JSGlobalData*, ExpressionNode* base, ExpressionNode* subscript, Operator, ExpressionNode* right, bool subscriptHasAssignments, bool rightHasAssignments, unsigned divot, unsigned startOffset, unsigned endOffset);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        ExpressionNode* m_base;
        ExpressionNode* m_subscript;
        ExpressionNode* m_right;
        Operator m_operator : 30;
        bool m_subscriptHasAssignments : 1;
        bool m_rightHasAssignments : 1;
    };

    class AssignBracketNode : public ExpressionNode, public ThrowableExpressionData {
    public:
        AssignBracketNode(JSGlobalData*, ExpressionNode* base, ExpressionNode* subscript, ExpressionNode* right, bool subscriptHasAssignments, bool rightHasAssignments, unsigned divot, unsigned startOffset, unsigned endOffset);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        ExpressionNode* m_base;
        ExpressionNode* m_subscript;
        ExpressionNode* m_right;
        bool m_subscriptHasAssignments : 1;
        bool m_rightHasAssignments : 1;
    };

    class AssignDotNode : public ExpressionNode, public ThrowableExpressionData {
    public:
        AssignDotNode(JSGlobalData*, ExpressionNode* base, const Identifier&, ExpressionNode* right, bool rightHasAssignments, unsigned divot, unsigned startOffset, unsigned endOffset);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        ExpressionNode* m_base;
        const Identifier& m_ident;
        ExpressionNode* m_right;
        bool m_rightHasAssignments;
    };

    class ReadModifyDotNode : public ExpressionNode, public ThrowableSubExpressionData {
    public:
        ReadModifyDotNode(JSGlobalData*, ExpressionNode* base, const Identifier&, Operator, ExpressionNode* right, bool rightHasAssignments, unsigned divot, unsigned startOffset, unsigned endOffset);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        ExpressionNode* m_base;
        const Identifier& m_ident;
        ExpressionNode* m_right;
        Operator m_operator : 31;
        bool m_rightHasAssignments : 1;
    };

    class AssignErrorNode : public ExpressionNode, public ThrowableExpressionData {
    public:
        AssignErrorNode(JSGlobalData*, ExpressionNode* left, Operator, ExpressionNode* right, unsigned divot, unsigned startOffset, unsigned endOffset);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        ExpressionNode* m_left;
        Operator m_operator;
        ExpressionNode* m_right;
    };

    typedef Vector<ExpressionNode*, 8> ExpressionVector;

    class CommaNode : public ExpressionNode, public ParserArenaDeletable {
    public:
        CommaNode(JSGlobalData*, ExpressionNode* expr1, ExpressionNode* expr2);

        using ParserArenaDeletable::operator new;

        void append(ExpressionNode* expr) { m_expressions.append(expr); }

    private:
        virtual bool isCommaNode() const { return true; }
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        ExpressionVector m_expressions;
    };

    class ConstDeclNode : public ExpressionNode {
    public:
        ConstDeclNode(JSGlobalData*, const Identifier&, ExpressionNode*);

        bool hasInitializer() const { return m_init; }
        const Identifier& ident() { return m_ident; }

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);
        virtual RegisterID* emitCodeSingle(BytecodeGenerator&);

        const Identifier& m_ident;

    public:
        ConstDeclNode* m_next;

    private:
        ExpressionNode* m_init;
    };

    class ConstStatementNode : public StatementNode {
    public:
        ConstStatementNode(JSGlobalData*, ConstDeclNode* next);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        ConstDeclNode* m_next;
    };

    class SourceElements : public ParserArenaDeletable {
    public:
        SourceElements(JSGlobalData*);

        void append(StatementNode*);

        StatementNode* singleStatement() const;
        StatementNode* lastStatement() const;

        void emitBytecode(BytecodeGenerator&, RegisterID* destination);

    private:
        Vector<StatementNode*> m_statements;
    };

    class BlockNode : public StatementNode {
    public:
        BlockNode(JSGlobalData*, SourceElements* = 0);

        StatementNode* singleStatement() const;
        StatementNode* lastStatement() const;

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        virtual bool isBlock() const { return true; }

        SourceElements* m_statements;
    };

    class EmptyStatementNode : public StatementNode {
    public:
        EmptyStatementNode(JSGlobalData*);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        virtual bool isEmptyStatement() const { return true; }
    };

    class DebuggerStatementNode : public StatementNode {
    public:
        DebuggerStatementNode(JSGlobalData*);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);
    };

    class ExprStatementNode : public StatementNode {
    public:
        ExprStatementNode(JSGlobalData*, ExpressionNode*);

        ExpressionNode* expr() const { return m_expr; }

    private:
        virtual bool isExprStatement() const { return true; }

        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        ExpressionNode* m_expr;
    };

    class VarStatementNode : public StatementNode {
    public:
        VarStatementNode(JSGlobalData*, ExpressionNode*);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        ExpressionNode* m_expr;
    };

    class IfNode : public StatementNode {
    public:
        IfNode(JSGlobalData*, ExpressionNode* condition, StatementNode* ifBlock);

    protected:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        ExpressionNode* m_condition;
        StatementNode* m_ifBlock;
    };

    class IfElseNode : public IfNode {
    public:
        IfElseNode(JSGlobalData*, ExpressionNode* condition, StatementNode* ifBlock, StatementNode* elseBlock);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        StatementNode* m_elseBlock;
    };

    class DoWhileNode : public StatementNode {
    public:
        DoWhileNode(JSGlobalData*, StatementNode* statement, ExpressionNode*);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        StatementNode* m_statement;
        ExpressionNode* m_expr;
    };

    class WhileNode : public StatementNode {
    public:
        WhileNode(JSGlobalData*, ExpressionNode*, StatementNode* statement);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        ExpressionNode* m_expr;
        StatementNode* m_statement;
    };

    class ForNode : public StatementNode {
    public:
        ForNode(JSGlobalData*, ExpressionNode* expr1, ExpressionNode* expr2, ExpressionNode* expr3, StatementNode* statement, bool expr1WasVarDecl);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        ExpressionNode* m_expr1;
        ExpressionNode* m_expr2;
        ExpressionNode* m_expr3;
        StatementNode* m_statement;
        bool m_expr1WasVarDecl;
    };

    class ForInNode : public StatementNode, public ThrowableExpressionData {
    public:
        ForInNode(JSGlobalData*, ExpressionNode*, ExpressionNode*, StatementNode*);
        ForInNode(JSGlobalData*, const Identifier&, ExpressionNode*, ExpressionNode*, StatementNode*, int divot, int startOffset, int endOffset);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        const Identifier& m_ident;
        ExpressionNode* m_init;
        ExpressionNode* m_lexpr;
        ExpressionNode* m_expr;
        StatementNode* m_statement;
        bool m_identIsVarDecl;
    };

    class ContinueNode : public StatementNode, public ThrowableExpressionData {
    public:
        ContinueNode(JSGlobalData*);
        ContinueNode(JSGlobalData*, const Identifier&);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        const Identifier& m_ident;
    };

    class BreakNode : public StatementNode, public ThrowableExpressionData {
    public:
        BreakNode(JSGlobalData*);
        BreakNode(JSGlobalData*, const Identifier&);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        const Identifier& m_ident;
    };

    class ReturnNode : public StatementNode, public ThrowableExpressionData {
    public:
        ReturnNode(JSGlobalData*, ExpressionNode* value);

        ExpressionNode* value() { return m_value; }

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        virtual bool isReturnNode() const { return true; }

        ExpressionNode* m_value;
    };

    class WithNode : public StatementNode {
    public:
        WithNode(JSGlobalData*, ExpressionNode*, StatementNode*, uint32_t divot, uint32_t expressionLength);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        ExpressionNode* m_expr;
        StatementNode* m_statement;
        uint32_t m_divot;
        uint32_t m_expressionLength;
    };

    class LabelNode : public StatementNode, public ThrowableExpressionData {
    public:
        LabelNode(JSGlobalData*, const Identifier& name, StatementNode*);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        const Identifier& m_name;
        StatementNode* m_statement;
    };

    class ThrowNode : public StatementNode, public ThrowableExpressionData {
    public:
        ThrowNode(JSGlobalData*, ExpressionNode*);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        ExpressionNode* m_expr;
    };

    class TryNode : public StatementNode {
    public:
        TryNode(JSGlobalData*, StatementNode* tryBlock, const Identifier& exceptionIdent, bool catchHasEval, StatementNode* catchBlock, StatementNode* finallyBlock);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        StatementNode* m_tryBlock;
        const Identifier& m_exceptionIdent;
        StatementNode* m_catchBlock;
        StatementNode* m_finallyBlock;
        bool m_catchHasEval;
    };

    class ParameterNode : public ParserArenaFreeable {
    public:
        ParameterNode(JSGlobalData*, const Identifier&);
        ParameterNode(JSGlobalData*, ParameterNode*, const Identifier&);

        const Identifier& ident() const { return m_ident; }
        ParameterNode* nextParam() const { return m_next; }

    private:
        const Identifier& m_ident;
        ParameterNode* m_next;
    };

    struct ScopeNodeData {
        public: void* operator new(size_t, void* p) { return p; } void* operator new[](size_t, void* p) { return p; } void* operator new(size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNew); return p; } void operator delete(void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNew); ::WTF::fastFree(p); } void* operator new[](size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNewArray); return p; } void operator delete[](void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNewArray); ::WTF::fastFree(p); } private: typedef int ThisIsHereToForceASemicolonAfterThisMacro;
    public:
        typedef DeclarationStacks::VarStack VarStack;
        typedef DeclarationStacks::FunctionStack FunctionStack;

        ScopeNodeData(ParserArena&, SourceElements*, VarStack*, FunctionStack*, IdentifierSet&, int numConstants);

        ParserArena m_arena;
        VarStack m_varStack;
        FunctionStack m_functionStack;
        int m_numConstants;
        SourceElements* m_statements;
        IdentifierSet m_capturedVariables;
    };

    class ScopeNode : public StatementNode, public ParserArenaRefCounted {
    public:
        typedef DeclarationStacks::VarStack VarStack;
        typedef DeclarationStacks::FunctionStack FunctionStack;

        ScopeNode(JSGlobalData*, bool inStrictContext);
        ScopeNode(JSGlobalData*, const SourceCode&, SourceElements*, VarStack*, FunctionStack*, IdentifierSet&, CodeFeatures, int numConstants);

        using ParserArenaRefCounted::operator new;

        ScopeNodeData* data() const { return m_data.get(); }
        void destroyData() { m_data.clear(); }

        const SourceCode& source() const { return m_source; }
        const UString& sourceURL() const { return m_source.provider()->url(); }
        intptr_t sourceID() const { return m_source.provider()->asID(); }

        void setFeatures(CodeFeatures features) { m_features = features; }
        CodeFeatures features() { return m_features; }

        bool usesEval() const { return m_features & EvalFeature; }
        bool usesArguments() const { return (m_features & ArgumentsFeature) && !(m_features & ShadowsArgumentsFeature); }
        bool isStrictMode() const { return m_features & StrictModeFeature; }
        void setUsesArguments() { m_features |= ArgumentsFeature; }
        bool usesThis() const { return m_features & ThisFeature; }
        bool needsActivationForMoreThanVariables() const { ((void)0); return m_features & (EvalFeature | WithFeature | CatchFeature); }
        bool needsActivation() const { ((void)0); return (hasCapturedVariables()) || (m_features & (EvalFeature | WithFeature | CatchFeature)); }
        bool hasCapturedVariables() const { return !!m_data->m_capturedVariables.size(); }
        size_t capturedVariableCount() const { return m_data->m_capturedVariables.size(); }
        bool captures(const Identifier& ident) { return m_data->m_capturedVariables.contains(ident.impl()); }

        VarStack& varStack() { ((void)0); return m_data->m_varStack; }
        FunctionStack& functionStack() { ((void)0); return m_data->m_functionStack; }

        int neededConstants()
        {
            ((void)0);


            return m_data->m_numConstants + 2;
        }

        StatementNode* singleStatement() const;

        void emitStatementsBytecode(BytecodeGenerator&, RegisterID* destination);

    protected:
        void setSource(const SourceCode& source) { m_source = source; }

    private:
        OwnPtr<ScopeNodeData> m_data;
        CodeFeatures m_features;
        SourceCode m_source;
    };

    class ProgramNode : public ScopeNode {
    public:
        static const bool isFunctionNode = false;
        static PassRefPtr<ProgramNode> create(JSGlobalData*, SourceElements*, VarStack*, FunctionStack*, IdentifierSet&, const SourceCode&, CodeFeatures, int numConstants);

        static const bool scopeIsFunction = false;

    private:
        ProgramNode(JSGlobalData*, SourceElements*, VarStack*, FunctionStack*, IdentifierSet&, const SourceCode&, CodeFeatures, int numConstants);

        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);
    };

    class EvalNode : public ScopeNode {
    public:
        static const bool isFunctionNode = false;
        static PassRefPtr<EvalNode> create(JSGlobalData*, SourceElements*, VarStack*, FunctionStack*, IdentifierSet&, const SourceCode&, CodeFeatures, int numConstants);

        static const bool scopeIsFunction = false;

    private:
        EvalNode(JSGlobalData*, SourceElements*, VarStack*, FunctionStack*, IdentifierSet&, const SourceCode&, CodeFeatures, int numConstants);

        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);
    };

    class FunctionParameters : public Vector<Identifier>, public RefCounted<FunctionParameters> {
        public: void* operator new(size_t, void* p) { return p; } void* operator new[](size_t, void* p) { return p; } void* operator new(size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNew); return p; } void operator delete(void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNew); ::WTF::fastFree(p); } void* operator new[](size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNewArray); return p; } void operator delete[](void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNewArray); ::WTF::fastFree(p); } private: typedef int ThisIsHereToForceASemicolonAfterThisMacro;
    public:
        static PassRefPtr<FunctionParameters> create(ParameterNode* firstParameter) { return adoptRef(new FunctionParameters(firstParameter)); }

    private:
        FunctionParameters(ParameterNode*);
    };

    class FunctionBodyNode : public ScopeNode {
    public:
        static const bool isFunctionNode = true;
        static FunctionBodyNode* create(JSGlobalData*, bool isStrictMode);
        static PassRefPtr<FunctionBodyNode> create(JSGlobalData*, SourceElements*, VarStack*, FunctionStack*, IdentifierSet&, const SourceCode&, CodeFeatures, int numConstants);

        FunctionParameters* parameters() const { return m_parameters.get(); }
        size_t parameterCount() const { return m_parameters->size(); }

        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        void finishParsing(const SourceCode&, ParameterNode*, const Identifier&);
        void finishParsing(PassRefPtr<FunctionParameters>, const Identifier&);

        const Identifier& ident() { return m_ident; }

        static const bool scopeIsFunction = true;

    private:
        FunctionBodyNode(JSGlobalData*, bool inStrictContext);
        FunctionBodyNode(JSGlobalData*, SourceElements*, VarStack*, FunctionStack*, IdentifierSet&, const SourceCode&, CodeFeatures, int numConstants);

        Identifier m_ident;
        RefPtr<FunctionParameters> m_parameters;
    };

    class FuncExprNode : public ExpressionNode {
    public:
        FuncExprNode(JSGlobalData*, const Identifier&, FunctionBodyNode* body, const SourceCode& source, ParameterNode* parameter = 0);

        FunctionBodyNode* body() { return m_body; }

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        virtual bool isFuncExprNode() const { return true; }

        FunctionBodyNode* m_body;
    };

    class FuncDeclNode : public StatementNode {
    public:
        FuncDeclNode(JSGlobalData*, const Identifier&, FunctionBodyNode*, const SourceCode&, ParameterNode* = 0);

        FunctionBodyNode* body() { return m_body; }

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        FunctionBodyNode* m_body;
    };

    class CaseClauseNode : public ParserArenaFreeable {
    public:
        CaseClauseNode(JSGlobalData*, ExpressionNode*, SourceElements* = 0);

        ExpressionNode* expr() const { return m_expr; }

        void emitBytecode(BytecodeGenerator&, RegisterID* destination);

    private:
        ExpressionNode* m_expr;
        SourceElements* m_statements;
    };

    class ClauseListNode : public ParserArenaFreeable {
    public:
        ClauseListNode(JSGlobalData*, CaseClauseNode*);
        ClauseListNode(JSGlobalData*, ClauseListNode*, CaseClauseNode*);

        CaseClauseNode* getClause() const { return m_clause; }
        ClauseListNode* getNext() const { return m_next; }

    private:
        CaseClauseNode* m_clause;
        ClauseListNode* m_next;
    };

    class CaseBlockNode : public ParserArenaFreeable {
    public:
        CaseBlockNode(JSGlobalData*, ClauseListNode* list1, CaseClauseNode* defaultClause, ClauseListNode* list2);

        RegisterID* emitBytecodeForBlock(BytecodeGenerator&, RegisterID* input, RegisterID* destination);

    private:
        SwitchInfo::SwitchType tryOptimizedSwitch(Vector<ExpressionNode*, 8>& literalVector, int32_t& min_num, int32_t& max_num);
        ClauseListNode* m_list1;
        CaseClauseNode* m_defaultClause;
        ClauseListNode* m_list2;
    };

    class SwitchNode : public StatementNode {
    public:
        SwitchNode(JSGlobalData*, ExpressionNode*, CaseBlockNode*);

    private:
        virtual RegisterID* emitBytecode(BytecodeGenerator&, RegisterID* = 0);

        ExpressionNode* m_expr;
        CaseBlockNode* m_block;
    };

    struct ElementList {
        ElementNode* head;
        ElementNode* tail;
    };

    struct PropertyList {
        PropertyListNode* head;
        PropertyListNode* tail;
    };

    struct ArgumentList {
        ArgumentListNode* head;
        ArgumentListNode* tail;
    };

    struct ConstDeclList {
        ConstDeclNode* head;
        ConstDeclNode* tail;
    };

    struct ParameterList {
        ParameterNode* head;
        ParameterNode* tail;
    };

    struct ClauseList {
        ClauseListNode* head;
        ClauseListNode* tail;
    };

}
# 33 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/Executable.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/SamplingTool.h" 1
# 40 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/SamplingTool.h"
namespace JSC {

    class ScriptExecutable;

    class SamplingFlags {
    public:
        static void start();
        static void stop();
# 89 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/SamplingTool.h"
    private:
        static uint32_t s_flags;



    };

    class CodeBlock;
    class ExecState;
    class Interpreter;
    class ScopeNode;
    struct Instruction;

    struct ScriptSampleRecord {
        ScriptSampleRecord(JSGlobalData& globalData, ScriptExecutable* executable)
            : m_executable(globalData, executable)
            , m_codeBlock(0)
            , m_sampleCount(0)
            , m_opcodeSampleCount(0)
            , m_samples(0)
            , m_size(0)
        {
        }

        ~ScriptSampleRecord()
        {
            if (m_samples)
                free(m_samples);
        }

        void sample(CodeBlock*, Instruction*);

        Strong<ScriptExecutable> m_executable;
        CodeBlock* m_codeBlock;
        int m_sampleCount;
        int m_opcodeSampleCount;
        int* m_samples;
        unsigned m_size;
    };

    typedef WTF::HashMap<ScriptExecutable*, ScriptSampleRecord*> ScriptSampleRecordMap;

    class SamplingThread {
    public:

        static bool s_running;
        static unsigned s_hertz;
        static ThreadIdentifier s_samplingThread;

        static void start(unsigned hertz=10000);
        static void stop();

        static void* threadStartFunc(void*);
    };

    class SamplingTool {
    public:
        friend struct CallRecord;
        friend class HostCallRecord;
# 181 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/SamplingTool.h"
        class CallRecord {
            private: CallRecord(const CallRecord&); CallRecord& operator=(const CallRecord&);
        public:
            CallRecord(SamplingTool*)
            {
            }
        };

        class HostCallRecord : public CallRecord {
        public:
            HostCallRecord(SamplingTool* samplingTool)
                : CallRecord(samplingTool)
            {
            }
        };


        SamplingTool(Interpreter* interpreter)
            : m_interpreter(interpreter)
            , m_codeBlock(0)
            , m_sample(0)
            , m_sampleCount(0)
            , m_opcodeSampleCount(0)



        {
            memset(m_opcodeSamples, 0, sizeof(m_opcodeSamples));
            memset(m_opcodeSamplesInCTIFunctions, 0, sizeof(m_opcodeSamplesInCTIFunctions));
        }

        ~SamplingTool()
        {



        }

        void setup();
        void dump(ExecState*);

        void notifyOfScope(JSGlobalData&, ScriptExecutable* scope);

        void sample(CodeBlock* codeBlock, Instruction* vPC)
        {
            ((void)0);
            m_codeBlock = codeBlock;
            m_sample = reinterpret_cast<intptr_t>(vPC);
        }

        CodeBlock** codeBlockSlot() { return &m_codeBlock; }
        intptr_t* sampleSlot() { return &m_sample; }

        void* encodeSample(Instruction* vPC, bool inCTIFunction = false, bool inHostFunction = false)
        {
            ((void)0);
            return reinterpret_cast<void*>(reinterpret_cast<intptr_t>(vPC) | (static_cast<intptr_t>(inCTIFunction) << 1) | static_cast<intptr_t>(inHostFunction));
        }

        static void sample();

    private:
        class Sample {
        public:
            Sample(volatile intptr_t sample, CodeBlock* volatile codeBlock)
                : m_sample(sample)
                , m_codeBlock(codeBlock)
            {
            }

            bool isNull() { return !m_sample; }
            CodeBlock* codeBlock() { return m_codeBlock; }
            Instruction* vPC() { return reinterpret_cast<Instruction*>(m_sample & ~0x3); }
            bool inHostFunction() { return m_sample & 0x1; }
            bool inCTIFunction() { return m_sample & 0x2; }

        private:
            intptr_t m_sample;
            CodeBlock* m_codeBlock;
        };

        void doRun();
        static SamplingTool* s_samplingTool;

        Interpreter* m_interpreter;


        CodeBlock* m_codeBlock;
        intptr_t m_sample;


        long long m_sampleCount;
        long long m_opcodeSampleCount;
        unsigned m_opcodeSamples[numOpcodeIDs];
        unsigned m_opcodeSamplesInCTIFunctions[numOpcodeIDs];





    };

}
# 34 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/Executable.h" 2


namespace JSC {

    class CodeBlock;
    class Debugger;
    class EvalCodeBlock;
    class FunctionCodeBlock;
    class ProgramCodeBlock;
    class ScopeChainNode;

    struct ExceptionInfo;

    enum CodeSpecializationKind { CodeForCall, CodeForConstruct };
    enum CompilationKind { FirstCompilation, OptimizingCompilation };

    inline bool isCall(CodeSpecializationKind kind)
    {
        if (kind == CodeForCall)
            return true;
        ((void)0);
        return false;
    }

    class ExecutableBase : public JSCell {
        friend class JIT;

    protected:
        static const int NUM_PARAMETERS_IS_HOST = 0;
        static const int NUM_PARAMETERS_NOT_COMPILED = -1;

        ExecutableBase(JSGlobalData& globalData, Structure* structure, int numParameters)
            : JSCell(globalData, structure)
            , m_numParametersForCall(numParameters)
            , m_numParametersForConstruct(numParameters)
        {
        }

        void finishCreation(JSGlobalData& globalData)
        {
            Base::finishCreation(globalData);
            globalData.heap.addFinalizer(this, clearCode);
        }

    public:
        typedef JSCell Base;

        static ExecutableBase* create(JSGlobalData& globalData, Structure* structure, int numParameters)
        {
            ExecutableBase* executable = new (allocateCell<ExecutableBase>(globalData.heap)) ExecutableBase(globalData, structure, numParameters);
            executable->finishCreation(globalData);
            return executable;
        }

        bool isHostFunction() const
        {
            ((void)0);
            return m_numParametersForCall == NUM_PARAMETERS_IS_HOST;
        }

        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue proto) { return Structure::create(globalData, globalObject, proto, TypeInfo(CompoundType, StructureFlags), &s_info); }

        static const ClassInfo s_info;

        virtual void clearCodeVirtual();

    protected:
        static const unsigned StructureFlags = 0;
        int m_numParametersForCall;
        int m_numParametersForConstruct;


    public:
        JITCode& generatedJITCodeForCall()
        {
            ((void)0);
            return m_jitCodeForCall;
        }

        JITCode& generatedJITCodeForConstruct()
        {
            ((void)0);
            return m_jitCodeForConstruct;
        }

        JITCode& generatedJITCodeFor(CodeSpecializationKind kind)
        {
            if (kind == CodeForCall)
                return generatedJITCodeForCall();
            ((void)0);
            return generatedJITCodeForConstruct();
        }

        MacroAssemblerCodePtr generatedJITCodeForCallWithArityCheck()
        {
            ((void)0);
            ((void)0);
            return m_jitCodeForCallWithArityCheck;
        }

        MacroAssemblerCodePtr generatedJITCodeForConstructWithArityCheck()
        {
            ((void)0);
            ((void)0);
            return m_jitCodeForConstructWithArityCheck;
        }

        MacroAssemblerCodePtr generatedJITCodeWithArityCheckFor(CodeSpecializationKind kind)
        {
            if (kind == CodeForCall)
                return generatedJITCodeForCallWithArityCheck();
            ((void)0);
            return generatedJITCodeForConstructWithArityCheck();
        }

        bool hasJITCodeForCall() const
        {
            return m_numParametersForCall >= 0;
        }

        bool hasJITCodeForConstruct() const
        {
            return m_numParametersForConstruct >= 0;
        }

        bool hasJITCodeFor(CodeSpecializationKind kind) const
        {
            if (kind == CodeForCall)
                return hasJITCodeForCall();
            ((void)0);
            return hasJITCodeForConstruct();
        }



        virtual DFG::Intrinsic intrinsic() const;

        DFG::Intrinsic intrinsicFor(CodeSpecializationKind kind) const
        {
            if (isCall(kind))
                return intrinsic();
            return DFG::NoIntrinsic;
        }


    protected:
        JITCode m_jitCodeForCall;
        JITCode m_jitCodeForConstruct;
        MacroAssemblerCodePtr m_jitCodeForCallWithArityCheck;
        MacroAssemblerCodePtr m_jitCodeForConstructWithArityCheck;


    private:
        static void clearCode(JSCell*);
    };

    class NativeExecutable : public ExecutableBase {
        friend class JIT;
    public:
        typedef ExecutableBase Base;


        static NativeExecutable* create(JSGlobalData& globalData, MacroAssemblerCodeRef callThunk, NativeFunction function, MacroAssemblerCodeRef constructThunk, NativeFunction constructor, DFG::Intrinsic intrinsic)
        {
            NativeExecutable* executable;
            if (!callThunk) {
                executable = new (allocateCell<NativeExecutable>(globalData.heap)) NativeExecutable(globalData, function, constructor);
                executable->finishCreation(globalData, JITCode(), JITCode(), intrinsic);
            } else {
                executable = new (allocateCell<NativeExecutable>(globalData.heap)) NativeExecutable(globalData, function, constructor);
                executable->finishCreation(globalData, JITCode::HostFunction(callThunk), JITCode::HostFunction(constructThunk), intrinsic);
            }
            return executable;
        }
# 217 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/Executable.h"
        ~NativeExecutable();

        NativeFunction function() { return m_function; }
        NativeFunction constructor() { return m_constructor; }

        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue proto) { return Structure::create(globalData, globalObject, proto, TypeInfo(LeafType, StructureFlags), &s_info); }

        static const ClassInfo s_info;

    protected:

        void finishCreation(JSGlobalData& globalData, JITCode callThunk, JITCode constructThunk, DFG::Intrinsic intrinsic)
        {
            Base::finishCreation(globalData);
            m_jitCodeForCall = callThunk;
            m_jitCodeForConstruct = constructThunk;
            m_jitCodeForCallWithArityCheck = callThunk.addressForCall();
            m_jitCodeForConstructWithArityCheck = constructThunk.addressForCall();

            m_intrinsic = intrinsic;



        }



        virtual DFG::Intrinsic intrinsic() const;


    private:
        NativeExecutable(JSGlobalData& globalData, NativeFunction function, NativeFunction constructor)
            : ExecutableBase(globalData, globalData.nativeExecutableStructure.get(), NUM_PARAMETERS_IS_HOST)
            , m_function(function)
            , m_constructor(constructor)
        {
        }

        NativeFunction m_function;
        NativeFunction m_constructor;

        DFG::Intrinsic m_intrinsic;
    };

    class ScriptExecutable : public ExecutableBase {
    public:
        typedef ExecutableBase Base;

        ScriptExecutable(Structure* structure, JSGlobalData& globalData, const SourceCode& source, bool isInStrictContext)
            : ExecutableBase(globalData, structure, NUM_PARAMETERS_NOT_COMPILED)
            , m_source(source)
            , m_features(isInStrictContext ? StrictModeFeature : 0)
        {
        }

        ScriptExecutable(Structure* structure, ExecState* exec, const SourceCode& source, bool isInStrictContext)
            : ExecutableBase(exec->globalData(), structure, NUM_PARAMETERS_NOT_COMPILED)
            , m_source(source)
            , m_features(isInStrictContext ? StrictModeFeature : 0)
        {
        }

        const SourceCode& source() { return m_source; }
        intptr_t sourceID() const { return m_source.provider()->asID(); }
        const UString& sourceURL() const { return m_source.provider()->url(); }
        int lineNo() const { return m_firstLine; }
        int lastLine() const { return m_lastLine; }

        bool usesEval() const { return m_features & EvalFeature; }
        bool usesArguments() const { return m_features & ArgumentsFeature; }
        bool needsActivation() const { return m_hasCapturedVariables || m_features & (EvalFeature | WithFeature | CatchFeature); }
        bool isStrictMode() const { return m_features & StrictModeFeature; }

        virtual void unlinkCalls() = 0;

        static const ClassInfo s_info;

    protected:
        void finishCreation(JSGlobalData& globalData)
        {
            Base::finishCreation(globalData);




        }

        void recordParse(CodeFeatures features, bool hasCapturedVariables, int firstLine, int lastLine)
        {
            m_features = features;
            m_hasCapturedVariables = hasCapturedVariables;
            m_firstLine = firstLine;
            m_lastLine = lastLine;
        }

        SourceCode m_source;
        CodeFeatures m_features;
        bool m_hasCapturedVariables;
        int m_firstLine;
        int m_lastLine;
    };

    class EvalExecutable : public ScriptExecutable {
    public:
        typedef ScriptExecutable Base;

        ~EvalExecutable();

        JSObject* compile(ExecState* exec, ScopeChainNode* scopeChainNode)
        {
            ((void)0);
            JSObject* error = 0;
            if (!m_evalCodeBlock)
                error = compileInternal(exec, scopeChainNode, JITCode::bottomTierJIT());
            ((void)0);
            return error;
        }

        JSObject* compileOptimized(ExecState*, ScopeChainNode*);


        void jettisonOptimizedCode(JSGlobalData&);


        EvalCodeBlock& generatedBytecode()
        {
            ((void)0);
            return *m_evalCodeBlock;
        }

        static EvalExecutable* create(ExecState* exec, const SourceCode& source, bool isInStrictContext)
        {
            EvalExecutable* executable = new (allocateCell<EvalExecutable>(*exec->heap())) EvalExecutable(exec, source, isInStrictContext);
            executable->finishCreation(exec->globalData());
            return executable;
        }


        JITCode& generatedJITCode()
        {
            return generatedJITCodeForCall();
        }

        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue proto)
        {
            return Structure::create(globalData, globalObject, proto, TypeInfo(CompoundType, StructureFlags), &s_info);
        }

        static const ClassInfo s_info;

    protected:
        virtual void clearCodeVirtual();

    private:
        static const unsigned StructureFlags = OverridesVisitChildren | ScriptExecutable::StructureFlags;
        EvalExecutable(ExecState*, const SourceCode&, bool);

        JSObject* compileInternal(ExecState*, ScopeChainNode*, JITCode::JITType);
        static void visitChildren(JSCell*, SlotVisitor&);
        void unlinkCalls();

        OwnPtr<EvalCodeBlock> m_evalCodeBlock;
    };

    class ProgramExecutable : public ScriptExecutable {
    public:
        typedef ScriptExecutable Base;

        static ProgramExecutable* create(ExecState* exec, const SourceCode& source)
        {
            ProgramExecutable* executable = new (allocateCell<ProgramExecutable>(*exec->heap())) ProgramExecutable(exec, source);
            executable->finishCreation(exec->globalData());
            return executable;
        }

        ~ProgramExecutable();

        JSObject* compile(ExecState* exec, ScopeChainNode* scopeChainNode)
        {
            ((void)0);
            JSObject* error = 0;
            if (!m_programCodeBlock)
                error = compileInternal(exec, scopeChainNode, JITCode::bottomTierJIT());
            ((void)0);
            return error;
        }

        JSObject* compileOptimized(ExecState*, ScopeChainNode*);


        void jettisonOptimizedCode(JSGlobalData&);


        ProgramCodeBlock& generatedBytecode()
        {
            ((void)0);
            return *m_programCodeBlock;
        }

        JSObject* checkSyntax(ExecState*);


        JITCode& generatedJITCode()
        {
            return generatedJITCodeForCall();
        }


        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue proto)
        {
            return Structure::create(globalData, globalObject, proto, TypeInfo(CompoundType, StructureFlags), &s_info);
        }

        static const ClassInfo s_info;

    protected:
        virtual void clearCodeVirtual();

    private:
        static const unsigned StructureFlags = OverridesVisitChildren | ScriptExecutable::StructureFlags;
        ProgramExecutable(ExecState*, const SourceCode&);

        JSObject* compileInternal(ExecState*, ScopeChainNode*, JITCode::JITType);
        static void visitChildren(JSCell*, SlotVisitor&);
        void unlinkCalls();

        OwnPtr<ProgramCodeBlock> m_programCodeBlock;
    };

    class FunctionExecutable : public ScriptExecutable {
        friend class JIT;
    public:
        typedef ScriptExecutable Base;

        static FunctionExecutable* create(ExecState* exec, const Identifier& name, const SourceCode& source, bool forceUsesArguments, FunctionParameters* parameters, bool isInStrictContext, int firstLine, int lastLine)
        {
            FunctionExecutable* executable = new (allocateCell<FunctionExecutable>(*exec->heap())) FunctionExecutable(exec, name, source, forceUsesArguments, parameters, isInStrictContext);
            executable->finishCreation(exec->globalData(), name, firstLine, lastLine);
            return executable;
        }

        static FunctionExecutable* create(JSGlobalData& globalData, const Identifier& name, const SourceCode& source, bool forceUsesArguments, FunctionParameters* parameters, bool isInStrictContext, int firstLine, int lastLine)
        {
            FunctionExecutable* executable = new (allocateCell<FunctionExecutable>(globalData.heap)) FunctionExecutable(globalData, name, source, forceUsesArguments, parameters, isInStrictContext);
            executable->finishCreation(globalData, name, firstLine, lastLine);
            return executable;
        }

        JSFunction* make(ExecState* exec, ScopeChainNode* scopeChain)
        {
            return JSFunction::create(exec, this, scopeChain);
        }




        FunctionCodeBlock& generatedBytecode()
        {
            if (m_codeBlockForCall)
                return *m_codeBlockForCall;
            ((void)0);
            return *m_codeBlockForConstruct;
        }

        PassOwnPtr<FunctionCodeBlock> produceCodeBlockFor(ScopeChainNode*, CompilationKind, CodeSpecializationKind, JSObject*& exception);

        JSObject* compileForCall(ExecState* exec, ScopeChainNode* scopeChainNode)
        {
            ((void)0);
            JSObject* error = 0;
            if (!m_codeBlockForCall)
                error = compileForCallInternal(exec, scopeChainNode, JITCode::bottomTierJIT());
            ((void)0);
            return error;
        }

        JSObject* compileOptimizedForCall(ExecState*, ScopeChainNode*);


        void jettisonOptimizedCodeForCall(JSGlobalData&);


        bool isGeneratedForCall() const
        {
            return m_codeBlockForCall;
        }

        FunctionCodeBlock& generatedBytecodeForCall()
        {
            ((void)0);
            return *m_codeBlockForCall;
        }

        JSObject* compileForConstruct(ExecState* exec, ScopeChainNode* scopeChainNode)
        {
            ((void)0);
            JSObject* error = 0;
            if (!m_codeBlockForConstruct)
                error = compileForConstructInternal(exec, scopeChainNode, JITCode::bottomTierJIT());
            ((void)0);
            return error;
        }

        JSObject* compileOptimizedForConstruct(ExecState*, ScopeChainNode*);


        void jettisonOptimizedCodeForConstruct(JSGlobalData&);


        bool isGeneratedForConstruct() const
        {
            return m_codeBlockForConstruct;
        }

        FunctionCodeBlock& generatedBytecodeForConstruct()
        {
            ((void)0);
            return *m_codeBlockForConstruct;
        }

        JSObject* compileFor(ExecState* exec, ScopeChainNode* scopeChainNode, CodeSpecializationKind kind)
        {
            ((void)0);
            ((void)0);
            ((void)0);

            if (kind == CodeForCall)
                return compileForCall(exec, scopeChainNode);
            ((void)0);
            return compileForConstruct(exec, scopeChainNode);
        }

        JSObject* compileOptimizedFor(ExecState* exec, ScopeChainNode* scopeChainNode, CodeSpecializationKind kind)
        {
            ((void)0);
            ((void)0);
            ((void)0);

            if (kind == CodeForCall)
                return compileOptimizedForCall(exec, scopeChainNode);
            ((void)0);
            return compileOptimizedForConstruct(exec, scopeChainNode);
        }


        void jettisonOptimizedCodeFor(JSGlobalData& globalData, CodeSpecializationKind kind)
        {
            if (kind == CodeForCall)
                jettisonOptimizedCodeForCall(globalData);
            else {
                ((void)0);
                jettisonOptimizedCodeForConstruct(globalData);
            }
        }


        bool isGeneratedFor(CodeSpecializationKind kind)
        {
            if (kind == CodeForCall)
                return isGeneratedForCall();
            ((void)0);
            return isGeneratedForConstruct();
        }

        FunctionCodeBlock& generatedBytecodeFor(CodeSpecializationKind kind)
        {
            if (kind == CodeForCall)
                return generatedBytecodeForCall();
            ((void)0);
            return generatedBytecodeForConstruct();
        }

        CodeBlock* baselineCodeBlockFor(CodeSpecializationKind);

        CodeBlock* profiledCodeBlockFor(CodeSpecializationKind kind)
        {
            return baselineCodeBlockFor(kind);
        }

        const Identifier& name() { return m_name; }
        JSString* nameValue() const { return m_nameValue.get(); }
        size_t parameterCount() const { return m_parameters->size(); }
        unsigned capturedVariableCount() const { return m_numCapturedVariables; }
        UString paramString() const;
        SharedSymbolTable* symbolTable() const { return m_symbolTable; }

        void discardCode();
        static void visitChildren(JSCell*, SlotVisitor&);
        static FunctionExecutable* fromGlobalCode(const Identifier&, ExecState*, Debugger*, const SourceCode&, JSObject** exception);
        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue proto)
        {
            return Structure::create(globalData, globalObject, proto, TypeInfo(CompoundType, StructureFlags), &s_info);
        }

        static const ClassInfo s_info;

    protected:
        virtual void clearCodeVirtual();

        void finishCreation(JSGlobalData& globalData, const Identifier& name, int firstLine, int lastLine)
        {
            Base::finishCreation(globalData);
            m_firstLine = firstLine;
            m_lastLine = lastLine;
            m_nameValue.set(globalData, this, jsString(&globalData, name.ustring()));
        }

    private:
        FunctionExecutable(JSGlobalData&, const Identifier& name, const SourceCode&, bool forceUsesArguments, FunctionParameters*, bool);
        FunctionExecutable(ExecState*, const Identifier& name, const SourceCode&, bool forceUsesArguments, FunctionParameters*, bool);

        JSObject* compileForCallInternal(ExecState*, ScopeChainNode*, JITCode::JITType);
        JSObject* compileForConstructInternal(ExecState*, ScopeChainNode*, JITCode::JITType);

        OwnPtr<FunctionCodeBlock>& codeBlockFor(CodeSpecializationKind kind)
        {
            if (kind == CodeForCall)
                return m_codeBlockForCall;
            ((void)0);
            return m_codeBlockForConstruct;
        }

        static const unsigned StructureFlags = OverridesVisitChildren | ScriptExecutable::StructureFlags;
        unsigned m_numCapturedVariables : 31;
        bool m_forceUsesArguments : 1;
        void unlinkCalls();

        RefPtr<FunctionParameters> m_parameters;
        OwnPtr<FunctionCodeBlock> m_codeBlockForCall;
        OwnPtr<FunctionCodeBlock> m_codeBlockForConstruct;
        Identifier m_name;
        WriteBarrier<JSString> m_nameValue;
        SharedSymbolTable* m_symbolTable;
    };

    inline FunctionExecutable* JSFunction::jsExecutable() const
    {
        ((void)0);
        return static_cast<FunctionExecutable*>(m_executable.get());
    }

    inline bool JSFunction::isHostFunction() const
    {
        ((void)0);
        return m_executable->isHostFunction();
    }

    inline NativeFunction JSFunction::nativeFunction()
    {
        ((void)0);
        return static_cast<NativeExecutable*>(m_executable.get())->function();
    }

    inline NativeFunction JSFunction::nativeConstructor()
    {
        ((void)0);
        return static_cast<NativeExecutable*>(m_executable.get())->constructor();
    }

    inline bool isHostFunction(JSValue value, NativeFunction nativeFunction)
    {
        JSFunction* function = static_cast<JSFunction*>(getJSFunction(value));
        if (!function || !function->isHostFunction())
            return false;
        return function->nativeFunction() == nativeFunction;
    }

}
# 33 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/EvalCodeCache.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSGlobalObject.h" 1
# 25 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSGlobalObject.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSArray.h" 1
# 28 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSArray.h"
namespace JSC {

    typedef HashMap<unsigned, WriteBarrier<Unknown> > SparseArrayValueMap;






    struct ArrayStorage {
        unsigned m_length;
        unsigned m_numValuesInVector;
        SparseArrayValueMap* m_sparseValueMap;
        void* subclassData;
        void* m_allocBase;
        size_t reportedMapCapacity;



        WriteBarrier<Unknown> m_vector[1];
    };
# 58 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSArray.h"
    enum ArrayCreationMode { CreateCompact, CreateInitialized };

    class JSArray : public JSNonFinalObject {
        friend class Walker;

    protected:
        explicit JSArray(JSGlobalData&, Structure*);

        void finishCreation(JSGlobalData&);
        void finishCreation(JSGlobalData&, unsigned initialLength, ArrayCreationMode);
        void finishCreation(JSGlobalData&, const ArgList&);

    public:
        typedef JSNonFinalObject Base;

        JSArray(VPtrStealingHackType);
        virtual ~JSArray();

        static JSArray* create(JSGlobalData& globalData, Structure* structure)
        {
            JSArray* array = new (allocateCell<JSArray>(globalData.heap)) JSArray(globalData, structure);
            array->finishCreation(globalData);
            return array;
        }

        static JSArray* create(JSGlobalData& globalData, Structure* structure, unsigned initialLength, ArrayCreationMode createMode)
        {
            JSArray* array = new (allocateCell<JSArray>(globalData.heap)) JSArray(globalData, structure);
            array->finishCreation(globalData, initialLength, createMode);
            return array;
        }

        static JSArray* create(JSGlobalData& globalData, Structure* structure, const ArgList& initialValues)
        {
            JSArray* array = new (allocateCell<JSArray>(globalData.heap)) JSArray(globalData, structure);
            array->finishCreation(globalData, initialValues);
            return array;
        }

        static bool getOwnPropertySlot(JSCell*, ExecState*, const Identifier& propertyName, PropertySlot&);
        static bool getOwnPropertySlotByIndex(JSCell*, ExecState*, unsigned propertyName, PropertySlot&);
        virtual bool getOwnPropertyDescriptor(ExecState*, const Identifier&, PropertyDescriptor&);
        static void putByIndex(JSCell*, ExecState*, unsigned propertyName, JSValue);

        static const ClassInfo s_info;

        unsigned length() const { return m_storage->m_length; }
        void setLength(unsigned);

        void sort(ExecState*);
        void sort(ExecState*, JSValue compareFunction, CallType, const CallData&);
        void sortNumeric(ExecState*, JSValue compareFunction, CallType, const CallData&);

        void push(ExecState*, JSValue);
        JSValue pop();

        void shiftCount(ExecState*, int count);
        void unshiftCount(ExecState*, int count);

        bool canGetIndex(unsigned i) { return i < m_vectorLength && m_storage->m_vector[i]; }
        JSValue getIndex(unsigned i)
        {
            ((void)0);
            return m_storage->m_vector[i].get();
        }

        bool canSetIndex(unsigned i) { return i < m_vectorLength; }
        void setIndex(JSGlobalData& globalData, unsigned i, JSValue v)
        {
            ((void)0);

            WriteBarrier<Unknown>& x = m_storage->m_vector[i];
            if (!x) {
                ArrayStorage *storage = m_storage;
                ++storage->m_numValuesInVector;
                if (i >= storage->m_length)
                    storage->m_length = i + 1;
            }
            x.set(globalData, this, v);
        }

        void uncheckedSetIndex(JSGlobalData& globalData, unsigned i, JSValue v)
        {
            ((void)0);
            ArrayStorage *storage = m_storage;



            storage->m_vector[i].set(globalData, this, v);
        }

        void fillArgList(ExecState*, MarkedArgumentBuffer&);
        void copyToRegisters(ExecState*, Register*, uint32_t);

        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue prototype)
        {
            return Structure::create(globalData, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), &s_info);
        }

        static ptrdiff_t storageOffset()
        {
            return (reinterpret_cast<ptrdiff_t>(&(reinterpret_cast<JSArray*>(0x4000)->m_storage)) - 0x4000);
        }

        static ptrdiff_t vectorLengthOffset()
        {
            return (reinterpret_cast<ptrdiff_t>(&(reinterpret_cast<JSArray*>(0x4000)->m_vectorLength)) - 0x4000);
        }

        static void visitChildren(JSCell*, SlotVisitor&);

    protected:
        static const unsigned StructureFlags = OverridesGetOwnPropertySlot | OverridesVisitChildren | OverridesGetPropertyNames | JSObject::StructureFlags;
        static void put(JSCell*, ExecState*, const Identifier& propertyName, JSValue, PutPropertySlot&);

        static bool deleteProperty(JSCell*, ExecState*, const Identifier& propertyName);
        static bool deletePropertyByIndex(JSCell*, ExecState*, unsigned propertyName);
        virtual void getOwnPropertyNames(ExecState*, PropertyNameArray&, EnumerationMode mode = ExcludeDontEnumProperties);

        void* subclassData() const;
        void setSubclassData(void*);

    private:
        bool getOwnPropertySlotSlowCase(ExecState*, unsigned propertyName, PropertySlot&);
        void putSlowCase(ExecState*, unsigned propertyName, JSValue);

        unsigned getNewVectorLength(unsigned desiredLength);
        bool increaseVectorLength(unsigned newLength);
        bool increaseVectorPrefixLength(unsigned newLength);

        unsigned compactForSorting();

        enum ConsistencyCheckType { NormalConsistencyCheck, DestructorConsistencyCheck, SortConsistencyCheck };
        void checkConsistency(ConsistencyCheckType = NormalConsistencyCheck);

        unsigned m_vectorLength;
        int m_indexBias;
        ArrayStorage *m_storage;
    };

    JSArray* asArray(JSValue);

    inline JSArray* asArray(JSCell* cell)
    {
        ((void)0);
        return static_cast<JSArray*>(cell);
    }

    inline JSArray* asArray(JSValue value)
    {
        return asArray(value.asCell());
    }

    inline bool isJSArray(JSGlobalData* globalData, JSCell* cell) { return cell->vptr() == globalData->jsArrayVPtr; }
    inline bool isJSArray(JSGlobalData* globalData, JSValue v) { return v.isCell() && isJSArray(globalData, v.asCell()); }



    inline unsigned Identifier::toArrayIndex(bool& ok) const
    {
        unsigned i = toUInt32(ok);
        if (ok && i >= 0xFFFFFFFFU)
            ok = false;
        return i;
    }

}
# 26 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSGlobalObject.h" 2

# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSGlobalThis.h" 1
# 31 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSGlobalThis.h"
namespace JSC {

class JSGlobalThis : public JSNonFinalObject {
public:
    typedef JSNonFinalObject Base;

    static JSGlobalThis* create(JSGlobalData& globalData, Structure* structure)
    {
        JSGlobalThis* globalThis = new (allocateCell<JSGlobalThis>(globalData.heap)) JSGlobalThis(globalData, structure);
        globalThis->finishCreation(globalData);
        return globalThis;
    }

protected:
    JSGlobalThis(JSGlobalData& globalData, Structure* structure)
        : JSNonFinalObject(globalData, structure)
    {
    }

    void finishCreation(JSGlobalData& globalData)
    {
        Base::finishCreation(globalData);
    }
};

}
# 28 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSGlobalObject.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSVariableObject.h" 1
# 39 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSVariableObject.h"
namespace JSC {

    class Register;

    class JSVariableObject : public JSNonFinalObject {
        friend class JIT;

    public:
        typedef JSNonFinalObject Base;

        SymbolTable& symbolTable() const { return *m_symbolTable; }

        virtual void putWithAttributes(ExecState*, const Identifier&, JSValue, unsigned attributes) = 0;

        static bool deleteProperty(JSCell*, ExecState*, const Identifier&);
        virtual void getOwnPropertyNames(ExecState*, PropertyNameArray&, EnumerationMode mode = ExcludeDontEnumProperties);

        virtual bool isVariableObject() const;
        virtual bool isDynamicScope(bool& requiresDynamicChecks) const = 0;

        WriteBarrier<Unknown>& registerAt(int index) const { return m_registers[index]; }

        WriteBarrier<Unknown>* const * addressOfRegisters() const { return &m_registers; }
        static size_t offsetOfRegisters() { return (reinterpret_cast<ptrdiff_t>(&(reinterpret_cast<JSVariableObject*>(0x4000)->m_registers)) - 0x4000); }

        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue prototype)
        {
            return Structure::create(globalData, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), &s_info);
        }

    protected:
        static const unsigned StructureFlags = OverridesGetPropertyNames | JSNonFinalObject::StructureFlags;

        JSVariableObject(JSGlobalData& globalData, Structure* structure, SymbolTable* symbolTable, Register* registers)
            : JSNonFinalObject(globalData, structure)
            , m_symbolTable(symbolTable)
            , m_registers(reinterpret_cast<WriteBarrier<Unknown>*>(registers))
        {
        }

        void finishCreation(JSGlobalData& globalData)
        {
            Base::finishCreation(globalData);
            ((void)0);
            typedef int dummyRegister_should_be_same_size_as_WriteBarrier [(sizeof(WriteBarrier<Unknown>) == sizeof(Register)) ? 1 : -1];
        }

        PassOwnArrayPtr<WriteBarrier<Unknown> > copyRegisterArray(JSGlobalData&, WriteBarrier<Unknown>* src, size_t count, size_t callframeStarts);
        void setRegisters(WriteBarrier<Unknown>* registers, PassOwnArrayPtr<WriteBarrier<Unknown> > registerArray);

        bool symbolTableGet(const Identifier&, PropertySlot&);
        bool symbolTableGet(const Identifier&, PropertyDescriptor&);
        bool symbolTableGet(const Identifier&, PropertySlot&, bool& slotIsWriteable);
        bool symbolTablePut(JSGlobalData&, const Identifier&, JSValue);
        bool symbolTablePutWithAttributes(JSGlobalData&, const Identifier&, JSValue, unsigned attributes);

        SymbolTable* m_symbolTable;
        WriteBarrier<Unknown>* m_registers;
        OwnArrayPtr<WriteBarrier<Unknown> > m_registerArray;
    };

    inline bool JSVariableObject::symbolTableGet(const Identifier& propertyName, PropertySlot& slot)
    {
        SymbolTableEntry entry = symbolTable().inlineGet(propertyName.impl());
        if (!entry.isNull()) {
            slot.setValue(registerAt(entry.getIndex()).get());
            return true;
        }
        return false;
    }

    inline bool JSVariableObject::symbolTableGet(const Identifier& propertyName, PropertySlot& slot, bool& slotIsWriteable)
    {
        SymbolTableEntry entry = symbolTable().inlineGet(propertyName.impl());
        if (!entry.isNull()) {
            slot.setValue(registerAt(entry.getIndex()).get());
            slotIsWriteable = !entry.isReadOnly();
            return true;
        }
        return false;
    }

    inline bool JSVariableObject::symbolTablePut(JSGlobalData& globalData, const Identifier& propertyName, JSValue value)
    {
        ((void)0);

        SymbolTableEntry entry = symbolTable().inlineGet(propertyName.impl());
        if (entry.isNull())
            return false;
        if (entry.isReadOnly())
            return true;
        registerAt(entry.getIndex()).set(globalData, this, value);
        return true;
    }

    inline bool JSVariableObject::symbolTablePutWithAttributes(JSGlobalData& globalData, const Identifier& propertyName, JSValue value, unsigned attributes)
    {
        ((void)0);

        SymbolTable::iterator iter = symbolTable().find(propertyName.impl());
        if (iter == symbolTable().end())
            return false;
        SymbolTableEntry& entry = iter->second;
        ((void)0);
        entry.setAttributes(attributes);
        registerAt(entry.getIndex()).set(globalData, this, value);
        return true;
    }

    inline PassOwnArrayPtr<WriteBarrier<Unknown> > JSVariableObject::copyRegisterArray(JSGlobalData& globalData, WriteBarrier<Unknown>* src, size_t count, size_t callframeStarts)
    {
        OwnArrayPtr<WriteBarrier<Unknown> > registerArray = adoptArrayPtr(new WriteBarrier<Unknown>[count]);
        for (size_t i = 0; i < callframeStarts; i++)
            registerArray[i].set(globalData, this, src[i].get());
        for (size_t i = callframeStarts + RegisterFile::CallFrameHeaderSize; i < count; i++)
            registerArray[i].set(globalData, this, src[i].get());

        return registerArray.release();
    }

    inline void JSVariableObject::setRegisters(WriteBarrier<Unknown>* registers, PassOwnArrayPtr<WriteBarrier<Unknown> > registerArray)
    {
        ((void)0);
        m_registerArray = registerArray;
        m_registers = registers;
    }

}
# 29 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSGlobalObject.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/API/JSWeakObjectMapRefInternal.h" 1
# 32 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/API/JSWeakObjectMapRefInternal.h"
namespace JSC {

class JSObject;

}

typedef void (*JSWeakMapDestroyedCallback)(struct OpaqueJSWeakObjectMap*, void*);

typedef JSC::WeakGCMap<void*, JSC::JSObject> WeakMapType;

struct OpaqueJSWeakObjectMap : public RefCounted<OpaqueJSWeakObjectMap> {
public:
    static PassRefPtr<OpaqueJSWeakObjectMap> create(void* data, JSWeakMapDestroyedCallback callback)
    {
        return adoptRef(new OpaqueJSWeakObjectMap(data, callback));
    }

    WeakMapType& map() { return m_map; }

    ~OpaqueJSWeakObjectMap()
    {
        m_callback(this, m_data);
    }

private:
    OpaqueJSWeakObjectMap(void* data, JSWeakMapDestroyedCallback callback)
        : m_data(data)
        , m_callback(callback)
    {
    }
    WeakMapType m_map;
    void* m_data;
    JSWeakMapDestroyedCallback m_callback;
};
# 30 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSGlobalObject.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/NumberPrototype.h" 1
# 24 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/NumberPrototype.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/NumberObject.h" 1
# 24 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/NumberObject.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSWrapperObject.h" 1
# 27 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSWrapperObject.h"
namespace JSC {



    class JSWrapperObject : public JSNonFinalObject {
    public:
        typedef JSNonFinalObject Base;

        JSValue internalValue() const;
        void setInternalValue(JSGlobalData&, JSValue);

        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue prototype)
        {
            return Structure::create(globalData, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), &s_info);
        }

    protected:
        explicit JSWrapperObject(JSGlobalData&, Structure*);
        static const unsigned StructureFlags = OverridesVisitChildren | JSNonFinalObject::StructureFlags;

        static void visitChildren(JSCell*, SlotVisitor&);

        virtual ~JSWrapperObject();

    private:
        WriteBarrier<Unknown> m_internalValue;
    };

    inline JSWrapperObject::JSWrapperObject(JSGlobalData& globalData, Structure* structure)
        : JSNonFinalObject(globalData, structure)
    {
    }

    inline JSValue JSWrapperObject::internalValue() const
    {
        return m_internalValue.get();
    }

    inline void JSWrapperObject::setInternalValue(JSGlobalData& globalData, JSValue value)
    {
        ((void)0);
        ((void)0);
        m_internalValue.set(globalData, this, value);
    }

}
# 25 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/NumberObject.h" 2

namespace JSC {

    class NumberObject : public JSWrapperObject {
    protected:
        NumberObject(JSGlobalData&, Structure*);
        void finishCreation(JSGlobalData&);

    public:
        typedef JSWrapperObject Base;

        static NumberObject* create(JSGlobalData& globalData, Structure* structure)
        {
            NumberObject* number = new (allocateCell<NumberObject>(globalData.heap)) NumberObject(globalData, structure);
            number->finishCreation(globalData);
            return number;
        }

        static const ClassInfo s_info;

        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue prototype)
        {
            return Structure::create(globalData, globalObject, prototype, TypeInfo(NumberObjectType, StructureFlags), &s_info);
        }
    };

    NumberObject* constructNumber(ExecState*, JSGlobalObject*, JSValue);

}
# 25 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/NumberPrototype.h" 2

namespace JSC {

    class NumberPrototype : public NumberObject {
    public:
        typedef NumberObject Base;

        static NumberPrototype* create(ExecState* exec, JSGlobalObject* globalObject, Structure* structure)
        {
            NumberPrototype* prototype = new (allocateCell<NumberPrototype>(*exec->heap())) NumberPrototype(exec, structure);
            prototype->finishCreation(exec, globalObject);
            return prototype;
        }

        static const ClassInfo s_info;

        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue prototype)
        {
            return Structure::create(globalData, globalObject, prototype, TypeInfo(NumberObjectType, StructureFlags), &s_info);
        }

    protected:
        void finishCreation(ExecState*, JSGlobalObject*);
        static const unsigned StructureFlags = OverridesGetOwnPropertySlot | NumberObject::StructureFlags;

    private:
        NumberPrototype(ExecState*, Structure*);
        static bool getOwnPropertySlot(JSCell*, ExecState*, const Identifier&, PropertySlot&);
        virtual bool getOwnPropertyDescriptor(ExecState*, const Identifier&, PropertyDescriptor&);
    };

}
# 31 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSGlobalObject.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/StringPrototype.h" 1
# 24 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/StringPrototype.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/StringObject.h" 1
# 27 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/StringObject.h"
namespace JSC {

    class StringObject : public JSWrapperObject {
    public:
        typedef JSWrapperObject Base;

        static StringObject* create(ExecState* exec, Structure* structure)
        {
            JSString* string = jsEmptyString(exec);
            StringObject* object = new (allocateCell<StringObject>(*exec->heap())) StringObject(exec->globalData(), structure);
            object->finishCreation(exec->globalData(), string);
            return object;
        }
        static StringObject* create(ExecState* exec, Structure* structure, JSString* string)
        {
            StringObject* object = new (allocateCell<StringObject>(*exec->heap())) StringObject(exec->globalData(), structure);
            object->finishCreation(exec->globalData(), string);
            return object;
        }
        static StringObject* create(ExecState*, JSGlobalObject*, JSString*);

        static bool getOwnPropertySlot(JSCell*, ExecState*, const Identifier& propertyName, PropertySlot&);
        static bool getOwnPropertySlotByIndex(JSCell*, ExecState*, unsigned propertyName, PropertySlot&);
        virtual bool getOwnPropertyDescriptor(ExecState*, const Identifier&, PropertyDescriptor&);

        static void put(JSCell*, ExecState*, const Identifier& propertyName, JSValue, PutPropertySlot&);

        static bool deleteProperty(JSCell*, ExecState*, const Identifier& propertyName);
        virtual void getOwnPropertyNames(ExecState*, PropertyNameArray&, EnumerationMode mode = ExcludeDontEnumProperties);

        static const ClassInfo s_info;

        JSString* internalValue() const { return asString(JSWrapperObject::internalValue());}

        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue prototype)
        {
            return Structure::create(globalData, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), &s_info);
        }

    protected:
        void finishCreation(JSGlobalData&, JSString*);
        static const unsigned StructureFlags = OverridesGetOwnPropertySlot | OverridesGetPropertyNames | JSWrapperObject::StructureFlags;
        StringObject(JSGlobalData&, Structure*);
    };

    StringObject* asStringObject(JSValue);

    inline StringObject* asStringObject(JSValue value)
    {
        ((void)0);
        return static_cast<StringObject*>(asObject(value));
    }

}
# 25 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/StringPrototype.h" 2

namespace JSC {

    class ObjectPrototype;

    class StringPrototype : public StringObject {
    private:
        StringPrototype(ExecState*, Structure*);

    public:
        typedef StringObject Base;

        static StringPrototype* create(ExecState* exec, JSGlobalObject* globalObject, Structure* structure)
        {
            JSString* empty = jsEmptyString(exec);
            StringPrototype* prototype = new (allocateCell<StringPrototype>(*exec->heap())) StringPrototype(exec, structure);
            prototype->finishCreation(exec, globalObject, empty);
            return prototype;
        }

        static bool getOwnPropertySlot(JSCell*, ExecState*, const Identifier& propertyName, PropertySlot&);
        virtual bool getOwnPropertyDescriptor(ExecState*, const Identifier&, PropertyDescriptor&);

        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue prototype)
        {
            return Structure::create(globalData, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), &s_info);
        }

        static const ClassInfo s_info;

    protected:
        void finishCreation(ExecState*, JSGlobalObject*, JSString*);
        static const unsigned StructureFlags = OverridesGetOwnPropertySlot | StringObject::StructureFlags;

    };

}
# 32 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSGlobalObject.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/StructureChain.h" 1
# 38 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/StructureChain.h"
namespace JSC {

    class Structure;

    class StructureChain : public JSCell {
        friend class JIT;

    public:
        typedef JSCell Base;

        static StructureChain* create(JSGlobalData& globalData, Structure* head)
        {
            StructureChain* chain = new (allocateCell<StructureChain>(globalData.heap)) StructureChain(globalData, globalData.structureChainStructure.get());
            chain->finishCreation(globalData, head);
            return chain;
        }
        WriteBarrier<Structure>* head() { return m_vector.get(); }
        static void visitChildren(JSCell*, SlotVisitor&);

        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue prototype) { return Structure::create(globalData, globalObject, prototype, TypeInfo(CompoundType, OverridesVisitChildren), &s_info); }

        static ClassInfo s_info;

    protected:
        void finishCreation(JSGlobalData& globalData, Structure* head)
        {
            Base::finishCreation(globalData);
            size_t size = 0;
            for (Structure* current = head; current; current = current->storedPrototype().isNull() ? 0 : asObject(current->storedPrototype())->structure())
                ++size;

            m_vector = adoptArrayPtr(new WriteBarrier<Structure>[size + 1]);

            size_t i = 0;
            for (Structure* current = head; current; current = current->storedPrototype().isNull() ? 0 : asObject(current->storedPrototype())->structure())
                m_vector[i++].set(globalData, this, current);
        }

    private:
        StructureChain(JSGlobalData&, Structure*);
        ~StructureChain();
        OwnArrayPtr<WriteBarrier<Structure> > m_vector;
    };

}
# 33 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSGlobalObject.h" 2


# 1 "./wtf/RandomNumber.h" 1
# 29 "./wtf/RandomNumber.h"
namespace WTF {



    double randomNumber();

}

using WTF::randomNumber;
# 36 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSGlobalObject.h" 2

namespace JSC {

    class ArrayPrototype;
    class BooleanPrototype;
    class DatePrototype;
    class Debugger;
    class ErrorConstructor;
    class FunctionPrototype;
    class GetterSetter;
    class GlobalCodeBlock;
    class NativeErrorConstructor;
    class ProgramCodeBlock;
    class RegExpConstructor;
    class RegExpPrototype;
    class RegisterFile;

    struct ActivationStackNode;
    struct HashTable;

    typedef Vector<ExecState*, 16> ExecStateStack;

    class JSGlobalObject : public JSVariableObject {
    private:
        typedef HashSet<RefPtr<OpaqueJSWeakObjectMap> > WeakMapSet;

        struct JSGlobalObjectRareData {
            JSGlobalObjectRareData()
                : profileGroup(0)
            {
            }

            WeakMapSet weakMaps;
            unsigned profileGroup;
        };

    protected:

        RefPtr<JSGlobalData> m_globalData;

        size_t m_registerArraySize;
        Register m_globalCallFrame[RegisterFile::CallFrameHeaderSize];

        WriteBarrier<ScopeChainNode> m_globalScopeChain;
        WriteBarrier<JSObject> m_methodCallDummy;

        WriteBarrier<RegExpConstructor> m_regExpConstructor;
        WriteBarrier<ErrorConstructor> m_errorConstructor;
        WriteBarrier<NativeErrorConstructor> m_evalErrorConstructor;
        WriteBarrier<NativeErrorConstructor> m_rangeErrorConstructor;
        WriteBarrier<NativeErrorConstructor> m_referenceErrorConstructor;
        WriteBarrier<NativeErrorConstructor> m_syntaxErrorConstructor;
        WriteBarrier<NativeErrorConstructor> m_typeErrorConstructor;
        WriteBarrier<NativeErrorConstructor> m_URIErrorConstructor;

        WriteBarrier<JSFunction> m_evalFunction;
        WriteBarrier<JSFunction> m_callFunction;
        WriteBarrier<JSFunction> m_applyFunction;
        WriteBarrier<GetterSetter> m_throwTypeErrorGetterSetter;

        WriteBarrier<ObjectPrototype> m_objectPrototype;
        WriteBarrier<FunctionPrototype> m_functionPrototype;
        WriteBarrier<ArrayPrototype> m_arrayPrototype;
        WriteBarrier<BooleanPrototype> m_booleanPrototype;
        WriteBarrier<StringPrototype> m_stringPrototype;
        WriteBarrier<NumberPrototype> m_numberPrototype;
        WriteBarrier<DatePrototype> m_datePrototype;
        WriteBarrier<RegExpPrototype> m_regExpPrototype;

        WriteBarrier<Structure> m_argumentsStructure;
        WriteBarrier<Structure> m_arrayStructure;
        WriteBarrier<Structure> m_booleanObjectStructure;
        WriteBarrier<Structure> m_callbackConstructorStructure;
        WriteBarrier<Structure> m_callbackFunctionStructure;
        WriteBarrier<Structure> m_callbackObjectStructure;
        WriteBarrier<Structure> m_dateStructure;
        WriteBarrier<Structure> m_emptyObjectStructure;
        WriteBarrier<Structure> m_nullPrototypeObjectStructure;
        WriteBarrier<Structure> m_errorStructure;
        WriteBarrier<Structure> m_functionStructure;
        WriteBarrier<Structure> m_boundFunctionStructure;
        WriteBarrier<Structure> m_namedFunctionStructure;
        size_t m_functionNameOffset;
        WriteBarrier<Structure> m_numberObjectStructure;
        WriteBarrier<Structure> m_regExpMatchesArrayStructure;
        WriteBarrier<Structure> m_regExpStructure;
        WriteBarrier<Structure> m_stringObjectStructure;
        WriteBarrier<Structure> m_internalFunctionStructure;
        WriteBarrier<Structure> m_strictModeTypeErrorFunctionStructure;

        Debugger* m_debugger;

        OwnPtr<JSGlobalObjectRareData> m_rareData;

        WeakRandom m_weakRandom;

        SymbolTable m_symbolTable;

        bool m_evalEnabled;

        void createRareDataIfNeeded()
        {
            if (m_rareData)
                return;
            m_rareData = adoptPtr(new JSGlobalObjectRareData);
            Heap::heap(this)->addFinalizer(this, clearRareData);
        }

    public:
        typedef JSVariableObject Base;

        static JSGlobalObject* create(JSGlobalData& globalData, Structure* structure)
        {
            JSGlobalObject* globalObject = new (allocateCell<JSGlobalObject>(globalData.heap)) JSGlobalObject(globalData, structure);
            globalObject->finishCreation(globalData);
            return globalObject;
        }

        static const ClassInfo s_info;

    protected:
        explicit JSGlobalObject(JSGlobalData& globalData, Structure* structure)
            : JSVariableObject(globalData, structure, &m_symbolTable, 0)
            , m_registerArraySize(0)
            , m_globalScopeChain()
            , m_weakRandom(static_cast<unsigned>(randomNumber() * (std::numeric_limits<unsigned>::max() + 1.0)))
            , m_evalEnabled(true)
        {
        }

        void finishCreation(JSGlobalData& globalData)
        {
            Base::finishCreation(globalData);
            structure()->setGlobalObject(globalData, this);
            init(this);
        }

        void finishCreation(JSGlobalData& globalData, JSGlobalThis* thisValue)
        {
            Base::finishCreation(globalData);
            structure()->setGlobalObject(globalData, this);
            init(thisValue);
        }

    public:
        virtual ~JSGlobalObject();

        static void visitChildren(JSCell*, SlotVisitor&);

        static bool getOwnPropertySlot(JSCell*, ExecState*, const Identifier&, PropertySlot&);
        virtual bool getOwnPropertyDescriptor(ExecState*, const Identifier&, PropertyDescriptor&);
        virtual bool hasOwnPropertyForWrite(ExecState*, const Identifier&);
        static void put(JSCell*, ExecState*, const Identifier&, JSValue, PutPropertySlot&);

        virtual void putWithAttributes(ExecState*, const Identifier& propertyName, JSValue value, unsigned attributes);

        virtual void defineGetter(ExecState*, const Identifier& propertyName, JSObject* getterFunc, unsigned attributes);
        virtual void defineSetter(ExecState*, const Identifier& propertyName, JSObject* setterFunc, unsigned attributes);



        bool symbolTableHasProperty(const Identifier& propertyName);




        RegExpConstructor* regExpConstructor() const { return m_regExpConstructor.get(); }

        ErrorConstructor* errorConstructor() const { return m_errorConstructor.get(); }
        NativeErrorConstructor* evalErrorConstructor() const { return m_evalErrorConstructor.get(); }
        NativeErrorConstructor* rangeErrorConstructor() const { return m_rangeErrorConstructor.get(); }
        NativeErrorConstructor* referenceErrorConstructor() const { return m_referenceErrorConstructor.get(); }
        NativeErrorConstructor* syntaxErrorConstructor() const { return m_syntaxErrorConstructor.get(); }
        NativeErrorConstructor* typeErrorConstructor() const { return m_typeErrorConstructor.get(); }
        NativeErrorConstructor* URIErrorConstructor() const { return m_URIErrorConstructor.get(); }

        JSFunction* evalFunction() const { return m_evalFunction.get(); }
        JSFunction* callFunction() const { return m_callFunction.get(); }
        JSFunction* applyFunction() const { return m_applyFunction.get(); }
        GetterSetter* throwTypeErrorGetterSetter(ExecState* exec)
        {
            if (!m_throwTypeErrorGetterSetter)
                createThrowTypeError(exec);
            return m_throwTypeErrorGetterSetter.get();
        }

        ObjectPrototype* objectPrototype() const { return m_objectPrototype.get(); }
        FunctionPrototype* functionPrototype() const { return m_functionPrototype.get(); }
        ArrayPrototype* arrayPrototype() const { return m_arrayPrototype.get(); }
        BooleanPrototype* booleanPrototype() const { return m_booleanPrototype.get(); }
        StringPrototype* stringPrototype() const { return m_stringPrototype.get(); }
        NumberPrototype* numberPrototype() const { return m_numberPrototype.get(); }
        DatePrototype* datePrototype() const { return m_datePrototype.get(); }
        RegExpPrototype* regExpPrototype() const { return m_regExpPrototype.get(); }

        JSObject* methodCallDummy() const { return m_methodCallDummy.get(); }

        Structure* argumentsStructure() const { return m_argumentsStructure.get(); }
        Structure* arrayStructure() const { return m_arrayStructure.get(); }
        Structure* booleanObjectStructure() const { return m_booleanObjectStructure.get(); }
        Structure* callbackConstructorStructure() const { return m_callbackConstructorStructure.get(); }
        Structure* callbackFunctionStructure() const { return m_callbackFunctionStructure.get(); }
        Structure* callbackObjectStructure() const { return m_callbackObjectStructure.get(); }
        Structure* dateStructure() const { return m_dateStructure.get(); }
        Structure* emptyObjectStructure() const { return m_emptyObjectStructure.get(); }
        Structure* nullPrototypeObjectStructure() const { return m_nullPrototypeObjectStructure.get(); }
        Structure* errorStructure() const { return m_errorStructure.get(); }
        Structure* functionStructure() const { return m_functionStructure.get(); }
        Structure* boundFunctionStructure() const { return m_boundFunctionStructure.get(); }
        Structure* namedFunctionStructure() const { return m_namedFunctionStructure.get(); }
        size_t functionNameOffset() const { return m_functionNameOffset; }
        Structure* numberObjectStructure() const { return m_numberObjectStructure.get(); }
        Structure* internalFunctionStructure() const { return m_internalFunctionStructure.get(); }
        Structure* strictModeTypeErrorFunctionStructure() const { return m_strictModeTypeErrorFunctionStructure.get(); }
        Structure* regExpMatchesArrayStructure() const { return m_regExpMatchesArrayStructure.get(); }
        Structure* regExpStructure() const { return m_regExpStructure.get(); }
        Structure* stringObjectStructure() const { return m_stringObjectStructure.get(); }

        void setProfileGroup(unsigned value) { createRareDataIfNeeded(); m_rareData->profileGroup = value; }
        unsigned profileGroup() const
        {
            if (!m_rareData)
                return 0;
            return m_rareData->profileGroup;
        }

        Debugger* debugger() const { return m_debugger; }
        void setDebugger(Debugger* debugger) { m_debugger = debugger; }

        virtual bool supportsProfiling() const { return false; }
        virtual bool supportsRichSourceInfo() const { return true; }

        ScopeChainNode* globalScopeChain() { return m_globalScopeChain.get(); }

        virtual bool isGlobalObject() const { return true; }

        ExecState* globalExec();

        virtual bool shouldInterruptScript() const { return true; }

        virtual bool allowsAccessFrom(const JSGlobalObject*) const { return true; }

        virtual bool isDynamicScope(bool& requiresDynamicChecks) const;

        void setEvalEnabled(bool enabled) { m_evalEnabled = enabled; }
        bool evalEnabled() { return m_evalEnabled; }

        void resizeRegisters(size_t newSize);

        void resetPrototype(JSGlobalData&, JSValue prototype);

        JSGlobalData& globalData() const { return *m_globalData.get(); }

        static Structure* createStructure(JSGlobalData& globalData, JSValue prototype)
        {
            return Structure::create(globalData, 0, prototype, TypeInfo(ObjectType, StructureFlags), &s_info);
        }

        void registerWeakMap(OpaqueJSWeakObjectMap* map)
        {
            createRareDataIfNeeded();
            m_rareData->weakMaps.add(map);
        }

        void unregisterWeakMap(OpaqueJSWeakObjectMap* map)
        {
            if (m_rareData)
                m_rareData->weakMaps.remove(map);
        }

        double weakRandomNumber() { return m_weakRandom.get(); }
    protected:

        static const unsigned StructureFlags = OverridesGetOwnPropertySlot | OverridesVisitChildren | OverridesGetPropertyNames | JSVariableObject::StructureFlags;

        struct GlobalPropertyInfo {
            GlobalPropertyInfo(const Identifier& i, JSValue v, unsigned a)
                : identifier(i)
                , value(v)
                , attributes(a)
            {
            }

            const Identifier identifier;
            JSValue value;
            unsigned attributes;
        };
        void addStaticGlobals(GlobalPropertyInfo*, int count);

    private:

        void init(JSObject* thisValue);
        void reset(JSValue prototype);

        void createThrowTypeError(ExecState*);

        void setRegisters(WriteBarrier<Unknown>* registers, PassOwnArrayPtr<WriteBarrier<Unknown> > registerArray, size_t count);
        static void clearRareData(JSCell*);
    };

    JSGlobalObject* asGlobalObject(JSValue);

    inline JSGlobalObject* asGlobalObject(JSValue value)
    {
        ((void)0);
        return static_cast<JSGlobalObject*>(asObject(value));
    }

    inline void JSGlobalObject::setRegisters(WriteBarrier<Unknown>* registers, PassOwnArrayPtr<WriteBarrier<Unknown> > registerArray, size_t count)
    {
        JSVariableObject::setRegisters(registers, registerArray);
        m_registerArraySize = count;
    }

    inline bool JSGlobalObject::hasOwnPropertyForWrite(ExecState* exec, const Identifier& propertyName)
    {
        PropertySlot slot;
        if (JSVariableObject::getOwnPropertySlot(this, exec, propertyName, slot))
            return true;
        bool slotIsWriteable;
        return symbolTableGet(propertyName, slot, slotIsWriteable);
    }

    inline bool JSGlobalObject::symbolTableHasProperty(const Identifier& propertyName)
    {
        SymbolTableEntry entry = symbolTable().inlineGet(propertyName.impl());
        return !entry.isNull();
    }

    inline JSValue Structure::prototypeForLookup(ExecState* exec) const
    {
        if (isObject())
            return m_prototype.get();

        ((void)0);
        return exec->lexicalGlobalObject()->stringPrototype();
    }

    inline StructureChain* Structure::prototypeChain(ExecState* exec) const
    {

        if (!isValid(exec, m_cachedPrototypeChain.get())) {
            JSValue prototype = prototypeForLookup(exec);
            m_cachedPrototypeChain.set(exec->globalData(), this, StructureChain::create(exec->globalData(), prototype.isNull() ? 0 : asObject(prototype)->structure()));
        }
        return m_cachedPrototypeChain.get();
    }

    inline bool Structure::isValid(ExecState* exec, StructureChain* cachedPrototypeChain) const
    {
        if (!cachedPrototypeChain)
            return false;

        JSValue prototype = prototypeForLookup(exec);
        WriteBarrier<Structure>* cachedStructure = cachedPrototypeChain->head();
        while(*cachedStructure && !prototype.isNull()) {
            if (asObject(prototype)->structure() != cachedStructure->get())
                return false;
            ++cachedStructure;
            prototype = asObject(prototype)->prototype();
        }
        return prototype.isNull() && !*cachedStructure;
    }

    inline JSGlobalObject* ExecState::dynamicGlobalObject()
    {
        if (this == lexicalGlobalObject()->globalExec())
            return lexicalGlobalObject();



        ((void)0);
        return globalData().dynamicGlobalObject;
    }

    inline JSObject* constructEmptyObject(ExecState* exec, JSGlobalObject* globalObject)
    {
        return constructEmptyObject(exec, globalObject->emptyObjectStructure());
    }

    inline JSObject* constructEmptyObject(ExecState* exec)
    {
        return constructEmptyObject(exec, exec->lexicalGlobalObject());
    }

    inline JSArray* constructEmptyArray(ExecState* exec, JSGlobalObject* globalObject)
    {
        return JSArray::create(exec->globalData(), globalObject->arrayStructure());
    }

    inline JSArray* constructEmptyArray(ExecState* exec)
    {
        return constructEmptyArray(exec, exec->lexicalGlobalObject());
    }

    inline JSArray* constructEmptyArray(ExecState* exec, JSGlobalObject* globalObject, unsigned initialLength)
    {
        return JSArray::create(exec->globalData(), globalObject->arrayStructure(), initialLength, CreateInitialized);
    }

    inline JSArray* constructEmptyArray(ExecState* exec, unsigned initialLength)
    {
        return constructEmptyArray(exec, exec->lexicalGlobalObject(), initialLength);
    }

    inline JSArray* constructArray(ExecState* exec, JSGlobalObject* globalObject, JSValue singleItemValue)
    {
        MarkedArgumentBuffer values;
        values.append(singleItemValue);
        return JSArray::create(exec->globalData(), globalObject->arrayStructure(), values);
    }

    inline JSArray* constructArray(ExecState* exec, JSValue singleItemValue)
    {
        return constructArray(exec, exec->lexicalGlobalObject(), singleItemValue);
    }

    inline JSArray* constructArray(ExecState* exec, JSGlobalObject* globalObject, const ArgList& values)
    {
        return JSArray::create(exec->globalData(), globalObject->arrayStructure(), values);
    }

    inline JSArray* constructArray(ExecState* exec, const ArgList& values)
    {
        return constructArray(exec, exec->lexicalGlobalObject(), values);
    }

    class DynamicGlobalObjectScope {
        private: DynamicGlobalObjectScope(const DynamicGlobalObjectScope&); DynamicGlobalObjectScope& operator=(const DynamicGlobalObjectScope&);
    public:
        DynamicGlobalObjectScope(JSGlobalData&, JSGlobalObject*);

        ~DynamicGlobalObjectScope()
        {
            m_dynamicGlobalObjectSlot = m_savedDynamicGlobalObject;
        }

    private:
        JSGlobalObject*& m_dynamicGlobalObjectSlot;
        JSGlobalObject* m_savedDynamicGlobalObject;
    };

}
# 34 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/EvalCodeCache.h" 2

# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/parser/Parser.h" 1
# 26 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/parser/Parser.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/debugger/Debugger.h" 1
# 27 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/debugger/Debugger.h"
namespace JSC {

    class DebuggerCallFrame;
    class ExecState;
    class JSGlobalData;
    class JSGlobalObject;
    class JSValue;
    class SourceProvider;
    class UString;

    class Debugger {
    public:
        virtual ~Debugger();

        void attach(JSGlobalObject*);
        virtual void detach(JSGlobalObject*);

        virtual void sourceParsed(ExecState*, SourceProvider*, int errorLineNumber, const UString& errorMessage) = 0;
        virtual void exception(const DebuggerCallFrame&, intptr_t sourceID, int lineNumber, bool hasHandler) = 0;
        virtual void atStatement(const DebuggerCallFrame&, intptr_t sourceID, int lineNumber) = 0;
        virtual void callEvent(const DebuggerCallFrame&, intptr_t sourceID, int lineNumber) = 0;
        virtual void returnEvent(const DebuggerCallFrame&, intptr_t sourceID, int lineNumber) = 0;

        virtual void willExecuteProgram(const DebuggerCallFrame&, intptr_t sourceID, int lineNumber) = 0;
        virtual void didExecuteProgram(const DebuggerCallFrame&, intptr_t sourceID, int lineNumber) = 0;
        virtual void didReachBreakpoint(const DebuggerCallFrame&, intptr_t sourceID, int lineNumber) = 0;

        void recompileAllJSFunctions(JSGlobalData*);

    private:
        HashSet<JSGlobalObject*> m_globalObjects;
    };


    JSValue evaluateInGlobalCallFrame(const UString&, JSValue& exception, JSGlobalObject*);

}
# 27 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/parser/Parser.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/ExceptionHelpers.h" 1
# 34 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/ExceptionHelpers.h"
namespace JSC {

JSObject* createInterruptedExecutionException(JSGlobalData*);
bool isInterruptedExecutionException(JSObject*);
bool isInterruptedExecutionException(JSValue);

JSObject* createTerminatedExecutionException(JSGlobalData*);
bool isTerminatedExecutionException(JSObject*);
bool isTerminatedExecutionException(JSValue);

JSObject* createStackOverflowError(ExecState*);
JSObject* createStackOverflowError(JSGlobalObject*);
JSObject* createOutOfMemoryError(JSGlobalObject*);
JSObject* createUndefinedVariableError(ExecState*, const Identifier&);
JSObject* createNotAnObjectError(ExecState*, JSValue);
JSObject* createInvalidParamError(ExecState*, const char* op, JSValue);
JSObject* createNotAConstructorError(ExecState*, JSValue);
JSObject* createNotAFunctionError(ExecState*, JSValue);
JSObject* createErrorForInvalidGlobalAssignment(ExecState*, const UString&);

JSObject* throwOutOfMemoryError(ExecState*);
JSObject* throwStackOverflowError(ExecState*);


class InterruptedExecutionError : public JSNonFinalObject {
private:
    InterruptedExecutionError(JSGlobalData& globalData)
        : JSNonFinalObject(globalData, globalData.interruptedExecutionErrorStructure.get())
    {
    }

    virtual JSValue defaultValue(ExecState*, PreferredPrimitiveType) const;

public:
    typedef JSNonFinalObject Base;

    static InterruptedExecutionError* create(JSGlobalData& globalData)
    {
        InterruptedExecutionError* error = new (allocateCell<InterruptedExecutionError>(globalData.heap)) InterruptedExecutionError(globalData);
        error->finishCreation(globalData);
        return error;
    }

    static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue prototype)
    {
        return Structure::create(globalData, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), &s_info);
    }

    static const ClassInfo s_info;
};

class TerminatedExecutionError : public JSNonFinalObject {
private:
    TerminatedExecutionError(JSGlobalData& globalData)
        : JSNonFinalObject(globalData, globalData.terminatedExecutionErrorStructure.get())
    {
    }

    virtual JSValue defaultValue(ExecState*, PreferredPrimitiveType) const;

public:
    typedef JSNonFinalObject Base;

    static TerminatedExecutionError* create(JSGlobalData& globalData)
    {
        TerminatedExecutionError* error = new (allocateCell<TerminatedExecutionError>(globalData.heap)) TerminatedExecutionError(globalData);
        error->finishCreation(globalData);
        return error;
    }

    static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue prototype)
    {
        return Structure::create(globalData, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), &s_info);
    }

    static const ClassInfo s_info;
};

}
# 28 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/parser/Parser.h" 2


# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/parser/Lexer.h" 1
# 26 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/parser/Lexer.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/parser/JSParser.h" 1
# 31 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/parser/JSParser.h"
namespace JSC {

class ExecState;
class FunctionParameters;
class Identifier;
class JSGlobalData;
class SourceCode;

enum {
    UnaryOpTokenFlag = 64,
    KeywordTokenFlag = 128,
    BinaryOpTokenPrecedenceShift = 8,
    BinaryOpTokenAllowsInPrecedenceAdditionalShift = 4,
    BinaryOpTokenPrecedenceMask = 15 << BinaryOpTokenPrecedenceShift,
};




enum JSTokenType {
    NULLTOKEN = KeywordTokenFlag,
    TRUETOKEN,
    FALSETOKEN,
    BREAK,
    CASE,
    DEFAULT,
    FOR,
    NEW,
    VAR,
    CONSTTOKEN,
    CONTINUE,
    FUNCTION,
    RETURN,
    IF,
    THISTOKEN,
    DO,
    WHILE,
    SWITCH,
    WITH,
    RESERVED,
    RESERVED_IF_STRICT,
    THROW,
    TRY,
    CATCH,
    FINALLY,
    DEBUGGER,
    ELSE,
    OPENBRACE = 0,
    CLOSEBRACE,
    OPENPAREN,
    CLOSEPAREN,
    OPENBRACKET,
    CLOSEBRACKET,
    COMMA,
    QUESTION,
    NUMBER,
    IDENT,
    STRING,
    SEMICOLON,
    COLON,
    DOT,
    ERRORTOK,
    EOFTOK,
    EQUAL,
    PLUSEQUAL,
    MINUSEQUAL,
    MULTEQUAL,
    DIVEQUAL,
    LSHIFTEQUAL,
    RSHIFTEQUAL,
    URSHIFTEQUAL,
    ANDEQUAL,
    MODEQUAL,
    XOREQUAL,
    OREQUAL,
    LastUntaggedToken,


    PLUSPLUS = 0 | UnaryOpTokenFlag,
    MINUSMINUS = 1 | UnaryOpTokenFlag,
    EXCLAMATION = 2 | UnaryOpTokenFlag,
    TILDE = 3 | UnaryOpTokenFlag,
    AUTOPLUSPLUS = 4 | UnaryOpTokenFlag,
    AUTOMINUSMINUS = 5 | UnaryOpTokenFlag,
    TYPEOF = 6 | UnaryOpTokenFlag | KeywordTokenFlag,
    VOIDTOKEN = 7 | UnaryOpTokenFlag | KeywordTokenFlag,
    DELETETOKEN = 8 | UnaryOpTokenFlag | KeywordTokenFlag,
    OR = 0 | (((1) << BinaryOpTokenPrecedenceShift) | ((1) << (BinaryOpTokenPrecedenceShift + BinaryOpTokenAllowsInPrecedenceAdditionalShift))),
    AND = 1 | (((2) << BinaryOpTokenPrecedenceShift) | ((2) << (BinaryOpTokenPrecedenceShift + BinaryOpTokenAllowsInPrecedenceAdditionalShift))),
    BITOR = 2 | (((3) << BinaryOpTokenPrecedenceShift) | ((3) << (BinaryOpTokenPrecedenceShift + BinaryOpTokenAllowsInPrecedenceAdditionalShift))),
    BITXOR = 3 | (((4) << BinaryOpTokenPrecedenceShift) | ((4) << (BinaryOpTokenPrecedenceShift + BinaryOpTokenAllowsInPrecedenceAdditionalShift))),
    BITAND = 4 | (((5) << BinaryOpTokenPrecedenceShift) | ((5) << (BinaryOpTokenPrecedenceShift + BinaryOpTokenAllowsInPrecedenceAdditionalShift))),
    EQEQ = 5 | (((6) << BinaryOpTokenPrecedenceShift) | ((6) << (BinaryOpTokenPrecedenceShift + BinaryOpTokenAllowsInPrecedenceAdditionalShift))),
    NE = 6 | (((6) << BinaryOpTokenPrecedenceShift) | ((6) << (BinaryOpTokenPrecedenceShift + BinaryOpTokenAllowsInPrecedenceAdditionalShift))),
    STREQ = 7 | (((6) << BinaryOpTokenPrecedenceShift) | ((6) << (BinaryOpTokenPrecedenceShift + BinaryOpTokenAllowsInPrecedenceAdditionalShift))),
    STRNEQ = 8 | (((6) << BinaryOpTokenPrecedenceShift) | ((6) << (BinaryOpTokenPrecedenceShift + BinaryOpTokenAllowsInPrecedenceAdditionalShift))),
    LT = 9 | (((7) << BinaryOpTokenPrecedenceShift) | ((7) << (BinaryOpTokenPrecedenceShift + BinaryOpTokenAllowsInPrecedenceAdditionalShift))),
    GT = 10 | (((7) << BinaryOpTokenPrecedenceShift) | ((7) << (BinaryOpTokenPrecedenceShift + BinaryOpTokenAllowsInPrecedenceAdditionalShift))),
    LE = 11 | (((7) << BinaryOpTokenPrecedenceShift) | ((7) << (BinaryOpTokenPrecedenceShift + BinaryOpTokenAllowsInPrecedenceAdditionalShift))),
    GE = 12 | (((7) << BinaryOpTokenPrecedenceShift) | ((7) << (BinaryOpTokenPrecedenceShift + BinaryOpTokenAllowsInPrecedenceAdditionalShift))),
    INSTANCEOF = 13 | (((7) << BinaryOpTokenPrecedenceShift) | ((7) << (BinaryOpTokenPrecedenceShift + BinaryOpTokenAllowsInPrecedenceAdditionalShift))) | KeywordTokenFlag,
    INTOKEN = 14 | ((7) << (BinaryOpTokenPrecedenceShift + BinaryOpTokenAllowsInPrecedenceAdditionalShift)) | KeywordTokenFlag,
    LSHIFT = 15 | (((8) << BinaryOpTokenPrecedenceShift) | ((8) << (BinaryOpTokenPrecedenceShift + BinaryOpTokenAllowsInPrecedenceAdditionalShift))),
    RSHIFT = 16 | (((8) << BinaryOpTokenPrecedenceShift) | ((8) << (BinaryOpTokenPrecedenceShift + BinaryOpTokenAllowsInPrecedenceAdditionalShift))),
    URSHIFT = 17 | (((8) << BinaryOpTokenPrecedenceShift) | ((8) << (BinaryOpTokenPrecedenceShift + BinaryOpTokenAllowsInPrecedenceAdditionalShift))),
    PLUS = 18 | (((9) << BinaryOpTokenPrecedenceShift) | ((9) << (BinaryOpTokenPrecedenceShift + BinaryOpTokenAllowsInPrecedenceAdditionalShift))) | UnaryOpTokenFlag,
    MINUS = 19 | (((9) << BinaryOpTokenPrecedenceShift) | ((9) << (BinaryOpTokenPrecedenceShift + BinaryOpTokenAllowsInPrecedenceAdditionalShift))) | UnaryOpTokenFlag,
    TIMES = 20 | (((10) << BinaryOpTokenPrecedenceShift) | ((10) << (BinaryOpTokenPrecedenceShift + BinaryOpTokenAllowsInPrecedenceAdditionalShift))),
    DIVIDE = 21 | (((10) << BinaryOpTokenPrecedenceShift) | ((10) << (BinaryOpTokenPrecedenceShift + BinaryOpTokenAllowsInPrecedenceAdditionalShift))),
    MOD = 22 | (((10) << BinaryOpTokenPrecedenceShift) | ((10) << (BinaryOpTokenPrecedenceShift + BinaryOpTokenAllowsInPrecedenceAdditionalShift)))
};

union JSTokenData {
    int intValue;
    double doubleValue;
    const Identifier* ident;
};

struct JSTokenInfo {
    JSTokenInfo() : line(0) {}
    int line;
    int startOffset;
    int endOffset;
};

struct JSToken {
    JSTokenType m_type;
    JSTokenData m_data;
    JSTokenInfo m_info;
};

enum JSParserStrictness { JSParseNormal, JSParseStrict };
enum JSParserMode { JSParseProgramCode, JSParseFunctionCode };

UString jsParse(JSGlobalData*, FunctionParameters*, JSParserStrictness, JSParserMode, const SourceCode*);
}
# 27 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/parser/Lexer.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/Lookup.h" 1
# 39 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/Lookup.h"
namespace JSC {

    struct HashTableValue {
        const char* key;
        unsigned char attributes;
        intptr_t value1;
        intptr_t value2;

        ThunkGenerator generator;

        DFG::Intrinsic intrinsic;


    };



    typedef PropertySlot::GetValueFunc GetFunction;
    typedef void (*PutFunction)(ExecState*, JSObject* baseObject, JSValue value);

    class HashEntry {
        public: void* operator new(size_t, void* p) { return p; } void* operator new[](size_t, void* p) { return p; } void* operator new(size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNew); return p; } void operator delete(void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNew); ::WTF::fastFree(p); } void* operator new[](size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNewArray); return p; } void operator delete[](void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNewArray); ::WTF::fastFree(p); } private: typedef int ThisIsHereToForceASemicolonAfterThisMacro;
    public:
        void initialize(StringImpl* key, unsigned char attributes, intptr_t v1, intptr_t v2

                        , ThunkGenerator generator = 0

                        , DFG::Intrinsic intrinsic = DFG::NoIntrinsic


                        )
        {
            m_key = key;
            m_attributes = attributes;
            m_u.store.value1 = v1;
            m_u.store.value2 = v2;

            m_u.function.generator = generator;

            m_u.function.intrinsic = intrinsic;


            m_next = 0;
        }

        void setKey(StringImpl* key) { m_key = key; }
        StringImpl* key() const { return m_key; }

        unsigned char attributes() const { return m_attributes; }


        ThunkGenerator generator() const { ((void)0); return m_u.function.generator; }
        DFG::Intrinsic intrinsic() const
        {
            ((void)0);

            return m_u.function.intrinsic;



        }

        NativeFunction function() const { ((void)0); return m_u.function.functionValue; }
        unsigned char functionLength() const { ((void)0); return static_cast<unsigned char>(m_u.function.length); }

        GetFunction propertyGetter() const { ((void)0); return m_u.property.get; }
        PutFunction propertyPutter() const { ((void)0); return m_u.property.put; }

        intptr_t lexerValue() const { ((void)0); return m_u.lexer.value; }

        void setNext(HashEntry *next) { m_next = next; }
        HashEntry* next() const { return m_next; }

    private:
        StringImpl* m_key;
        unsigned char m_attributes;

        union {
            struct {
                intptr_t value1;
                intptr_t value2;
            } store;
            struct {
                NativeFunction functionValue;
                intptr_t length;

                ThunkGenerator generator;

                DFG::Intrinsic intrinsic;


            } function;
            struct {
                GetFunction get;
                PutFunction put;
            } property;
            struct {
                intptr_t value;
                intptr_t unused;
            } lexer;
        } m_u;

        HashEntry* m_next;
    };

    struct HashTable {

        int compactSize;
        int compactHashSizeMask;

        const HashTableValue* values;
        mutable const HashEntry* table;

        inline __attribute__((__always_inline__)) void initializeIfNeeded(JSGlobalData* globalData) const
        {
            if (!table)
                createTable(globalData);
        }

        inline __attribute__((__always_inline__)) void initializeIfNeeded(ExecState* exec) const
        {
            if (!table)
                createTable(&exec->globalData());
        }

        void deleteTable() const;


        inline __attribute__((__always_inline__)) const HashEntry* entry(JSGlobalData* globalData, const Identifier& identifier) const
        {
            initializeIfNeeded(globalData);
            return entry(identifier);
        }

        inline __attribute__((__always_inline__)) const HashEntry* entry(ExecState* exec, const Identifier& identifier) const
        {
            initializeIfNeeded(exec);
            return entry(identifier);
        }

        class ConstIterator {
        public:
            ConstIterator(const HashTable* table, int position)
                : m_table(table)
                , m_position(position)
            {
                skipInvalidKeys();
            }

            const HashEntry* operator->()
            {
                return &m_table->table[m_position];
            }

            const HashEntry* operator*()
            {
                return &m_table->table[m_position];
            }

            bool operator!=(const ConstIterator& other)
            {
                ((void)0);
                return m_position != other.m_position;
            }

            ConstIterator& operator++()
            {
                ((void)0);
                ++m_position;
                skipInvalidKeys();
                return *this;
            }

        private:
            void skipInvalidKeys()
            {
                ((void)0);
                while (m_position < m_table->compactSize && !m_table->table[m_position].key())
                    ++m_position;
                ((void)0);
            }

            const HashTable* m_table;
            int m_position;
        };

        ConstIterator begin(JSGlobalData& globalData) const
        {
            initializeIfNeeded(&globalData);
            return ConstIterator(this, 0);
        }
        ConstIterator end(JSGlobalData& globalData) const
        {
            initializeIfNeeded(&globalData);
            return ConstIterator(this, compactSize);
        }

    private:
        inline __attribute__((__always_inline__)) const HashEntry* entry(const Identifier& identifier) const
        {
            ((void)0);

            const HashEntry* entry = &table[identifier.impl()->existingHash() & compactHashSizeMask];

            if (!entry->key())
                return 0;

            do {
                if (entry->key() == identifier.impl())
                    return entry;
                entry = entry->next();
            } while (entry);

            return 0;
        }


        void createTable(JSGlobalData*) const;
    };

    bool setUpStaticFunctionSlot(ExecState*, const HashEntry*, JSObject* thisObject, const Identifier& propertyName, PropertySlot&);







    template <class ThisImp, class ParentImp>
    inline bool getStaticPropertySlot(ExecState* exec, const HashTable* table, ThisImp* thisObj, const Identifier& propertyName, PropertySlot& slot)
    {
        const HashEntry* entry = table->entry(exec, propertyName);

        if (!entry)
            return ParentImp::getOwnPropertySlot(thisObj, exec, propertyName, slot);

        if (entry->attributes() & Function)
            return setUpStaticFunctionSlot(exec, entry, thisObj, propertyName, slot);

        slot.setCacheableCustom(thisObj, entry->propertyGetter());
        return true;
    }

    template <class ThisImp, class ParentImp>
    inline bool getStaticPropertyDescriptor(ExecState* exec, const HashTable* table, ThisImp* thisObj, const Identifier& propertyName, PropertyDescriptor& descriptor)
    {
        const HashEntry* entry = table->entry(exec, propertyName);

        if (!entry)
            return thisObj->ParentImp::getOwnPropertyDescriptor(exec, propertyName, descriptor);

        PropertySlot slot;
        if (entry->attributes() & Function) {
            bool present = setUpStaticFunctionSlot(exec, entry, thisObj, propertyName, slot);
            if (present)
                descriptor.setDescriptor(slot.getValue(exec, propertyName), entry->attributes());
            return present;
        }

        slot.setCustom(thisObj, entry->propertyGetter());
        descriptor.setDescriptor(slot.getValue(exec, propertyName), entry->attributes());
        return true;
    }






    template <class ParentImp>
    inline bool getStaticFunctionSlot(ExecState* exec, const HashTable* table, JSObject* thisObj, const Identifier& propertyName, PropertySlot& slot)
    {
        if (ParentImp::getOwnPropertySlot(thisObj, exec, propertyName, slot))
            return true;

        const HashEntry* entry = table->entry(exec, propertyName);
        if (!entry)
            return false;

        return setUpStaticFunctionSlot(exec, entry, thisObj, propertyName, slot);
    }






    template <class ParentImp>
    inline bool getStaticFunctionDescriptor(ExecState* exec, const HashTable* table, JSObject* thisObj, const Identifier& propertyName, PropertyDescriptor& descriptor)
    {
        if (static_cast<ParentImp*>(thisObj)->ParentImp::getOwnPropertyDescriptor(exec, propertyName, descriptor))
            return true;

        const HashEntry* entry = table->entry(exec, propertyName);
        if (!entry)
            return false;

        PropertySlot slot;
        bool present = setUpStaticFunctionSlot(exec, entry, thisObj, propertyName, slot);
        if (present)
            descriptor.setDescriptor(slot.getValue(exec, propertyName), entry->attributes());
        return present;
    }





    template <class ThisImp, class ParentImp>
    inline bool getStaticValueSlot(ExecState* exec, const HashTable* table, ThisImp* thisObj, const Identifier& propertyName, PropertySlot& slot)
    {
        const HashEntry* entry = table->entry(exec, propertyName);

        if (!entry)
            return ParentImp::getOwnPropertySlot(thisObj, exec, propertyName, slot);

        ((void)0);

        slot.setCacheableCustom(thisObj, entry->propertyGetter());
        return true;
    }





    template <class ThisImp, class ParentImp>
    inline bool getStaticValueDescriptor(ExecState* exec, const HashTable* table, ThisImp* thisObj, const Identifier& propertyName, PropertyDescriptor& descriptor)
    {
        const HashEntry* entry = table->entry(exec, propertyName);

        if (!entry)
            return thisObj->ParentImp::getOwnPropertyDescriptor(exec, propertyName, descriptor);

        ((void)0);
        PropertySlot slot;
        slot.setCustom(thisObj, entry->propertyGetter());
        descriptor.setDescriptor(slot.getValue(exec, propertyName), entry->attributes());
        return true;
    }






    template <class ThisImp>
    inline bool lookupPut(ExecState* exec, const Identifier& propertyName, JSValue value, const HashTable* table, ThisImp* thisObj)
    {
        const HashEntry* entry = table->entry(exec, propertyName);

        if (!entry)
            return false;


        if (entry->attributes() & Function)
            thisObj->putDirect(exec->globalData(), propertyName, value);
        else if (!(entry->attributes() & ReadOnly))
            entry->propertyPutter()(exec, thisObj, value);

        return true;
    }







    template <class ThisImp, class ParentImp>
    inline void lookupPut(ExecState* exec, const Identifier& propertyName, JSValue value, const HashTable* table, ThisImp* thisObj, PutPropertySlot& slot)
    {
        if (!lookupPut<ThisImp>(exec, propertyName, value, table, thisObj))
            ParentImp::put(thisObj, exec, propertyName, value, slot);
    }

}
# 28 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/parser/Lexer.h" 2



# 1 "./wtf/AlwaysInline.h" 1
# 32 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/parser/Lexer.h" 2




namespace JSC {

    class RegExp;

    class Lexer {
        private: Lexer(const Lexer&); Lexer& operator=(const Lexer&); public: void* operator new(size_t, void* p) { return p; } void* operator new[](size_t, void* p) { return p; } void* operator new(size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNew); return p; } void operator delete(void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNew); ::WTF::fastFree(p); } void* operator new[](size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNewArray); return p; } void operator delete[](void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNewArray); ::WTF::fastFree(p); } private: typedef int ThisIsHereToForceASemicolonAfterThisMacro;
    public:

        static bool isWhiteSpace(int character);
        static bool isLineTerminator(int character);
        static unsigned char convertHex(int c1, int c2);
        static UChar convertUnicode(int c1, int c2, int c3, int c4);


        void setCode(const SourceCode&, ParserArena&);
        void setIsReparsing() { m_isReparsing = true; }
        bool isReparsing() const { return m_isReparsing; }


        enum LexType {
            IgnoreReservedWords = 1,
            DontBuildStrings = 2,
            DontBuildKeywords = 4
        };
        JSTokenType lex(JSTokenData*, JSTokenInfo*, unsigned, bool strictMode);
        bool nextTokenIsColon();
        int lineNumber() const { return m_lineNumber; }
        void setLastLineNumber(int lastLineNumber) { m_lastLineNumber = lastLineNumber; }
        int lastLineNumber() const { return m_lastLineNumber; }
        bool prevTerminator() const { return m_terminator; }
        SourceCode sourceCode(int openBrace, int closeBrace, int firstLine);
        bool scanRegExp(const Identifier*& pattern, const Identifier*& flags, UChar patternPrefix = 0);
        bool skipRegExp();


        bool sawError() const { return m_error; }
        UString getErrorMessage() const { return m_lexErrorMessage; }
        void clear();
        int currentOffset() { return m_code - m_codeStart; }
        void setOffset(int offset)
        {
            m_error = 0;
            m_lexErrorMessage = UString();
            m_code = m_codeStart + offset;
            m_buffer8.resize(0);
            m_buffer16.resize(0);

            m_current = -1;
            if (__builtin_expect((m_code < m_codeEnd), 1))
                m_current = *m_code;
        }
        void setLineNumber(int line)
        {
            m_lineNumber = line;
        }

        SourceProvider* sourceProvider() const { return m_source->provider(); }

        JSTokenType lexExpectIdentifier(JSTokenData*, JSTokenInfo*, unsigned, bool strictMode);

        bool isKeyword(const Identifier&);

    private:
        friend class JSGlobalData;

        Lexer(JSGlobalData*);
        ~Lexer();

        void record8(int);
        void record16(int);
        void record16(UChar);

        void copyCodeWithoutBOMs();

        inline __attribute__((__always_inline__)) void shift();
        inline __attribute__((__always_inline__)) int peek(int offset);
        int getUnicodeCharacter();
        void shiftLineTerminator();

        UString getInvalidCharMessage();
        inline __attribute__((__always_inline__)) const UChar* currentCharacter() const;
        inline __attribute__((__always_inline__)) int currentOffset() const;

        inline __attribute__((__always_inline__)) const Identifier* makeIdentifier(const UChar* characters, size_t length);

        inline __attribute__((__always_inline__)) bool lastTokenWasRestrKeyword() const;

        enum ShiftType { DoBoundsCheck, DoNotBoundsCheck };
        template <int shiftAmount, ShiftType shouldBoundsCheck> void internalShift();
        template <bool shouldCreateIdentifier> inline __attribute__((__always_inline__)) JSTokenType parseKeyword(JSTokenData*);
        template <bool shouldBuildIdentifiers> inline __attribute__((__always_inline__)) JSTokenType parseIdentifier(JSTokenData*, unsigned, bool strictMode);
        template <bool shouldBuildStrings> inline __attribute__((__always_inline__)) bool parseString(JSTokenData*, bool strictMode);
        inline __attribute__((__always_inline__)) void parseHex(double& returnValue);
        inline __attribute__((__always_inline__)) bool parseOctal(double& returnValue);
        inline __attribute__((__always_inline__)) bool parseDecimal(double& returnValue);
        inline __attribute__((__always_inline__)) void parseNumberAfterDecimalPoint();
        inline __attribute__((__always_inline__)) bool parseNumberAfterExponentIndicator();
        inline __attribute__((__always_inline__)) bool parseMultilineComment();

        static const size_t initialReadBufferCapacity = 32;

        int m_lineNumber;
        int m_lastLineNumber;

        Vector<char> m_buffer8;
        Vector<UChar> m_buffer16;
        bool m_terminator;
        bool m_delimited;
        int m_lastToken;

        const SourceCode* m_source;
        const UChar* m_code;
        const UChar* m_codeStart;
        const UChar* m_codeEnd;
        bool m_isReparsing;
        bool m_atLineStart;
        bool m_error;
        UString m_lexErrorMessage;


        int m_current;

        IdentifierArena* m_arena;

        JSGlobalData* m_globalData;

        const HashTable m_keywordTable;
    };

    inline __attribute__((__always_inline__)) bool Lexer::isWhiteSpace(int ch)
    {
        return isASCII(ch) ? (ch == ' ' || ch == '\t' || ch == 0xB || ch == 0xC) : (WTF::Unicode::isSeparatorSpace(ch) || ch == 0xFEFF);
    }

    inline __attribute__((__always_inline__)) bool Lexer::isLineTerminator(int ch)
    {
        return ch == '\r' || ch == '\n' || (ch & ~1) == 0x2028;
    }

    inline unsigned char Lexer::convertHex(int c1, int c2)
    {
        return (toASCIIHexValue(c1) << 4) | toASCIIHexValue(c2);
    }

    inline UChar Lexer::convertUnicode(int c1, int c2, int c3, int c4)
    {
        return (convertHex(c1, c2) << 8) | convertHex(c3, c4);
    }

    inline __attribute__((__always_inline__)) const Identifier* Lexer::makeIdentifier(const UChar* characters, size_t length)
    {
        return &m_arena->makeIdentifier(m_globalData, characters, length);
    }

    inline __attribute__((__always_inline__)) JSTokenType Lexer::lexExpectIdentifier(JSTokenData* tokenData, JSTokenInfo* tokenInfo, unsigned lexType, bool strictMode)
    {
        ((void)0);
        const UChar* start = m_code;
        const UChar* ptr = start;
        const UChar* end = m_codeEnd;
        if (ptr >= end) {
            ((void)0);
            goto slowCase;
        }
        if (!WTF::isASCIIAlpha(*ptr))
            goto slowCase;
        ++ptr;
        while (ptr < end) {
            if (!WTF::isASCIIAlphanumeric(*ptr))
                break;
            ++ptr;
        }


        if (ptr < end) {
            if ((!WTF::isASCII(*ptr)) || (*ptr == '\\') || (*ptr == '_') || (*ptr == '$'))
                goto slowCase;
            m_current = *ptr;
        } else
            m_current = -1;

        m_code = ptr;


        if (lexType & DontBuildKeywords)
            tokenData->ident = 0;
        else
            tokenData->ident = makeIdentifier(start, ptr - start);
        tokenInfo->line = m_lineNumber;
        tokenInfo->startOffset = start - m_codeStart;
        tokenInfo->endOffset = currentOffset();
        m_lastToken = IDENT;
        return IDENT;

    slowCase:
        return lex(tokenData, tokenInfo, lexType, strictMode);
    }

}
# 31 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/parser/Parser.h" 2








namespace JSC {

    class FunctionBodyNode;

    class ProgramNode;
    class UString;

    template <typename T> inline bool isEvalNode() { return false; }
    template <> inline bool isEvalNode<EvalNode>() { return true; }
    template <typename T> struct ParserArenaData : ParserArenaDeletable { T data; };

    class Parser {
        private: Parser(const Parser&); Parser& operator=(const Parser&); public: void* operator new(size_t, void* p) { return p; } void* operator new[](size_t, void* p) { return p; } void* operator new(size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNew); return p; } void operator delete(void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNew); ::WTF::fastFree(p); } void* operator new[](size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNewArray); return p; } void operator delete[](void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNewArray); ::WTF::fastFree(p); } private: typedef int ThisIsHereToForceASemicolonAfterThisMacro;
    public:
        Parser() { }
        template <class ParsedNode>
        PassRefPtr<ParsedNode> parse(JSGlobalObject* lexicalGlobalObject, Debugger*, ExecState*, const SourceCode& source, FunctionParameters*, JSParserStrictness strictness, JSObject** exception);

        void didFinishParsing(SourceElements*, ParserArenaData<DeclarationStacks::VarStack>*,
                              ParserArenaData<DeclarationStacks::FunctionStack>*, CodeFeatures features,
                              int lastLine, int numConstants, IdentifierSet&);

        ParserArena& arena() { return m_arena; }

    private:
        void parse(JSGlobalData*, FunctionParameters*, JSParserStrictness strictness, JSParserMode mode, int* errLine, UString* errMsg);


        bool isFunctionBodyNode(ScopeNode*) { return false; }
        bool isFunctionBodyNode(FunctionBodyNode*) { return true; }

        ParserArena m_arena;
        const SourceCode* m_source;
        SourceElements* m_sourceElements;
        ParserArenaData<DeclarationStacks::VarStack>* m_varDeclarations;
        ParserArenaData<DeclarationStacks::FunctionStack>* m_funcDeclarations;
        IdentifierSet m_capturedVariables;
        CodeFeatures m_features;
        int m_lastLine;
        int m_numConstants;
    };

    template <class ParsedNode>
    PassRefPtr<ParsedNode> Parser::parse(JSGlobalObject* lexicalGlobalObject, Debugger* debugger, ExecState* debuggerExecState, const SourceCode& source, FunctionParameters* parameters, JSParserStrictness strictness, JSObject** exception)
    {
        ((void)0);
        ((void)0);
        int errLine;
        UString errMsg;

        m_source = &source;
        if (ParsedNode::scopeIsFunction)
            lexicalGlobalObject->globalData().lexer->setIsReparsing();
        parse(&lexicalGlobalObject->globalData(), parameters, strictness, ParsedNode::isFunctionNode ? JSParseFunctionCode : JSParseProgramCode, &errLine, &errMsg);

        RefPtr<ParsedNode> result;
        if (m_sourceElements) {
            result = ParsedNode::create(&lexicalGlobalObject->globalData(),
                m_sourceElements,
                m_varDeclarations ? &m_varDeclarations->data : 0,
                m_funcDeclarations ? &m_funcDeclarations->data : 0,
                m_capturedVariables,
                source,
                m_features,
                m_numConstants);
            result->setLoc(m_source->firstLine(), m_lastLine);
        } else if (lexicalGlobalObject) {






            if (isFunctionBodyNode(static_cast<ParsedNode*>(0)))
                *exception = createStackOverflowError(lexicalGlobalObject);
            else if (isEvalNode<ParsedNode>())
                *exception = createSyntaxError(lexicalGlobalObject, errMsg);
            else
                *exception = addErrorInfo(&lexicalGlobalObject->globalData(), createSyntaxError(lexicalGlobalObject, errMsg), errLine, source);
        }

        m_arena.reset();

        m_source = 0;
        m_sourceElements = 0;
        m_varDeclarations = 0;
        m_funcDeclarations = 0;

        if (debugger && !ParsedNode::scopeIsFunction)
            debugger->sourceParsed(debuggerExecState, source.provider(), errLine, errMsg);
        return result.release();
    }

}
# 36 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/EvalCodeCache.h" 2






namespace JSC {

    class SlotVisitor;

    class EvalCodeCache {
    public:
        EvalExecutable* tryGet(bool inStrictContext, const UString& evalSource, ScopeChainNode* scopeChain)
        {
            if (!inStrictContext && evalSource.length() < maxCacheableSourceLength && (*scopeChain->begin())->isVariableObject())
                return m_cacheMap.get(evalSource.impl()).get();
            return 0;
        }

        EvalExecutable* getSlow(ExecState* exec, ScriptExecutable* owner, bool inStrictContext, const UString& evalSource, ScopeChainNode* scopeChain, JSValue& exceptionValue)
        {
            EvalExecutable* evalExecutable = EvalExecutable::create(exec, makeSource(evalSource), inStrictContext);
            exceptionValue = evalExecutable->compile(exec, scopeChain);
            if (exceptionValue)
                return 0;

            if (!inStrictContext && evalSource.length() < maxCacheableSourceLength && (*scopeChain->begin())->isVariableObject() && m_cacheMap.size() < maxCacheEntries)
                m_cacheMap.set(evalSource.impl(), WriteBarrier<EvalExecutable>(exec->globalData(), owner, evalExecutable));

            return evalExecutable;
        }

        EvalExecutable* get(ExecState* exec, ScriptExecutable* owner, bool inStrictContext, const UString& evalSource, ScopeChainNode* scopeChain, JSValue& exceptionValue)
        {
            EvalExecutable* evalExecutable = tryGet(inStrictContext, evalSource, scopeChain);

            if (!evalExecutable)
                evalExecutable = getSlow(exec, owner, inStrictContext, evalSource, scopeChain, exceptionValue);

            return evalExecutable;
        }

        bool isEmpty() const { return m_cacheMap.isEmpty(); }

        void visitAggregate(SlotVisitor&);

        void clear()
        {
            m_cacheMap.clear();
        }

    private:
        static const unsigned maxCacheableSourceLength = 256;
        static const int maxCacheEntries = 64;

        typedef HashMap<RefPtr<StringImpl>, WriteBarrier<EvalExecutable> > EvalCacheMap;
        EvalCacheMap m_cacheMap;
    };

}
# 37 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/CodeBlock.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/Heuristics.h" 1
# 31 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/Heuristics.h"
namespace JSC { namespace Heuristics {

extern unsigned maximumEvalOptimizationCandidateInstructionCount;
extern unsigned maximumProgramOptimizationCandidateInstructionCount;
extern unsigned maximumFunctionForCallOptimizationCandidateInstructionCount;
extern unsigned maximumFunctionForConstructOptimizationCandidateInstructionCount;

extern unsigned maximumFunctionForCallInlineCandidateInstructionCount;
extern unsigned maximumFunctionForConstructInlineCandidateInstructionCount;

extern unsigned maximumInliningDepth;

extern int32_t executionCounterValueForOptimizeAfterWarmUp;
extern int32_t executionCounterValueForOptimizeAfterLongWarmUp;
extern int32_t executionCounterValueForDontOptimizeAnytimeSoon;
extern int32_t executionCounterValueForOptimizeSoon;
extern int32_t executionCounterValueForOptimizeNextInvocation;

extern int32_t executionCounterIncrementForLoop;
extern int32_t executionCounterIncrementForReturn;

extern unsigned desiredSpeculativeSuccessFailRatio;

extern unsigned likelyToTakeSlowCaseThreshold;
extern unsigned couldTakeSlowCaseThreshold;

extern unsigned largeFailCountThresholdBase;
extern unsigned largeFailCountThresholdBaseForLoop;

extern unsigned reoptimizationRetryCounterMax;
extern unsigned reoptimizationRetryCounterStep;

extern unsigned maximumOptimizationDelay;
extern double desiredProfileLivenessRate;
extern double desiredProfileFullnessRate;

void initializeHeuristics();

} }
# 38 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/CodeBlock.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/Instruction.h" 1
# 32 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/Instruction.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/MacroAssembler.h" 1
# 50 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/MacroAssembler.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/MacroAssemblerX86_64.h" 1
# 31 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/MacroAssemblerX86_64.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/MacroAssemblerX86Common.h" 1
# 31 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/MacroAssemblerX86Common.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/X86Assembler.h" 1
# 31 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/X86Assembler.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/AssemblerBuffer.h" 1
# 39 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/AssemblerBuffer.h"
namespace JSC {

    struct AssemblerLabel {
        AssemblerLabel()
            : m_offset(std::numeric_limits<uint32_t>::max())
        {
        }

        explicit AssemblerLabel(uint32_t offset)
            : m_offset(offset)
        {
        }

        bool isSet() const { return (m_offset != std::numeric_limits<uint32_t>::max()); }

        AssemblerLabel labelAtOffset(int offset) const
        {
            return AssemblerLabel(m_offset + offset);
        }

        uint32_t m_offset;
    };

    class AssemblerBuffer {
        static const int inlineCapacity = 128;
    public:
        AssemblerBuffer()
            : m_storage(inlineCapacity)
            , m_buffer(m_storage.begin())
            , m_capacity(inlineCapacity)
            , m_index(0)
        {
        }

        ~AssemblerBuffer()
        {
        }

        bool isAvailable(int space)
        {
            return m_index + space <= m_capacity;
        }

        void ensureSpace(int space)
        {
            if (!isAvailable(space))
                grow();
        }

        bool isAligned(int alignment) const
        {
            return !(m_index & (alignment - 1));
        }

        template<typename IntegralType>
        void putIntegral(IntegralType value)
        {
            ensureSpace(sizeof(IntegralType));
            putIntegralUnchecked(value);
        }

        template<typename IntegralType>
        void putIntegralUnchecked(IntegralType value)
        {
            ((void)0);
            *reinterpret_cast<IntegralType*>(m_buffer + m_index) = value;
            m_index += sizeof(IntegralType);
        }

        void putByteUnchecked(int8_t value) { putIntegralUnchecked(value); }
        void putByte(int8_t value) { putIntegral(value); }
        void putShortUnchecked(int16_t value) { putIntegralUnchecked(value); }
        void putShort(int16_t value) { putIntegral(value); }
        void putIntUnchecked(int32_t value) { putIntegralUnchecked(value); }
        void putInt(int32_t value) { putIntegral(value); }
        void putInt64Unchecked(int64_t value) { putIntegralUnchecked(value); }
        void putInt64(int64_t value) { putIntegral(value); }

        void* data() const
        {
            return m_buffer;
        }

        size_t codeSize() const
        {
            return m_index;
        }

        AssemblerLabel label() const
        {
            return AssemblerLabel(m_index);
        }

        PassRefPtr<ExecutableMemoryHandle> executableCopy(JSGlobalData& globalData)
        {
            if (!m_index)
                return 0;

            RefPtr<ExecutableMemoryHandle> result = globalData.executableAllocator.allocate(globalData, m_index);

            if (!result)
                return 0;

            ExecutableAllocator::makeWritable(result->start(), result->sizeInBytes());

            memcpy(result->start(), m_buffer, m_index);

            return result.release();
        }

        void rewindToLabel(AssemblerLabel label)
        {
            m_index = label.m_offset;
        }





    protected:
        void append(const char* data, int size)
        {
            if (!isAvailable(size))
                grow(size);

            memcpy(m_buffer + m_index, data, size);
            m_index += size;
        }

        void grow(int extraCapacity = 0)
        {
            m_capacity += m_capacity / 2 + extraCapacity;

            m_storage.grow(m_capacity);
            m_buffer = m_storage.begin();
        }

    private:
        Vector<char, inlineCapacity> m_storage;
        char* m_buffer;
        int m_capacity;
        int m_index;
    };

}
# 32 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/X86Assembler.h" 2




namespace JSC {

inline bool CAN_SIGN_EXTEND_8_32(int32_t value) { return value == (int32_t)(signed char)value; }

namespace X86Registers {
    typedef enum {
        eax,
        ecx,
        edx,
        ebx,
        esp,
        ebp,
        esi,
        edi,


        r8,
        r9,
        r10,
        r11,
        r12,
        r13,
        r14,
        r15,

    } RegisterID;

    typedef enum {
        xmm0,
        xmm1,
        xmm2,
        xmm3,
        xmm4,
        xmm5,
        xmm6,
        xmm7,
    } XMMRegisterID;
}

class X86Assembler {
public:
    typedef X86Registers::RegisterID RegisterID;
    typedef X86Registers::XMMRegisterID XMMRegisterID;
    typedef XMMRegisterID FPRegisterID;

    typedef enum {
        ConditionO,
        ConditionNO,
        ConditionB,
        ConditionAE,
        ConditionE,
        ConditionNE,
        ConditionBE,
        ConditionA,
        ConditionS,
        ConditionNS,
        ConditionP,
        ConditionNP,
        ConditionL,
        ConditionGE,
        ConditionLE,
        ConditionG,

        ConditionC = ConditionB,
        ConditionNC = ConditionAE,
    } Condition;

private:
    typedef enum {
        OP_ADD_EvGv = 0x01,
        OP_ADD_GvEv = 0x03,
        OP_OR_EvGv = 0x09,
        OP_OR_GvEv = 0x0B,
        OP_2BYTE_ESCAPE = 0x0F,
        OP_AND_EvGv = 0x21,
        OP_AND_GvEv = 0x23,
        OP_SUB_EvGv = 0x29,
        OP_SUB_GvEv = 0x2B,
        PRE_PREDICT_BRANCH_NOT_TAKEN = 0x2E,
        OP_XOR_EvGv = 0x31,
        OP_XOR_GvEv = 0x33,
        OP_CMP_EvGv = 0x39,
        OP_CMP_GvEv = 0x3B,

        PRE_REX = 0x40,

        OP_PUSH_EAX = 0x50,
        OP_POP_EAX = 0x58,

        OP_MOVSXD_GvEv = 0x63,

        PRE_OPERAND_SIZE = 0x66,
        PRE_SSE_66 = 0x66,
        OP_PUSH_Iz = 0x68,
        OP_IMUL_GvEvIz = 0x69,
        OP_GROUP1_EbIb = 0x80,
        OP_GROUP1_EvIz = 0x81,
        OP_GROUP1_EvIb = 0x83,
        OP_TEST_EbGb = 0x84,
        OP_TEST_EvGv = 0x85,
        OP_XCHG_EvGv = 0x87,
        OP_MOV_EbGb = 0x88,
        OP_MOV_EvGv = 0x89,
        OP_MOV_GvEv = 0x8B,
        OP_LEA = 0x8D,
        OP_GROUP1A_Ev = 0x8F,
        OP_NOP = 0x90,
        OP_CDQ = 0x99,
        OP_MOV_EAXOv = 0xA1,
        OP_MOV_OvEAX = 0xA3,
        OP_MOV_EAXIv = 0xB8,
        OP_GROUP2_EvIb = 0xC1,
        OP_RET = 0xC3,
        OP_GROUP11_EvIb = 0xC6,
        OP_GROUP11_EvIz = 0xC7,
        OP_INT3 = 0xCC,
        OP_GROUP2_Ev1 = 0xD1,
        OP_GROUP2_EvCL = 0xD3,
        OP_ESCAPE_DD = 0xDD,
        OP_CALL_rel32 = 0xE8,
        OP_JMP_rel32 = 0xE9,
        PRE_SSE_F2 = 0xF2,
        OP_HLT = 0xF4,
        OP_GROUP3_EbIb = 0xF6,
        OP_GROUP3_Ev = 0xF7,
        OP_GROUP3_EvIz = 0xF7,
        OP_GROUP5_Ev = 0xFF,
    } OneByteOpcodeID;

    typedef enum {
        OP2_MOVSD_VsdWsd = 0x10,
        OP2_MOVSD_WsdVsd = 0x11,
        OP2_CVTSI2SD_VsdEd = 0x2A,
        OP2_CVTTSD2SI_GdWsd = 0x2C,
        OP2_UCOMISD_VsdWsd = 0x2E,
        OP2_ADDSD_VsdWsd = 0x58,
        OP2_MULSD_VsdWsd = 0x59,
        OP2_SUBSD_VsdWsd = 0x5C,
        OP2_DIVSD_VsdWsd = 0x5E,
        OP2_SQRTSD_VsdWsd = 0x51,
        OP2_ANDNPD_VpdWpd = 0x55,
        OP2_XORPD_VpdWpd = 0x57,
        OP2_MOVD_VdEd = 0x6E,
        OP2_MOVD_EdVd = 0x7E,
        OP2_JCC_rel32 = 0x80,
        OP_SETCC = 0x90,
        OP2_IMUL_GvEv = 0xAF,
        OP2_MOVZX_GvEb = 0xB6,
        OP2_MOVZX_GvEw = 0xB7,
        OP2_PEXTRW_GdUdIb = 0xC5,
        OP2_PSLLQ_UdqIb = 0x73,
        OP2_PSRLQ_UdqIb = 0x73,
        OP2_POR_VdqWdq = 0XEB,
    } TwoByteOpcodeID;

    TwoByteOpcodeID jccRel32(Condition cond)
    {
        return (TwoByteOpcodeID)(OP2_JCC_rel32 + cond);
    }

    TwoByteOpcodeID setccOpcode(Condition cond)
    {
        return (TwoByteOpcodeID)(OP_SETCC + cond);
    }

    typedef enum {
        GROUP1_OP_ADD = 0,
        GROUP1_OP_OR = 1,
        GROUP1_OP_ADC = 2,
        GROUP1_OP_AND = 4,
        GROUP1_OP_SUB = 5,
        GROUP1_OP_XOR = 6,
        GROUP1_OP_CMP = 7,

        GROUP1A_OP_POP = 0,

        GROUP2_OP_SHL = 4,
        GROUP2_OP_SHR = 5,
        GROUP2_OP_SAR = 7,

        GROUP3_OP_TEST = 0,
        GROUP3_OP_NOT = 2,
        GROUP3_OP_NEG = 3,
        GROUP3_OP_IDIV = 7,

        GROUP5_OP_CALLN = 2,
        GROUP5_OP_JMPN = 4,
        GROUP5_OP_PUSH = 6,

        GROUP11_MOV = 0,

        GROUP14_OP_PSLLQ = 6,
        GROUP14_OP_PSRLQ = 2,

        ESCAPE_DD_FSTP_doubleReal = 3,
    } GroupOpcodeID;

    class X86InstructionFormatter;
public:

    X86Assembler()
    {
    }



    void push_r(RegisterID reg)
    {
        m_formatter.oneByteOp(OP_PUSH_EAX, reg);
    }

    void pop_r(RegisterID reg)
    {
        m_formatter.oneByteOp(OP_POP_EAX, reg);
    }

    void push_i32(int imm)
    {
        m_formatter.oneByteOp(OP_PUSH_Iz);
        m_formatter.immediate32(imm);
    }

    void push_m(int offset, RegisterID base)
    {
        m_formatter.oneByteOp(OP_GROUP5_Ev, GROUP5_OP_PUSH, base, offset);
    }

    void pop_m(int offset, RegisterID base)
    {
        m_formatter.oneByteOp(OP_GROUP1A_Ev, GROUP1A_OP_POP, base, offset);
    }
# 283 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/X86Assembler.h"
    void addl_rr(RegisterID src, RegisterID dst)
    {
        m_formatter.oneByteOp(OP_ADD_EvGv, src, dst);
    }

    void addl_mr(int offset, RegisterID base, RegisterID dst)
    {
        m_formatter.oneByteOp(OP_ADD_GvEv, dst, base, offset);
    }

    void addl_rm(RegisterID src, int offset, RegisterID base)
    {
        m_formatter.oneByteOp(OP_ADD_EvGv, src, base, offset);
    }

    void addl_ir(int imm, RegisterID dst)
    {
        if (CAN_SIGN_EXTEND_8_32(imm)) {
            m_formatter.oneByteOp(OP_GROUP1_EvIb, GROUP1_OP_ADD, dst);
            m_formatter.immediate8(imm);
        } else {
            m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_ADD, dst);
            m_formatter.immediate32(imm);
        }
    }

    void addl_im(int imm, int offset, RegisterID base)
    {
        if (CAN_SIGN_EXTEND_8_32(imm)) {
            m_formatter.oneByteOp(OP_GROUP1_EvIb, GROUP1_OP_ADD, base, offset);
            m_formatter.immediate8(imm);
        } else {
            m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_ADD, base, offset);
            m_formatter.immediate32(imm);
        }
    }


    void addq_rr(RegisterID src, RegisterID dst)
    {
        m_formatter.oneByteOp64(OP_ADD_EvGv, src, dst);
    }

    void addq_ir(int imm, RegisterID dst)
    {
        if (CAN_SIGN_EXTEND_8_32(imm)) {
            m_formatter.oneByteOp64(OP_GROUP1_EvIb, GROUP1_OP_ADD, dst);
            m_formatter.immediate8(imm);
        } else {
            m_formatter.oneByteOp64(OP_GROUP1_EvIz, GROUP1_OP_ADD, dst);
            m_formatter.immediate32(imm);
        }
    }

    void addq_im(int imm, int offset, RegisterID base)
    {
        if (CAN_SIGN_EXTEND_8_32(imm)) {
            m_formatter.oneByteOp64(OP_GROUP1_EvIb, GROUP1_OP_ADD, base, offset);
            m_formatter.immediate8(imm);
        } else {
            m_formatter.oneByteOp64(OP_GROUP1_EvIz, GROUP1_OP_ADD, base, offset);
            m_formatter.immediate32(imm);
        }
    }
# 360 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/X86Assembler.h"
    void andl_rr(RegisterID src, RegisterID dst)
    {
        m_formatter.oneByteOp(OP_AND_EvGv, src, dst);
    }

    void andl_mr(int offset, RegisterID base, RegisterID dst)
    {
        m_formatter.oneByteOp(OP_AND_GvEv, dst, base, offset);
    }

    void andl_rm(RegisterID src, int offset, RegisterID base)
    {
        m_formatter.oneByteOp(OP_AND_EvGv, src, base, offset);
    }

    void andl_ir(int imm, RegisterID dst)
    {
        if (CAN_SIGN_EXTEND_8_32(imm)) {
            m_formatter.oneByteOp(OP_GROUP1_EvIb, GROUP1_OP_AND, dst);
            m_formatter.immediate8(imm);
        } else {
            m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_AND, dst);
            m_formatter.immediate32(imm);
        }
    }

    void andl_im(int imm, int offset, RegisterID base)
    {
        if (CAN_SIGN_EXTEND_8_32(imm)) {
            m_formatter.oneByteOp(OP_GROUP1_EvIb, GROUP1_OP_AND, base, offset);
            m_formatter.immediate8(imm);
        } else {
            m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_AND, base, offset);
            m_formatter.immediate32(imm);
        }
    }


    void andq_rr(RegisterID src, RegisterID dst)
    {
        m_formatter.oneByteOp64(OP_AND_EvGv, src, dst);
    }

    void andq_ir(int imm, RegisterID dst)
    {
        if (CAN_SIGN_EXTEND_8_32(imm)) {
            m_formatter.oneByteOp64(OP_GROUP1_EvIb, GROUP1_OP_AND, dst);
            m_formatter.immediate8(imm);
        } else {
            m_formatter.oneByteOp64(OP_GROUP1_EvIz, GROUP1_OP_AND, dst);
            m_formatter.immediate32(imm);
        }
    }
# 426 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/X86Assembler.h"
    void negl_r(RegisterID dst)
    {
        m_formatter.oneByteOp(OP_GROUP3_Ev, GROUP3_OP_NEG, dst);
    }

    void negl_m(int offset, RegisterID base)
    {
        m_formatter.oneByteOp(OP_GROUP3_Ev, GROUP3_OP_NEG, base, offset);
    }

    void notl_r(RegisterID dst)
    {
        m_formatter.oneByteOp(OP_GROUP3_Ev, GROUP3_OP_NOT, dst);
    }

    void notl_m(int offset, RegisterID base)
    {
        m_formatter.oneByteOp(OP_GROUP3_Ev, GROUP3_OP_NOT, base, offset);
    }

    void orl_rr(RegisterID src, RegisterID dst)
    {
        m_formatter.oneByteOp(OP_OR_EvGv, src, dst);
    }

    void orl_mr(int offset, RegisterID base, RegisterID dst)
    {
        m_formatter.oneByteOp(OP_OR_GvEv, dst, base, offset);
    }

    void orl_rm(RegisterID src, int offset, RegisterID base)
    {
        m_formatter.oneByteOp(OP_OR_EvGv, src, base, offset);
    }

    void orl_ir(int imm, RegisterID dst)
    {
        if (CAN_SIGN_EXTEND_8_32(imm)) {
            m_formatter.oneByteOp(OP_GROUP1_EvIb, GROUP1_OP_OR, dst);
            m_formatter.immediate8(imm);
        } else {
            m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_OR, dst);
            m_formatter.immediate32(imm);
        }
    }

    void orl_im(int imm, int offset, RegisterID base)
    {
        if (CAN_SIGN_EXTEND_8_32(imm)) {
            m_formatter.oneByteOp(OP_GROUP1_EvIb, GROUP1_OP_OR, base, offset);
            m_formatter.immediate8(imm);
        } else {
            m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_OR, base, offset);
            m_formatter.immediate32(imm);
        }
    }


    void orq_rr(RegisterID src, RegisterID dst)
    {
        m_formatter.oneByteOp64(OP_OR_EvGv, src, dst);
    }

    void orq_ir(int imm, RegisterID dst)
    {
        if (CAN_SIGN_EXTEND_8_32(imm)) {
            m_formatter.oneByteOp64(OP_GROUP1_EvIb, GROUP1_OP_OR, dst);
            m_formatter.immediate8(imm);
        } else {
            m_formatter.oneByteOp64(OP_GROUP1_EvIz, GROUP1_OP_OR, dst);
            m_formatter.immediate32(imm);
        }
    }
# 512 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/X86Assembler.h"
    void subl_rr(RegisterID src, RegisterID dst)
    {
        m_formatter.oneByteOp(OP_SUB_EvGv, src, dst);
    }

    void subl_mr(int offset, RegisterID base, RegisterID dst)
    {
        m_formatter.oneByteOp(OP_SUB_GvEv, dst, base, offset);
    }

    void subl_rm(RegisterID src, int offset, RegisterID base)
    {
        m_formatter.oneByteOp(OP_SUB_EvGv, src, base, offset);
    }

    void subl_ir(int imm, RegisterID dst)
    {
        if (CAN_SIGN_EXTEND_8_32(imm)) {
            m_formatter.oneByteOp(OP_GROUP1_EvIb, GROUP1_OP_SUB, dst);
            m_formatter.immediate8(imm);
        } else {
            m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_SUB, dst);
            m_formatter.immediate32(imm);
        }
    }

    void subl_im(int imm, int offset, RegisterID base)
    {
        if (CAN_SIGN_EXTEND_8_32(imm)) {
            m_formatter.oneByteOp(OP_GROUP1_EvIb, GROUP1_OP_SUB, base, offset);
            m_formatter.immediate8(imm);
        } else {
            m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_SUB, base, offset);
            m_formatter.immediate32(imm);
        }
    }


    void subq_rr(RegisterID src, RegisterID dst)
    {
        m_formatter.oneByteOp64(OP_SUB_EvGv, src, dst);
    }

    void subq_ir(int imm, RegisterID dst)
    {
        if (CAN_SIGN_EXTEND_8_32(imm)) {
            m_formatter.oneByteOp64(OP_GROUP1_EvIb, GROUP1_OP_SUB, dst);
            m_formatter.immediate8(imm);
        } else {
            m_formatter.oneByteOp64(OP_GROUP1_EvIz, GROUP1_OP_SUB, dst);
            m_formatter.immediate32(imm);
        }
    }
# 578 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/X86Assembler.h"
    void xorl_rr(RegisterID src, RegisterID dst)
    {
        m_formatter.oneByteOp(OP_XOR_EvGv, src, dst);
    }

    void xorl_mr(int offset, RegisterID base, RegisterID dst)
    {
        m_formatter.oneByteOp(OP_XOR_GvEv, dst, base, offset);
    }

    void xorl_rm(RegisterID src, int offset, RegisterID base)
    {
        m_formatter.oneByteOp(OP_XOR_EvGv, src, base, offset);
    }

    void xorl_im(int imm, int offset, RegisterID base)
    {
        if (CAN_SIGN_EXTEND_8_32(imm)) {
            m_formatter.oneByteOp(OP_GROUP1_EvIb, GROUP1_OP_XOR, base, offset);
            m_formatter.immediate8(imm);
        } else {
            m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_XOR, base, offset);
            m_formatter.immediate32(imm);
        }
    }

    void xorl_ir(int imm, RegisterID dst)
    {
        if (CAN_SIGN_EXTEND_8_32(imm)) {
            m_formatter.oneByteOp(OP_GROUP1_EvIb, GROUP1_OP_XOR, dst);
            m_formatter.immediate8(imm);
        } else {
            m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_XOR, dst);
            m_formatter.immediate32(imm);
        }
    }


    void xorq_rr(RegisterID src, RegisterID dst)
    {
        m_formatter.oneByteOp64(OP_XOR_EvGv, src, dst);
    }

    void xorq_ir(int imm, RegisterID dst)
    {
        if (CAN_SIGN_EXTEND_8_32(imm)) {
            m_formatter.oneByteOp64(OP_GROUP1_EvIb, GROUP1_OP_XOR, dst);
            m_formatter.immediate8(imm);
        } else {
            m_formatter.oneByteOp64(OP_GROUP1_EvIz, GROUP1_OP_XOR, dst);
            m_formatter.immediate32(imm);
        }
    }


    void sarl_i8r(int imm, RegisterID dst)
    {
        if (imm == 1)
            m_formatter.oneByteOp(OP_GROUP2_Ev1, GROUP2_OP_SAR, dst);
        else {
            m_formatter.oneByteOp(OP_GROUP2_EvIb, GROUP2_OP_SAR, dst);
            m_formatter.immediate8(imm);
        }
    }

    void sarl_CLr(RegisterID dst)
    {
        m_formatter.oneByteOp(OP_GROUP2_EvCL, GROUP2_OP_SAR, dst);
    }

    void shrl_i8r(int imm, RegisterID dst)
    {
        if (imm == 1)
            m_formatter.oneByteOp(OP_GROUP2_Ev1, GROUP2_OP_SHR, dst);
        else {
            m_formatter.oneByteOp(OP_GROUP2_EvIb, GROUP2_OP_SHR, dst);
            m_formatter.immediate8(imm);
        }
    }

    void shrl_CLr(RegisterID dst)
    {
        m_formatter.oneByteOp(OP_GROUP2_EvCL, GROUP2_OP_SHR, dst);
    }

    void shll_i8r(int imm, RegisterID dst)
    {
        if (imm == 1)
            m_formatter.oneByteOp(OP_GROUP2_Ev1, GROUP2_OP_SHL, dst);
        else {
            m_formatter.oneByteOp(OP_GROUP2_EvIb, GROUP2_OP_SHL, dst);
            m_formatter.immediate8(imm);
        }
    }

    void shll_CLr(RegisterID dst)
    {
        m_formatter.oneByteOp(OP_GROUP2_EvCL, GROUP2_OP_SHL, dst);
    }


    void sarq_CLr(RegisterID dst)
    {
        m_formatter.oneByteOp64(OP_GROUP2_EvCL, GROUP2_OP_SAR, dst);
    }

    void sarq_i8r(int imm, RegisterID dst)
    {
        if (imm == 1)
            m_formatter.oneByteOp64(OP_GROUP2_Ev1, GROUP2_OP_SAR, dst);
        else {
            m_formatter.oneByteOp64(OP_GROUP2_EvIb, GROUP2_OP_SAR, dst);
            m_formatter.immediate8(imm);
        }
    }


    void imull_rr(RegisterID src, RegisterID dst)
    {
        m_formatter.twoByteOp(OP2_IMUL_GvEv, dst, src);
    }

    void imull_mr(int offset, RegisterID base, RegisterID dst)
    {
        m_formatter.twoByteOp(OP2_IMUL_GvEv, dst, base, offset);
    }

    void imull_i32r(RegisterID src, int32_t value, RegisterID dst)
    {
        m_formatter.oneByteOp(OP_IMUL_GvEvIz, dst, src);
        m_formatter.immediate32(value);
    }

    void idivl_r(RegisterID dst)
    {
        m_formatter.oneByteOp(OP_GROUP3_Ev, GROUP3_OP_IDIV, dst);
    }



    void cmpl_rr(RegisterID src, RegisterID dst)
    {
        m_formatter.oneByteOp(OP_CMP_EvGv, src, dst);
    }

    void cmpl_rm(RegisterID src, int offset, RegisterID base)
    {
        m_formatter.oneByteOp(OP_CMP_EvGv, src, base, offset);
    }

    void cmpl_mr(int offset, RegisterID base, RegisterID src)
    {
        m_formatter.oneByteOp(OP_CMP_GvEv, src, base, offset);
    }

    void cmpl_ir(int imm, RegisterID dst)
    {
        if (CAN_SIGN_EXTEND_8_32(imm)) {
            m_formatter.oneByteOp(OP_GROUP1_EvIb, GROUP1_OP_CMP, dst);
            m_formatter.immediate8(imm);
        } else {
            m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_CMP, dst);
            m_formatter.immediate32(imm);
        }
    }

    void cmpl_ir_force32(int imm, RegisterID dst)
    {
        m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_CMP, dst);
        m_formatter.immediate32(imm);
    }

    void cmpl_im(int imm, int offset, RegisterID base)
    {
        if (CAN_SIGN_EXTEND_8_32(imm)) {
            m_formatter.oneByteOp(OP_GROUP1_EvIb, GROUP1_OP_CMP, base, offset);
            m_formatter.immediate8(imm);
        } else {
            m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_CMP, base, offset);
            m_formatter.immediate32(imm);
        }
    }

    void cmpb_im(int imm, int offset, RegisterID base)
    {
        m_formatter.oneByteOp(OP_GROUP1_EbIb, GROUP1_OP_CMP, base, offset);
        m_formatter.immediate8(imm);
    }

    void cmpb_im(int imm, int offset, RegisterID base, RegisterID index, int scale)
    {
        m_formatter.oneByteOp(OP_GROUP1_EbIb, GROUP1_OP_CMP, base, index, scale, offset);
        m_formatter.immediate8(imm);
    }

    void cmpl_im(int imm, int offset, RegisterID base, RegisterID index, int scale)
    {
        if (CAN_SIGN_EXTEND_8_32(imm)) {
            m_formatter.oneByteOp(OP_GROUP1_EvIb, GROUP1_OP_CMP, base, index, scale, offset);
            m_formatter.immediate8(imm);
        } else {
            m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_CMP, base, index, scale, offset);
            m_formatter.immediate32(imm);
        }
    }

    void cmpl_im_force32(int imm, int offset, RegisterID base)
    {
        m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_CMP, base, offset);
        m_formatter.immediate32(imm);
    }


    void cmpq_rr(RegisterID src, RegisterID dst)
    {
        m_formatter.oneByteOp64(OP_CMP_EvGv, src, dst);
    }

    void cmpq_rm(RegisterID src, int offset, RegisterID base)
    {
        m_formatter.oneByteOp64(OP_CMP_EvGv, src, base, offset);
    }

    void cmpq_mr(int offset, RegisterID base, RegisterID src)
    {
        m_formatter.oneByteOp64(OP_CMP_GvEv, src, base, offset);
    }

    void cmpq_ir(int imm, RegisterID dst)
    {
        if (CAN_SIGN_EXTEND_8_32(imm)) {
            m_formatter.oneByteOp64(OP_GROUP1_EvIb, GROUP1_OP_CMP, dst);
            m_formatter.immediate8(imm);
        } else {
            m_formatter.oneByteOp64(OP_GROUP1_EvIz, GROUP1_OP_CMP, dst);
            m_formatter.immediate32(imm);
        }
    }

    void cmpq_im(int imm, int offset, RegisterID base)
    {
        if (CAN_SIGN_EXTEND_8_32(imm)) {
            m_formatter.oneByteOp64(OP_GROUP1_EvIb, GROUP1_OP_CMP, base, offset);
            m_formatter.immediate8(imm);
        } else {
            m_formatter.oneByteOp64(OP_GROUP1_EvIz, GROUP1_OP_CMP, base, offset);
            m_formatter.immediate32(imm);
        }
    }

    void cmpq_im(int imm, int offset, RegisterID base, RegisterID index, int scale)
    {
        if (CAN_SIGN_EXTEND_8_32(imm)) {
            m_formatter.oneByteOp64(OP_GROUP1_EvIb, GROUP1_OP_CMP, base, index, scale, offset);
            m_formatter.immediate8(imm);
        } else {
            m_formatter.oneByteOp64(OP_GROUP1_EvIz, GROUP1_OP_CMP, base, index, scale, offset);
            m_formatter.immediate32(imm);
        }
    }
# 856 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/X86Assembler.h"
    void cmpw_ir(int imm, RegisterID dst)
    {
        if (CAN_SIGN_EXTEND_8_32(imm)) {
            m_formatter.prefix(PRE_OPERAND_SIZE);
            m_formatter.oneByteOp(OP_GROUP1_EvIb, GROUP1_OP_CMP, dst);
            m_formatter.immediate8(imm);
        } else {
            m_formatter.prefix(PRE_OPERAND_SIZE);
            m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_CMP, dst);
            m_formatter.immediate16(imm);
        }
    }

    void cmpw_rm(RegisterID src, int offset, RegisterID base, RegisterID index, int scale)
    {
        m_formatter.prefix(PRE_OPERAND_SIZE);
        m_formatter.oneByteOp(OP_CMP_EvGv, src, base, index, scale, offset);
    }

    void cmpw_im(int imm, int offset, RegisterID base, RegisterID index, int scale)
    {
        if (CAN_SIGN_EXTEND_8_32(imm)) {
            m_formatter.prefix(PRE_OPERAND_SIZE);
            m_formatter.oneByteOp(OP_GROUP1_EvIb, GROUP1_OP_CMP, base, index, scale, offset);
            m_formatter.immediate8(imm);
        } else {
            m_formatter.prefix(PRE_OPERAND_SIZE);
            m_formatter.oneByteOp(OP_GROUP1_EvIz, GROUP1_OP_CMP, base, index, scale, offset);
            m_formatter.immediate16(imm);
        }
    }

    void testl_rr(RegisterID src, RegisterID dst)
    {
        m_formatter.oneByteOp(OP_TEST_EvGv, src, dst);
    }

    void testl_i32r(int imm, RegisterID dst)
    {
        m_formatter.oneByteOp(OP_GROUP3_EvIz, GROUP3_OP_TEST, dst);
        m_formatter.immediate32(imm);
    }

    void testl_i32m(int imm, int offset, RegisterID base)
    {
        m_formatter.oneByteOp(OP_GROUP3_EvIz, GROUP3_OP_TEST, base, offset);
        m_formatter.immediate32(imm);
    }

    void testb_rr(RegisterID src, RegisterID dst)
    {
        m_formatter.oneByteOp8(OP_TEST_EbGb, src, dst);
    }

    void testb_im(int imm, int offset, RegisterID base)
    {
        m_formatter.oneByteOp(OP_GROUP3_EbIb, GROUP3_OP_TEST, base, offset);
        m_formatter.immediate8(imm);
    }

    void testb_im(int imm, int offset, RegisterID base, RegisterID index, int scale)
    {
        m_formatter.oneByteOp(OP_GROUP3_EbIb, GROUP3_OP_TEST, base, index, scale, offset);
        m_formatter.immediate8(imm);
    }

    void testl_i32m(int imm, int offset, RegisterID base, RegisterID index, int scale)
    {
        m_formatter.oneByteOp(OP_GROUP3_EvIz, GROUP3_OP_TEST, base, index, scale, offset);
        m_formatter.immediate32(imm);
    }


    void testq_rr(RegisterID src, RegisterID dst)
    {
        m_formatter.oneByteOp64(OP_TEST_EvGv, src, dst);
    }

    void testq_i32r(int imm, RegisterID dst)
    {
        m_formatter.oneByteOp64(OP_GROUP3_EvIz, GROUP3_OP_TEST, dst);
        m_formatter.immediate32(imm);
    }

    void testq_i32m(int imm, int offset, RegisterID base)
    {
        m_formatter.oneByteOp64(OP_GROUP3_EvIz, GROUP3_OP_TEST, base, offset);
        m_formatter.immediate32(imm);
    }

    void testq_i32m(int imm, int offset, RegisterID base, RegisterID index, int scale)
    {
        m_formatter.oneByteOp64(OP_GROUP3_EvIz, GROUP3_OP_TEST, base, index, scale, offset);
        m_formatter.immediate32(imm);
    }


    void testw_rr(RegisterID src, RegisterID dst)
    {
        m_formatter.prefix(PRE_OPERAND_SIZE);
        m_formatter.oneByteOp(OP_TEST_EvGv, src, dst);
    }

    void testb_i8r(int imm, RegisterID dst)
    {
        m_formatter.oneByteOp8(OP_GROUP3_EbIb, GROUP3_OP_TEST, dst);
        m_formatter.immediate8(imm);
    }

    void setCC_r(Condition cond, RegisterID dst)
    {
        m_formatter.twoByteOp8(setccOpcode(cond), (GroupOpcodeID)0, dst);
    }

    void sete_r(RegisterID dst)
    {
        m_formatter.twoByteOp8(setccOpcode(ConditionE), (GroupOpcodeID)0, dst);
    }

    void setz_r(RegisterID dst)
    {
        sete_r(dst);
    }

    void setne_r(RegisterID dst)
    {
        m_formatter.twoByteOp8(setccOpcode(ConditionNE), (GroupOpcodeID)0, dst);
    }

    void setnz_r(RegisterID dst)
    {
        setne_r(dst);
    }



    void cdq()
    {
        m_formatter.oneByteOp(OP_CDQ);
    }

    void fstpl(int offset, RegisterID base)
    {
        m_formatter.oneByteOp(OP_ESCAPE_DD, ESCAPE_DD_FSTP_doubleReal, base, offset);
    }

    void xchgl_rr(RegisterID src, RegisterID dst)
    {
        m_formatter.oneByteOp(OP_XCHG_EvGv, src, dst);
    }


    void xchgq_rr(RegisterID src, RegisterID dst)
    {
        m_formatter.oneByteOp64(OP_XCHG_EvGv, src, dst);
    }


    void movl_rr(RegisterID src, RegisterID dst)
    {
        m_formatter.oneByteOp(OP_MOV_EvGv, src, dst);
    }

    void movl_rm(RegisterID src, int offset, RegisterID base)
    {
        m_formatter.oneByteOp(OP_MOV_EvGv, src, base, offset);
    }

    void movl_rm_disp32(RegisterID src, int offset, RegisterID base)
    {
        m_formatter.oneByteOp_disp32(OP_MOV_EvGv, src, base, offset);
    }

    void movl_rm(RegisterID src, int offset, RegisterID base, RegisterID index, int scale)
    {
        m_formatter.oneByteOp(OP_MOV_EvGv, src, base, index, scale, offset);
    }

    void movl_mEAX(const void* addr)
    {
        m_formatter.oneByteOp(OP_MOV_EAXOv);

        m_formatter.immediate64(reinterpret_cast<int64_t>(addr));



    }

    void movl_mr(int offset, RegisterID base, RegisterID dst)
    {
        m_formatter.oneByteOp(OP_MOV_GvEv, dst, base, offset);
    }

    void movl_mr_disp32(int offset, RegisterID base, RegisterID dst)
    {
        m_formatter.oneByteOp_disp32(OP_MOV_GvEv, dst, base, offset);
    }

    void movl_mr_disp8(int offset, RegisterID base, RegisterID dst)
    {
        m_formatter.oneByteOp_disp8(OP_MOV_GvEv, dst, base, offset);
    }

    void movl_mr(int offset, RegisterID base, RegisterID index, int scale, RegisterID dst)
    {
        m_formatter.oneByteOp(OP_MOV_GvEv, dst, base, index, scale, offset);
    }

    void movl_i32r(int imm, RegisterID dst)
    {
        m_formatter.oneByteOp(OP_MOV_EAXIv, dst);
        m_formatter.immediate32(imm);
    }

    void movl_i32m(int imm, int offset, RegisterID base)
    {
        m_formatter.oneByteOp(OP_GROUP11_EvIz, GROUP11_MOV, base, offset);
        m_formatter.immediate32(imm);
    }

    void movl_i32m(int imm, int offset, RegisterID base, RegisterID index, int scale)
    {
        m_formatter.oneByteOp(OP_GROUP11_EvIz, GROUP11_MOV, base, index, scale, offset);
        m_formatter.immediate32(imm);
    }

    void movb_i8m(int imm, int offset, RegisterID base)
    {
        ((void)0);
        m_formatter.oneByteOp(OP_GROUP11_EvIb, GROUP11_MOV, base, offset);
        m_formatter.immediate8(imm);
    }

    void movb_i8m(int imm, int offset, RegisterID base, RegisterID index, int scale)
    {
        ((void)0);
        m_formatter.oneByteOp(OP_GROUP11_EvIb, GROUP11_MOV, base, index, scale, offset);
        m_formatter.immediate8(imm);
    }

    void movb_rm(RegisterID src, int offset, RegisterID base, RegisterID index, int scale)
    {
# 1116 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/X86Assembler.h"
        m_formatter.oneByteOp8(OP_MOV_EbGb, src, base, index, scale, offset);
    }

    void movl_EAXm(const void* addr)
    {
        m_formatter.oneByteOp(OP_MOV_OvEAX);

        m_formatter.immediate64(reinterpret_cast<int64_t>(addr));



    }


    void movq_rr(RegisterID src, RegisterID dst)
    {
        m_formatter.oneByteOp64(OP_MOV_EvGv, src, dst);
    }

    void movq_rm(RegisterID src, int offset, RegisterID base)
    {
        m_formatter.oneByteOp64(OP_MOV_EvGv, src, base, offset);
    }

    void movq_rm_disp32(RegisterID src, int offset, RegisterID base)
    {
        m_formatter.oneByteOp64_disp32(OP_MOV_EvGv, src, base, offset);
    }

    void movq_rm(RegisterID src, int offset, RegisterID base, RegisterID index, int scale)
    {
        m_formatter.oneByteOp64(OP_MOV_EvGv, src, base, index, scale, offset);
    }

    void movq_mEAX(const void* addr)
    {
        m_formatter.oneByteOp64(OP_MOV_EAXOv);
        m_formatter.immediate64(reinterpret_cast<int64_t>(addr));
    }

    void movq_EAXm(const void* addr)
    {
        m_formatter.oneByteOp64(OP_MOV_OvEAX);
        m_formatter.immediate64(reinterpret_cast<int64_t>(addr));
    }

    void movq_mr(int offset, RegisterID base, RegisterID dst)
    {
        m_formatter.oneByteOp64(OP_MOV_GvEv, dst, base, offset);
    }

    void movq_mr_disp32(int offset, RegisterID base, RegisterID dst)
    {
        m_formatter.oneByteOp64_disp32(OP_MOV_GvEv, dst, base, offset);
    }

    void movq_mr_disp8(int offset, RegisterID base, RegisterID dst)
    {
        m_formatter.oneByteOp64_disp8(OP_MOV_GvEv, dst, base, offset);
    }

    void movq_mr(int offset, RegisterID base, RegisterID index, int scale, RegisterID dst)
    {
        m_formatter.oneByteOp64(OP_MOV_GvEv, dst, base, index, scale, offset);
    }

    void movq_i32m(int imm, int offset, RegisterID base)
    {
        m_formatter.oneByteOp64(OP_GROUP11_EvIz, GROUP11_MOV, base, offset);
        m_formatter.immediate32(imm);
    }

    void movq_i64r(int64_t imm, RegisterID dst)
    {
        m_formatter.oneByteOp64(OP_MOV_EAXIv, dst);
        m_formatter.immediate64(imm);
    }

    void movsxd_rr(RegisterID src, RegisterID dst)
    {
        m_formatter.oneByteOp64(OP_MOVSXD_GvEv, dst, src);
    }
# 1224 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/X86Assembler.h"
    void movzwl_mr(int offset, RegisterID base, RegisterID dst)
    {
        m_formatter.twoByteOp(OP2_MOVZX_GvEw, dst, base, offset);
    }

    void movzwl_mr(int offset, RegisterID base, RegisterID index, int scale, RegisterID dst)
    {
        m_formatter.twoByteOp(OP2_MOVZX_GvEw, dst, base, index, scale, offset);
    }

    void movzbl_mr(int offset, RegisterID base, RegisterID index, int scale, RegisterID dst)
    {
        m_formatter.twoByteOp(OP2_MOVZX_GvEb, dst, base, index, scale, offset);
    }

    void movzbl_rr(RegisterID src, RegisterID dst)
    {



        m_formatter.twoByteOp8(OP2_MOVZX_GvEb, dst, src);
    }

    void leal_mr(int offset, RegisterID base, RegisterID dst)
    {
        m_formatter.oneByteOp(OP_LEA, dst, base, offset);
    }

    void leaq_mr(int offset, RegisterID base, RegisterID dst)
    {
        m_formatter.oneByteOp64(OP_LEA, dst, base, offset);
    }




    AssemblerLabel call()
    {
        m_formatter.oneByteOp(OP_CALL_rel32);
        return m_formatter.immediateRel32();
    }

    AssemblerLabel call(RegisterID dst)
    {
        m_formatter.oneByteOp(OP_GROUP5_Ev, GROUP5_OP_CALLN, dst);
        return m_formatter.label();
    }

    void call_m(int offset, RegisterID base)
    {
        m_formatter.oneByteOp(OP_GROUP5_Ev, GROUP5_OP_CALLN, base, offset);
    }

    AssemblerLabel jmp()
    {
        m_formatter.oneByteOp(OP_JMP_rel32);
        return m_formatter.immediateRel32();
    }




    AssemblerLabel jmp_r(RegisterID dst)
    {
        m_formatter.oneByteOp(OP_GROUP5_Ev, GROUP5_OP_JMPN, dst);
        return m_formatter.label();
    }

    void jmp_m(int offset, RegisterID base)
    {
        m_formatter.oneByteOp(OP_GROUP5_Ev, GROUP5_OP_JMPN, base, offset);
    }

    AssemblerLabel jne()
    {
        m_formatter.twoByteOp(jccRel32(ConditionNE));
        return m_formatter.immediateRel32();
    }

    AssemblerLabel jnz()
    {
        return jne();
    }

    AssemblerLabel je()
    {
        m_formatter.twoByteOp(jccRel32(ConditionE));
        return m_formatter.immediateRel32();
    }

    AssemblerLabel jz()
    {
        return je();
    }

    AssemblerLabel jl()
    {
        m_formatter.twoByteOp(jccRel32(ConditionL));
        return m_formatter.immediateRel32();
    }

    AssemblerLabel jb()
    {
        m_formatter.twoByteOp(jccRel32(ConditionB));
        return m_formatter.immediateRel32();
    }

    AssemblerLabel jle()
    {
        m_formatter.twoByteOp(jccRel32(ConditionLE));
        return m_formatter.immediateRel32();
    }

    AssemblerLabel jbe()
    {
        m_formatter.twoByteOp(jccRel32(ConditionBE));
        return m_formatter.immediateRel32();
    }

    AssemblerLabel jge()
    {
        m_formatter.twoByteOp(jccRel32(ConditionGE));
        return m_formatter.immediateRel32();
    }

    AssemblerLabel jg()
    {
        m_formatter.twoByteOp(jccRel32(ConditionG));
        return m_formatter.immediateRel32();
    }

    AssemblerLabel ja()
    {
        m_formatter.twoByteOp(jccRel32(ConditionA));
        return m_formatter.immediateRel32();
    }

    AssemblerLabel jae()
    {
        m_formatter.twoByteOp(jccRel32(ConditionAE));
        return m_formatter.immediateRel32();
    }

    AssemblerLabel jo()
    {
        m_formatter.twoByteOp(jccRel32(ConditionO));
        return m_formatter.immediateRel32();
    }

    AssemblerLabel jp()
    {
        m_formatter.twoByteOp(jccRel32(ConditionP));
        return m_formatter.immediateRel32();
    }

    AssemblerLabel js()
    {
        m_formatter.twoByteOp(jccRel32(ConditionS));
        return m_formatter.immediateRel32();
    }

    AssemblerLabel jCC(Condition cond)
    {
        m_formatter.twoByteOp(jccRel32(cond));
        return m_formatter.immediateRel32();
    }



    void addsd_rr(XMMRegisterID src, XMMRegisterID dst)
    {
        m_formatter.prefix(PRE_SSE_F2);
        m_formatter.twoByteOp(OP2_ADDSD_VsdWsd, (RegisterID)dst, (RegisterID)src);
    }

    void addsd_mr(int offset, RegisterID base, XMMRegisterID dst)
    {
        m_formatter.prefix(PRE_SSE_F2);
        m_formatter.twoByteOp(OP2_ADDSD_VsdWsd, (RegisterID)dst, base, offset);
    }
# 1413 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/X86Assembler.h"
    void cvtsi2sd_rr(RegisterID src, XMMRegisterID dst)
    {
        m_formatter.prefix(PRE_SSE_F2);
        m_formatter.twoByteOp(OP2_CVTSI2SD_VsdEd, (RegisterID)dst, src);
    }

    void cvtsi2sd_mr(int offset, RegisterID base, XMMRegisterID dst)
    {
        m_formatter.prefix(PRE_SSE_F2);
        m_formatter.twoByteOp(OP2_CVTSI2SD_VsdEd, (RegisterID)dst, base, offset);
    }
# 1433 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/X86Assembler.h"
    void cvttsd2si_rr(XMMRegisterID src, RegisterID dst)
    {
        m_formatter.prefix(PRE_SSE_F2);
        m_formatter.twoByteOp(OP2_CVTTSD2SI_GdWsd, dst, (RegisterID)src);
    }

    void movd_rr(XMMRegisterID src, RegisterID dst)
    {
        m_formatter.prefix(PRE_SSE_66);
        m_formatter.twoByteOp(OP2_MOVD_EdVd, (RegisterID)src, dst);
    }

    void movd_rr(RegisterID src, XMMRegisterID dst)
    {
        m_formatter.prefix(PRE_SSE_66);
        m_formatter.twoByteOp(OP2_MOVD_VdEd, (RegisterID)dst, src);
    }


    void movq_rr(XMMRegisterID src, RegisterID dst)
    {
        m_formatter.prefix(PRE_SSE_66);
        m_formatter.twoByteOp64(OP2_MOVD_EdVd, (RegisterID)src, dst);
    }

    void movq_rr(RegisterID src, XMMRegisterID dst)
    {
        m_formatter.prefix(PRE_SSE_66);
        m_formatter.twoByteOp64(OP2_MOVD_VdEd, (RegisterID)dst, src);
    }


    void movsd_rr(XMMRegisterID src, XMMRegisterID dst)
    {
        m_formatter.prefix(PRE_SSE_F2);
        m_formatter.twoByteOp(OP2_MOVSD_VsdWsd, (RegisterID)dst, (RegisterID)src);
    }

    void movsd_rm(XMMRegisterID src, int offset, RegisterID base)
    {
        m_formatter.prefix(PRE_SSE_F2);
        m_formatter.twoByteOp(OP2_MOVSD_WsdVsd, (RegisterID)src, base, offset);
    }

    void movsd_mr(int offset, RegisterID base, XMMRegisterID dst)
    {
        m_formatter.prefix(PRE_SSE_F2);
        m_formatter.twoByteOp(OP2_MOVSD_VsdWsd, (RegisterID)dst, base, offset);
    }
# 1496 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/X86Assembler.h"
    void mulsd_rr(XMMRegisterID src, XMMRegisterID dst)
    {
        m_formatter.prefix(PRE_SSE_F2);
        m_formatter.twoByteOp(OP2_MULSD_VsdWsd, (RegisterID)dst, (RegisterID)src);
    }

    void mulsd_mr(int offset, RegisterID base, XMMRegisterID dst)
    {
        m_formatter.prefix(PRE_SSE_F2);
        m_formatter.twoByteOp(OP2_MULSD_VsdWsd, (RegisterID)dst, base, offset);
    }

    void pextrw_irr(int whichWord, XMMRegisterID src, RegisterID dst)
    {
        m_formatter.prefix(PRE_SSE_66);
        m_formatter.twoByteOp(OP2_PEXTRW_GdUdIb, (RegisterID)dst, (RegisterID)src);
        m_formatter.immediate8(whichWord);
    }

    void psllq_i8r(int imm, XMMRegisterID dst)
    {
        m_formatter.prefix(PRE_SSE_66);
        m_formatter.twoByteOp8(OP2_PSLLQ_UdqIb, GROUP14_OP_PSLLQ, (RegisterID)dst);
        m_formatter.immediate8(imm);
    }

    void psrlq_i8r(int imm, XMMRegisterID dst)
    {
        m_formatter.prefix(PRE_SSE_66);
        m_formatter.twoByteOp8(OP2_PSRLQ_UdqIb, GROUP14_OP_PSRLQ, (RegisterID)dst);
        m_formatter.immediate8(imm);
    }

    void por_rr(XMMRegisterID src, XMMRegisterID dst)
    {
        m_formatter.prefix(PRE_SSE_66);
        m_formatter.twoByteOp(OP2_POR_VdqWdq, (RegisterID)dst, (RegisterID)src);
    }

    void subsd_rr(XMMRegisterID src, XMMRegisterID dst)
    {
        m_formatter.prefix(PRE_SSE_F2);
        m_formatter.twoByteOp(OP2_SUBSD_VsdWsd, (RegisterID)dst, (RegisterID)src);
    }

    void subsd_mr(int offset, RegisterID base, XMMRegisterID dst)
    {
        m_formatter.prefix(PRE_SSE_F2);
        m_formatter.twoByteOp(OP2_SUBSD_VsdWsd, (RegisterID)dst, base, offset);
    }

    void ucomisd_rr(XMMRegisterID src, XMMRegisterID dst)
    {
        m_formatter.prefix(PRE_SSE_66);
        m_formatter.twoByteOp(OP2_UCOMISD_VsdWsd, (RegisterID)dst, (RegisterID)src);
    }

    void ucomisd_mr(int offset, RegisterID base, XMMRegisterID dst)
    {
        m_formatter.prefix(PRE_SSE_66);
        m_formatter.twoByteOp(OP2_UCOMISD_VsdWsd, (RegisterID)dst, base, offset);
    }

    void divsd_rr(XMMRegisterID src, XMMRegisterID dst)
    {
        m_formatter.prefix(PRE_SSE_F2);
        m_formatter.twoByteOp(OP2_DIVSD_VsdWsd, (RegisterID)dst, (RegisterID)src);
    }

    void divsd_mr(int offset, RegisterID base, XMMRegisterID dst)
    {
        m_formatter.prefix(PRE_SSE_F2);
        m_formatter.twoByteOp(OP2_DIVSD_VsdWsd, (RegisterID)dst, base, offset);
    }

    void xorpd_rr(XMMRegisterID src, XMMRegisterID dst)
    {
        m_formatter.prefix(PRE_SSE_66);
        m_formatter.twoByteOp(OP2_XORPD_VpdWpd, (RegisterID)dst, (RegisterID)src);
    }

    void andnpd_rr(XMMRegisterID src, XMMRegisterID dst)
    {
        m_formatter.prefix(PRE_SSE_66);
        m_formatter.twoByteOp(OP2_ANDNPD_VpdWpd, (RegisterID)dst, (RegisterID)src);
    }

    void sqrtsd_rr(XMMRegisterID src, XMMRegisterID dst)
    {
        m_formatter.prefix(PRE_SSE_F2);
        m_formatter.twoByteOp(OP2_SQRTSD_VsdWsd, (RegisterID)dst, (RegisterID)src);
    }



    void int3()
    {
        m_formatter.oneByteOp(OP_INT3);
    }

    void ret()
    {
        m_formatter.oneByteOp(OP_RET);
    }

    void predictNotTaken()
    {
        m_formatter.prefix(PRE_PREDICT_BRANCH_NOT_TAKEN);
    }



    size_t codeSize() const
    {
        return m_formatter.codeSize();
    }

    AssemblerLabel label()
    {
        return m_formatter.label();
    }

    AssemblerLabel align(int alignment)
    {
        while (!m_formatter.isAligned(alignment))
            m_formatter.oneByteOp(OP_HLT);

        return label();
    }
# 1634 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/X86Assembler.h"
    void linkJump(AssemblerLabel from, AssemblerLabel to)
    {
        ((void)0);
        ((void)0);

        char* code = reinterpret_cast<char*>(m_formatter.data());
        ((void)0);
        setRel32(code + from.m_offset, code + to.m_offset);
    }

    static void linkJump(void* code, AssemblerLabel from, void* to)
    {
        ((void)0);

        setRel32(reinterpret_cast<char*>(code) + from.m_offset, to);
    }

    static void linkCall(void* code, AssemblerLabel from, void* to)
    {
        ((void)0);

        setRel32(reinterpret_cast<char*>(code) + from.m_offset, to);
    }

    static void linkPointer(void* code, AssemblerLabel where, void* value)
    {
        ((void)0);

        setPointer(reinterpret_cast<char*>(code) + where.m_offset, value);
    }

    static void relinkJump(void* from, void* to)
    {
        setRel32(from, to);
    }

    static void relinkCall(void* from, void* to)
    {
        setRel32(from, to);
    }

    static void repatchCompact(void* where, int32_t value)
    {
        ((void)0);
        ((void)0);
        setInt8(where, value);
    }

    static void repatchInt32(void* where, int32_t value)
    {
        setInt32(where, value);
    }

    static void repatchPointer(void* where, void* value)
    {
        setPointer(where, value);
    }

    static void* readPointer(void* where)
    {
        return reinterpret_cast<void**>(where)[-1];
    }

    static unsigned getCallReturnOffset(AssemblerLabel call)
    {
        ((void)0);
        return call.m_offset;
    }

    static void* getRelocatedAddress(void* code, AssemblerLabel label)
    {
        ((void)0);
        return reinterpret_cast<void*>(reinterpret_cast<ptrdiff_t>(code) + label.m_offset);
    }

    static int getDifferenceBetweenLabels(AssemblerLabel a, AssemblerLabel b)
    {
        return b.m_offset - a.m_offset;
    }

    PassRefPtr<ExecutableMemoryHandle> executableCopy(JSGlobalData& globalData)
    {
        return m_formatter.executableCopy(globalData);
    }

    void rewindToLabel(AssemblerLabel rewindTo) { m_formatter.rewindToLabel(rewindTo); }





    void nop()
    {
        m_formatter.oneByteOp(OP_NOP);
    }

private:

    static void setPointer(void* where, void* value)
    {
        reinterpret_cast<void**>(where)[-1] = value;
    }

    static void setInt32(void* where, int32_t value)
    {
        reinterpret_cast<int32_t*>(where)[-1] = value;
    }

    static void setInt8(void* where, int8_t value)
    {
        reinterpret_cast<int8_t*>(where)[-1] = value;
    }

    static void setRel32(void* from, void* to)
    {
        intptr_t offset = reinterpret_cast<intptr_t>(to) - reinterpret_cast<intptr_t>(from);
        ((void)0);

        setInt32(from, offset);
    }

    class X86InstructionFormatter {

        static const int maxInstructionSize = 16;

    public:





        void prefix(OneByteOpcodeID pre)
        {
            m_buffer.putByte(pre);
        }
# 1784 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/X86Assembler.h"
        void oneByteOp(OneByteOpcodeID opcode)
        {
            m_buffer.ensureSpace(maxInstructionSize);
            m_buffer.putByteUnchecked(opcode);
        }

        void oneByteOp(OneByteOpcodeID opcode, RegisterID reg)
        {
            m_buffer.ensureSpace(maxInstructionSize);
            emitRexIfNeeded(0, 0, reg);
            m_buffer.putByteUnchecked(opcode + (reg & 7));
        }

        void oneByteOp(OneByteOpcodeID opcode, int reg, RegisterID rm)
        {
            m_buffer.ensureSpace(maxInstructionSize);
            emitRexIfNeeded(reg, 0, rm);
            m_buffer.putByteUnchecked(opcode);
            registerModRM(reg, rm);
        }

        void oneByteOp(OneByteOpcodeID opcode, int reg, RegisterID base, int offset)
        {
            m_buffer.ensureSpace(maxInstructionSize);
            emitRexIfNeeded(reg, 0, base);
            m_buffer.putByteUnchecked(opcode);
            memoryModRM(reg, base, offset);
        }

        void oneByteOp_disp32(OneByteOpcodeID opcode, int reg, RegisterID base, int offset)
        {
            m_buffer.ensureSpace(maxInstructionSize);
            emitRexIfNeeded(reg, 0, base);
            m_buffer.putByteUnchecked(opcode);
            memoryModRM_disp32(reg, base, offset);
        }

        void oneByteOp_disp8(OneByteOpcodeID opcode, int reg, RegisterID base, int offset)
        {
            m_buffer.ensureSpace(maxInstructionSize);
            emitRexIfNeeded(reg, 0, base);
            m_buffer.putByteUnchecked(opcode);
            memoryModRM_disp8(reg, base, offset);
        }

        void oneByteOp(OneByteOpcodeID opcode, int reg, RegisterID base, RegisterID index, int scale, int offset)
        {
            m_buffer.ensureSpace(maxInstructionSize);
            emitRexIfNeeded(reg, index, base);
            m_buffer.putByteUnchecked(opcode);
            memoryModRM(reg, base, index, scale, offset);
        }
# 1846 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/X86Assembler.h"
        void twoByteOp(TwoByteOpcodeID opcode)
        {
            m_buffer.ensureSpace(maxInstructionSize);
            m_buffer.putByteUnchecked(OP_2BYTE_ESCAPE);
            m_buffer.putByteUnchecked(opcode);
        }

        void twoByteOp(TwoByteOpcodeID opcode, int reg, RegisterID rm)
        {
            m_buffer.ensureSpace(maxInstructionSize);
            emitRexIfNeeded(reg, 0, rm);
            m_buffer.putByteUnchecked(OP_2BYTE_ESCAPE);
            m_buffer.putByteUnchecked(opcode);
            registerModRM(reg, rm);
        }

        void twoByteOp(TwoByteOpcodeID opcode, int reg, RegisterID base, int offset)
        {
            m_buffer.ensureSpace(maxInstructionSize);
            emitRexIfNeeded(reg, 0, base);
            m_buffer.putByteUnchecked(OP_2BYTE_ESCAPE);
            m_buffer.putByteUnchecked(opcode);
            memoryModRM(reg, base, offset);
        }

        void twoByteOp(TwoByteOpcodeID opcode, int reg, RegisterID base, RegisterID index, int scale, int offset)
        {
            m_buffer.ensureSpace(maxInstructionSize);
            emitRexIfNeeded(reg, index, base);
            m_buffer.putByteUnchecked(OP_2BYTE_ESCAPE);
            m_buffer.putByteUnchecked(opcode);
            memoryModRM(reg, base, index, scale, offset);
        }
# 1897 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/X86Assembler.h"
        void oneByteOp64(OneByteOpcodeID opcode)
        {
            m_buffer.ensureSpace(maxInstructionSize);
            emitRexW(0, 0, 0);
            m_buffer.putByteUnchecked(opcode);
        }

        void oneByteOp64(OneByteOpcodeID opcode, RegisterID reg)
        {
            m_buffer.ensureSpace(maxInstructionSize);
            emitRexW(0, 0, reg);
            m_buffer.putByteUnchecked(opcode + (reg & 7));
        }

        void oneByteOp64(OneByteOpcodeID opcode, int reg, RegisterID rm)
        {
            m_buffer.ensureSpace(maxInstructionSize);
            emitRexW(reg, 0, rm);
            m_buffer.putByteUnchecked(opcode);
            registerModRM(reg, rm);
        }

        void oneByteOp64(OneByteOpcodeID opcode, int reg, RegisterID base, int offset)
        {
            m_buffer.ensureSpace(maxInstructionSize);
            emitRexW(reg, 0, base);
            m_buffer.putByteUnchecked(opcode);
            memoryModRM(reg, base, offset);
        }

        void oneByteOp64_disp32(OneByteOpcodeID opcode, int reg, RegisterID base, int offset)
        {
            m_buffer.ensureSpace(maxInstructionSize);
            emitRexW(reg, 0, base);
            m_buffer.putByteUnchecked(opcode);
            memoryModRM_disp32(reg, base, offset);
        }

        void oneByteOp64_disp8(OneByteOpcodeID opcode, int reg, RegisterID base, int offset)
        {
            m_buffer.ensureSpace(maxInstructionSize);
            emitRexW(reg, 0, base);
            m_buffer.putByteUnchecked(opcode);
            memoryModRM_disp8(reg, base, offset);
        }

        void oneByteOp64(OneByteOpcodeID opcode, int reg, RegisterID base, RegisterID index, int scale, int offset)
        {
            m_buffer.ensureSpace(maxInstructionSize);
            emitRexW(reg, index, base);
            m_buffer.putByteUnchecked(opcode);
            memoryModRM(reg, base, index, scale, offset);
        }

        void twoByteOp64(TwoByteOpcodeID opcode, int reg, RegisterID rm)
        {
            m_buffer.ensureSpace(maxInstructionSize);
            emitRexW(reg, 0, rm);
            m_buffer.putByteUnchecked(OP_2BYTE_ESCAPE);
            m_buffer.putByteUnchecked(opcode);
            registerModRM(reg, rm);
        }
# 1986 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/X86Assembler.h"
        void oneByteOp8(OneByteOpcodeID opcode, GroupOpcodeID groupOp, RegisterID rm)
        {
            m_buffer.ensureSpace(maxInstructionSize);
            emitRexIf(byteRegRequiresRex(rm), 0, 0, rm);
            m_buffer.putByteUnchecked(opcode);
            registerModRM(groupOp, rm);
        }

        void oneByteOp8(OneByteOpcodeID opcode, int reg, RegisterID rm)
        {
            m_buffer.ensureSpace(maxInstructionSize);
            emitRexIf(byteRegRequiresRex(reg) || byteRegRequiresRex(rm), reg, 0, rm);
            m_buffer.putByteUnchecked(opcode);
            registerModRM(reg, rm);
        }

        void oneByteOp8(OneByteOpcodeID opcode, int reg, RegisterID base, RegisterID index, int scale, int offset)
        {
            m_buffer.ensureSpace(maxInstructionSize);
            emitRexIf(byteRegRequiresRex(reg) || regRequiresRex(index) || regRequiresRex(base), reg, index, base);
            m_buffer.putByteUnchecked(opcode);
            memoryModRM(reg, base, index, scale, offset);
        }

        void twoByteOp8(TwoByteOpcodeID opcode, RegisterID reg, RegisterID rm)
        {
            m_buffer.ensureSpace(maxInstructionSize);
            emitRexIf(byteRegRequiresRex(reg)|byteRegRequiresRex(rm), reg, 0, rm);
            m_buffer.putByteUnchecked(OP_2BYTE_ESCAPE);
            m_buffer.putByteUnchecked(opcode);
            registerModRM(reg, rm);
        }

        void twoByteOp8(TwoByteOpcodeID opcode, GroupOpcodeID groupOp, RegisterID rm)
        {
            m_buffer.ensureSpace(maxInstructionSize);
            emitRexIf(byteRegRequiresRex(rm), 0, 0, rm);
            m_buffer.putByteUnchecked(OP_2BYTE_ESCAPE);
            m_buffer.putByteUnchecked(opcode);
            registerModRM(groupOp, rm);
        }






        void immediate8(int imm)
        {
            m_buffer.putByteUnchecked(imm);
        }

        void immediate16(int imm)
        {
            m_buffer.putShortUnchecked(imm);
        }

        void immediate32(int imm)
        {
            m_buffer.putIntUnchecked(imm);
        }

        void immediate64(int64_t imm)
        {
            m_buffer.putInt64Unchecked(imm);
        }

        AssemblerLabel immediateRel32()
        {
            m_buffer.putIntUnchecked(0);
            return label();
        }



        size_t codeSize() const { return m_buffer.codeSize(); }
        AssemblerLabel label() const { return m_buffer.label(); }
        bool isAligned(int alignment) const { return m_buffer.isAligned(alignment); }
        void* data() const { return m_buffer.data(); }

        PassRefPtr<ExecutableMemoryHandle> executableCopy(JSGlobalData& globalData)
        {
            return m_buffer.executableCopy(globalData);
        }

        void rewindToLabel(AssemblerLabel rewindTo) { m_buffer.rewindToLabel(rewindTo); }





    private:



        static const RegisterID noBase = X86Registers::ebp;
        static const RegisterID hasSib = X86Registers::esp;
        static const RegisterID noIndex = X86Registers::esp;

        static const RegisterID noBase2 = X86Registers::r13;
        static const RegisterID hasSib2 = X86Registers::r12;


        inline bool regRequiresRex(int reg)
        {
            return (reg >= X86Registers::r8);
        }


        inline bool byteRegRequiresRex(int reg)
        {
            return (reg >= X86Registers::esp);
        }


        inline void emitRex(bool w, int r, int x, int b)
        {
            m_buffer.putByteUnchecked(PRE_REX | ((int)w << 3) | ((r>>3)<<2) | ((x>>3)<<1) | (b>>3));
        }


        inline void emitRexW(int r, int x, int b)
        {
            emitRex(true, r, x, b);
        }



        inline void emitRexIf(bool condition, int r, int x, int b)
        {
            if (condition) emitRex(false, r, x, b);
        }


        inline void emitRexIfNeeded(int r, int x, int b)
        {
            emitRexIf(regRequiresRex(r) || regRequiresRex(x) || regRequiresRex(b), r, x, b);
        }
# 2132 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/X86Assembler.h"
        enum ModRmMode {
            ModRmMemoryNoDisp,
            ModRmMemoryDisp8,
            ModRmMemoryDisp32,
            ModRmRegister,
        };

        void putModRm(ModRmMode mode, int reg, RegisterID rm)
        {
            m_buffer.putByteUnchecked((mode << 6) | ((reg & 7) << 3) | (rm & 7));
        }

        void putModRmSib(ModRmMode mode, int reg, RegisterID base, RegisterID index, int scale)
        {
            ((void)0);

            putModRm(mode, reg, hasSib);
            m_buffer.putByteUnchecked((scale << 6) | ((index & 7) << 3) | (base & 7));
        }

        void registerModRM(int reg, RegisterID rm)
        {
            putModRm(ModRmRegister, reg, rm);
        }

        void memoryModRM(int reg, RegisterID base, int offset)
        {


            if ((base == hasSib) || (base == hasSib2)) {



                if (!offset)
                    putModRmSib(ModRmMemoryNoDisp, reg, base, noIndex, 0);
                else if (CAN_SIGN_EXTEND_8_32(offset)) {
                    putModRmSib(ModRmMemoryDisp8, reg, base, noIndex, 0);
                    m_buffer.putByteUnchecked(offset);
                } else {
                    putModRmSib(ModRmMemoryDisp32, reg, base, noIndex, 0);
                    m_buffer.putIntUnchecked(offset);
                }
            } else {

                if (!offset && (base != noBase) && (base != noBase2))



                    putModRm(ModRmMemoryNoDisp, reg, base);
                else if (CAN_SIGN_EXTEND_8_32(offset)) {
                    putModRm(ModRmMemoryDisp8, reg, base);
                    m_buffer.putByteUnchecked(offset);
                } else {
                    putModRm(ModRmMemoryDisp32, reg, base);
                    m_buffer.putIntUnchecked(offset);
                }
            }
        }

        void memoryModRM_disp8(int reg, RegisterID base, int offset)
        {

            ((void)0);

            if ((base == hasSib) || (base == hasSib2)) {



                putModRmSib(ModRmMemoryDisp8, reg, base, noIndex, 0);
                m_buffer.putByteUnchecked(offset);
            } else {
                putModRm(ModRmMemoryDisp8, reg, base);
                m_buffer.putByteUnchecked(offset);
            }
        }

        void memoryModRM_disp32(int reg, RegisterID base, int offset)
        {


            if ((base == hasSib) || (base == hasSib2)) {



                putModRmSib(ModRmMemoryDisp32, reg, base, noIndex, 0);
                m_buffer.putIntUnchecked(offset);
            } else {
                putModRm(ModRmMemoryDisp32, reg, base);
                m_buffer.putIntUnchecked(offset);
            }
        }

        void memoryModRM(int reg, RegisterID base, RegisterID index, int scale, int offset)
        {
            ((void)0);


            if (!offset && (base != noBase) && (base != noBase2))



                putModRmSib(ModRmMemoryNoDisp, reg, base, index, scale);
            else if (CAN_SIGN_EXTEND_8_32(offset)) {
                putModRmSib(ModRmMemoryDisp8, reg, base, index, scale);
                m_buffer.putByteUnchecked(offset);
            } else {
                putModRmSib(ModRmMemoryDisp32, reg, base, index, scale);
                m_buffer.putIntUnchecked(offset);
            }
        }
# 2252 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/X86Assembler.h"
        AssemblerBuffer m_buffer;
    } m_formatter;
};

}
# 32 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/MacroAssemblerX86Common.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/AbstractMacroAssembler.h" 1
# 29 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/AbstractMacroAssembler.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/CodeLocation.h" 1
# 33 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/CodeLocation.h"
namespace JSC {

class CodeLocationInstruction;
class CodeLocationLabel;
class CodeLocationJump;
class CodeLocationCall;
class CodeLocationNearCall;
class CodeLocationDataLabelCompact;
class CodeLocationDataLabel32;
class CodeLocationDataLabelPtr;
# 55 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/CodeLocation.h"
class CodeLocationCommon : public MacroAssemblerCodePtr {
public:
    CodeLocationInstruction instructionAtOffset(int offset);
    CodeLocationLabel labelAtOffset(int offset);
    CodeLocationJump jumpAtOffset(int offset);
    CodeLocationCall callAtOffset(int offset);
    CodeLocationNearCall nearCallAtOffset(int offset);
    CodeLocationDataLabelPtr dataLabelPtrAtOffset(int offset);
    CodeLocationDataLabel32 dataLabel32AtOffset(int offset);
    CodeLocationDataLabelCompact dataLabelCompactAtOffset(int offset);

protected:
    CodeLocationCommon()
    {
    }

    CodeLocationCommon(MacroAssemblerCodePtr location)
        : MacroAssemblerCodePtr(location)
    {
    }
};

class CodeLocationInstruction : public CodeLocationCommon {
public:
    CodeLocationInstruction() {}
    explicit CodeLocationInstruction(MacroAssemblerCodePtr location)
        : CodeLocationCommon(location) {}
    explicit CodeLocationInstruction(void* location)
        : CodeLocationCommon(MacroAssemblerCodePtr(location)) {}
};

class CodeLocationLabel : public CodeLocationCommon {
public:
    CodeLocationLabel() {}
    explicit CodeLocationLabel(MacroAssemblerCodePtr location)
        : CodeLocationCommon(location) {}
    explicit CodeLocationLabel(void* location)
        : CodeLocationCommon(MacroAssemblerCodePtr(location)) {}
};

class CodeLocationJump : public CodeLocationCommon {
public:
    CodeLocationJump() {}
    explicit CodeLocationJump(MacroAssemblerCodePtr location)
        : CodeLocationCommon(location) {}
    explicit CodeLocationJump(void* location)
        : CodeLocationCommon(MacroAssemblerCodePtr(location)) {}
};

class CodeLocationCall : public CodeLocationCommon {
public:
    CodeLocationCall() {}
    explicit CodeLocationCall(MacroAssemblerCodePtr location)
        : CodeLocationCommon(location) {}
    explicit CodeLocationCall(void* location)
        : CodeLocationCommon(MacroAssemblerCodePtr(location)) {}
};

class CodeLocationNearCall : public CodeLocationCommon {
public:
    CodeLocationNearCall() {}
    explicit CodeLocationNearCall(MacroAssemblerCodePtr location)
        : CodeLocationCommon(location) {}
    explicit CodeLocationNearCall(void* location)
        : CodeLocationCommon(MacroAssemblerCodePtr(location)) {}
};

class CodeLocationDataLabel32 : public CodeLocationCommon {
public:
    CodeLocationDataLabel32() {}
    explicit CodeLocationDataLabel32(MacroAssemblerCodePtr location)
        : CodeLocationCommon(location) {}
    explicit CodeLocationDataLabel32(void* location)
        : CodeLocationCommon(MacroAssemblerCodePtr(location)) {}
};

class CodeLocationDataLabelCompact : public CodeLocationCommon {
public:
    CodeLocationDataLabelCompact() { }
    explicit CodeLocationDataLabelCompact(MacroAssemblerCodePtr location)
        : CodeLocationCommon(location) { }
    explicit CodeLocationDataLabelCompact(void* location)
        : CodeLocationCommon(MacroAssemblerCodePtr(location)) { }
};

class CodeLocationDataLabelPtr : public CodeLocationCommon {
public:
    CodeLocationDataLabelPtr() {}
    explicit CodeLocationDataLabelPtr(MacroAssemblerCodePtr location)
        : CodeLocationCommon(location) {}
    explicit CodeLocationDataLabelPtr(void* location)
        : CodeLocationCommon(MacroAssemblerCodePtr(location)) {}
};

inline CodeLocationInstruction CodeLocationCommon::instructionAtOffset(int offset)
{
                                    ;
    return CodeLocationInstruction(reinterpret_cast<char*>(dataLocation()) + offset);
}

inline CodeLocationLabel CodeLocationCommon::labelAtOffset(int offset)
{
                                    ;
    return CodeLocationLabel(reinterpret_cast<char*>(dataLocation()) + offset);
}

inline CodeLocationJump CodeLocationCommon::jumpAtOffset(int offset)
{
                                    ;
    return CodeLocationJump(reinterpret_cast<char*>(dataLocation()) + offset);
}

inline CodeLocationCall CodeLocationCommon::callAtOffset(int offset)
{
                                    ;
    return CodeLocationCall(reinterpret_cast<char*>(dataLocation()) + offset);
}

inline CodeLocationNearCall CodeLocationCommon::nearCallAtOffset(int offset)
{
                                    ;
    return CodeLocationNearCall(reinterpret_cast<char*>(dataLocation()) + offset);
}

inline CodeLocationDataLabelPtr CodeLocationCommon::dataLabelPtrAtOffset(int offset)
{
                                    ;
    return CodeLocationDataLabelPtr(reinterpret_cast<char*>(dataLocation()) + offset);
}

inline CodeLocationDataLabel32 CodeLocationCommon::dataLabel32AtOffset(int offset)
{
                                    ;
    return CodeLocationDataLabel32(reinterpret_cast<char*>(dataLocation()) + offset);
}

inline CodeLocationDataLabelCompact CodeLocationCommon::dataLabelCompactAtOffset(int offset)
{
                                    ;
    return CodeLocationDataLabelCompact(reinterpret_cast<char*>(dataLocation()) + offset);
}

}
# 30 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/AbstractMacroAssembler.h" 2






namespace JSC {

class LinkBuffer;
class RepatchBuffer;

template <class AssemblerType>
class AbstractMacroAssembler {
public:
    friend class JITWriteBarrierBase;
    typedef AssemblerType AssemblerType_T;

    typedef MacroAssemblerCodePtr CodePtr;
    typedef MacroAssemblerCodeRef CodeRef;

    class Jump;

    typedef typename AssemblerType::RegisterID RegisterID;







    enum Scale {
        TimesOne,
        TimesTwo,
        TimesFour,
        TimesEight,
    };




    struct Address {
        explicit Address(RegisterID base, int32_t offset = 0)
            : base(base)
            , offset(offset)
        {
        }

        RegisterID base;
        int32_t offset;
    };

    struct ExtendedAddress {
        explicit ExtendedAddress(RegisterID base, intptr_t offset = 0)
            : base(base)
            , offset(offset)
        {
        }

        RegisterID base;
        intptr_t offset;
    };
# 106 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/AbstractMacroAssembler.h"
    struct ImplicitAddress {
        ImplicitAddress(RegisterID base)
            : base(base)
            , offset(0)
        {
        }

        ImplicitAddress(Address address)
            : base(address.base)
            , offset(address.offset)
        {
        }

        RegisterID base;
        int32_t offset;
    };




    struct BaseIndex {
        BaseIndex(RegisterID base, RegisterID index, Scale scale, int32_t offset = 0)
            : base(base)
            , index(index)
            , scale(scale)
            , offset(offset)
        {
        }

        RegisterID base;
        RegisterID index;
        Scale scale;
        int32_t offset;
    };





    struct AbsoluteAddress {
        explicit AbsoluteAddress(const void* ptr)
            : m_ptr(ptr)
        {
        }

        const void* m_ptr;
    };






    struct TrustedImmPtr {
        explicit TrustedImmPtr(const void* value)
            : m_value(value)
        {
        }



        explicit TrustedImmPtr(int value)
            : m_value(0)
        {
            ((void)value);
        }

        explicit TrustedImmPtr(size_t value)
            : m_value(reinterpret_cast<void*>(value))
        {
        }

        intptr_t asIntptr()
        {
            return reinterpret_cast<intptr_t>(m_value);
        }

        const void* m_value;
    };

    struct ImmPtr : public TrustedImmPtr {
        explicit ImmPtr(const void* value)
            : TrustedImmPtr(value)
        {
        }
    };







    struct TrustedImm32 {
        explicit TrustedImm32(int32_t value)
            : m_value(value)



        {
        }
# 218 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/AbstractMacroAssembler.h"
        int32_t m_value;
# 229 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/AbstractMacroAssembler.h"
    };


    struct Imm32 : public TrustedImm32 {
        explicit Imm32(int32_t value)
            : TrustedImm32(value)
        {
        }






    };
# 257 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/AbstractMacroAssembler.h"
    class Label {
        template<class TemplateAssemblerType>
        friend class AbstractMacroAssembler;
        friend class Jump;
        friend class MacroAssemblerCodeRef;
        friend class LinkBuffer;

    public:
        Label()
        {
        }

        Label(AbstractMacroAssembler<AssemblerType>* masm)
            : m_label(masm->m_assembler.label())
        {
        }

        bool isSet() const { return m_label.isSet(); }
    private:
        AssemblerLabel m_label;
    };





    class DataLabelPtr {
        template<class TemplateAssemblerType>
        friend class AbstractMacroAssembler;
        friend class LinkBuffer;
    public:
        DataLabelPtr()
        {
        }

        DataLabelPtr(AbstractMacroAssembler<AssemblerType>* masm)
            : m_label(masm->m_assembler.label())
        {
        }

        bool isSet() const { return m_label.isSet(); }

    private:
        AssemblerLabel m_label;
    };





    class DataLabel32 {
        template<class TemplateAssemblerType>
        friend class AbstractMacroAssembler;
        friend class LinkBuffer;
    public:
        DataLabel32()
        {
        }

        DataLabel32(AbstractMacroAssembler<AssemblerType>* masm)
            : m_label(masm->m_assembler.label())
        {
        }

        AssemblerLabel label() const { return m_label; }

    private:
        AssemblerLabel m_label;
    };





    class DataLabelCompact {
        template<class TemplateAssemblerType>
        friend class AbstractMacroAssembler;
        friend class LinkBuffer;
    public:
        DataLabelCompact()
        {
        }

        DataLabelCompact(AbstractMacroAssembler<AssemblerType>* masm)
            : m_label(masm->m_assembler.label())
        {
        }

        DataLabelCompact(AssemblerLabel label)
            : m_label(label)
        {
        }

    private:
        AssemblerLabel m_label;
    };







    class Call {
        template<class TemplateAssemblerType>
        friend class AbstractMacroAssembler;

    public:
        enum Flags {
            None = 0x0,
            Linkable = 0x1,
            Near = 0x2,
            LinkableNear = 0x3,
        };

        Call()
            : m_flags(None)
        {
        }

        Call(AssemblerLabel jmp, Flags flags)
            : m_label(jmp)
            , m_flags(flags)
        {
        }

        bool isFlagSet(Flags flag)
        {
            return m_flags & flag;
        }

        static Call fromTailJump(Jump jump)
        {
            return Call(jump.m_label, Linkable);
        }

        AssemblerLabel m_label;
    private:
        Flags m_flags;
    };







    class Jump {
        template<class TemplateAssemblerType>
        friend class AbstractMacroAssembler;
        friend class Call;
        friend class LinkBuffer;
    public:
        Jump()
        {
        }
# 423 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/AbstractMacroAssembler.h"
        Jump(AssemblerLabel jmp)
            : m_label(jmp)
        {
        }


        void link(AbstractMacroAssembler<AssemblerType>* masm) const
        {



            masm->m_assembler.linkJump(m_label, masm->m_assembler.label());

        }

        void linkTo(Label label, AbstractMacroAssembler<AssemblerType>* masm) const
        {



            masm->m_assembler.linkJump(m_label, label.m_label);

        }

        bool isSet() const { return m_label.isSet(); }

    private:
        AssemblerLabel m_label;




    };





    class JumpList {
        friend class LinkBuffer;

    public:
        typedef Vector<Jump, 16> JumpVector;

        void link(AbstractMacroAssembler<AssemblerType>* masm)
        {
            size_t size = m_jumps.size();
            for (size_t i = 0; i < size; ++i)
                m_jumps[i].link(masm);
            m_jumps.clear();
        }

        void linkTo(Label label, AbstractMacroAssembler<AssemblerType>* masm)
        {
            size_t size = m_jumps.size();
            for (size_t i = 0; i < size; ++i)
                m_jumps[i].linkTo(label, masm);
            m_jumps.clear();
        }

        void append(Jump jump)
        {
            m_jumps.append(jump);
        }

        void append(JumpList& other)
        {
            m_jumps.append(other.m_jumps.begin(), other.m_jumps.size());
        }

        bool empty()
        {
            return !m_jumps.size();
        }

        void clear()
        {
            m_jumps.clear();
        }

        const JumpVector& jumps() { return m_jumps; }

    private:
        JumpVector m_jumps;
    };



    Label label()
    {
        return Label(this);
    }

    Label align()
    {
        m_assembler.align(16);
        return Label(this);
    }

    template<typename T, typename U>
    ptrdiff_t differenceBetween(T from, U to)
    {
        return AssemblerType::getDifferenceBetweenLabels(from.m_label, to.m_label);
    }



    void rewindToLabel(Label rewindTo) { m_assembler.rewindToLabel(rewindTo.m_label); }


    void beginUninterruptedSequence() { }
    void endUninterruptedSequence() { }





protected:
    AssemblerType m_assembler;

    friend class LinkBuffer;
    friend class RepatchBuffer;

    static void linkJump(void* code, Jump jump, CodeLocationLabel target)
    {
        AssemblerType::linkJump(code, jump.m_label, target.dataLocation());
    }

    static void linkPointer(void* code, AssemblerLabel label, void* value)
    {
        AssemblerType::linkPointer(code, label, value);
    }

    static void* getLinkerAddress(void* code, AssemblerLabel label)
    {
        return AssemblerType::getRelocatedAddress(code, label);
    }

    static unsigned getLinkerCallReturnOffset(Call call)
    {
        return AssemblerType::getCallReturnOffset(call.m_label);
    }

    static void repatchJump(CodeLocationJump jump, CodeLocationLabel destination)
    {
        AssemblerType::relinkJump(jump.dataLocation(), destination.dataLocation());
    }

    static void repatchNearCall(CodeLocationNearCall nearCall, CodeLocationLabel destination)
    {
        AssemblerType::relinkCall(nearCall.dataLocation(), destination.executableAddress());
    }

    static void repatchCompact(CodeLocationDataLabelCompact dataLabelCompact, int32_t value)
    {
        AssemblerType::repatchCompact(dataLabelCompact.dataLocation(), value);
    }

    static void repatchInt32(CodeLocationDataLabel32 dataLabel32, int32_t value)
    {
        AssemblerType::repatchInt32(dataLabel32.dataLocation(), value);
    }

    static void repatchPointer(CodeLocationDataLabelPtr dataLabelPtr, void* value)
    {
        AssemblerType::repatchPointer(dataLabelPtr.dataLocation(), value);
    }

    static void* readPointer(CodeLocationDataLabelPtr dataLabelPtr)
    {
        return AssemblerType::readPointer(dataLabelPtr.dataLocation());
    }
};

}
# 33 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/MacroAssemblerX86Common.h" 2

namespace JSC {

class MacroAssemblerX86Common : public AbstractMacroAssembler<X86Assembler> {
    static const int DoubleConditionBitInvert = 0x10;
    static const int DoubleConditionBitSpecial = 0x20;
    static const int DoubleConditionBits = DoubleConditionBitInvert | DoubleConditionBitSpecial;

public:
    typedef X86Assembler::FPRegisterID FPRegisterID;
    typedef X86Assembler::XMMRegisterID XMMRegisterID;

    static const int MaximumCompactPtrAlignedAddressOffset = 127;

    enum RelationalCondition {
        Equal = X86Assembler::ConditionE,
        NotEqual = X86Assembler::ConditionNE,
        Above = X86Assembler::ConditionA,
        AboveOrEqual = X86Assembler::ConditionAE,
        Below = X86Assembler::ConditionB,
        BelowOrEqual = X86Assembler::ConditionBE,
        GreaterThan = X86Assembler::ConditionG,
        GreaterThanOrEqual = X86Assembler::ConditionGE,
        LessThan = X86Assembler::ConditionL,
        LessThanOrEqual = X86Assembler::ConditionLE
    };

    enum ResultCondition {
        Overflow = X86Assembler::ConditionO,
        Signed = X86Assembler::ConditionS,
        Zero = X86Assembler::ConditionE,
        NonZero = X86Assembler::ConditionNE
    };

    enum DoubleCondition {

        DoubleEqual = X86Assembler::ConditionE | DoubleConditionBitSpecial,
        DoubleNotEqual = X86Assembler::ConditionNE,
        DoubleGreaterThan = X86Assembler::ConditionA,
        DoubleGreaterThanOrEqual = X86Assembler::ConditionAE,
        DoubleLessThan = X86Assembler::ConditionA | DoubleConditionBitInvert,
        DoubleLessThanOrEqual = X86Assembler::ConditionAE | DoubleConditionBitInvert,

        DoubleEqualOrUnordered = X86Assembler::ConditionE,
        DoubleNotEqualOrUnordered = X86Assembler::ConditionNE | DoubleConditionBitSpecial,
        DoubleGreaterThanOrUnordered = X86Assembler::ConditionB | DoubleConditionBitInvert,
        DoubleGreaterThanOrEqualOrUnordered = X86Assembler::ConditionBE | DoubleConditionBitInvert,
        DoubleLessThanOrUnordered = X86Assembler::ConditionB,
        DoubleLessThanOrEqualOrUnordered = X86Assembler::ConditionBE,
    };
    typedef int dummyDoubleConditionBits_should_not_interfere_with_X86Assembler_Condition_codes [(!((X86Assembler::ConditionE | X86Assembler::ConditionNE | X86Assembler::ConditionA | X86Assembler::ConditionAE | X86Assembler::ConditionB | X86Assembler::ConditionBE) & DoubleConditionBits)) ? 1 : -1];



    static const RegisterID stackPointerRegister = X86Registers::esp;
# 96 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/MacroAssemblerX86Common.h"
    void add32(RegisterID src, RegisterID dest)
    {
        m_assembler.addl_rr(src, dest);
    }

    void add32(TrustedImm32 imm, Address address)
    {
        m_assembler.addl_im(imm.m_value, address.offset, address.base);
    }

    void add32(TrustedImm32 imm, RegisterID dest)
    {
        m_assembler.addl_ir(imm.m_value, dest);
    }

    void add32(Address src, RegisterID dest)
    {
        m_assembler.addl_mr(src.offset, src.base, dest);
    }

    void add32(RegisterID src, Address dest)
    {
        m_assembler.addl_rm(src, dest.offset, dest.base);
    }

    void and32(RegisterID src, RegisterID dest)
    {
        m_assembler.andl_rr(src, dest);
    }

    void and32(TrustedImm32 imm, RegisterID dest)
    {
        m_assembler.andl_ir(imm.m_value, dest);
    }

    void and32(RegisterID src, Address dest)
    {
        m_assembler.andl_rm(src, dest.offset, dest.base);
    }

    void and32(Address src, RegisterID dest)
    {
        m_assembler.andl_mr(src.offset, src.base, dest);
    }

    void and32(TrustedImm32 imm, Address address)
    {
        m_assembler.andl_im(imm.m_value, address.offset, address.base);
    }

    void and32(RegisterID op1, RegisterID op2, RegisterID dest)
    {
        if (op1 == op2)
            zeroExtend32ToPtr(op1, dest);
        else if (op1 == dest)
            and32(op2, dest);
        else {
            move(op2, dest);
            and32(op1, dest);
        }
    }

    void and32(TrustedImm32 imm, RegisterID src, RegisterID dest)
    {
        move(src, dest);
        and32(imm, dest);
    }

    void lshift32(RegisterID shift_amount, RegisterID dest)
    {
        ((void)0);

        if (shift_amount == X86Registers::ecx)
            m_assembler.shll_CLr(dest);
        else {



            swap(shift_amount, X86Registers::ecx);
            m_assembler.shll_CLr(dest == X86Registers::ecx ? shift_amount : dest);
            swap(shift_amount, X86Registers::ecx);
        }
    }

    void lshift32(RegisterID src, RegisterID shift_amount, RegisterID dest)
    {
        ((void)0);

        if (src != dest)
            move(src, dest);
        lshift32(shift_amount, dest);
    }

    void lshift32(TrustedImm32 imm, RegisterID dest)
    {
        m_assembler.shll_i8r(imm.m_value, dest);
    }

    void lshift32(RegisterID src, TrustedImm32 imm, RegisterID dest)
    {
        if (src != dest)
            move(src, dest);
        lshift32(imm, dest);
    }

    void mul32(RegisterID src, RegisterID dest)
    {
        m_assembler.imull_rr(src, dest);
    }

    void mul32(Address src, RegisterID dest)
    {
        m_assembler.imull_mr(src.offset, src.base, dest);
    }

    void mul32(TrustedImm32 imm, RegisterID src, RegisterID dest)
    {
        m_assembler.imull_i32r(src, imm.m_value, dest);
    }

    void neg32(RegisterID srcDest)
    {
        m_assembler.negl_r(srcDest);
    }

    void neg32(Address srcDest)
    {
        m_assembler.negl_m(srcDest.offset, srcDest.base);
    }

    void not32(RegisterID srcDest)
    {
        m_assembler.notl_r(srcDest);
    }

    void not32(Address srcDest)
    {
        m_assembler.notl_m(srcDest.offset, srcDest.base);
    }

    void or32(RegisterID src, RegisterID dest)
    {
        m_assembler.orl_rr(src, dest);
    }

    void or32(TrustedImm32 imm, RegisterID dest)
    {
        m_assembler.orl_ir(imm.m_value, dest);
    }

    void or32(RegisterID src, Address dest)
    {
        m_assembler.orl_rm(src, dest.offset, dest.base);
    }

    void or32(Address src, RegisterID dest)
    {
        m_assembler.orl_mr(src.offset, src.base, dest);
    }

    void or32(TrustedImm32 imm, Address address)
    {
        m_assembler.orl_im(imm.m_value, address.offset, address.base);
    }

    void or32(RegisterID op1, RegisterID op2, RegisterID dest)
    {
        if (op1 == op2)
            zeroExtend32ToPtr(op1, dest);
        else if (op1 == dest)
            or32(op2, dest);
        else {
            move(op2, dest);
            or32(op1, dest);
        }
    }

    void or32(TrustedImm32 imm, RegisterID src, RegisterID dest)
    {
        move(src, dest);
        or32(imm, dest);
    }

    void rshift32(RegisterID shift_amount, RegisterID dest)
    {
        ((void)0);

        if (shift_amount == X86Registers::ecx)
            m_assembler.sarl_CLr(dest);
        else {



            swap(shift_amount, X86Registers::ecx);
            m_assembler.sarl_CLr(dest == X86Registers::ecx ? shift_amount : dest);
            swap(shift_amount, X86Registers::ecx);
        }
    }

    void rshift32(RegisterID src, RegisterID shift_amount, RegisterID dest)
    {
        ((void)0);

        if (src != dest)
            move(src, dest);
        rshift32(shift_amount, dest);
    }

    void rshift32(TrustedImm32 imm, RegisterID dest)
    {
        m_assembler.sarl_i8r(imm.m_value, dest);
    }

    void rshift32(RegisterID src, TrustedImm32 imm, RegisterID dest)
    {
        if (src != dest)
            move(src, dest);
        rshift32(imm, dest);
    }

    void urshift32(RegisterID shift_amount, RegisterID dest)
    {
        ((void)0);

        if (shift_amount == X86Registers::ecx)
            m_assembler.shrl_CLr(dest);
        else {



            swap(shift_amount, X86Registers::ecx);
            m_assembler.shrl_CLr(dest == X86Registers::ecx ? shift_amount : dest);
            swap(shift_amount, X86Registers::ecx);
        }
    }

    void urshift32(RegisterID src, RegisterID shift_amount, RegisterID dest)
    {
        ((void)0);

        if (src != dest)
            move(src, dest);
        urshift32(shift_amount, dest);
    }

    void urshift32(TrustedImm32 imm, RegisterID dest)
    {
        m_assembler.shrl_i8r(imm.m_value, dest);
    }

    void urshift32(RegisterID src, TrustedImm32 imm, RegisterID dest)
    {
        if (src != dest)
            move(src, dest);
        urshift32(imm, dest);
    }

    void sub32(RegisterID src, RegisterID dest)
    {
        m_assembler.subl_rr(src, dest);
    }

    void sub32(TrustedImm32 imm, RegisterID dest)
    {
        m_assembler.subl_ir(imm.m_value, dest);
    }

    void sub32(TrustedImm32 imm, Address address)
    {
        m_assembler.subl_im(imm.m_value, address.offset, address.base);
    }

    void sub32(Address src, RegisterID dest)
    {
        m_assembler.subl_mr(src.offset, src.base, dest);
    }

    void sub32(RegisterID src, Address dest)
    {
        m_assembler.subl_rm(src, dest.offset, dest.base);
    }


    void xor32(RegisterID src, RegisterID dest)
    {
        m_assembler.xorl_rr(src, dest);
    }

    void xor32(TrustedImm32 imm, Address dest)
    {
        m_assembler.xorl_im(imm.m_value, dest.offset, dest.base);
    }

    void xor32(TrustedImm32 imm, RegisterID dest)
    {
        m_assembler.xorl_ir(imm.m_value, dest);
    }

    void xor32(RegisterID src, Address dest)
    {
        m_assembler.xorl_rm(src, dest.offset, dest.base);
    }

    void xor32(Address src, RegisterID dest)
    {
        m_assembler.xorl_mr(src.offset, src.base, dest);
    }

    void xor32(RegisterID op1, RegisterID op2, RegisterID dest)
    {
        if (op1 == op2)
            move(TrustedImm32(0), dest);
        else if (op1 == dest)
            xor32(op2, dest);
        else {
            move(op2, dest);
            xor32(op1, dest);
        }
    }

    void xor32(TrustedImm32 imm, RegisterID src, RegisterID dest)
    {
        move(src, dest);
        xor32(imm, dest);
    }

    void sqrtDouble(FPRegisterID src, FPRegisterID dst)
    {
        m_assembler.sqrtsd_rr(src, dst);
    }

    void andnotDouble(FPRegisterID src, FPRegisterID dst)
    {
        m_assembler.andnpd_rr(src, dst);
    }
# 439 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/MacroAssemblerX86Common.h"
    void load32(ImplicitAddress address, RegisterID dest)
    {
        m_assembler.movl_mr(address.offset, address.base, dest);
    }

    void load32(BaseIndex address, RegisterID dest)
    {
        m_assembler.movl_mr(address.offset, address.base, address.index, address.scale, dest);
    }

    void load32WithUnalignedHalfWords(BaseIndex address, RegisterID dest)
    {
        load32(address, dest);
    }

    DataLabel32 load32WithAddressOffsetPatch(Address address, RegisterID dest)
    {
        m_assembler.movl_mr_disp32(address.offset, address.base, dest);
        return DataLabel32(this);
    }

    DataLabelCompact load32WithCompactAddressOffsetPatch(Address address, RegisterID dest)
    {
        m_assembler.movl_mr_disp8(address.offset, address.base, dest);
        return DataLabelCompact(this);
    }

    static void repatchCompact(CodeLocationDataLabelCompact dataLabelCompact, int32_t value)
    {
        ((void)0);
        ((void)0);
        AssemblerType_T::repatchCompact(dataLabelCompact.dataLocation(), value);
    }

    DataLabelCompact loadCompactWithAddressOffsetPatch(Address address, RegisterID dest)
    {
        m_assembler.movl_mr_disp8(address.offset, address.base, dest);
        return DataLabelCompact(this);
    }

    void load8(BaseIndex address, RegisterID dest)
    {
        m_assembler.movzbl_mr(address.offset, address.base, address.index, address.scale, dest);
    }

    void load16(BaseIndex address, RegisterID dest)
    {
        m_assembler.movzwl_mr(address.offset, address.base, address.index, address.scale, dest);
    }

    void load16(Address address, RegisterID dest)
    {
        m_assembler.movzwl_mr(address.offset, address.base, dest);
    }

    DataLabel32 store32WithAddressOffsetPatch(RegisterID src, Address address)
    {
        m_assembler.movl_rm_disp32(src, address.offset, address.base);
        return DataLabel32(this);
    }

    void store32(RegisterID src, ImplicitAddress address)
    {
        m_assembler.movl_rm(src, address.offset, address.base);
    }

    void store32(RegisterID src, BaseIndex address)
    {
        m_assembler.movl_rm(src, address.offset, address.base, address.index, address.scale);
    }

    void store32(TrustedImm32 imm, ImplicitAddress address)
    {
        m_assembler.movl_i32m(imm.m_value, address.offset, address.base);
    }

    void store32(TrustedImm32 imm, BaseIndex address)
    {
        m_assembler.movl_i32m(imm.m_value, address.offset, address.base, address.index, address.scale);
    }

    void store8(TrustedImm32 imm, Address address)
    {
        ((void)0);
        m_assembler.movb_i8m(imm.m_value, address.offset, address.base);
    }

    void store8(TrustedImm32 imm, BaseIndex address)
    {
        ((void)0);
        m_assembler.movb_i8m(imm.m_value, address.offset, address.base, address.index, address.scale);
    }

    void store8(RegisterID src, BaseIndex address)
    {
        m_assembler.movb_rm(src, address.offset, address.base, address.index, address.scale);
    }






    void moveDouble(FPRegisterID src, FPRegisterID dest)
    {
        ((void)0);
        if (src != dest)
            m_assembler.movsd_rr(src, dest);
    }

    void loadDouble(ImplicitAddress address, FPRegisterID dest)
    {
        ((void)0);
        m_assembler.movsd_mr(address.offset, address.base, dest);
    }

    void storeDouble(FPRegisterID src, ImplicitAddress address)
    {
        ((void)0);
        m_assembler.movsd_rm(src, address.offset, address.base);
    }

    void addDouble(FPRegisterID src, FPRegisterID dest)
    {
        ((void)0);
        m_assembler.addsd_rr(src, dest);
    }

    void addDouble(FPRegisterID op1, FPRegisterID op2, FPRegisterID dest)
    {
        ((void)0);
        if (op1 == dest)
            addDouble(op2, dest);
        else {
            moveDouble(op2, dest);
            addDouble(op1, dest);
        }
    }

    void addDouble(Address src, FPRegisterID dest)
    {
        ((void)0);
        m_assembler.addsd_mr(src.offset, src.base, dest);
    }

    void divDouble(FPRegisterID src, FPRegisterID dest)
    {
        ((void)0);
        m_assembler.divsd_rr(src, dest);
    }

    void divDouble(FPRegisterID op1, FPRegisterID op2, FPRegisterID dest)
    {

        ((void)0);

        moveDouble(op1, dest);
        divDouble(op2, dest);
    }

    void divDouble(Address src, FPRegisterID dest)
    {
        ((void)0);
        m_assembler.divsd_mr(src.offset, src.base, dest);
    }

    void subDouble(FPRegisterID src, FPRegisterID dest)
    {
        ((void)0);
        m_assembler.subsd_rr(src, dest);
    }

    void subDouble(FPRegisterID op1, FPRegisterID op2, FPRegisterID dest)
    {

        ((void)0);

        moveDouble(op1, dest);
        subDouble(op2, dest);
    }

    void subDouble(Address src, FPRegisterID dest)
    {
        ((void)0);
        m_assembler.subsd_mr(src.offset, src.base, dest);
    }

    void mulDouble(FPRegisterID src, FPRegisterID dest)
    {
        ((void)0);
        m_assembler.mulsd_rr(src, dest);
    }

    void mulDouble(FPRegisterID op1, FPRegisterID op2, FPRegisterID dest)
    {
        ((void)0);
        if (op1 == dest)
            mulDouble(op2, dest);
        else {
            moveDouble(op2, dest);
            mulDouble(op1, dest);
        }
    }

    void mulDouble(Address src, FPRegisterID dest)
    {
        ((void)0);
        m_assembler.mulsd_mr(src.offset, src.base, dest);
    }

    void convertInt32ToDouble(RegisterID src, FPRegisterID dest)
    {
        ((void)0);
        m_assembler.cvtsi2sd_rr(src, dest);
    }

    void convertInt32ToDouble(Address src, FPRegisterID dest)
    {
        ((void)0);
        m_assembler.cvtsi2sd_mr(src.offset, src.base, dest);
    }

    Jump branchDouble(DoubleCondition cond, FPRegisterID left, FPRegisterID right)
    {
        ((void)0);

        if (cond & DoubleConditionBitInvert)
            m_assembler.ucomisd_rr(left, right);
        else
            m_assembler.ucomisd_rr(right, left);

        if (cond == DoubleEqual) {
            Jump isUnordered(m_assembler.jp());
            Jump result = Jump(m_assembler.je());
            isUnordered.link(this);
            return result;
        } else if (cond == DoubleNotEqualOrUnordered) {
            Jump isUnordered(m_assembler.jp());
            Jump isEqual(m_assembler.je());
            isUnordered.link(this);
            Jump result = jump();
            isEqual.link(this);
            return result;
        }

        ((void)0);
        return Jump(m_assembler.jCC(static_cast<X86Assembler::Condition>(cond & ~DoubleConditionBits)));
    }





    enum BranchTruncateType { BranchIfTruncateFailed, BranchIfTruncateSuccessful };
    Jump branchTruncateDoubleToInt32(FPRegisterID src, RegisterID dest, BranchTruncateType branchType = BranchIfTruncateFailed)
    {
        ((void)0);
        m_assembler.cvttsd2si_rr(src, dest);
        return branch32(branchType ? NotEqual : Equal, dest, TrustedImm32(0x80000000));
    }

    void truncateDoubleToInt32(FPRegisterID src, RegisterID dest)
    {
        ((void)0);
        m_assembler.cvttsd2si_rr(src, dest);
    }





    void branchConvertDoubleToInt32(FPRegisterID src, RegisterID dest, JumpList& failureCases, FPRegisterID fpTemp)
    {
        ((void)0);
        m_assembler.cvttsd2si_rr(src, dest);


        failureCases.append(branchTest32(Zero, dest));


        convertInt32ToDouble(dest, fpTemp);
        m_assembler.ucomisd_rr(fpTemp, src);
        failureCases.append(m_assembler.jp());
        failureCases.append(m_assembler.jne());
    }

    Jump branchDoubleNonZero(FPRegisterID reg, FPRegisterID scratch)
    {
        ((void)0);
        m_assembler.xorpd_rr(scratch, scratch);
        return branchDouble(DoubleNotEqual, reg, scratch);
    }

    Jump branchDoubleZeroOrNaN(FPRegisterID reg, FPRegisterID scratch)
    {
        ((void)0);
        m_assembler.xorpd_rr(scratch, scratch);
        return branchDouble(DoubleEqualOrUnordered, reg, scratch);
    }

    void lshiftPacked(TrustedImm32 imm, XMMRegisterID reg)
    {
        ((void)0);
        m_assembler.psllq_i8r(imm.m_value, reg);
    }

    void rshiftPacked(TrustedImm32 imm, XMMRegisterID reg)
    {
        ((void)0);
        m_assembler.psrlq_i8r(imm.m_value, reg);
    }

    void orPacked(XMMRegisterID src, XMMRegisterID dst)
    {
        ((void)0);
        m_assembler.por_rr(src, dst);
    }

    void moveInt32ToPacked(RegisterID src, XMMRegisterID dst)
    {
        ((void)0);
        m_assembler.movd_rr(src, dst);
    }

    void movePackedToInt32(XMMRegisterID src, RegisterID dst)
    {
        ((void)0);
        m_assembler.movd_rr(src, dst);
    }
# 777 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/MacroAssemblerX86Common.h"
    void pop(RegisterID dest)
    {
        m_assembler.pop_r(dest);
    }

    void push(RegisterID src)
    {
        m_assembler.push_r(src);
    }

    void push(Address address)
    {
        m_assembler.push_m(address.offset, address.base);
    }

    void push(TrustedImm32 imm)
    {
        m_assembler.push_i32(imm.m_value);
    }






    void move(TrustedImm32 imm, RegisterID dest)
    {


        if (!imm.m_value)
            m_assembler.xorl_rr(dest, dest);
        else
            m_assembler.movl_i32r(imm.m_value, dest);
    }


    void move(RegisterID src, RegisterID dest)
    {


        if (src != dest)
            m_assembler.movq_rr(src, dest);
    }

    void move(TrustedImmPtr imm, RegisterID dest)
    {
        m_assembler.movq_i64r(imm.asIntptr(), dest);
    }

    void swap(RegisterID reg1, RegisterID reg2)
    {
        if (reg1 != reg2)
            m_assembler.xchgq_rr(reg1, reg2);
    }

    void signExtend32ToPtr(RegisterID src, RegisterID dest)
    {
        m_assembler.movsxd_rr(src, dest);
    }

    void zeroExtend32ToPtr(RegisterID src, RegisterID dest)
    {
        m_assembler.movl_rr(src, dest);
    }
# 889 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/MacroAssemblerX86Common.h"
public:
    Jump branch8(RelationalCondition cond, Address left, TrustedImm32 right)
    {
        m_assembler.cmpb_im(right.m_value, left.offset, left.base);
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }

    Jump branch32(RelationalCondition cond, RegisterID left, RegisterID right)
    {
        m_assembler.cmpl_rr(right, left);
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }

    Jump branch32(RelationalCondition cond, RegisterID left, TrustedImm32 right)
    {
        if (((cond == Equal) || (cond == NotEqual)) && !right.m_value)
            m_assembler.testl_rr(left, left);
        else
            m_assembler.cmpl_ir(right.m_value, left);
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }

    Jump branch32(RelationalCondition cond, RegisterID left, Address right)
    {
        m_assembler.cmpl_mr(right.offset, right.base, left);
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }

    Jump branch32(RelationalCondition cond, Address left, RegisterID right)
    {
        m_assembler.cmpl_rm(right, left.offset, left.base);
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }

    Jump branch32(RelationalCondition cond, Address left, TrustedImm32 right)
    {
        m_assembler.cmpl_im(right.m_value, left.offset, left.base);
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }

    Jump branch32(RelationalCondition cond, BaseIndex left, TrustedImm32 right)
    {
        m_assembler.cmpl_im(right.m_value, left.offset, left.base, left.index, left.scale);
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }

    Jump branch32WithUnalignedHalfWords(RelationalCondition cond, BaseIndex left, TrustedImm32 right)
    {
        return branch32(cond, left, right);
    }

    Jump branchTest32(ResultCondition cond, RegisterID reg, RegisterID mask)
    {
        m_assembler.testl_rr(reg, mask);
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }

    Jump branchTest32(ResultCondition cond, RegisterID reg, TrustedImm32 mask = TrustedImm32(-1))
    {

        if (mask.m_value == -1)
            m_assembler.testl_rr(reg, reg);
        else
            m_assembler.testl_i32r(mask.m_value, reg);
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }

    Jump branchTest32(ResultCondition cond, Address address, TrustedImm32 mask = TrustedImm32(-1))
    {
        if (mask.m_value == -1)
            m_assembler.cmpl_im(0, address.offset, address.base);
        else
            m_assembler.testl_i32m(mask.m_value, address.offset, address.base);
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }

    Jump branchTest32(ResultCondition cond, BaseIndex address, TrustedImm32 mask = TrustedImm32(-1))
    {
        if (mask.m_value == -1)
            m_assembler.cmpl_im(0, address.offset, address.base, address.index, address.scale);
        else
            m_assembler.testl_i32m(mask.m_value, address.offset, address.base, address.index, address.scale);
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }

    Jump branchTest8(ResultCondition cond, Address address, TrustedImm32 mask = TrustedImm32(-1))
    {

        ((void)0);
        if (mask.m_value == -1)
            m_assembler.cmpb_im(0, address.offset, address.base);
        else
            m_assembler.testb_im(mask.m_value, address.offset, address.base);
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }

    Jump branchTest8(ResultCondition cond, BaseIndex address, TrustedImm32 mask = TrustedImm32(-1))
    {

        ((void)0);
        if (mask.m_value == -1)
            m_assembler.cmpb_im(0, address.offset, address.base, address.index, address.scale);
        else
            m_assembler.testb_im(mask.m_value, address.offset, address.base, address.index, address.scale);
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }

    Jump branch8(RelationalCondition cond, BaseIndex left, TrustedImm32 right)
    {
        ((void)0);

        m_assembler.cmpb_im(right.m_value, left.offset, left.base, left.index, left.scale);
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }

    Jump jump()
    {
        return Jump(m_assembler.jmp());
    }

    void jump(RegisterID target)
    {
        m_assembler.jmp_r(target);
    }


    void jump(Address address)
    {
        m_assembler.jmp_m(address.offset, address.base);
    }
# 1031 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/MacroAssemblerX86Common.h"
    Jump branchAdd32(ResultCondition cond, RegisterID src, RegisterID dest)
    {
        add32(src, dest);
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }

    Jump branchAdd32(ResultCondition cond, TrustedImm32 imm, RegisterID dest)
    {
        add32(imm, dest);
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }

    Jump branchAdd32(ResultCondition cond, TrustedImm32 src, Address dest)
    {
        add32(src, dest);
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }

    Jump branchAdd32(ResultCondition cond, RegisterID src, Address dest)
    {
        add32(src, dest);
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }

    Jump branchAdd32(ResultCondition cond, Address src, RegisterID dest)
    {
        add32(src, dest);
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }

    Jump branchAdd32(ResultCondition cond, RegisterID src1, RegisterID src2, RegisterID dest)
    {
        if (src1 == dest)
            return branchAdd32(cond, src2, dest);
        move(src2, dest);
        return branchAdd32(cond, src1, dest);
    }

    Jump branchAdd32(ResultCondition cond, RegisterID src, TrustedImm32 imm, RegisterID dest)
    {
        move(src, dest);
        return branchAdd32(cond, imm, dest);
    }

    Jump branchMul32(ResultCondition cond, RegisterID src, RegisterID dest)
    {
        mul32(src, dest);
        if (cond != Overflow)
            m_assembler.testl_rr(dest, dest);
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }

    Jump branchMul32(ResultCondition cond, Address src, RegisterID dest)
    {
        mul32(src, dest);
        if (cond != Overflow)
            m_assembler.testl_rr(dest, dest);
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }

    Jump branchMul32(ResultCondition cond, TrustedImm32 imm, RegisterID src, RegisterID dest)
    {
        mul32(imm, src, dest);
        if (cond != Overflow)
            m_assembler.testl_rr(dest, dest);
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }

    Jump branchMul32(ResultCondition cond, RegisterID src1, RegisterID src2, RegisterID dest)
    {
        if (src1 == dest)
            return branchMul32(cond, src2, dest);
        move(src2, dest);
        return branchMul32(cond, src1, dest);
    }

    Jump branchSub32(ResultCondition cond, RegisterID src, RegisterID dest)
    {
        sub32(src, dest);
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }

    Jump branchSub32(ResultCondition cond, TrustedImm32 imm, RegisterID dest)
    {
        sub32(imm, dest);
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }

    Jump branchSub32(ResultCondition cond, TrustedImm32 imm, Address dest)
    {
        sub32(imm, dest);
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }

    Jump branchSub32(ResultCondition cond, RegisterID src, Address dest)
    {
        sub32(src, dest);
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }

    Jump branchSub32(ResultCondition cond, Address src, RegisterID dest)
    {
        sub32(src, dest);
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }

    Jump branchSub32(ResultCondition cond, RegisterID src1, RegisterID src2, RegisterID dest)
    {

        ((void)0);

        move(src1, dest);
        return branchSub32(cond, src2, dest);
    }

    Jump branchSub32(ResultCondition cond, RegisterID src1, TrustedImm32 src2, RegisterID dest)
    {
        move(src1, dest);
        return branchSub32(cond, src2, dest);
    }

    Jump branchNeg32(ResultCondition cond, RegisterID srcDest)
    {
        neg32(srcDest);
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }

    Jump branchOr32(ResultCondition cond, RegisterID src, RegisterID dest)
    {
        or32(src, dest);
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }




    void breakpoint()
    {
        m_assembler.int3();
    }

    Call nearCall()
    {
        return Call(m_assembler.call(), Call::LinkableNear);
    }

    Call call(RegisterID target)
    {
        return Call(m_assembler.call(target), Call::None);
    }

    void call(Address address)
    {
        m_assembler.call_m(address.offset, address.base);
    }

    void ret()
    {
        m_assembler.ret();
    }

    void compare32(RelationalCondition cond, RegisterID left, RegisterID right, RegisterID dest)
    {
        m_assembler.cmpl_rr(right, left);
        set32(x86Condition(cond), dest);
    }

    void compare32(RelationalCondition cond, RegisterID left, TrustedImm32 right, RegisterID dest)
    {
        if (((cond == Equal) || (cond == NotEqual)) && !right.m_value)
            m_assembler.testl_rr(left, left);
        else
            m_assembler.cmpl_ir(right.m_value, left);
        set32(x86Condition(cond), dest);
    }






    void test8(ResultCondition cond, Address address, TrustedImm32 mask, RegisterID dest)
    {
        if (mask.m_value == -1)
            m_assembler.cmpb_im(0, address.offset, address.base);
        else
            m_assembler.testb_im(mask.m_value, address.offset, address.base);
        set32(x86Condition(cond), dest);
    }

    void test32(ResultCondition cond, Address address, TrustedImm32 mask, RegisterID dest)
    {
        if (mask.m_value == -1)
            m_assembler.cmpl_im(0, address.offset, address.base);
        else
            m_assembler.testl_i32m(mask.m_value, address.offset, address.base);
        set32(x86Condition(cond), dest);
    }


    static RelationalCondition invert(RelationalCondition cond)
    {
        return static_cast<RelationalCondition>(cond ^ 1);
    }

    void nop()
    {
        m_assembler.nop();
    }

protected:
    X86Assembler::Condition x86Condition(RelationalCondition cond)
    {
        return static_cast<X86Assembler::Condition>(cond);
    }

    X86Assembler::Condition x86Condition(ResultCondition cond)
    {
        return static_cast<X86Assembler::Condition>(cond);
    }

    void set32(X86Assembler::Condition cond, RegisterID dest)
    {
# 1265 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/MacroAssemblerX86Common.h"
        m_assembler.setCC_r(cond, dest);
        m_assembler.movzbl_rr(dest, dest);
    }

private:


    friend class MacroAssemblerX86;
# 1337 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/MacroAssemblerX86Common.h"
};

}
# 32 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/MacroAssemblerX86_64.h" 2



namespace JSC {

class MacroAssemblerX86_64 : public MacroAssemblerX86Common {
protected:
    static const X86Registers::RegisterID scratchRegister = X86Registers::r11;

public:
    static const Scale ScalePtr = TimesEight;

    using MacroAssemblerX86Common::add32;
    using MacroAssemblerX86Common::and32;
    using MacroAssemblerX86Common::branchAdd32;
    using MacroAssemblerX86Common::or32;
    using MacroAssemblerX86Common::sub32;
    using MacroAssemblerX86Common::load32;
    using MacroAssemblerX86Common::store32;
    using MacroAssemblerX86Common::call;
    using MacroAssemblerX86Common::addDouble;
    using MacroAssemblerX86Common::loadDouble;
    using MacroAssemblerX86Common::convertInt32ToDouble;

    void add32(TrustedImm32 imm, AbsoluteAddress address)
    {
        move(TrustedImmPtr(address.m_ptr), scratchRegister);
        add32(imm, Address(scratchRegister));
    }

    void and32(TrustedImm32 imm, AbsoluteAddress address)
    {
        move(TrustedImmPtr(address.m_ptr), scratchRegister);
        and32(imm, Address(scratchRegister));
    }

    void or32(TrustedImm32 imm, AbsoluteAddress address)
    {
        move(TrustedImmPtr(address.m_ptr), scratchRegister);
        or32(imm, Address(scratchRegister));
    }

    void sub32(TrustedImm32 imm, AbsoluteAddress address)
    {
        move(TrustedImmPtr(address.m_ptr), scratchRegister);
        sub32(imm, Address(scratchRegister));
    }

    void load32(const void* address, RegisterID dest)
    {
        if (dest == X86Registers::eax)
            m_assembler.movl_mEAX(address);
        else {
            move(TrustedImmPtr(address), dest);
            load32(dest, dest);
        }
    }

    void loadDouble(const void* address, FPRegisterID dest)
    {
        move(TrustedImmPtr(address), scratchRegister);
        loadDouble(scratchRegister, dest);
    }

    void addDouble(AbsoluteAddress address, FPRegisterID dest)
    {
        move(TrustedImmPtr(address.m_ptr), scratchRegister);
        m_assembler.addsd_mr(0, scratchRegister, dest);
    }

    void convertInt32ToDouble(TrustedImm32 imm, FPRegisterID dest)
    {
        move(imm, scratchRegister);
        m_assembler.cvtsi2sd_rr(scratchRegister, dest);
    }

    void store32(TrustedImm32 imm, void* address)
    {
        move(TrustedImmPtr(address), scratchRegister);
        store32(imm, scratchRegister);
    }

    Call call()
    {
        DataLabelPtr label = moveWithPatch(TrustedImmPtr(0), scratchRegister);
        Call result = Call(m_assembler.call(scratchRegister), Call::Linkable);
        ((void)label);
        return result;
    }

    Call tailRecursiveCall()
    {
        DataLabelPtr label = moveWithPatch(TrustedImmPtr(0), scratchRegister);
        Jump newJump = Jump(m_assembler.jmp_r(scratchRegister));
        ((void)label);
        return Call::fromTailJump(newJump);
    }

    Call makeTailRecursiveCall(Jump oldJump)
    {
        oldJump.link(this);
        DataLabelPtr label = moveWithPatch(TrustedImmPtr(0), scratchRegister);
        Jump newJump = Jump(m_assembler.jmp_r(scratchRegister));
        ((void)label);
        return Call::fromTailJump(newJump);
    }


    void addPtr(RegisterID src, RegisterID dest)
    {
        m_assembler.addq_rr(src, dest);
    }

    void addPtr(TrustedImm32 imm, RegisterID srcDest)
    {
        m_assembler.addq_ir(imm.m_value, srcDest);
    }

    void addPtr(TrustedImmPtr imm, RegisterID dest)
    {
        move(imm, scratchRegister);
        m_assembler.addq_rr(scratchRegister, dest);
    }

    void addPtr(TrustedImm32 imm, RegisterID src, RegisterID dest)
    {
        m_assembler.leaq_mr(imm.m_value, src, dest);
    }

    void addPtr(TrustedImm32 imm, Address address)
    {
        m_assembler.addq_im(imm.m_value, address.offset, address.base);
    }

    void addPtr(TrustedImm32 imm, AbsoluteAddress address)
    {
        move(TrustedImmPtr(address.m_ptr), scratchRegister);
        addPtr(imm, Address(scratchRegister));
    }

    void andPtr(RegisterID src, RegisterID dest)
    {
        m_assembler.andq_rr(src, dest);
    }

    void andPtr(TrustedImm32 imm, RegisterID srcDest)
    {
        m_assembler.andq_ir(imm.m_value, srcDest);
    }

    void orPtr(RegisterID src, RegisterID dest)
    {
        m_assembler.orq_rr(src, dest);
    }

    void orPtr(TrustedImmPtr imm, RegisterID dest)
    {
        move(imm, scratchRegister);
        m_assembler.orq_rr(scratchRegister, dest);
    }

    void orPtr(TrustedImm32 imm, RegisterID dest)
    {
        m_assembler.orq_ir(imm.m_value, dest);
    }

    void orPtr(RegisterID op1, RegisterID op2, RegisterID dest)
    {
        if (op1 == op2)
            move(op1, dest);
        else if (op1 == dest)
            orPtr(op2, dest);
        else {
            move(op2, dest);
            orPtr(op1, dest);
        }
    }

    void orPtr(TrustedImm32 imm, RegisterID src, RegisterID dest)
    {
        move(src, dest);
        orPtr(imm, dest);
    }

    void subPtr(RegisterID src, RegisterID dest)
    {
        m_assembler.subq_rr(src, dest);
    }

    void subPtr(TrustedImm32 imm, RegisterID dest)
    {
        m_assembler.subq_ir(imm.m_value, dest);
    }

    void subPtr(TrustedImmPtr imm, RegisterID dest)
    {
        move(imm, scratchRegister);
        m_assembler.subq_rr(scratchRegister, dest);
    }

    void xorPtr(RegisterID src, RegisterID dest)
    {
        m_assembler.xorq_rr(src, dest);
    }

    void xorPtr(TrustedImm32 imm, RegisterID srcDest)
    {
        m_assembler.xorq_ir(imm.m_value, srcDest);
    }


    void loadPtr(ImplicitAddress address, RegisterID dest)
    {
        m_assembler.movq_mr(address.offset, address.base, dest);
    }

    void loadPtr(BaseIndex address, RegisterID dest)
    {
        m_assembler.movq_mr(address.offset, address.base, address.index, address.scale, dest);
    }

    void loadPtr(const void* address, RegisterID dest)
    {
        if (dest == X86Registers::eax)
            m_assembler.movq_mEAX(address);
        else {
            move(TrustedImmPtr(address), dest);
            loadPtr(dest, dest);
        }
    }

    DataLabel32 loadPtrWithAddressOffsetPatch(Address address, RegisterID dest)
    {
        m_assembler.movq_mr_disp32(address.offset, address.base, dest);
        return DataLabel32(this);
    }

    DataLabelCompact loadPtrWithCompactAddressOffsetPatch(Address address, RegisterID dest)
    {
        m_assembler.movq_mr_disp8(address.offset, address.base, dest);
        return DataLabelCompact(this);
    }

    void storePtr(RegisterID src, ImplicitAddress address)
    {
        m_assembler.movq_rm(src, address.offset, address.base);
    }

    void storePtr(RegisterID src, BaseIndex address)
    {
        m_assembler.movq_rm(src, address.offset, address.base, address.index, address.scale);
    }

    void storePtr(RegisterID src, void* address)
    {
        if (src == X86Registers::eax)
            m_assembler.movq_EAXm(address);
        else {
            move(TrustedImmPtr(address), scratchRegister);
            storePtr(src, scratchRegister);
        }
    }

    void storePtr(TrustedImmPtr imm, ImplicitAddress address)
    {
        move(imm, scratchRegister);
        storePtr(scratchRegister, address);
    }

    void storePtr(TrustedImmPtr imm, BaseIndex address)
    {
        move(imm, scratchRegister);
        m_assembler.movq_rm(scratchRegister, address.offset, address.base, address.index, address.scale);
    }

    DataLabel32 storePtrWithAddressOffsetPatch(RegisterID src, Address address)
    {
        m_assembler.movq_rm_disp32(src, address.offset, address.base);
        return DataLabel32(this);
    }

    void movePtrToDouble(RegisterID src, FPRegisterID dest)
    {
        m_assembler.movq_rr(src, dest);
    }

    void moveDoubleToPtr(FPRegisterID src, RegisterID dest)
    {
        m_assembler.movq_rr(src, dest);
    }

    void comparePtr(RelationalCondition cond, RegisterID left, TrustedImm32 right, RegisterID dest)
    {
        if (((cond == Equal) || (cond == NotEqual)) && !right.m_value)
            m_assembler.testq_rr(left, left);
        else
            m_assembler.cmpq_ir(right.m_value, left);
        m_assembler.setCC_r(x86Condition(cond), dest);
        m_assembler.movzbl_rr(dest, dest);
    }

    Jump branchAdd32(ResultCondition cond, TrustedImm32 src, AbsoluteAddress dest)
    {
        move(TrustedImmPtr(dest.m_ptr), scratchRegister);
        add32(src, Address(scratchRegister));
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }

    Jump branchPtr(RelationalCondition cond, RegisterID left, RegisterID right)
    {
        m_assembler.cmpq_rr(right, left);
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }

    Jump branchPtr(RelationalCondition cond, RegisterID left, TrustedImmPtr right)
    {
        move(right, scratchRegister);
        return branchPtr(cond, left, scratchRegister);
    }

    Jump branchPtr(RelationalCondition cond, RegisterID left, Address right)
    {
        m_assembler.cmpq_mr(right.offset, right.base, left);
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }

    Jump branchPtr(RelationalCondition cond, AbsoluteAddress left, RegisterID right)
    {
        move(TrustedImmPtr(left.m_ptr), scratchRegister);
        return branchPtr(cond, Address(scratchRegister), right);
    }

    Jump branchPtr(RelationalCondition cond, Address left, RegisterID right)
    {
        m_assembler.cmpq_rm(right, left.offset, left.base);
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }

    Jump branchPtr(RelationalCondition cond, Address left, TrustedImmPtr right)
    {
        move(right, scratchRegister);
        return branchPtr(cond, left, scratchRegister);
    }

    Jump branchTestPtr(ResultCondition cond, RegisterID reg, RegisterID mask)
    {
        m_assembler.testq_rr(reg, mask);
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }

    Jump branchTestPtr(ResultCondition cond, RegisterID reg, TrustedImm32 mask = TrustedImm32(-1))
    {

        if (mask.m_value == -1)
            m_assembler.testq_rr(reg, reg);
        else if ((mask.m_value & ~0x7f) == 0)
            m_assembler.testb_i8r(mask.m_value, reg);
        else
            m_assembler.testq_i32r(mask.m_value, reg);
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }

    Jump branchTestPtr(ResultCondition cond, AbsoluteAddress address, TrustedImm32 mask = TrustedImm32(-1))
    {
        loadPtr(address.m_ptr, scratchRegister);
        return branchTestPtr(cond, scratchRegister, mask);
    }

    Jump branchTestPtr(ResultCondition cond, Address address, TrustedImm32 mask = TrustedImm32(-1))
    {
        if (mask.m_value == -1)
            m_assembler.cmpq_im(0, address.offset, address.base);
        else
            m_assembler.testq_i32m(mask.m_value, address.offset, address.base);
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }

    Jump branchTestPtr(ResultCondition cond, BaseIndex address, TrustedImm32 mask = TrustedImm32(-1))
    {
        if (mask.m_value == -1)
            m_assembler.cmpq_im(0, address.offset, address.base, address.index, address.scale);
        else
            m_assembler.testq_i32m(mask.m_value, address.offset, address.base, address.index, address.scale);
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }


    Jump branchAddPtr(ResultCondition cond, RegisterID src, RegisterID dest)
    {
        addPtr(src, dest);
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }

    Jump branchSubPtr(ResultCondition cond, TrustedImm32 imm, RegisterID dest)
    {
        subPtr(imm, dest);
        return Jump(m_assembler.jCC(x86Condition(cond)));
    }

    DataLabelPtr moveWithPatch(TrustedImmPtr initialValue, RegisterID dest)
    {
        m_assembler.movq_i64r(initialValue.asIntptr(), dest);
        return DataLabelPtr(this);
    }

    Jump branchPtrWithPatch(RelationalCondition cond, RegisterID left, DataLabelPtr& dataLabel, TrustedImmPtr initialRightValue = TrustedImmPtr(0))
    {
        dataLabel = moveWithPatch(initialRightValue, scratchRegister);
        return branchPtr(cond, left, scratchRegister);
    }

    Jump branchPtrWithPatch(RelationalCondition cond, Address left, DataLabelPtr& dataLabel, TrustedImmPtr initialRightValue = TrustedImmPtr(0))
    {
        dataLabel = moveWithPatch(initialRightValue, scratchRegister);
        return branchPtr(cond, left, scratchRegister);
    }

    DataLabelPtr storePtrWithPatch(TrustedImmPtr initialValue, ImplicitAddress address)
    {
        DataLabelPtr label = moveWithPatch(initialValue, scratchRegister);
        storePtr(scratchRegister, address);
        return label;
    }

    using MacroAssemblerX86Common::branchTest8;
    Jump branchTest8(ResultCondition cond, ExtendedAddress address, TrustedImm32 mask = TrustedImm32(-1))
    {
        TrustedImmPtr addr(reinterpret_cast<void*>(address.offset));
        MacroAssemblerX86Common::move(addr, scratchRegister);
        return MacroAssemblerX86Common::branchTest8(cond, BaseIndex(scratchRegister, address.base, TimesOne), mask);
    }

    bool supportsFloatingPoint() const { return true; }

    bool supportsFloatingPointTruncate() const { return true; }
    bool supportsFloatingPointSqrt() const { return true; }
    bool supportsDoubleBitops() const { return true; }

private:
    friend class LinkBuffer;
    friend class RepatchBuffer;

    static void linkCall(void* code, Call call, FunctionPtr function)
    {
        if (!call.isFlagSet(Call::Near))
            X86Assembler::linkPointer(code, call.m_label.labelAtOffset(-3), function.value());
        else
            X86Assembler::linkCall(code, call.m_label, function.value());
    }

    static void repatchCall(CodeLocationCall call, CodeLocationLabel destination)
    {
        X86Assembler::repatchPointer(call.dataLabelPtrAtOffset(-3).dataLocation(), destination.executableAddress());
    }

    static void repatchCall(CodeLocationCall call, FunctionPtr destination)
    {
        X86Assembler::repatchPointer(call.dataLabelPtrAtOffset(-3).dataLocation(), destination.executableAddress());
    }

};

}
# 51 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/MacroAssembler.h" 2
namespace JSC { typedef MacroAssemblerX86_64 MacroAssemblerBase; };
# 64 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/MacroAssembler.h"
namespace JSC {

class MacroAssembler : public MacroAssemblerBase {
public:

    using MacroAssemblerBase::pop;
    using MacroAssemblerBase::jump;
    using MacroAssemblerBase::branch32;

    using MacroAssemblerBase::branchPtr;
    using MacroAssemblerBase::branchTestPtr;





    void pop()
    {
        addPtr(TrustedImm32(sizeof(void*)), stackPointerRegister);
    }

    void peek(RegisterID dest, int index = 0)
    {
        loadPtr(Address(stackPointerRegister, (index * sizeof(void*))), dest);
    }

    void poke(RegisterID src, int index = 0)
    {
        storePtr(src, Address(stackPointerRegister, (index * sizeof(void*))));
    }

    void poke(TrustedImm32 value, int index = 0)
    {
        store32(value, Address(stackPointerRegister, (index * sizeof(void*))));
    }

    void poke(TrustedImmPtr imm, int index = 0)
    {
        storePtr(imm, Address(stackPointerRegister, (index * sizeof(void*))));
    }



    void branchPtr(RelationalCondition cond, RegisterID op1, TrustedImmPtr imm, Label target)
    {
        branchPtr(cond, op1, imm).linkTo(target, this);
    }

    void branch32(RelationalCondition cond, RegisterID op1, RegisterID op2, Label target)
    {
        branch32(cond, op1, op2).linkTo(target, this);
    }

    void branch32(RelationalCondition cond, RegisterID op1, TrustedImm32 imm, Label target)
    {
        branch32(cond, op1, imm).linkTo(target, this);
    }

    void branch32(RelationalCondition cond, RegisterID left, Address right, Label target)
    {
        branch32(cond, left, right).linkTo(target, this);
    }

    Jump branch32(RelationalCondition cond, TrustedImm32 left, RegisterID right)
    {
        return branch32(commute(cond), right, left);
    }

    void branchTestPtr(ResultCondition cond, RegisterID reg, Label target)
    {
        branchTestPtr(cond, reg).linkTo(target, this);
    }

    void jump(Label target)
    {
        jump().linkTo(target, this);
    }



    static RelationalCondition commute(RelationalCondition condition)
    {
        switch (condition) {
        case Above:
            return Below;
        case AboveOrEqual:
            return BelowOrEqual;
        case Below:
            return Above;
        case BelowOrEqual:
            return AboveOrEqual;
        case GreaterThan:
            return LessThan;
        case GreaterThanOrEqual:
            return LessThanOrEqual;
        case LessThan:
            return GreaterThan;
        case LessThanOrEqual:
            return GreaterThanOrEqual;
        default:
            break;
        }

        ((void)0);
        return condition;
    }
# 390 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/assembler/MacroAssembler.h"
};

}
# 33 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/Instruction.h" 2








namespace JSC {






    class JSCell;
    class Structure;
    class StructureChain;


    typedef MacroAssemblerCodeRef PolymorphicAccessStructureListStubRoutineType;


    struct PolymorphicAccessStructureList {
        public: void* operator new(size_t, void* p) { return p; } void* operator new[](size_t, void* p) { return p; } void* operator new(size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNew); return p; } void operator delete(void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNew); ::WTF::fastFree(p); } void* operator new[](size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNewArray); return p; } void operator delete[](void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNewArray); ::WTF::fastFree(p); } private: typedef int ThisIsHereToForceASemicolonAfterThisMacro;
    public:
        struct PolymorphicStubInfo {
            bool isChain;
            bool isDirect;
            PolymorphicAccessStructureListStubRoutineType stubRoutine;
            WriteBarrier<Structure> base;
            union {
                WriteBarrierBase<Structure> proto;
                WriteBarrierBase<StructureChain> chain;
            } u;

            PolymorphicStubInfo()
            {
                u.proto.clear();
            }

            void set(JSGlobalData& globalData, JSCell* owner, PolymorphicAccessStructureListStubRoutineType _stubRoutine, Structure* _base, bool isDirect)
            {
                stubRoutine = _stubRoutine;
                base.set(globalData, owner, _base);
                u.proto.clear();
                isChain = false;
                this->isDirect = isDirect;
            }

            void set(JSGlobalData& globalData, JSCell* owner, PolymorphicAccessStructureListStubRoutineType _stubRoutine, Structure* _base, Structure* _proto, bool isDirect)
            {
                stubRoutine = _stubRoutine;
                base.set(globalData, owner, _base);
                u.proto.set(globalData, owner, _proto);
                isChain = false;
                this->isDirect = isDirect;
            }

            void set(JSGlobalData& globalData, JSCell* owner, PolymorphicAccessStructureListStubRoutineType _stubRoutine, Structure* _base, StructureChain* _chain, bool isDirect)
            {
                stubRoutine = _stubRoutine;
                base.set(globalData, owner, _base);
                u.chain.set(globalData, owner, _chain);
                isChain = true;
                this->isDirect = isDirect;
            }
        } list[8];

        PolymorphicAccessStructureList(JSGlobalData& globalData, JSCell* owner, PolymorphicAccessStructureListStubRoutineType stubRoutine, Structure* firstBase, bool isDirect)
        {
            list[0].set(globalData, owner, stubRoutine, firstBase, isDirect);
        }

        PolymorphicAccessStructureList(JSGlobalData& globalData, JSCell* owner, PolymorphicAccessStructureListStubRoutineType stubRoutine, Structure* firstBase, Structure* firstProto, bool isDirect)
        {
            list[0].set(globalData, owner, stubRoutine, firstBase, firstProto, isDirect);
        }

        PolymorphicAccessStructureList(JSGlobalData& globalData, JSCell* owner, PolymorphicAccessStructureListStubRoutineType stubRoutine, Structure* firstBase, StructureChain* firstChain, bool isDirect)
        {
            list[0].set(globalData, owner, stubRoutine, firstBase, firstChain, isDirect);
        }

        void visitAggregate(SlotVisitor& visitor, int count)
        {
            for (int i = 0; i < count; ++i) {
                PolymorphicStubInfo& info = list[i];
                if (!info.base) {

                    ((void)0);
                    continue;
                }

                visitor.append(&info.base);
                if (info.u.proto && !info.isChain)
                    visitor.append(&info.u.proto);
                if (info.u.chain && info.isChain)
                    visitor.append(&info.u.chain);
            }
        }
    };



    struct Instruction {
        Instruction(Opcode opcode)
        {



            u.jsCell.clear();

            u.opcode = opcode;
        }

        Instruction(int operand)
        {


            u.jsCell.clear();
            u.operand = operand;
        }

        Instruction(JSGlobalData& globalData, JSCell* owner, Structure* structure)
        {
            u.structure.clear();
            u.structure.set(globalData, owner, structure);
        }
        Instruction(JSGlobalData& globalData, JSCell* owner, StructureChain* structureChain)
        {
            u.structureChain.clear();
            u.structureChain.set(globalData, owner, structureChain);
        }
        Instruction(JSGlobalData& globalData, JSCell* owner, JSCell* jsCell)
        {
            u.jsCell.clear();
            u.jsCell.set(globalData, owner, jsCell);
        }

        Instruction(PropertySlot::GetValueFunc getterFunc) { u.getterFunc = getterFunc; }

        union {
            Opcode opcode;
            int operand;
            WriteBarrierBase<Structure> structure;
            WriteBarrierBase<StructureChain> structureChain;
            WriteBarrierBase<JSCell> jsCell;
            PropertySlot::GetValueFunc getterFunc;
        } u;

    private:
        Instruction(StructureChain*);
        Instruction(Structure*);
    };

}

namespace WTF {

    template<> struct VectorTraits<JSC::Instruction> : VectorTraitsBase<true, JSC::Instruction> { };

}
# 39 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/CodeBlock.h" 2

# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/jit/JITWriteBarrier.h" 1
# 35 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/jit/JITWriteBarrier.h"
namespace JSC {

class JSCell;
class JSGlobalData;



class JITWriteBarrierBase {
public:
    typedef void* (JITWriteBarrierBase::*UnspecifiedBoolType);
    operator UnspecifiedBoolType*() const { return get() ? reinterpret_cast<UnspecifiedBoolType*>(1) : 0; }
    bool operator!() const { return !get(); }

    void setFlagOnBarrier()
    {
        ((void)0);
        m_location = CodeLocationDataLabelPtr(((void*)2));
    }

    bool isFlagged() const
    {
        return !!m_location;
    }

    void setLocation(CodeLocationDataLabelPtr location)
    {
        ((void)0);
        m_location = location;
    }

    CodeLocationDataLabelPtr location() const
    {
        ((void)0);
        return m_location;
    }

    void clear() { clear(0); }

protected:
    JITWriteBarrierBase()
    {
    }

    void set(JSGlobalData&, CodeLocationDataLabelPtr location, JSCell* owner, JSCell* value)
    {
        Heap::writeBarrier(owner, value);
        m_location = location;
        ((void)0);
        MacroAssembler::repatchPointer(m_location, value);
        ((void)0);
    }

    JSCell* get() const
    {
        if (!m_location || m_location.executableAddress() == ((void*)2))
            return 0;
        void* result = static_cast<JSCell*>(MacroAssembler::readPointer(m_location));

        if (result == (void*)-1)
            return 0;
        return static_cast<JSCell*>(result);
    }

private:
    void clear(void* clearedValue)
    {
        if (!m_location)
            return;
        if (m_location.executableAddress() != ((void*)2))
            MacroAssembler::repatchPointer(m_location, clearedValue);
    }

    CodeLocationDataLabelPtr m_location;
};



template <typename T> class JITWriteBarrier : public JITWriteBarrierBase {
public:
    JITWriteBarrier()
    {
    }

    void set(JSGlobalData& globalData, CodeLocationDataLabelPtr location, JSCell* owner, T* value)
    {
        validateCell(owner);
        validateCell(value);
        JITWriteBarrierBase::set(globalData, location, owner, value);
    }
    void set(JSGlobalData& globalData, JSCell* owner, T* value)
    {
        set(globalData, location(), owner, value);
    }
    T* get() const
    {
        T* result = static_cast<T*>(JITWriteBarrierBase::get());
        if (result)
            validateCell(result);
        return result;
    }
};

template<typename T> inline void MarkStack::append(JITWriteBarrier<T>* slot)
{
    internalAppend(slot->get());
}

}
# 41 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/CodeBlock.h" 2

# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/JumpTable.h" 1
# 38 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/JumpTable.h"
namespace JSC {

    struct OffsetLocation {
        int32_t branchOffset;

        CodeLocationLabel ctiOffset;

    };

    struct StringJumpTable {
        typedef HashMap<RefPtr<StringImpl>, OffsetLocation> StringOffsetTable;
        StringOffsetTable offsetTable;

        CodeLocationLabel ctiDefault;


        inline int32_t offsetForValue(StringImpl* value, int32_t defaultOffset)
        {
            StringOffsetTable::const_iterator end = offsetTable.end();
            StringOffsetTable::const_iterator loc = offsetTable.find(value);
            if (loc == end)
                return defaultOffset;
            return loc->second.branchOffset;
        }


        inline CodeLocationLabel ctiForValue(StringImpl* value)
        {
            StringOffsetTable::const_iterator end = offsetTable.end();
            StringOffsetTable::const_iterator loc = offsetTable.find(value);
            if (loc == end)
                return ctiDefault;
            return loc->second.ctiOffset;
        }

    };

    struct SimpleJumpTable {

        Vector<int32_t> branchOffsets;
        int32_t min;

        Vector<CodeLocationLabel> ctiOffsets;
        CodeLocationLabel ctiDefault;


        int32_t offsetForValue(int32_t value, int32_t defaultOffset);
        void add(int32_t key, int32_t offset)
        {
            if (!branchOffsets[key])
                branchOffsets[key] = offset;
        }


        inline CodeLocationLabel ctiForValue(int32_t value)
        {
            if (value >= min && static_cast<uint32_t>(value - min) < ctiOffsets.size())
                return ctiOffsets[value - min];
            return ctiDefault;
        }

    };

}
# 43 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/CodeBlock.h" 2

# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/PredictionTracker.h" 1
# 32 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/PredictionTracker.h"
namespace JSC {

struct PredictionSlot {
public:
    PredictionSlot()
        : m_value(PredictNone)
    {
    }
    PredictedType m_value;
};

class PredictionTracker {
public:
    PredictionTracker()
    {
    }

    bool predictGlobalVar(unsigned varNumber, PredictedType prediction)
    {
        HashMap<unsigned, PredictionSlot>::iterator iter = m_globalVars.find(varNumber + 1);
        if (iter == m_globalVars.end()) {
            PredictionSlot predictionSlot;
            bool result = mergePrediction(predictionSlot.m_value, prediction);
            m_globalVars.add(varNumber + 1, predictionSlot);
            return result;
        }
        return mergePrediction(iter->second.m_value, prediction);
    }

    PredictedType getGlobalVarPrediction(unsigned varNumber)
    {
        HashMap<unsigned, PredictionSlot>::iterator iter = m_globalVars.find(varNumber + 1);
        if (iter == m_globalVars.end())
            return PredictNone;
        return iter->second.m_value;
    }

private:
    HashMap<unsigned, PredictionSlot> m_globalVars;
};

}
# 45 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/CodeBlock.h" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/RegExpObject.h" 1
# 25 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/RegExpObject.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/RegExp.h" 1
# 28 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/RegExp.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/RegExpKey.h" 1
# 34 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/RegExpKey.h"
namespace JSC {

enum RegExpFlags {
    NoFlags = 0,
    FlagGlobal = 1,
    FlagIgnoreCase = 2,
    FlagMultiline = 4,
    InvalidFlags = 8,
    DeletedValueFlags = -1
};

struct RegExpKey {
    RegExpFlags flagsValue;
    RefPtr<StringImpl> pattern;

    RegExpKey()
        : flagsValue(NoFlags)
    {
    }

    RegExpKey(RegExpFlags flags)
        : flagsValue(flags)
    {
    }

    RegExpKey(RegExpFlags flags, const UString& pattern)
        : flagsValue(flags)
        , pattern(pattern.impl())
    {
    }

    RegExpKey(RegExpFlags flags, const PassRefPtr<StringImpl> pattern)
        : flagsValue(flags)
        , pattern(pattern)
    {
    }

    RegExpKey(RegExpFlags flags, const RefPtr<StringImpl>& pattern)
        : flagsValue(flags)
        , pattern(pattern)
    {
    }
};

inline bool operator==(const RegExpKey& a, const RegExpKey& b)
{
    if (a.flagsValue != b.flagsValue)
        return false;
    if (!a.pattern)
        return !b.pattern;
    if (!b.pattern)
        return false;
    return equal(a.pattern.get(), b.pattern.get());
}

}

namespace WTF {
template<typename T> struct DefaultHash;
template<typename T> struct RegExpHash;

template<> struct RegExpHash<JSC::RegExpKey> {
    static unsigned hash(const JSC::RegExpKey& key) { return key.pattern->hash(); }
    static bool equal(const JSC::RegExpKey& a, const JSC::RegExpKey& b) { return a == b; }
    static const bool safeToCompareToEmptyOrDeleted = false;
};

template<> struct DefaultHash<JSC::RegExpKey> {
    typedef RegExpHash<JSC::RegExpKey> Hash;
};

template<> struct HashTraits<JSC::RegExpKey> : GenericHashTraits<JSC::RegExpKey> {
    static void constructDeletedValue(JSC::RegExpKey& slot) { slot.flagsValue = JSC::DeletedValueFlags; }
    static bool isDeletedValue(const JSC::RegExpKey& value) { return value.flagsValue == JSC::DeletedValueFlags; }
};
}
# 29 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/RegExp.h" 2
# 1 "./yarr/Yarr.h" 1
# 31 "./yarr/Yarr.h"
# 1 "./yarr/YarrInterpreter.h" 1
# 29 "./yarr/YarrInterpreter.h"
# 1 "./yarr/YarrPattern.h" 1
# 36 "./yarr/YarrPattern.h"
namespace JSC { namespace Yarr {

struct PatternDisjunction;

struct CharacterRange {
    UChar begin;
    UChar end;

    CharacterRange(UChar begin, UChar end)
        : begin(begin)
        , end(end)
    {
    }
};

struct CharacterClassTable : RefCounted<CharacterClassTable> {
    const char* m_table;
    bool m_inverted;
    static PassRefPtr<CharacterClassTable> create(const char* table, bool inverted)
    {
        return adoptRef(new CharacterClassTable(table, inverted));
    }

private:
    CharacterClassTable(const char* table, bool inverted)
        : m_table(table)
        , m_inverted(inverted)
    {
    }
};

struct CharacterClass {
    public: void* operator new(size_t, void* p) { return p; } void* operator new[](size_t, void* p) { return p; } void* operator new(size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNew); return p; } void operator delete(void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNew); ::WTF::fastFree(p); } void* operator new[](size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNewArray); return p; } void operator delete[](void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNewArray); ::WTF::fastFree(p); } private: typedef int ThisIsHereToForceASemicolonAfterThisMacro;
public:



    CharacterClass(PassRefPtr<CharacterClassTable> table)
        : m_table(table)
    {
    }
    Vector<UChar> m_matches;
    Vector<CharacterRange> m_ranges;
    Vector<UChar> m_matchesUnicode;
    Vector<CharacterRange> m_rangesUnicode;
    RefPtr<CharacterClassTable> m_table;
};

enum QuantifierType {
    QuantifierFixedCount,
    QuantifierGreedy,
    QuantifierNonGreedy,
};

struct PatternTerm {
    enum Type {
        TypeAssertionBOL,
        TypeAssertionEOL,
        TypeAssertionWordBoundary,
        TypePatternCharacter,
        TypeCharacterClass,
        TypeBackReference,
        TypeForwardReference,
        TypeParenthesesSubpattern,
        TypeParentheticalAssertion,
        TypeDotStarEnclosure,
    } type;
    bool m_capture :1;
    bool m_invert :1;
    union {
        UChar patternCharacter;
        CharacterClass* characterClass;
        unsigned backReferenceSubpatternId;
        struct {
            PatternDisjunction* disjunction;
            unsigned subpatternId;
            unsigned lastSubpatternId;
            bool isCopy;
            bool isTerminal;
        } parentheses;
        struct {
            bool bolAnchor : 1;
            bool eolAnchor : 1;
        } anchors;
    };
    QuantifierType quantityType;
    Checked<unsigned> quantityCount;
    int inputPosition;
    unsigned frameLocation;

    PatternTerm(UChar ch)
        : type(PatternTerm::TypePatternCharacter)
        , m_capture(false)
        , m_invert(false)
    {
        patternCharacter = ch;
        quantityType = QuantifierFixedCount;
        quantityCount = 1;
    }

    PatternTerm(CharacterClass* charClass, bool invert)
        : type(PatternTerm::TypeCharacterClass)
        , m_capture(false)
        , m_invert(invert)
    {
        characterClass = charClass;
        quantityType = QuantifierFixedCount;
        quantityCount = 1;
    }

    PatternTerm(Type type, unsigned subpatternId, PatternDisjunction* disjunction, bool capture = false, bool invert = false)
        : type(type)
        , m_capture(capture)
        , m_invert(invert)
    {
        parentheses.disjunction = disjunction;
        parentheses.subpatternId = subpatternId;
        parentheses.isCopy = false;
        parentheses.isTerminal = false;
        quantityType = QuantifierFixedCount;
        quantityCount = 1;
    }

    PatternTerm(Type type, bool invert = false)
        : type(type)
        , m_capture(false)
        , m_invert(invert)
    {
        quantityType = QuantifierFixedCount;
        quantityCount = 1;
    }

    PatternTerm(unsigned spatternId)
        : type(TypeBackReference)
        , m_capture(false)
        , m_invert(false)
    {
        backReferenceSubpatternId = spatternId;
        quantityType = QuantifierFixedCount;
        quantityCount = 1;
    }

    PatternTerm(bool bolAnchor, bool eolAnchor)
        : type(TypeDotStarEnclosure)
        , m_capture(false)
        , m_invert(false)
    {
        anchors.bolAnchor = bolAnchor;
        anchors.eolAnchor = eolAnchor;
        quantityType = QuantifierFixedCount;
        quantityCount = 1;
    }

    static PatternTerm ForwardReference()
    {
        return PatternTerm(TypeForwardReference);
    }

    static PatternTerm BOL()
    {
        return PatternTerm(TypeAssertionBOL);
    }

    static PatternTerm EOL()
    {
        return PatternTerm(TypeAssertionEOL);
    }

    static PatternTerm WordBoundary(bool invert)
    {
        return PatternTerm(TypeAssertionWordBoundary, invert);
    }

    bool invert()
    {
        return m_invert;
    }

    bool capture()
    {
        return m_capture;
    }

    void quantify(unsigned count, QuantifierType type)
    {
        quantityCount = count;
        quantityType = type;
    }
};

struct PatternAlternative {
    public: void* operator new(size_t, void* p) { return p; } void* operator new[](size_t, void* p) { return p; } void* operator new(size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNew); return p; } void operator delete(void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNew); ::WTF::fastFree(p); } void* operator new[](size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNewArray); return p; } void operator delete[](void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNewArray); ::WTF::fastFree(p); } private: typedef int ThisIsHereToForceASemicolonAfterThisMacro;
public:
    PatternAlternative(PatternDisjunction* disjunction)
        : m_parent(disjunction)
        , m_onceThrough(false)
        , m_hasFixedSize(false)
        , m_startsWithBOL(false)
        , m_containsBOL(false)
    {
    }

    PatternTerm& lastTerm()
    {
        ((void)0);
        return m_terms[m_terms.size() - 1];
    }

    void removeLastTerm()
    {
        ((void)0);
        m_terms.shrink(m_terms.size() - 1);
    }

    void setOnceThrough()
    {
        m_onceThrough = true;
    }

    bool onceThrough()
    {
        return m_onceThrough;
    }

    Vector<PatternTerm> m_terms;
    PatternDisjunction* m_parent;
    unsigned m_minimumSize;
    bool m_onceThrough : 1;
    bool m_hasFixedSize : 1;
    bool m_startsWithBOL : 1;
    bool m_containsBOL : 1;
};

struct PatternDisjunction {
    public: void* operator new(size_t, void* p) { return p; } void* operator new[](size_t, void* p) { return p; } void* operator new(size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNew); return p; } void operator delete(void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNew); ::WTF::fastFree(p); } void* operator new[](size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNewArray); return p; } void operator delete[](void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNewArray); ::WTF::fastFree(p); } private: typedef int ThisIsHereToForceASemicolonAfterThisMacro;
public:
    PatternDisjunction(PatternAlternative* parent = 0)
        : m_parent(parent)
        , m_hasFixedSize(false)
    {
    }

    ~PatternDisjunction()
    {
        deleteAllValues(m_alternatives);
    }

    PatternAlternative* addNewAlternative()
    {
        PatternAlternative* alternative = new PatternAlternative(this);
        m_alternatives.append(alternative);
        return alternative;
    }

    Vector<PatternAlternative*> m_alternatives;
    PatternAlternative* m_parent;
    unsigned m_minimumSize;
    unsigned m_callFrameSize;
    bool m_hasFixedSize;
};





CharacterClass* newlineCreate();
CharacterClass* digitsCreate();
CharacterClass* spacesCreate();
CharacterClass* wordcharCreate();
CharacterClass* nondigitsCreate();
CharacterClass* nonspacesCreate();
CharacterClass* nonwordcharCreate();

struct TermChain {
    TermChain(PatternTerm term)
        : term(term)
    {}

    PatternTerm term;
    Vector<TermChain> hotTerms;
};

struct YarrPattern {
    YarrPattern(const UString& pattern, bool ignoreCase, bool multiline, const char** error);

    ~YarrPattern()
    {
        deleteAllValues(m_disjunctions);
        deleteAllValues(m_userCharacterClasses);
    }

    void reset()
    {
        m_numSubpatterns = 0;
        m_maxBackReference = 0;

        m_containsBackreferences = false;
        m_containsBOL = false;

        newlineCached = 0;
        digitsCached = 0;
        spacesCached = 0;
        wordcharCached = 0;
        nondigitsCached = 0;
        nonspacesCached = 0;
        nonwordcharCached = 0;

        deleteAllValues(m_disjunctions);
        m_disjunctions.clear();
        deleteAllValues(m_userCharacterClasses);
        m_userCharacterClasses.clear();
    }

    bool containsIllegalBackReference()
    {
        return m_maxBackReference > m_numSubpatterns;
    }

    CharacterClass* newlineCharacterClass()
    {
        if (!newlineCached)
            m_userCharacterClasses.append(newlineCached = newlineCreate());
        return newlineCached;
    }
    CharacterClass* digitsCharacterClass()
    {
        if (!digitsCached)
            m_userCharacterClasses.append(digitsCached = digitsCreate());
        return digitsCached;
    }
    CharacterClass* spacesCharacterClass()
    {
        if (!spacesCached)
            m_userCharacterClasses.append(spacesCached = spacesCreate());
        return spacesCached;
    }
    CharacterClass* wordcharCharacterClass()
    {
        if (!wordcharCached)
            m_userCharacterClasses.append(wordcharCached = wordcharCreate());
        return wordcharCached;
    }
    CharacterClass* nondigitsCharacterClass()
    {
        if (!nondigitsCached)
            m_userCharacterClasses.append(nondigitsCached = nondigitsCreate());
        return nondigitsCached;
    }
    CharacterClass* nonspacesCharacterClass()
    {
        if (!nonspacesCached)
            m_userCharacterClasses.append(nonspacesCached = nonspacesCreate());
        return nonspacesCached;
    }
    CharacterClass* nonwordcharCharacterClass()
    {
        if (!nonwordcharCached)
            m_userCharacterClasses.append(nonwordcharCached = nonwordcharCreate());
        return nonwordcharCached;
    }

    bool m_ignoreCase : 1;
    bool m_multiline : 1;
    bool m_containsBackreferences : 1;
    bool m_containsBOL : 1;
    unsigned m_numSubpatterns;
    unsigned m_maxBackReference;
    PatternDisjunction* m_body;
    Vector<PatternDisjunction*, 4> m_disjunctions;
    Vector<CharacterClass*> m_userCharacterClasses;

private:
    const char* compile(const UString& patternString);

    CharacterClass* newlineCached;
    CharacterClass* digitsCached;
    CharacterClass* spacesCached;
    CharacterClass* wordcharCached;
    CharacterClass* nondigitsCached;
    CharacterClass* nonspacesCached;
    CharacterClass* nonwordcharCached;
};

} }
# 30 "./yarr/YarrInterpreter.h" 2



namespace WTF {
class BumpPointerAllocator;
}
using WTF::BumpPointerAllocator;

namespace JSC { namespace Yarr {

class ByteDisjunction;

struct ByteTerm {
    enum Type {
        TypeBodyAlternativeBegin,
        TypeBodyAlternativeDisjunction,
        TypeBodyAlternativeEnd,
        TypeAlternativeBegin,
        TypeAlternativeDisjunction,
        TypeAlternativeEnd,
        TypeSubpatternBegin,
        TypeSubpatternEnd,
        TypeAssertionBOL,
        TypeAssertionEOL,
        TypeAssertionWordBoundary,
        TypePatternCharacterOnce,
        TypePatternCharacterFixed,
        TypePatternCharacterGreedy,
        TypePatternCharacterNonGreedy,
        TypePatternCasedCharacterOnce,
        TypePatternCasedCharacterFixed,
        TypePatternCasedCharacterGreedy,
        TypePatternCasedCharacterNonGreedy,
        TypeCharacterClass,
        TypeBackReference,
        TypeParenthesesSubpattern,
        TypeParenthesesSubpatternOnceBegin,
        TypeParenthesesSubpatternOnceEnd,
        TypeParenthesesSubpatternTerminalBegin,
        TypeParenthesesSubpatternTerminalEnd,
        TypeParentheticalAssertionBegin,
        TypeParentheticalAssertionEnd,
        TypeCheckInput,
        TypeUncheckInput,
        TypeDotStarEnclosure,
    } type;
    union {
        struct {
            union {
                UChar patternCharacter;
                struct {
                    UChar lo;
                    UChar hi;
                } casedCharacter;
                CharacterClass* characterClass;
                unsigned subpatternId;
            };
            union {
                ByteDisjunction* parenthesesDisjunction;
                unsigned parenthesesWidth;
            };
            QuantifierType quantityType;
            unsigned quantityCount;
        } atom;
        struct {
            int next;
            int end;
            bool onceThrough;
        } alternative;
        struct {
            bool m_bol : 1;
            bool m_eol : 1;
        } anchors;
        unsigned checkInputCount;
    };
    unsigned frameLocation;
    bool m_capture : 1;
    bool m_invert : 1;
    int inputPosition;

    ByteTerm(UChar ch, int inputPos, unsigned frameLocation, Checked<unsigned> quantityCount, QuantifierType quantityType)
        : frameLocation(frameLocation)
        , m_capture(false)
        , m_invert(false)
    {
        switch (quantityType) {
        case QuantifierFixedCount:
            type = (quantityCount == 1) ? ByteTerm::TypePatternCharacterOnce : ByteTerm::TypePatternCharacterFixed;
            break;
        case QuantifierGreedy:
            type = ByteTerm::TypePatternCharacterGreedy;
            break;
        case QuantifierNonGreedy:
            type = ByteTerm::TypePatternCharacterNonGreedy;
            break;
        }

        atom.patternCharacter = ch;
        atom.quantityType = quantityType;
        atom.quantityCount = quantityCount.unsafeGet();
        inputPosition = inputPos;
    }

    ByteTerm(UChar lo, UChar hi, int inputPos, unsigned frameLocation, Checked<unsigned> quantityCount, QuantifierType quantityType)
        : frameLocation(frameLocation)
        , m_capture(false)
        , m_invert(false)
    {
        switch (quantityType) {
        case QuantifierFixedCount:
            type = (quantityCount == 1) ? ByteTerm::TypePatternCasedCharacterOnce : ByteTerm::TypePatternCasedCharacterFixed;
            break;
        case QuantifierGreedy:
            type = ByteTerm::TypePatternCasedCharacterGreedy;
            break;
        case QuantifierNonGreedy:
            type = ByteTerm::TypePatternCasedCharacterNonGreedy;
            break;
        }

        atom.casedCharacter.lo = lo;
        atom.casedCharacter.hi = hi;
        atom.quantityType = quantityType;
        atom.quantityCount = quantityCount.unsafeGet();
        inputPosition = inputPos;
    }

    ByteTerm(CharacterClass* characterClass, bool invert, int inputPos)
        : type(ByteTerm::TypeCharacterClass)
        , m_capture(false)
        , m_invert(invert)
    {
        atom.characterClass = characterClass;
        atom.quantityType = QuantifierFixedCount;
        atom.quantityCount = 1;
        inputPosition = inputPos;
    }

    ByteTerm(Type type, unsigned subpatternId, ByteDisjunction* parenthesesInfo, bool capture, int inputPos)
        : type(type)
        , m_capture(capture)
        , m_invert(false)
    {
        atom.subpatternId = subpatternId;
        atom.parenthesesDisjunction = parenthesesInfo;
        atom.quantityType = QuantifierFixedCount;
        atom.quantityCount = 1;
        inputPosition = inputPos;
    }

    ByteTerm(Type type, bool invert = false)
        : type(type)
        , m_capture(false)
        , m_invert(invert)
    {
        atom.quantityType = QuantifierFixedCount;
        atom.quantityCount = 1;
    }

    ByteTerm(Type type, unsigned subpatternId, bool capture, bool invert, int inputPos)
        : type(type)
        , m_capture(capture)
        , m_invert(invert)
    {
        atom.subpatternId = subpatternId;
        atom.quantityType = QuantifierFixedCount;
        atom.quantityCount = 1;
        inputPosition = inputPos;
    }

    static ByteTerm BOL(int inputPos)
    {
        ByteTerm term(TypeAssertionBOL);
        term.inputPosition = inputPos;
        return term;
    }

    static ByteTerm CheckInput(Checked<unsigned> count)
    {
        ByteTerm term(TypeCheckInput);
        term.checkInputCount = count.unsafeGet();
        return term;
    }

    static ByteTerm UncheckInput(Checked<unsigned> count)
    {
        ByteTerm term(TypeUncheckInput);
        term.checkInputCount = count.unsafeGet();
        return term;
    }

    static ByteTerm EOL(int inputPos)
    {
        ByteTerm term(TypeAssertionEOL);
        term.inputPosition = inputPos;
        return term;
    }

    static ByteTerm WordBoundary(bool invert, int inputPos)
    {
        ByteTerm term(TypeAssertionWordBoundary, invert);
        term.inputPosition = inputPos;
        return term;
    }

    static ByteTerm BackReference(unsigned subpatternId, int inputPos)
    {
        return ByteTerm(TypeBackReference, subpatternId, false, false, inputPos);
    }

    static ByteTerm BodyAlternativeBegin(bool onceThrough)
    {
        ByteTerm term(TypeBodyAlternativeBegin);
        term.alternative.next = 0;
        term.alternative.end = 0;
        term.alternative.onceThrough = onceThrough;
        return term;
    }

    static ByteTerm BodyAlternativeDisjunction(bool onceThrough)
    {
        ByteTerm term(TypeBodyAlternativeDisjunction);
        term.alternative.next = 0;
        term.alternative.end = 0;
        term.alternative.onceThrough = onceThrough;
        return term;
    }

    static ByteTerm BodyAlternativeEnd()
    {
        ByteTerm term(TypeBodyAlternativeEnd);
        term.alternative.next = 0;
        term.alternative.end = 0;
        term.alternative.onceThrough = false;
        return term;
    }

    static ByteTerm AlternativeBegin()
    {
        ByteTerm term(TypeAlternativeBegin);
        term.alternative.next = 0;
        term.alternative.end = 0;
        term.alternative.onceThrough = false;
        return term;
    }

    static ByteTerm AlternativeDisjunction()
    {
        ByteTerm term(TypeAlternativeDisjunction);
        term.alternative.next = 0;
        term.alternative.end = 0;
        term.alternative.onceThrough = false;
        return term;
    }

    static ByteTerm AlternativeEnd()
    {
        ByteTerm term(TypeAlternativeEnd);
        term.alternative.next = 0;
        term.alternative.end = 0;
        term.alternative.onceThrough = false;
        return term;
    }

    static ByteTerm SubpatternBegin()
    {
        return ByteTerm(TypeSubpatternBegin);
    }

    static ByteTerm SubpatternEnd()
    {
        return ByteTerm(TypeSubpatternEnd);
    }

    static ByteTerm DotStarEnclosure(bool bolAnchor, bool eolAnchor)
    {
        ByteTerm term(TypeDotStarEnclosure);
        term.anchors.m_bol = bolAnchor;
        term.anchors.m_eol = eolAnchor;
        return term;
    }

    bool invert()
    {
        return m_invert;
    }

    bool capture()
    {
        return m_capture;
    }
};

class ByteDisjunction {
    public: void* operator new(size_t, void* p) { return p; } void* operator new[](size_t, void* p) { return p; } void* operator new(size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNew); return p; } void operator delete(void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNew); ::WTF::fastFree(p); } void* operator new[](size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNewArray); return p; } void operator delete[](void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNewArray); ::WTF::fastFree(p); } private: typedef int ThisIsHereToForceASemicolonAfterThisMacro;
public:
    ByteDisjunction(unsigned numSubpatterns, unsigned frameSize)
        : m_numSubpatterns(numSubpatterns)
        , m_frameSize(frameSize)
    {
    }

    Vector<ByteTerm> terms;
    unsigned m_numSubpatterns;
    unsigned m_frameSize;
};

struct BytecodePattern {
    public: void* operator new(size_t, void* p) { return p; } void* operator new[](size_t, void* p) { return p; } void* operator new(size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNew); return p; } void operator delete(void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNew); ::WTF::fastFree(p); } void* operator new[](size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNewArray); return p; } void operator delete[](void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNewArray); ::WTF::fastFree(p); } private: typedef int ThisIsHereToForceASemicolonAfterThisMacro;
public:
    BytecodePattern(PassOwnPtr<ByteDisjunction> body, Vector<ByteDisjunction*> allParenthesesInfo, YarrPattern& pattern, BumpPointerAllocator* allocator)
        : m_body(body)
        , m_ignoreCase(pattern.m_ignoreCase)
        , m_multiline(pattern.m_multiline)
        , m_allocator(allocator)
    {
        newlineCharacterClass = pattern.newlineCharacterClass();
        wordcharCharacterClass = pattern.wordcharCharacterClass();

        m_allParenthesesInfo.append(allParenthesesInfo);
        m_userCharacterClasses.append(pattern.m_userCharacterClasses);



        pattern.m_userCharacterClasses.clear();
    }

    ~BytecodePattern()
    {
        deleteAllValues(m_allParenthesesInfo);
        deleteAllValues(m_userCharacterClasses);
    }

    OwnPtr<ByteDisjunction> m_body;
    bool m_ignoreCase;
    bool m_multiline;


    BumpPointerAllocator* m_allocator;

    CharacterClass* newlineCharacterClass;
    CharacterClass* wordcharCharacterClass;

private:
    Vector<ByteDisjunction*> m_allParenthesesInfo;
    Vector<CharacterClass*> m_userCharacterClasses;
};

} }
# 32 "./yarr/Yarr.h" 2


namespace JSC { namespace Yarr {
# 45 "./yarr/Yarr.h"
static const unsigned quantifyInfinite = (2147483647 *2U +1U);



static const unsigned matchLimit = 1000000;

enum JSRegExpResult {
    JSRegExpMatch = 1,
    JSRegExpNoMatch = 0,
    JSRegExpErrorNoMatch = -1,
    JSRegExpErrorHitLimit = -2,
    JSRegExpErrorNoMemory = -3,
    JSRegExpErrorInternal = -4
};

enum YarrCharSize {
    Char8,
    Char16
};

PassOwnPtr<BytecodePattern> byteCompile(YarrPattern&, BumpPointerAllocator*);
int interpret(BytecodePattern*, const UString& input, unsigned start, unsigned length, int* output);

} }
# 30 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/RegExp.h" 2



namespace JSC {

    struct RegExpRepresentation;
    class JSGlobalData;

    RegExpFlags regExpFlags(const UString&);

    class RegExp : public JSCell {
    public:
        typedef JSCell Base;

        static RegExp* create(JSGlobalData&, const UString& pattern, RegExpFlags);
        ~RegExp();

        bool global() const { return m_flags & FlagGlobal; }
        bool ignoreCase() const { return m_flags & FlagIgnoreCase; }
        bool multiline() const { return m_flags & FlagMultiline; }

        const UString& pattern() const { return m_patternString; }

        bool isValid() const { return !m_constructionError && m_flags != InvalidFlags; }
        const char* errorMessage() const { return m_constructionError; }

        int match(JSGlobalData&, const UString&, int startOffset, Vector<int, 32>* ovector = 0);
        unsigned numSubpatterns() const { return m_numSubpatterns; }

        bool hasCode()
        {
            return m_representation;
        }

        void invalidateCode();





        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue prototype)
        {
            return Structure::create(globalData, globalObject, prototype, TypeInfo(LeafType, 0), &s_info);
        }

        static const ClassInfo s_info;

        RegExpKey key() { return RegExpKey(m_flags, m_patternString); }

    protected:
        void finishCreation(JSGlobalData&);

    private:
        friend class RegExpCache;
        RegExp(JSGlobalData&, const UString&, RegExpFlags);

        static RegExp* createWithoutCaching(JSGlobalData&, const UString&, RegExpFlags);

        enum RegExpState {
            ParseError,
            JITCode,
            ByteCode,
            NotCompiled
        } m_state;

        void compile(JSGlobalData*, Yarr::YarrCharSize);
        void compileIfNecessary(JSGlobalData&, Yarr::YarrCharSize);





        UString m_patternString;
        RegExpFlags m_flags;
        const char* m_constructionError;
        unsigned m_numSubpatterns;





        OwnPtr<RegExpRepresentation> m_representation;
    };

}
# 26 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/RegExpObject.h" 2

namespace JSC {

    class RegExpObject : public JSNonFinalObject {
    public:
        typedef JSNonFinalObject Base;

        static RegExpObject* create(ExecState* exec, JSGlobalObject* globalObject, Structure* structure, RegExp* regExp)
        {
            RegExpObject* object = new (allocateCell<RegExpObject>(*exec->heap())) RegExpObject(globalObject, structure, regExp);
            object->finishCreation(globalObject);
            return object;
        }

        static RegExpObject* create(JSGlobalData& globalData, JSGlobalObject* globalObject, Structure* structure, RegExp* regExp)
        {
            RegExpObject* object = new (allocateCell<RegExpObject>(globalData.heap)) RegExpObject(globalObject, structure, regExp);
            object->finishCreation(globalObject);
            return object;
        }

        virtual ~RegExpObject();

        void setRegExp(JSGlobalData& globalData, RegExp* r) { d->regExp.set(globalData, this, r); }
        RegExp* regExp() const { return d->regExp.get(); }

        void setLastIndex(size_t lastIndex)
        {
            d->lastIndex.setWithoutWriteBarrier(jsNumber(lastIndex));
        }
        void setLastIndex(JSGlobalData& globalData, JSValue lastIndex)
        {
            d->lastIndex.set(globalData, this, lastIndex);
        }
        JSValue getLastIndex() const
        {
            return d->lastIndex.get();
        }

        JSValue test(ExecState*);
        JSValue exec(ExecState*);

        static bool getOwnPropertySlot(JSCell*, ExecState*, const Identifier& propertyName, PropertySlot&);
        virtual bool getOwnPropertyDescriptor(ExecState*, const Identifier&, PropertyDescriptor&);
        static void put(JSCell*, ExecState*, const Identifier& propertyName, JSValue, PutPropertySlot&);

        static const ClassInfo s_info;

        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue prototype)
        {
            return Structure::create(globalData, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), &s_info);
        }

    protected:
        RegExpObject(JSGlobalObject*, Structure*, RegExp*);
        void finishCreation(JSGlobalObject*);
        static const unsigned StructureFlags = OverridesVisitChildren | OverridesGetOwnPropertySlot | Base::StructureFlags;

        static void visitChildren(JSCell*, SlotVisitor&);

    private:
        bool match(ExecState*);

        struct RegExpObjectData {
            public: void* operator new(size_t, void* p) { return p; } void* operator new[](size_t, void* p) { return p; } void* operator new(size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNew); return p; } void operator delete(void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNew); ::WTF::fastFree(p); } void* operator new[](size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNewArray); return p; } void operator delete[](void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNewArray); ::WTF::fastFree(p); } private: typedef int ThisIsHereToForceASemicolonAfterThisMacro;
        public:
            RegExpObjectData(JSGlobalData& globalData, RegExpObject* owner, RegExp* regExp)
                : regExp(globalData, owner, regExp)
            {
                lastIndex.setWithoutWriteBarrier(jsNumber(0));
            }

            WriteBarrier<RegExp> regExp;
            WriteBarrier<Unknown> lastIndex;
        };



        OwnPtr<RegExpObjectData> d;
    };

    RegExpObject* asRegExpObject(JSValue);

    inline RegExpObject* asRegExpObject(JSValue value)
    {
        ((void)0);
        return static_cast<RegExpObject*>(asObject(value));
    }

}
# 46 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/CodeBlock.h" 2

# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/ValueProfile.h" 1
# 37 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/ValueProfile.h"
namespace JSC {


struct ValueProfile {
    static const unsigned logNumberOfBuckets = 3;
    static const unsigned numberOfBuckets = 1 << logNumberOfBuckets;
    static const unsigned bucketIndexMask = numberOfBuckets - 1;
    static const unsigned certainty = numberOfBuckets * numberOfBuckets;
    static const unsigned majority = certainty / 2;

    ValueProfile(int bytecodeOffset)
        : m_bytecodeOffset(bytecodeOffset)
        , m_prediction(PredictNone)
        , m_numberOfSamplesInPrediction(0)
    {
        for (unsigned i = 0; i < numberOfBuckets; ++i)
            m_buckets[i] = JSValue::encode(JSValue());
    }

    const ClassInfo* classInfo(unsigned bucket) const
    {
        JSValue value = JSValue::decode(m_buckets[bucket]);
        if (!!value) {
            if (!value.isCell())
                return 0;
            return value.asCell()->structure()->classInfo();
        }
        return 0;
    }

    unsigned numberOfSamples() const
    {
        unsigned result = 0;
        for (unsigned i = 0; i < numberOfBuckets; ++i) {
            if (!!JSValue::decode(m_buckets[i]))
                result++;
        }
        return result;
    }

    unsigned totalNumberOfSamples() const
    {
        return numberOfSamples() + m_numberOfSamplesInPrediction;
    }

    bool isLive() const
    {
        for (unsigned i = 0; i < numberOfBuckets; ++i) {
            if (!!JSValue::decode(m_buckets[i]))
                return true;
        }
        return false;
    }

    static unsigned computeProbability(unsigned counts, unsigned numberOfSamples)
    {
        if (!numberOfSamples)
            return 0;
        return counts * certainty / numberOfSamples;
    }

    unsigned numberOfInt32s() const
    {
        unsigned result = 0;
        for (unsigned i = 0; i < numberOfBuckets; ++i) {
            if (JSValue::decode(m_buckets[i]).isInt32())
                result++;
        }
        return result;
    }

    unsigned numberOfDoubles() const
    {
        unsigned result = 0;
        for (unsigned i = 0; i < numberOfBuckets; ++i) {
            if (JSValue::decode(m_buckets[i]).isDouble())
                result++;
        }
        return result;
    }

    unsigned numberOfCells() const
    {
        unsigned result = 0;
        for (unsigned i = 0; i < numberOfBuckets; ++i) {
            if (!!classInfo(i))
                result++;
        }
        return result;
    }

    unsigned numberOfObjects() const
    {
        unsigned result = 0;
        for (unsigned i = 0; i < numberOfBuckets; ++i) {
            const ClassInfo* ci = classInfo(i);
            if (!!ci && ci->isSubClassOf(&JSObject::s_info))
                result++;
        }
        return result;
    }

    unsigned numberOfFinalObjects() const
    {
        unsigned result = 0;
        for (unsigned i = 0; i < numberOfBuckets; ++i) {
            if (classInfo(i) == &JSFinalObject::s_info)
                result++;
        }
        return result;
    }

    unsigned numberOfStrings() const
    {
        unsigned result = 0;
        for (unsigned i = 0; i < numberOfBuckets; ++i) {
            if (classInfo(i) == &JSString::s_info)
                result++;
        }
        return result;
    }

    unsigned numberOfArrays() const
    {
        unsigned result = 0;
        for (unsigned i = 0; i < numberOfBuckets; ++i) {
            if (classInfo(i) == &JSArray::s_info)
                result++;
        }
        return result;
    }

    unsigned numberOfBooleans() const
    {
        unsigned result = 0;
        for (unsigned i = 0; i < numberOfBuckets; ++i) {
            if (JSValue::decode(m_buckets[i]).isBoolean())
                result++;
        }
        return result;
    }






    unsigned probabilityOfInt32() const
    {
        return computeProbability(numberOfInt32s(), numberOfSamples());
    }

    unsigned probabilityOfDouble() const
    {
        return computeProbability(numberOfDoubles(), numberOfSamples());
    }

    unsigned probabilityOfCell() const
    {
        return computeProbability(numberOfCells(), numberOfSamples());
    }

    unsigned probabilityOfObject() const
    {
        return computeProbability(numberOfObjects(), numberOfSamples());
    }

    unsigned probabilityOfFinalObject() const
    {
        return computeProbability(numberOfFinalObjects(), numberOfSamples());
    }

    unsigned probabilityOfArray() const
    {
        return computeProbability(numberOfArrays(), numberOfSamples());
    }

    unsigned probabilityOfString() const
    {
        return computeProbability(numberOfStrings(), numberOfSamples());
    }

    unsigned probabilityOfBoolean() const
    {
        return computeProbability(numberOfBooleans(), numberOfSamples());
    }
# 254 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/ValueProfile.h"
    struct Statistics {
        unsigned samples;
        unsigned int32s;
        unsigned doubles;
        unsigned cells;
        unsigned objects;
        unsigned finalObjects;
        unsigned arrays;
        unsigned strings;
        unsigned booleans;

        Statistics()
        {
            bzero(this, sizeof(Statistics));
        }
    };




    static void computeStatistics(const ClassInfo*, Statistics&);


    void computeStatistics(Statistics&) const;


    PredictedType computeUpdatedPrediction();

    int m_bytecodeOffset;

    PredictedType m_prediction;
    unsigned m_numberOfSamplesInPrediction;

    EncodedJSValue m_buckets[numberOfBuckets];
};

inline int getValueProfileBytecodeOffset(ValueProfile* valueProfile)
{
    return valueProfile->m_bytecodeOffset;
}



struct RareCaseProfile {
    RareCaseProfile(int bytecodeOffset)
        : m_bytecodeOffset(bytecodeOffset)
        , m_counter(0)
    {
    }

    int m_bytecodeOffset;
    uint32_t m_counter;
};

inline int getRareCaseProfileBytecodeOffset(RareCaseProfile* rareCaseProfile)
{
    return rareCaseProfile->m_bytecodeOffset;
}


}
# 48 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/CodeBlock.h" 2








# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/StructureStubInfo.h" 1
# 36 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/StructureStubInfo.h"
namespace JSC {

    enum AccessType {
        access_get_by_id_self,
        access_get_by_id_proto,
        access_get_by_id_chain,
        access_get_by_id_self_list,
        access_get_by_id_proto_list,
        access_put_by_id_transition,
        access_put_by_id_replace,
        access_unset,
        access_get_by_id_generic,
        access_put_by_id_generic,
        access_get_array_length,
        access_get_string_length,
    };

    struct StructureStubInfo {
        StructureStubInfo()
            : accessType(access_unset)
            , seen(false)
        {
        }

        void initGetByIdSelf(JSGlobalData& globalData, JSCell* owner, Structure* baseObjectStructure)
        {
            accessType = access_get_by_id_self;

            u.getByIdSelf.baseObjectStructure.set(globalData, owner, baseObjectStructure);
        }

        void initGetByIdProto(JSGlobalData& globalData, JSCell* owner, Structure* baseObjectStructure, Structure* prototypeStructure)
        {
            accessType = access_get_by_id_proto;

            u.getByIdProto.baseObjectStructure.set(globalData, owner, baseObjectStructure);
            u.getByIdProto.prototypeStructure.set(globalData, owner, prototypeStructure);
        }

        void initGetByIdChain(JSGlobalData& globalData, JSCell* owner, Structure* baseObjectStructure, StructureChain* chain)
        {
            accessType = access_get_by_id_chain;

            u.getByIdChain.baseObjectStructure.set(globalData, owner, baseObjectStructure);
            u.getByIdChain.chain.set(globalData, owner, chain);
        }

        void initGetByIdSelfList(PolymorphicAccessStructureList* structureList, int listSize)
        {
            accessType = access_get_by_id_self_list;

            u.getByIdProtoList.structureList = structureList;
            u.getByIdProtoList.listSize = listSize;
        }

        void initGetByIdProtoList(PolymorphicAccessStructureList* structureList, int listSize)
        {
            accessType = access_get_by_id_proto_list;

            u.getByIdProtoList.structureList = structureList;
            u.getByIdProtoList.listSize = listSize;
        }



        void initPutByIdTransition(JSGlobalData& globalData, JSCell* owner, Structure* previousStructure, Structure* structure, StructureChain* chain)
        {
            accessType = access_put_by_id_transition;

            u.putByIdTransition.previousStructure.set(globalData, owner, previousStructure);
            u.putByIdTransition.structure.set(globalData, owner, structure);
            u.putByIdTransition.chain.set(globalData, owner, chain);
        }

        void initPutByIdReplace(JSGlobalData& globalData, JSCell* owner, Structure* baseObjectStructure)
        {
            accessType = access_put_by_id_replace;

            u.putByIdReplace.baseObjectStructure.set(globalData, owner, baseObjectStructure);
        }

        void deref();
        void visitAggregate(SlotVisitor&);

        bool seenOnce()
        {
            return seen;
        }

        void setSeen()
        {
            seen = true;
        }

        unsigned bytecodeIndex;

        int8_t accessType;
        int8_t seen;


        int8_t baseGPR;



        int8_t valueGPR;
        int8_t scratchGPR;
        int16_t deltaCallToDone;
        int16_t deltaCallToStructCheck;
        int16_t deltaCallToSlowCase;


        union {
            struct {
                int16_t deltaCheckImmToCall;

                int16_t deltaCallToLoadOrStore;




            } unset;
            struct {
                WriteBarrierBase<Structure> baseObjectStructure;
            } getByIdSelf;
            struct {
                WriteBarrierBase<Structure> baseObjectStructure;
                WriteBarrierBase<Structure> prototypeStructure;
            } getByIdProto;
            struct {
                WriteBarrierBase<Structure> baseObjectStructure;
                WriteBarrierBase<StructureChain> chain;
            } getByIdChain;
            struct {
                PolymorphicAccessStructureList* structureList;
                int listSize;
            } getByIdSelfList;
            struct {
                PolymorphicAccessStructureList* structureList;
                int listSize;
            } getByIdProtoList;
            struct {
                WriteBarrierBase<Structure> previousStructure;
                WriteBarrierBase<Structure> structure;
                WriteBarrierBase<StructureChain> chain;
            } putByIdTransition;
            struct {
                WriteBarrierBase<Structure> baseObjectStructure;
            } putByIdReplace;
        } u;

        MacroAssemblerCodeRef stubRoutine;
        CodeLocationCall callReturnLocation;
        CodeLocationLabel hotPathBegin;
    };

}
# 57 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/CodeBlock.h" 2






static const int FirstConstantRegisterIndex = 0x40000000;

namespace JSC {

    enum HasSeenShouldRepatch {
        hasSeenShouldRepatch
    };

    class ExecState;

    enum CodeType { GlobalCode, EvalCode, FunctionCode };

    inline int unmodifiedArgumentsRegister(int argumentsRegister) { return argumentsRegister - 1; }

    static inline __attribute__((__always_inline__)) int missingThisObjectMarker() { return std::numeric_limits<int>::max(); }

    struct HandlerInfo {
        uint32_t start;
        uint32_t end;
        uint32_t target;
        uint32_t scopeDepth;

        CodeLocationLabel nativeCode;

    };

    struct ExpressionRangeInfo {
        enum {
            MaxOffset = (1 << 7) - 1,
            MaxDivot = (1 << 25) - 1
        };
        uint32_t instructionOffset : 25;
        uint32_t divotPoint : 25;
        uint32_t startOffset : 7;
        uint32_t endOffset : 7;
    };

    struct LineInfo {
        uint32_t instructionOffset;
        int32_t lineNumber;
    };


    struct CallLinkInfo: public BasicRawSentinelNode<CallLinkInfo> {
        CallLinkInfo()
            : hasSeenShouldRepatch(false)
            , isCall(false)
            , isDFG(false)
        {
        }

        ~CallLinkInfo()
        {
            if (isOnList())
                remove();
        }

        CodeLocationLabel callReturnLocation;
        CodeLocationDataLabelPtr hotPathBegin;
        CodeLocationNearCall hotPathOther;
        JITWriteBarrier<JSFunction> callee;
        WriteBarrier<JSFunction> lastSeenCallee;
        bool hasSeenShouldRepatch : 1;
        bool isCall : 1;
        bool isDFG : 1;
        unsigned bytecodeIndex;

        bool isLinked() { return callee; }
        void unlink(JSGlobalData&, RepatchBuffer&);

        bool seenOnce()
        {
            return hasSeenShouldRepatch;
        }

        void setSeen()
        {
            hasSeenShouldRepatch = true;
        }
    };

    struct MethodCallLinkInfo {
        MethodCallLinkInfo()
            : seen(false)
        {
        }

        bool seenOnce()
        {
            return seen;
        }

        void setSeen()
        {
            seen = true;
        }

        unsigned bytecodeIndex;
        CodeLocationCall callReturnLocation;
        JITWriteBarrier<Structure> cachedStructure;
        JITWriteBarrier<Structure> cachedPrototypeStructure;


        JITWriteBarrier<JSObject> cachedFunction;
        JITWriteBarrier<JSObject> cachedPrototype;
        bool seen;
    };

    struct GlobalResolveInfo {
        GlobalResolveInfo(unsigned bytecodeOffset)
            : offset(0)
            , bytecodeOffset(bytecodeOffset)
        {
        }

        WriteBarrier<Structure> structure;
        unsigned offset;
        unsigned bytecodeOffset;
    };







    struct CallReturnOffsetToBytecodeOffset {
        CallReturnOffsetToBytecodeOffset(unsigned callReturnOffset, unsigned bytecodeOffset)
            : callReturnOffset(callReturnOffset)
            , bytecodeOffset(bytecodeOffset)
        {
        }

        unsigned callReturnOffset;
        unsigned bytecodeOffset;
    };



    inline void* getStructureStubInfoReturnLocation(StructureStubInfo* structureStubInfo)
    {
        return structureStubInfo->callReturnLocation.executableAddress();
    }

    inline unsigned getStructureStubInfoBytecodeIndex(StructureStubInfo* structureStubInfo)
    {
        return structureStubInfo->bytecodeIndex;
    }

    inline void* getCallLinkInfoReturnLocation(CallLinkInfo* callLinkInfo)
    {
        return callLinkInfo->callReturnLocation.executableAddress();
    }

    inline unsigned getCallLinkInfoBytecodeIndex(CallLinkInfo* callLinkInfo)
    {
        return callLinkInfo->bytecodeIndex;
    }

    inline void* getMethodCallLinkInfoReturnLocation(MethodCallLinkInfo* methodCallLinkInfo)
    {
        return methodCallLinkInfo->callReturnLocation.executableAddress();
    }

    inline unsigned getMethodCallLinkInfoBytecodeIndex(MethodCallLinkInfo* methodCallLinkInfo)
    {
        return methodCallLinkInfo->bytecodeIndex;
    }

    inline unsigned getCallReturnOffset(CallReturnOffsetToBytecodeOffset* pc)
    {
        return pc->callReturnOffset;
    }


    class CodeBlock {
        public: void* operator new(size_t, void* p) { return p; } void* operator new[](size_t, void* p) { return p; } void* operator new(size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNew); return p; } void operator delete(void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNew); ::WTF::fastFree(p); } void* operator new[](size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNewArray); return p; } void operator delete[](void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNewArray); ::WTF::fastFree(p); } private: typedef int ThisIsHereToForceASemicolonAfterThisMacro;
        friend class JIT;
    protected:
        CodeBlock(ScriptExecutable* ownerExecutable, CodeType, JSGlobalObject*, PassRefPtr<SourceProvider>, unsigned sourceOffset, SymbolTable*, bool isConstructor, PassOwnPtr<CodeBlock> alternative);

        WriteBarrier<JSGlobalObject> m_globalObject;
        Heap* m_heap;

    public:
        virtual ~CodeBlock();

        CodeBlock* alternative() { return m_alternative.get(); }
        PassOwnPtr<CodeBlock> releaseAlternative() { return m_alternative.release(); }
        void setAlternative(PassOwnPtr<CodeBlock> alternative) { m_alternative = alternative; }


        CodeBlock* baselineVersion()
        {
            CodeBlock* result = replacement();
            if (!result)
                return 0;
            while (result->alternative())
                result = result->alternative();
            ((void)0);
            ((void)0);
            return result;
        }


        void visitAggregate(SlotVisitor&);

        static void dumpStatistics();







        bool isStrictMode() const { return m_isStrictMode; }

        inline bool isKnownNotImmediate(int index)
        {
            if (index == m_thisRegister && !m_isStrictMode)
                return true;

            if (isConstantRegisterIndex(index))
                return getConstant(index).isCell();

            return false;
        }

        inline __attribute__((__always_inline__)) bool isTemporaryRegisterIndex(int index)
        {
            return index >= m_numVars;
        }

        HandlerInfo* handlerForBytecodeOffset(unsigned bytecodeOffset);
        int lineNumberForBytecodeOffset(unsigned bytecodeOffset);
        void expressionRangeForBytecodeOffset(unsigned bytecodeOffset, int& divot, int& startOffset, int& endOffset);



        StructureStubInfo& getStubInfo(ReturnAddressPtr returnAddress)
        {
            return *(binarySearch<StructureStubInfo, void*, getStructureStubInfoReturnLocation>(m_structureStubInfos.begin(), m_structureStubInfos.size(), returnAddress.value()));
        }

        StructureStubInfo& getStubInfo(unsigned bytecodeIndex)
        {
            return *(binarySearch<StructureStubInfo, unsigned, getStructureStubInfoBytecodeIndex>(m_structureStubInfos.begin(), m_structureStubInfos.size(), bytecodeIndex));
        }

        CallLinkInfo& getCallLinkInfo(ReturnAddressPtr returnAddress)
        {
            return *(binarySearch<CallLinkInfo, void*, getCallLinkInfoReturnLocation>(m_callLinkInfos.begin(), m_callLinkInfos.size(), returnAddress.value()));
        }

        CallLinkInfo& getCallLinkInfo(unsigned bytecodeIndex)
        {
            return *(binarySearch<CallLinkInfo, unsigned, getCallLinkInfoBytecodeIndex>(m_callLinkInfos.begin(), m_callLinkInfos.size(), bytecodeIndex));
        }

        MethodCallLinkInfo& getMethodCallLinkInfo(ReturnAddressPtr returnAddress)
        {
            return *(binarySearch<MethodCallLinkInfo, void*, getMethodCallLinkInfoReturnLocation>(m_methodCallLinkInfos.begin(), m_methodCallLinkInfos.size(), returnAddress.value()));
        }

        MethodCallLinkInfo& getMethodCallLinkInfo(unsigned bytecodeIndex)
        {
            return *(binarySearch<MethodCallLinkInfo, unsigned, getMethodCallLinkInfoBytecodeIndex>(m_methodCallLinkInfos.begin(), m_methodCallLinkInfos.size(), bytecodeIndex));
        }

        unsigned bytecodeOffset(ReturnAddressPtr returnAddress)
        {
            if (!m_rareData)
                return 1;
            Vector<CallReturnOffsetToBytecodeOffset>& callIndices = m_rareData->m_callReturnIndexVector;
            if (!callIndices.size())
                return 1;
            return binarySearch<CallReturnOffsetToBytecodeOffset, unsigned, getCallReturnOffset>(callIndices.begin(), callIndices.size(), getJITCode().offsetOf(returnAddress.value()))->bytecodeOffset;
        }

        void unlinkCalls();

        bool hasIncomingCalls() { return m_incomingCalls.begin() != m_incomingCalls.end(); }

        void linkIncomingCall(CallLinkInfo* incoming)
        {
            m_incomingCalls.push(incoming);
        }

        void unlinkIncomingCalls();



        void setJITCodeMap(PassOwnPtr<CompactJITCodeMap> jitCodeMap)
        {
            m_jitCodeMap = jitCodeMap;
        }
        CompactJITCodeMap* jitCodeMap()
        {
            return m_jitCodeMap.get();
        }

        DFG::OSREntryData* appendDFGOSREntryData(unsigned bytecodeIndex, unsigned machineCodeOffset)
        {
            DFG::OSREntryData entry;
            entry.m_bytecodeIndex = bytecodeIndex;
            entry.m_machineCodeOffset = machineCodeOffset;
            m_dfgOSREntry.append(entry);
            return &m_dfgOSREntry.last();
        }
        unsigned numberOfDFGOSREntries() const { return m_dfgOSREntry.size(); }
        DFG::OSREntryData* dfgOSREntryData(unsigned i) { return &m_dfgOSREntry[i]; }
        DFG::OSREntryData* dfgOSREntryDataForBytecodeIndex(unsigned bytecodeIndex)
        {
            return binarySearch<DFG::OSREntryData, unsigned, DFG::getOSREntryDataBytecodeIndex>(m_dfgOSREntry.begin(), m_dfgOSREntry.size(), bytecodeIndex);
        }
# 387 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/CodeBlock.h"
        void setIsNumericCompareFunction(bool isNumericCompareFunction) { m_isNumericCompareFunction = isNumericCompareFunction; }
        bool isNumericCompareFunction() { return m_isNumericCompareFunction; }

        Vector<Instruction>& instructions() { return m_instructions; }
        void discardBytecode() { m_instructions.clear(); }





        unsigned instructionCount() { return m_instructionCount; }
        void setInstructionCount(unsigned instructionCount) { m_instructionCount = instructionCount; }


        void setJITCode(const JITCode& code, MacroAssemblerCodePtr codeWithArityCheck)
        {
            m_jitCode = code;
            m_jitCodeWithArityCheck = codeWithArityCheck;
        }
        JITCode& getJITCode() { return m_jitCode; }
        MacroAssemblerCodePtr getJITCodeWithArityCheck() { return m_jitCodeWithArityCheck; }
        JITCode::JITType getJITType() { return m_jitCode.jitType(); }
        ExecutableMemoryHandle* executableMemory() { return getJITCode().getExecutableMemory(); }
        virtual JSObject* compileOptimized(ExecState*, ScopeChainNode*) = 0;
        virtual void jettison(JSGlobalData&) = 0;
        virtual CodeBlock* replacement() = 0;
        virtual bool canCompileWithDFG() = 0;
        bool hasOptimizedReplacement()
        {
            ((void)0);
            bool result = replacement()->getJITType() > getJITType();
# 426 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/CodeBlock.h"
            return result;
        }




        ScriptExecutable* ownerExecutable() const { return m_ownerExecutable.get(); }

        void setGlobalData(JSGlobalData* globalData) { m_globalData = globalData; }
        JSGlobalData* globalData() { return m_globalData; }

        void setThisRegister(int thisRegister) { m_thisRegister = thisRegister; }
        int thisRegister() const { return m_thisRegister; }

        void setNeedsFullScopeChain(bool needsFullScopeChain) { m_needsFullScopeChain = needsFullScopeChain; }
        bool needsFullScopeChain() const { return m_needsFullScopeChain; }
        void setUsesEval(bool usesEval) { m_usesEval = usesEval; }
        bool usesEval() const { return m_usesEval; }

        void setArgumentsRegister(int argumentsRegister)
        {
            ((void)0);
            m_argumentsRegister = argumentsRegister;
            ((void)0);
        }
        int argumentsRegister()
        {
            ((void)0);
            return m_argumentsRegister;
        }
        void setActivationRegister(int activationRegister)
        {
            m_activationRegister = activationRegister;
        }
        int activationRegister()
        {
            ((void)0);
            return m_activationRegister;
        }
        bool usesArguments() const { return m_argumentsRegister != -1; }

        CodeType codeType() const { return m_codeType; }

        SourceProvider* source() const { return m_source.get(); }
        unsigned sourceOffset() const { return m_sourceOffset; }

        size_t numberOfJumpTargets() const { return m_jumpTargets.size(); }
        void addJumpTarget(unsigned jumpTarget) { m_jumpTargets.append(jumpTarget); }
        unsigned jumpTarget(int index) const { return m_jumpTargets[index]; }
        unsigned lastJumpTarget() const { return m_jumpTargets.last(); }

        void createActivation(CallFrame*);

        void clearEvalCache();
# 495 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/CodeBlock.h"
        void setNumberOfStructureStubInfos(size_t size) { m_structureStubInfos.grow(size); }
        size_t numberOfStructureStubInfos() const { return m_structureStubInfos.size(); }
        StructureStubInfo& structureStubInfo(int index) { return m_structureStubInfos[index]; }

        void addGlobalResolveInfo(unsigned globalResolveInstruction)
        {
            if (m_globalData->canUseJIT())
                m_globalResolveInfos.append(GlobalResolveInfo(globalResolveInstruction));
        }
        GlobalResolveInfo& globalResolveInfo(int index) { return m_globalResolveInfos[index]; }
        bool hasGlobalResolveInfoAtBytecodeOffset(unsigned bytecodeOffset);

        void setNumberOfCallLinkInfos(size_t size) { m_callLinkInfos.grow(size); }
        size_t numberOfCallLinkInfos() const { return m_callLinkInfos.size(); }
        CallLinkInfo& callLinkInfo(int index) { return m_callLinkInfos[index]; }

        void addMethodCallLinkInfos(unsigned n) { ((void)0); m_methodCallLinkInfos.grow(n); }
        MethodCallLinkInfo& methodCallLinkInfo(int index) { return m_methodCallLinkInfos[index]; }



        ValueProfile* addValueProfile(int bytecodeOffset)
        {
            m_valueProfiles.append(ValueProfile(bytecodeOffset));
            return &m_valueProfiles.last();
        }
        unsigned numberOfValueProfiles() { return m_valueProfiles.size(); }
        ValueProfile* valueProfile(int index) { return &m_valueProfiles[index]; }
        ValueProfile* valueProfileForBytecodeOffset(int bytecodeOffset)
        {
            return WTF::genericBinarySearch<ValueProfile, int, getValueProfileBytecodeOffset>(m_valueProfiles, m_valueProfiles.size(), bytecodeOffset);
        }
        ValueProfile* valueProfileForArgument(int argumentIndex)
        {
            int index = argumentIndex;
            if (static_cast<unsigned>(index) >= m_valueProfiles.size())
                return 0;
            ValueProfile* result = valueProfile(argumentIndex);
            if (result->m_bytecodeOffset != -1)
                return 0;
            return result;
        }

        RareCaseProfile* addRareCaseProfile(int bytecodeOffset)
        {
            m_rareCaseProfiles.append(RareCaseProfile(bytecodeOffset));
            return &m_rareCaseProfiles.last();
        }
        unsigned numberOfRareCaseProfiles() { return m_rareCaseProfiles.size(); }
        RareCaseProfile* rareCaseProfile(int index) { return &m_rareCaseProfiles[index]; }
        RareCaseProfile* rareCaseProfileForBytecodeOffset(int bytecodeOffset)
        {
            return WTF::genericBinarySearch<RareCaseProfile, int, getRareCaseProfileBytecodeOffset>(m_rareCaseProfiles, m_rareCaseProfiles.size(), bytecodeOffset);
        }

        bool likelyToTakeSlowCase(int bytecodeOffset)
        {
            return rareCaseProfileForBytecodeOffset(bytecodeOffset)->m_counter >= Heuristics::likelyToTakeSlowCaseThreshold;
        }

        bool couldTakeSlowCase(int bytecodeOffset)
        {
            return rareCaseProfileForBytecodeOffset(bytecodeOffset)->m_counter >= Heuristics::couldTakeSlowCaseThreshold;
        }

        RareCaseProfile* addSpecialFastCaseProfile(int bytecodeOffset)
        {
            m_specialFastCaseProfiles.append(RareCaseProfile(bytecodeOffset));
            return &m_specialFastCaseProfiles.last();
        }
        unsigned numberOfSpecialFastCaseProfiles() { return m_specialFastCaseProfiles.size(); }
        RareCaseProfile* specialFastCaseProfile(int index) { return &m_specialFastCaseProfiles[index]; }
        RareCaseProfile* specialFastCaseProfileForBytecodeOffset(int bytecodeOffset)
        {
            return WTF::genericBinarySearch<RareCaseProfile, int, getRareCaseProfileBytecodeOffset>(m_specialFastCaseProfiles, m_specialFastCaseProfiles.size(), bytecodeOffset);
        }

        bool likelyToTakeSpecialFastCase(int bytecodeOffset)
        {
            unsigned specialFastCaseCount = specialFastCaseProfileForBytecodeOffset(bytecodeOffset)->m_counter;
            return specialFastCaseCount >= Heuristics::likelyToTakeSlowCaseThreshold;
        }

        bool likelyToTakeDeepestSlowCase(int bytecodeOffset)
        {
            unsigned slowCaseCount = rareCaseProfileForBytecodeOffset(bytecodeOffset)->m_counter;
            unsigned specialFastCaseCount = specialFastCaseProfileForBytecodeOffset(bytecodeOffset)->m_counter;
            return (slowCaseCount - specialFastCaseCount) >= Heuristics::likelyToTakeSlowCaseThreshold;
        }

        bool likelyToTakeAnySlowCase(int bytecodeOffset)
        {
            unsigned slowCaseCount = rareCaseProfileForBytecodeOffset(bytecodeOffset)->m_counter;
            unsigned specialFastCaseCount = specialFastCaseProfileForBytecodeOffset(bytecodeOffset)->m_counter;
            return (slowCaseCount + specialFastCaseCount) >= Heuristics::likelyToTakeSlowCaseThreshold;
        }

        void resetRareCaseProfiles();


        unsigned globalResolveInfoCount() const
        {

            if (m_globalData->canUseJIT())
                return m_globalResolveInfos.size();

            return 0;
        }



        size_t numberOfExceptionHandlers() const { return m_rareData ? m_rareData->m_exceptionHandlers.size() : 0; }
        void addExceptionHandler(const HandlerInfo& hanler) { createRareDataIfNecessary(); return m_rareData->m_exceptionHandlers.append(hanler); }
        HandlerInfo& exceptionHandler(int index) { ((void)0); return m_rareData->m_exceptionHandlers[index]; }

        void addExpressionInfo(const ExpressionRangeInfo& expressionInfo)
        {
            createRareDataIfNecessary();
            m_rareData->m_expressionInfo.append(expressionInfo);
        }

        void addLineInfo(unsigned bytecodeOffset, int lineNo)
        {
            createRareDataIfNecessary();
            Vector<LineInfo>& lineInfo = m_rareData->m_lineInfo;
            if (!lineInfo.size() || lineInfo.last().lineNumber != lineNo) {
                LineInfo info = { bytecodeOffset, lineNo };
                lineInfo.append(info);
            }
        }

        bool hasExpressionInfo() { return m_rareData && m_rareData->m_expressionInfo.size(); }
        bool hasLineInfo() { return m_rareData && m_rareData->m_lineInfo.size(); }


        bool needsCallReturnIndices()
        {
            return m_rareData &&
                (m_rareData->m_expressionInfo.size() || m_rareData->m_lineInfo.size() || m_rareData->m_exceptionHandlers.size());
        }


        Vector<CallReturnOffsetToBytecodeOffset>& callReturnIndexVector()
        {
            createRareDataIfNecessary();
            return m_rareData->m_callReturnIndexVector;
        }



        SegmentedVector<InlineCallFrame, 4>& inlineCallFrames()
        {
            createRareDataIfNecessary();
            return m_rareData->m_inlineCallFrames;
        }

        Vector<CodeOriginAtCallReturnOffset>& codeOrigins()
        {
            createRareDataIfNecessary();
            return m_rareData->m_codeOrigins;
        }


        bool hasCodeOrigins()
        {
            return m_rareData && !!m_rareData->m_codeOrigins.size();
        }

        CodeOrigin codeOriginForReturn(ReturnAddressPtr returnAddress)
        {
            ((void)0);
            return binarySearch<CodeOriginAtCallReturnOffset, unsigned, getCallReturnOffsetForCodeOrigin>(codeOrigins().begin(), codeOrigins().size(), getJITCode().offsetOf(returnAddress.value()))->codeOrigin;
        }




        size_t numberOfIdentifiers() const { return m_identifiers.size(); }
        void addIdentifier(const Identifier& i) { return m_identifiers.append(i); }
        Identifier& identifier(int index) { return m_identifiers[index]; }

        size_t numberOfConstantRegisters() const { return m_constantRegisters.size(); }
        void addConstant(JSValue v)
        {
            m_constantRegisters.append(WriteBarrier<Unknown>());
            m_constantRegisters.last().set(m_globalObject->globalData(), m_ownerExecutable.get(), v);
        }
        WriteBarrier<Unknown>& constantRegister(int index) { return m_constantRegisters[index - FirstConstantRegisterIndex]; }
        inline __attribute__((__always_inline__)) bool isConstantRegisterIndex(int index) const { return index >= FirstConstantRegisterIndex; }
        inline __attribute__((__always_inline__)) JSValue getConstant(int index) const { return m_constantRegisters[index - FirstConstantRegisterIndex].get(); }

        unsigned addFunctionDecl(FunctionExecutable* n)
        {
            unsigned size = m_functionDecls.size();
            m_functionDecls.append(WriteBarrier<FunctionExecutable>());
            m_functionDecls.last().set(m_globalObject->globalData(), m_ownerExecutable.get(), n);
            return size;
        }
        FunctionExecutable* functionDecl(int index) { return m_functionDecls[index].get(); }
        int numberOfFunctionDecls() { return m_functionDecls.size(); }
        unsigned addFunctionExpr(FunctionExecutable* n)
        {
            unsigned size = m_functionExprs.size();
            m_functionExprs.append(WriteBarrier<FunctionExecutable>());
            m_functionExprs.last().set(m_globalObject->globalData(), m_ownerExecutable.get(), n);
            return size;
        }
        FunctionExecutable* functionExpr(int index) { return m_functionExprs[index].get(); }

        unsigned addRegExp(RegExp* r)
        {
            createRareDataIfNecessary();
            unsigned size = m_rareData->m_regexps.size();
            m_rareData->m_regexps.append(WriteBarrier<RegExp>(*m_globalData, ownerExecutable(), r));
            return size;
        }
        unsigned numberOfRegExps() const
        {
            if (!m_rareData)
                return 0;
            return m_rareData->m_regexps.size();
        }
        RegExp* regexp(int index) const { ((void)0); return m_rareData->m_regexps[index].get(); }

        unsigned addConstantBuffer(unsigned length)
        {
            createRareDataIfNecessary();
            unsigned size = m_rareData->m_constantBuffers.size();
            m_rareData->m_constantBuffers.append(Vector<JSValue>(length));
            return size;
        }

        JSValue* constantBuffer(unsigned index)
        {
            ((void)0);
            return m_rareData->m_constantBuffers[index].data();
        }

        JSGlobalObject* globalObject() { return m_globalObject.get(); }



        size_t numberOfImmediateSwitchJumpTables() const { return m_rareData ? m_rareData->m_immediateSwitchJumpTables.size() : 0; }
        SimpleJumpTable& addImmediateSwitchJumpTable() { createRareDataIfNecessary(); m_rareData->m_immediateSwitchJumpTables.append(SimpleJumpTable()); return m_rareData->m_immediateSwitchJumpTables.last(); }
        SimpleJumpTable& immediateSwitchJumpTable(int tableIndex) { ((void)0); return m_rareData->m_immediateSwitchJumpTables[tableIndex]; }

        size_t numberOfCharacterSwitchJumpTables() const { return m_rareData ? m_rareData->m_characterSwitchJumpTables.size() : 0; }
        SimpleJumpTable& addCharacterSwitchJumpTable() { createRareDataIfNecessary(); m_rareData->m_characterSwitchJumpTables.append(SimpleJumpTable()); return m_rareData->m_characterSwitchJumpTables.last(); }
        SimpleJumpTable& characterSwitchJumpTable(int tableIndex) { ((void)0); return m_rareData->m_characterSwitchJumpTables[tableIndex]; }

        size_t numberOfStringSwitchJumpTables() const { return m_rareData ? m_rareData->m_stringSwitchJumpTables.size() : 0; }
        StringJumpTable& addStringSwitchJumpTable() { createRareDataIfNecessary(); m_rareData->m_stringSwitchJumpTables.append(StringJumpTable()); return m_rareData->m_stringSwitchJumpTables.last(); }
        StringJumpTable& stringSwitchJumpTable(int tableIndex) { ((void)0); return m_rareData->m_stringSwitchJumpTables[tableIndex]; }


        SymbolTable* symbolTable() { return m_symbolTable; }
        SharedSymbolTable* sharedSymbolTable() { ((void)0); return static_cast<SharedSymbolTable*>(m_symbolTable); }

        EvalCodeCache& evalCodeCache() { createRareDataIfNecessary(); return m_rareData->m_evalCodeCache; }

        void shrinkToFit();

        void copyDataFrom(CodeBlock* alternative);
        void copyDataFromAlternative();
# 781 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/CodeBlock.h"
        unsigned reoptimizationRetryCounter() const
        {
            ((void)0);
            return m_reoptimizationRetryCounter;
        }

        void countReoptimization()
        {
            m_reoptimizationRetryCounter++;
            if (m_reoptimizationRetryCounter > Heuristics::reoptimizationRetryCounterMax)
                m_reoptimizationRetryCounter = Heuristics::reoptimizationRetryCounterMax;
        }

        int32_t counterValueForOptimizeAfterWarmUp()
        {
            return Heuristics::executionCounterValueForOptimizeAfterWarmUp << reoptimizationRetryCounter();
        }

        int32_t counterValueForOptimizeAfterLongWarmUp()
        {
            return Heuristics::executionCounterValueForOptimizeAfterLongWarmUp << reoptimizationRetryCounter();
        }

        int32_t* addressOfExecuteCounter()
        {
            return &m_executeCounter;
        }

        static ptrdiff_t offsetOfExecuteCounter() { return (reinterpret_cast<ptrdiff_t>(&(reinterpret_cast<CodeBlock*>(0x4000)->m_executeCounter)) - 0x4000); }

        int32_t executeCounter() const { return m_executeCounter; }

        unsigned optimizationDelayCounter() const { return m_optimizationDelayCounter; }




        void optimizeNextInvocation()
        {
            m_executeCounter = Heuristics::executionCounterValueForOptimizeNextInvocation;
        }






        void dontOptimizeAnytimeSoon()
        {
            m_executeCounter = Heuristics::executionCounterValueForDontOptimizeAnytimeSoon;
        }







        void optimizeAfterWarmUp()
        {
            m_executeCounter = counterValueForOptimizeAfterWarmUp();
        }



        void optimizeAfterLongWarmUp()
        {
            m_executeCounter = counterValueForOptimizeAfterLongWarmUp();
        }
# 869 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/CodeBlock.h"
        void optimizeSoon()
        {
            m_executeCounter = Heuristics::executionCounterValueForOptimizeSoon << reoptimizationRetryCounter();
        }
# 884 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/CodeBlock.h"
        void countSpeculationSuccess()
        {
            m_speculativeSuccessCounter++;
        }

        void countSpeculationFailure()
        {
            m_speculativeFailCounter++;
        }

        uint32_t speculativeSuccessCounter() const { return m_speculativeSuccessCounter; }
        uint32_t speculativeFailCounter() const { return m_speculativeFailCounter; }

        uint32_t* addressOfSpeculativeSuccessCounter() { return &m_speculativeSuccessCounter; }
        uint32_t* addressOfSpeculativeFailCounter() { return &m_speculativeFailCounter; }

        static ptrdiff_t offsetOfSpeculativeSuccessCounter() { return (reinterpret_cast<ptrdiff_t>(&(reinterpret_cast<CodeBlock*>(0x4000)->m_speculativeSuccessCounter)) - 0x4000); }
        static ptrdiff_t offsetOfSpeculativeFailCounter() { return (reinterpret_cast<ptrdiff_t>(&(reinterpret_cast<CodeBlock*>(0x4000)->m_speculativeFailCounter)) - 0x4000); }


        unsigned largeFailCountThreshold() { return Heuristics::largeFailCountThresholdBase << alternative()->reoptimizationRetryCounter(); }
        unsigned largeFailCountThresholdForLoop() { return Heuristics::largeFailCountThresholdBaseForLoop << alternative()->reoptimizationRetryCounter(); }

        bool shouldReoptimizeNow()
        {
            return Heuristics::desiredSpeculativeSuccessFailRatio * speculativeFailCounter() >= speculativeSuccessCounter() && speculativeFailCounter() >= largeFailCountThreshold();
        }

        bool shouldReoptimizeFromLoopNow()
        {
            return Heuristics::desiredSpeculativeSuccessFailRatio * speculativeFailCounter() >= speculativeSuccessCounter() && speculativeFailCounter() >= largeFailCountThresholdForLoop();
        }


        bool shouldOptimizeNow();





        void reoptimize(JSGlobalData& globalData)
        {
            ((void)0);
            replacement()->jettison(globalData);
            countReoptimization();
            optimizeAfterWarmUp();
        }
# 939 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/CodeBlock.h"
        int m_numCalleeRegisters;
        int m_numVars;
        int m_numCapturedVars;
        int m_numParameters;
        bool m_isConstructor;

    private:
# 956 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/bytecode/CodeBlock.h"
        void visitStructures(SlotVisitor&, Instruction* vPC) const;

        void createRareDataIfNecessary()
        {
            if (!m_rareData)
                m_rareData = adoptPtr(new RareData);
        }

        WriteBarrier<ScriptExecutable> m_ownerExecutable;
        JSGlobalData* m_globalData;

        Vector<Instruction> m_instructions;
        unsigned m_instructionCount;

        int m_thisRegister;
        int m_argumentsRegister;
        int m_activationRegister;

        bool m_needsFullScopeChain;
        bool m_usesEval;
        bool m_isNumericCompareFunction;
        bool m_isStrictMode;

        CodeType m_codeType;

        RefPtr<SourceProvider> m_source;
        unsigned m_sourceOffset;






        Vector<StructureStubInfo> m_structureStubInfos;
        Vector<GlobalResolveInfo> m_globalResolveInfos;
        Vector<CallLinkInfo> m_callLinkInfos;
        Vector<MethodCallLinkInfo> m_methodCallLinkInfos;
        JITCode m_jitCode;
        MacroAssemblerCodePtr m_jitCodeWithArityCheck;
        SentinelLinkedList<CallLinkInfo, BasicRawSentinelNode<CallLinkInfo> > m_incomingCalls;


        OwnPtr<CompactJITCodeMap> m_jitCodeMap;
        Vector<DFG::OSREntryData> m_dfgOSREntry;


        SegmentedVector<ValueProfile, 8> m_valueProfiles;
        SegmentedVector<RareCaseProfile, 8> m_rareCaseProfiles;
        SegmentedVector<RareCaseProfile, 8> m_specialFastCaseProfiles;


        Vector<unsigned> m_jumpTargets;
        Vector<unsigned> m_loopTargets;


        Vector<Identifier> m_identifiers;
        typedef int dummyRegister_must_be_same_size_as_WriteBarrier_Unknown [(sizeof(Register) == sizeof(WriteBarrier<Unknown>)) ? 1 : -1];
        Vector<WriteBarrier<Unknown> > m_constantRegisters;
        Vector<WriteBarrier<FunctionExecutable> > m_functionDecls;
        Vector<WriteBarrier<FunctionExecutable> > m_functionExprs;

        SymbolTable* m_symbolTable;

        OwnPtr<CodeBlock> m_alternative;

        int32_t m_executeCounter;
        uint32_t m_speculativeSuccessCounter;
        uint32_t m_speculativeFailCounter;
        uint8_t m_optimizationDelayCounter;
        uint8_t m_reoptimizationRetryCounter;

        struct RareData {
           public: void* operator new(size_t, void* p) { return p; } void* operator new[](size_t, void* p) { return p; } void* operator new(size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNew); return p; } void operator delete(void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNew); ::WTF::fastFree(p); } void* operator new[](size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNewArray); return p; } void operator delete[](void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNewArray); ::WTF::fastFree(p); } private: typedef int ThisIsHereToForceASemicolonAfterThisMacro;
        public:
            Vector<HandlerInfo> m_exceptionHandlers;


            Vector<WriteBarrier<RegExp> > m_regexps;


            Vector<Vector<JSValue> > m_constantBuffers;


            Vector<SimpleJumpTable> m_immediateSwitchJumpTables;
            Vector<SimpleJumpTable> m_characterSwitchJumpTables;
            Vector<StringJumpTable> m_stringSwitchJumpTables;

            EvalCodeCache m_evalCodeCache;


            Vector<ExpressionRangeInfo> m_expressionInfo;

            Vector<LineInfo> m_lineInfo;

            Vector<CallReturnOffsetToBytecodeOffset> m_callReturnIndexVector;


            SegmentedVector<InlineCallFrame, 4> m_inlineCallFrames;
            Vector<CodeOriginAtCallReturnOffset> m_codeOrigins;

        };



        OwnPtr<RareData> m_rareData;
    };




    class GlobalCodeBlock : public CodeBlock {
    protected:
        GlobalCodeBlock(ScriptExecutable* ownerExecutable, CodeType codeType, JSGlobalObject* globalObject, PassRefPtr<SourceProvider> sourceProvider, unsigned sourceOffset, PassOwnPtr<CodeBlock> alternative)
            : CodeBlock(ownerExecutable, codeType, globalObject, sourceProvider, sourceOffset, &m_unsharedSymbolTable, false, alternative)
        {
        }

    private:
        SymbolTable m_unsharedSymbolTable;
    };

    class ProgramCodeBlock : public GlobalCodeBlock {
    public:
        ProgramCodeBlock(ProgramExecutable* ownerExecutable, CodeType codeType, JSGlobalObject* globalObject, PassRefPtr<SourceProvider> sourceProvider, PassOwnPtr<CodeBlock> alternative)
            : GlobalCodeBlock(ownerExecutable, codeType, globalObject, sourceProvider, 0, alternative)
        {
        }


    protected:
        virtual JSObject* compileOptimized(ExecState*, ScopeChainNode*);
        virtual void jettison(JSGlobalData&);
        virtual CodeBlock* replacement();
        virtual bool canCompileWithDFG();

    };

    class EvalCodeBlock : public GlobalCodeBlock {
    public:
        EvalCodeBlock(EvalExecutable* ownerExecutable, JSGlobalObject* globalObject, PassRefPtr<SourceProvider> sourceProvider, int baseScopeDepth, PassOwnPtr<CodeBlock> alternative)
            : GlobalCodeBlock(ownerExecutable, EvalCode, globalObject, sourceProvider, 0, alternative)
            , m_baseScopeDepth(baseScopeDepth)
        {
        }

        int baseScopeDepth() const { return m_baseScopeDepth; }

        const Identifier& variable(unsigned index) { return m_variables[index]; }
        unsigned numVariables() { return m_variables.size(); }
        void adoptVariables(Vector<Identifier>& variables)
        {
            ((void)0);
            m_variables.swap(variables);
        }


    protected:
        virtual JSObject* compileOptimized(ExecState*, ScopeChainNode*);
        virtual void jettison(JSGlobalData&);
        virtual CodeBlock* replacement();
        virtual bool canCompileWithDFG();


    private:
        int m_baseScopeDepth;
        Vector<Identifier> m_variables;
    };

    class FunctionCodeBlock : public CodeBlock {
    public:




        FunctionCodeBlock(FunctionExecutable* ownerExecutable, CodeType codeType, JSGlobalObject* globalObject, PassRefPtr<SourceProvider> sourceProvider, unsigned sourceOffset, bool isConstructor, PassOwnPtr<CodeBlock> alternative = nullptr)
            : CodeBlock(ownerExecutable, codeType, globalObject, sourceProvider, sourceOffset, SharedSymbolTable::create().leakRef(), isConstructor, alternative)
        {
        }
        ~FunctionCodeBlock()
        {
            sharedSymbolTable()->deref();
        }


    protected:
        virtual JSObject* compileOptimized(ExecState*, ScopeChainNode*);
        virtual void jettison(JSGlobalData&);
        virtual CodeBlock* replacement();
        virtual bool canCompileWithDFG();

    };

    inline Register& ExecState::r(int index)
    {
        CodeBlock* codeBlock = this->codeBlock();
        if (codeBlock->isConstantRegisterIndex(index))
            return *reinterpret_cast<Register*>(&codeBlock->constantRegister(index));
        return this[index];
    }

    inline Register& ExecState::uncheckedR(int index)
    {
        ((void)0);
        return this[index];
    }


    inline bool ExecState::isInlineCallFrame()
    {
        if (__builtin_expect((!codeBlock() || codeBlock()->getJITType() != JITCode::DFGJIT), 1))
            return false;
        return isInlineCallFrameSlow();
    }

    inline ExecState* ExecState::trueCallerFrame()
    {
        if (__builtin_expect((!codeBlock() || codeBlock()->getJITType() != JITCode::DFGJIT), 1))
            return callerFrame()->removeHostCallFrameFlag();
        return trueCallerFrameSlow();
    }


}
# 33 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSActivation.h" 2




namespace JSC {

    class Arguments;
    class Register;

    class JSActivation : public JSVariableObject {
    private:
        JSActivation(CallFrame*, FunctionExecutable*);

    public:
        typedef JSVariableObject Base;

        static JSActivation* create(JSGlobalData& globalData, CallFrame* callFrame, FunctionExecutable* funcExec)
        {
            JSActivation* activation = new (allocateCell<JSActivation>(globalData.heap)) JSActivation(callFrame, funcExec);
            activation->finishCreation(callFrame);
            return activation;
        }

        virtual ~JSActivation();

        static void visitChildren(JSCell*, SlotVisitor&);

        virtual bool isDynamicScope(bool& requiresDynamicChecks) const;

        virtual bool isActivationObject() const { return true; }

        static bool getOwnPropertySlot(JSCell*, ExecState*, const Identifier&, PropertySlot&);
        virtual void getOwnPropertyNames(ExecState*, PropertyNameArray&, EnumerationMode);

        static void put(JSCell*, ExecState*, const Identifier&, JSValue, PutPropertySlot&);

        virtual void putWithAttributes(ExecState*, const Identifier&, JSValue, unsigned attributes);
        static bool deleteProperty(JSCell*, ExecState*, const Identifier& propertyName);

        virtual JSObject* toThisObject(ExecState*) const;

        void copyRegisters(JSGlobalData&);

        static const ClassInfo s_info;

        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue proto) { return Structure::create(globalData, globalObject, proto, TypeInfo(ObjectType, StructureFlags), &s_info); }

    protected:
        void finishCreation(CallFrame*);
        static const unsigned StructureFlags = IsEnvironmentRecord | OverridesGetOwnPropertySlot | OverridesVisitChildren | OverridesGetPropertyNames | JSVariableObject::StructureFlags;

    private:
        bool symbolTableGet(const Identifier&, PropertySlot&);
        bool symbolTableGet(const Identifier&, PropertyDescriptor&);
        bool symbolTableGet(const Identifier&, PropertySlot&, bool& slotIsWriteable);
        bool symbolTablePut(JSGlobalData&, const Identifier&, JSValue);
        bool symbolTablePutWithAttributes(JSGlobalData&, const Identifier&, JSValue, unsigned attributes);

        static JSValue argumentsGetter(ExecState*, JSValue, const Identifier&);
        __attribute__((__noinline__)) PropertySlot::GetValueFunc getArgumentsGetter();

        int m_numParametersMinusThis;
        int m_numCapturedVars : 31;
        bool m_requiresDynamicChecks : 1;
        int m_argumentsRegister;
    };

    JSActivation* asActivation(JSValue);

    inline JSActivation* asActivation(JSValue value)
    {
        ((void)0);
        return static_cast<JSActivation*>(asObject(value));
    }

    inline __attribute__((__always_inline__)) JSActivation* Register::activation() const
    {
        return asActivation(jsValue());
    }

}
# 29 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/Arguments.h" 2



# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/ObjectConstructor.h" 1
# 26 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/ObjectConstructor.h"
namespace JSC {

    class ObjectPrototype;

    class ObjectConstructor : public InternalFunction {
    public:
        typedef InternalFunction Base;

        static ObjectConstructor* create(ExecState* exec, JSGlobalObject* globalObject, Structure* structure, ObjectPrototype* objectPrototype)
        {
            ObjectConstructor* constructor = new (allocateCell<ObjectConstructor>(*exec->heap())) ObjectConstructor(globalObject, structure);
            constructor->finishCreation(exec, objectPrototype);
            return constructor;
        }

        static bool getOwnPropertySlot(JSCell*, ExecState*, const Identifier&, PropertySlot&);
        virtual bool getOwnPropertyDescriptor(ExecState*, const Identifier&, PropertyDescriptor&);

        static const ClassInfo s_info;

        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue prototype)
        {
            return Structure::create(globalData, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), &s_info);
        }

    protected:
        void finishCreation(ExecState*, ObjectPrototype*);
        static const unsigned StructureFlags = OverridesGetOwnPropertySlot | InternalFunction::StructureFlags;

    private:
        ObjectConstructor(JSGlobalObject*, Structure*);
        static ConstructType getConstructData(JSCell*, ConstructData&);
        static CallType getCallData(JSCell*, CallData&);
    };

}
# 33 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/Arguments.h" 2

namespace JSC {

    struct ArgumentsData {
        private: ArgumentsData(const ArgumentsData&); ArgumentsData& operator=(const ArgumentsData&); public: void* operator new(size_t, void* p) { return p; } void* operator new[](size_t, void* p) { return p; } void* operator new(size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNew); return p; } void operator delete(void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNew); ::WTF::fastFree(p); } void* operator new[](size_t size) { void* p = ::WTF::fastMalloc(size); ::WTF::fastMallocMatchValidateMalloc(p, ::WTF::Internal::AllocTypeClassNewArray); return p; } void operator delete[](void* p) { ::WTF::fastMallocMatchValidateFree(p, ::WTF::Internal::AllocTypeClassNewArray); ::WTF::fastFree(p); } private: typedef int ThisIsHereToForceASemicolonAfterThisMacro;
    public:
        ArgumentsData() { }
        WriteBarrier<JSActivation> activation;

        unsigned numParameters;
        ptrdiff_t firstParameterIndex;
        unsigned numArguments;

        WriteBarrier<Unknown>* registers;
        OwnArrayPtr<WriteBarrier<Unknown> > registerArray;

        WriteBarrier<Unknown>* extraArguments;
        OwnArrayPtr<bool> deletedArguments;
        WriteBarrier<Unknown> extraArgumentsFixedBuffer[4];

        WriteBarrier<JSFunction> callee;
        bool overrodeLength : 1;
        bool overrodeCallee : 1;
        bool overrodeCaller : 1;
        bool isStrictMode : 1;
        bool isInlineFrame : 1;
    };


    class Arguments : public JSNonFinalObject {
    public:
        typedef JSNonFinalObject Base;

        static Arguments* create(JSGlobalData& globalData, CallFrame* callFrame)
        {
            Arguments* arguments = new (allocateCell<Arguments>(globalData.heap)) Arguments(callFrame);
            arguments->finishCreation(callFrame);
            return arguments;
        }

        static Arguments* createAndCopyRegisters(JSGlobalData& globalData, CallFrame* callFrame)
        {
            Arguments* arguments = new (allocateCell<Arguments>(globalData.heap)) Arguments(callFrame);
            arguments->finishCreationAndCopyRegisters(callFrame);
            return arguments;
        }

        static Arguments* createNoParameters(JSGlobalData& globalData, CallFrame* callFrame)
        {
            Arguments* arguments = new (allocateCell<Arguments>(globalData.heap)) Arguments(callFrame, NoParameters);
            arguments->finishCreation(callFrame, NoParameters);
            return arguments;
        }



        enum { MaxArguments = 0x10000 };

    private:
        enum NoParametersType { NoParameters };

        Arguments(CallFrame*);
        Arguments(CallFrame*, NoParametersType);

    public:
        virtual ~Arguments();

        static const ClassInfo s_info;

        static void visitChildren(JSCell*, SlotVisitor&);

        void fillArgList(ExecState*, MarkedArgumentBuffer&);

        uint32_t numProvidedArguments(ExecState* exec) const
        {
            if (__builtin_expect((d->overrodeLength), 0))
                return get(exec, exec->propertyNames().length).toUInt32(exec);
            return d->numArguments;
        }

        void copyToRegisters(ExecState* exec, Register* buffer, uint32_t maxSize);
        void copyRegisters(JSGlobalData&);
        bool isTornOff() const { return d->registerArray; }
        void setActivation(JSGlobalData& globalData, JSActivation* activation)
        {
            ((void)0);
            d->activation.set(globalData, this, activation);
            d->registers = &activation->registerAt(0);
        }

        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue prototype)
        {
            return Structure::create(globalData, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), &s_info);
        }

    protected:
        static const unsigned StructureFlags = OverridesGetOwnPropertySlot | OverridesVisitChildren | OverridesGetPropertyNames | JSObject::StructureFlags;

        void finishCreationButDontCopyRegisters(CallFrame*);
        void finishCreation(CallFrame*);
        void finishCreationAndCopyRegisters(CallFrame*);
        void finishCreation(CallFrame*, NoParametersType);

    private:
        void getArgumentsData(CallFrame*, JSFunction*&, ptrdiff_t& firstParameterIndex, Register*& argv, int& argc);
        static bool getOwnPropertySlot(JSCell*, ExecState*, const Identifier& propertyName, PropertySlot&);
        static bool getOwnPropertySlotByIndex(JSCell*, ExecState*, unsigned propertyName, PropertySlot&);
        virtual bool getOwnPropertyDescriptor(ExecState*, const Identifier&, PropertyDescriptor&);
        virtual void getOwnPropertyNames(ExecState*, PropertyNameArray&, EnumerationMode mode = ExcludeDontEnumProperties);
        static void put(JSCell*, ExecState*, const Identifier& propertyName, JSValue, PutPropertySlot&);
        static void putByIndex(JSCell*, ExecState*, unsigned propertyName, JSValue);
        static bool deleteProperty(JSCell*, ExecState*, const Identifier& propertyName);
        static bool deletePropertyByIndex(JSCell*, ExecState*, unsigned propertyName);
        void createStrictModeCallerIfNecessary(ExecState*);
        void createStrictModeCalleeIfNecessary(ExecState*);

        void init(CallFrame*);

        OwnPtr<ArgumentsData> d;
    };

    Arguments* asArguments(JSValue);

    inline Arguments* asArguments(JSValue value)
    {
        ((void)0);
        return static_cast<Arguments*>(asObject(value));
    }

    inline __attribute__((__always_inline__)) void Arguments::getArgumentsData(CallFrame* callFrame, JSFunction*& function, ptrdiff_t& firstParameterIndex, Register*& argv, int& argc)
    {
        function = asFunction(callFrame->callee());

        int numParameters = function->jsExecutable()->parameterCount();
        argc = callFrame->argumentCountIncludingThis();

        if (callFrame->isInlineCallFrame())
            ((void)0);

        if (argc <= numParameters)
            argv = callFrame->registers() - RegisterFile::CallFrameHeaderSize - numParameters;
        else
            argv = callFrame->registers() - RegisterFile::CallFrameHeaderSize - numParameters - argc;

        argc -= 1;
        firstParameterIndex = -RegisterFile::CallFrameHeaderSize - numParameters;
    }

    inline Arguments::Arguments(CallFrame* callFrame)
        : JSNonFinalObject(callFrame->globalData(), callFrame->lexicalGlobalObject()->argumentsStructure())
        , d(adoptPtr(new ArgumentsData))
    {
    }

    inline Arguments::Arguments(CallFrame* callFrame, NoParametersType)
        : JSNonFinalObject(callFrame->globalData(), callFrame->lexicalGlobalObject()->argumentsStructure())
        , d(adoptPtr(new ArgumentsData))
    {
    }

    inline void Arguments::finishCreationButDontCopyRegisters(CallFrame* callFrame)
    {
        Base::finishCreation(callFrame->globalData());
        ((void)0);

        JSFunction* callee;
        ptrdiff_t firstParameterIndex;
        Register* argv;
        int numArguments;
        getArgumentsData(callFrame, callee, firstParameterIndex, argv, numArguments);

        d->numParameters = callee->jsExecutable()->parameterCount();
        d->firstParameterIndex = firstParameterIndex;
        d->numArguments = numArguments;
        d->isInlineFrame = false;

        d->registers = reinterpret_cast<WriteBarrier<Unknown>*>(callFrame->registers());

        WriteBarrier<Unknown>* extraArguments;
        if (d->numArguments <= d->numParameters)
            extraArguments = 0;
        else {
            unsigned numExtraArguments = d->numArguments - d->numParameters;
            if (numExtraArguments > sizeof(d->extraArgumentsFixedBuffer) / sizeof(WriteBarrier<Unknown>))
                extraArguments = new WriteBarrier<Unknown>[numExtraArguments];
            else
                extraArguments = d->extraArgumentsFixedBuffer;
            for (unsigned i = 0; i < numExtraArguments; ++i)
                extraArguments[i].set(callFrame->globalData(), this, argv[d->numParameters + i].jsValue());
        }

        d->extraArguments = extraArguments;

        d->callee.set(callFrame->globalData(), this, callee);
        d->overrodeLength = false;
        d->overrodeCallee = false;
        d->overrodeCaller = false;
        d->isStrictMode = callFrame->codeBlock()->isStrictMode();
    }

    inline void Arguments::finishCreation(CallFrame* callFrame)
    {
        ((void)0);
        finishCreationButDontCopyRegisters(callFrame);
        if (d->isStrictMode)
            copyRegisters(callFrame->globalData());
    }

    inline void Arguments::finishCreationAndCopyRegisters(CallFrame* callFrame)
    {
        Base::finishCreation(callFrame->globalData());
        ((void)0);

        JSFunction* callee;

        ptrdiff_t firstParameterIndex;
        Register* argv;
        int numArguments;
        getArgumentsData(callFrame, callee, firstParameterIndex, argv, numArguments);

        d->numParameters = callee->jsExecutable()->parameterCount();
        d->firstParameterIndex = firstParameterIndex;
        d->numArguments = numArguments;

        if (d->numParameters) {
            int registerOffset = d->numParameters + RegisterFile::CallFrameHeaderSize;
            size_t registerArraySize = d->numParameters;

            OwnArrayPtr<WriteBarrier<Unknown> > registerArray = adoptArrayPtr(new WriteBarrier<Unknown>[registerArraySize]);
            for (size_t i = 0; i < registerArraySize; ++i)
                registerArray[i].set(callFrame->globalData(), this, callFrame->registers()[i - registerOffset].jsValue());
            d->registers = registerArray.get() + d->numParameters + RegisterFile::CallFrameHeaderSize;
            d->registerArray = registerArray.release();
        }

        WriteBarrier<Unknown>* extraArguments;
        if (callFrame->isInlineCallFrame())
            ((void)0);
        if (d->numArguments <= d->numParameters)
            extraArguments = 0;
        else {
            unsigned numExtraArguments = d->numArguments - d->numParameters;
            if (numExtraArguments > sizeof(d->extraArgumentsFixedBuffer) / sizeof(WriteBarrier<Unknown>))
                extraArguments = new WriteBarrier<Unknown>[numExtraArguments];
            else
                extraArguments = d->extraArgumentsFixedBuffer;
            for (unsigned i = 0; i < numExtraArguments; ++i)
                extraArguments[i].set(callFrame->globalData(), this, argv[d->numParameters + i].jsValue());
        }

        d->extraArguments = extraArguments;

        d->callee.set(callFrame->globalData(), this, callee);
        d->overrodeLength = false;
        d->overrodeCallee = false;
        d->overrodeCaller = false;
        d->isInlineFrame = callFrame->isInlineCallFrame();
        d->isStrictMode = callFrame->codeBlock()->isStrictMode();
    }

    inline void Arguments::finishCreation(CallFrame* callFrame, NoParametersType)
    {
        ((void)0);
        Base::finishCreation(callFrame->globalData());
        ((void)0);
        ((void)0);

        unsigned numArguments = callFrame->argumentCount();

        d->numParameters = 0;
        d->numArguments = numArguments;
        d->isInlineFrame = false;

        WriteBarrier<Unknown>* extraArguments;
        if (numArguments > sizeof(d->extraArgumentsFixedBuffer) / sizeof(Register))
            extraArguments = new WriteBarrier<Unknown>[numArguments];
        else
            extraArguments = d->extraArgumentsFixedBuffer;

        Register* argv = callFrame->registers() - RegisterFile::CallFrameHeaderSize - numArguments - 1;
        for (unsigned i = 0; i < numArguments; ++i)
            extraArguments[i].set(callFrame->globalData(), this, argv[i].jsValue());

        d->extraArguments = extraArguments;

        d->callee.set(callFrame->globalData(), this, asFunction(callFrame->callee()));
        d->overrodeLength = false;
        d->overrodeCallee = false;
        d->overrodeCaller = false;
        d->isStrictMode = callFrame->codeBlock()->isStrictMode();
        if (d->isStrictMode)
            copyRegisters(callFrame->globalData());
    }

    inline void Arguments::copyRegisters(JSGlobalData& globalData)
    {
        ((void)0);

        if (!d->numParameters)
            return;

        int registerOffset = d->numParameters + RegisterFile::CallFrameHeaderSize;
        size_t registerArraySize = d->numParameters;

        OwnArrayPtr<WriteBarrier<Unknown> > registerArray = adoptArrayPtr(new WriteBarrier<Unknown>[registerArraySize]);
        for (size_t i = 0; i < registerArraySize; i++)
            registerArray[i].set(globalData, this, d->registers[i - registerOffset].get());
        d->registers = registerArray.get() + registerOffset;
        d->registerArray = registerArray.release();
    }


    inline void JSActivation::copyRegisters(JSGlobalData& globalData)
    {
        ((void)0);

        size_t numLocals = m_numCapturedVars + m_numParametersMinusThis;

        if (!numLocals)
            return;

        int registerOffset = m_numParametersMinusThis + RegisterFile::CallFrameHeaderSize;
        size_t registerArraySize = numLocals + RegisterFile::CallFrameHeaderSize;

        OwnArrayPtr<WriteBarrier<Unknown> > registerArray = copyRegisterArray(globalData, m_registers - registerOffset, registerArraySize, m_numParametersMinusThis + 1);
        WriteBarrier<Unknown>* registers = registerArray.get() + registerOffset;
        setRegisters(registers, registerArray.release());
    }

}
# 34 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Interpreter.cpp" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/BatchedTransitionOptimizer.h" 1
# 32 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/BatchedTransitionOptimizer.h"
namespace JSC {

    class BatchedTransitionOptimizer {
        private: BatchedTransitionOptimizer(const BatchedTransitionOptimizer&); BatchedTransitionOptimizer& operator=(const BatchedTransitionOptimizer&);
    public:
        BatchedTransitionOptimizer(JSGlobalData& globalData, JSObject* object)
            : m_globalData(&globalData)
            , m_object(object)
        {
        }

        ~BatchedTransitionOptimizer()
        {
            if (m_object->structure()->isDictionary())
                m_object->flattenDictionaryObject(*m_globalData);
        }

    private:
        JSGlobalData* m_globalData;
        JSObject* m_object;
    };

}
# 35 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Interpreter.cpp" 2

# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/CallFrameClosure.h" 1
# 29 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/CallFrameClosure.h"
namespace JSC {

struct CallFrameClosure {
    CallFrame* oldCallFrame;
    CallFrame* newCallFrame;
    JSFunction* function;
    FunctionExecutable* functionExecutable;
    JSGlobalData* globalData;
    Register* oldEnd;
    ScopeChainNode* scopeChain;
    int expectedParams;
    int providedParams;

    void setArgument(int arg, JSValue value)
    {
        if (arg < expectedParams)
            newCallFrame[arg - RegisterFile::CallFrameHeaderSize - expectedParams] = value;
        else
            newCallFrame[arg - RegisterFile::CallFrameHeaderSize - expectedParams - providedParams] = value;
    }

    void resetCallFrame()
    {
        newCallFrame->setScopeChain(scopeChain);
        for (int i = providedParams; i < expectedParams; ++i)
            newCallFrame[i - RegisterFile::CallFrameHeaderSize - expectedParams] = jsUndefined();
    }
};

}
# 37 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Interpreter.cpp" 2



# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/debugger/DebuggerCallFrame.h" 1
# 34 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/debugger/DebuggerCallFrame.h"
namespace JSC {

    class DebuggerCallFrame {
    public:
        enum Type { ProgramType, FunctionType };

        DebuggerCallFrame(CallFrame* callFrame)
            : m_callFrame(callFrame)
        {
        }

        DebuggerCallFrame(CallFrame* callFrame, JSValue exception)
            : m_callFrame(callFrame)
            , m_exception(exception)
        {
        }

        JSGlobalObject* dynamicGlobalObject() const { return m_callFrame->dynamicGlobalObject(); }
        ScopeChainNode* scopeChain() const { return m_callFrame->scopeChain(); }
        const UString* functionName() const;
                          UString calculatedFunctionName() const;
                          Type type() const;
                          JSObject* thisObject() const;
                          JSValue evaluate(const UString&, JSValue& exception) const;
        JSValue exception() const { return m_exception; }

    private:
        CallFrame* m_callFrame;
        JSValue m_exception;
    };

}
# 41 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Interpreter.cpp" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/ErrorInstance.h" 1
# 26 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/ErrorInstance.h"
namespace JSC {

    class ErrorInstance : public JSNonFinalObject {
    public:
        typedef JSNonFinalObject Base;

        static const ClassInfo s_info;

        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue prototype)
        {
            return Structure::create(globalData, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), &s_info);
        }

        static ErrorInstance* create(JSGlobalData& globalData, Structure* structure, const UString& message)
        {
            ErrorInstance* instance = new (allocateCell<ErrorInstance>(globalData.heap)) ErrorInstance(globalData, structure);
            instance->finishCreation(globalData, message);
            return instance;
        }
        static ErrorInstance* create(ExecState* exec, Structure* structure, JSValue message)
        {
            if (message.isUndefined()) {
                ErrorInstance* instance = new (allocateCell<ErrorInstance>(*exec->heap())) ErrorInstance(exec->globalData(), structure);
                instance->finishCreation(exec->globalData(), UString("", 0));
                return instance;
            }
            return create(exec->globalData(), structure, message.toString(exec));
        }

        bool appendSourceToMessage() { return m_appendSourceToMessage; }
        void setAppendSourceToMessage() { m_appendSourceToMessage = true; }
        void clearAppendSourceToMessage() { m_appendSourceToMessage = false; }

        virtual bool isErrorInstance() const { return true; }

    protected:
        explicit ErrorInstance(JSGlobalData&, Structure*);

        void finishCreation(JSGlobalData& globalData, const UString& message)
        {
            Base::finishCreation(globalData);
            ((void)0);
            putDirect(globalData, globalData.propertyNames->message, jsString(&globalData, message), DontEnum);
        }

        bool m_appendSourceToMessage;
    };

}
# 42 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Interpreter.cpp" 2


# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/GetterSetter.h" 1
# 31 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/GetterSetter.h"
namespace JSC {

    class JSObject;



    class GetterSetter : public JSCell {
        friend class JIT;

    private:
        GetterSetter(ExecState* exec)
            : JSCell(exec->globalData(), exec->globalData().getterSetterStructure.get())
        {
        }

    public:
        typedef JSCell Base;

        static GetterSetter* create(ExecState* exec)
        {
            GetterSetter* getterSetter = new (allocateCell<GetterSetter>(*exec->heap())) GetterSetter(exec);
            getterSetter->finishCreation(exec->globalData());
            return getterSetter;
        }

        static void visitChildren(JSCell*, SlotVisitor&);

        JSObject* getter() const { return m_getter.get(); }
        void setGetter(JSGlobalData& globalData, JSObject* getter) { m_getter.set(globalData, this, getter); }
        JSObject* setter() const { return m_setter.get(); }
        void setSetter(JSGlobalData& globalData, JSObject* setter) { m_setter.set(globalData, this, setter); }
        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue prototype)
        {
            return Structure::create(globalData, globalObject, prototype, TypeInfo(GetterSetterType, OverridesVisitChildren), &s_info);
        }

        static const ClassInfo s_info;

    private:
        WriteBarrier<JSObject> m_getter;
        WriteBarrier<JSObject> m_setter;
    };

    GetterSetter* asGetterSetter(JSValue);

    inline GetterSetter* asGetterSetter(JSValue value)
    {
        ((void)0);
        return static_cast<GetterSetter*>(value.asCell());
    }


}
# 45 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Interpreter.cpp" 2


# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSByteArray.h" 1
# 31 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSByteArray.h"
# 1 "./wtf/ByteArray.h" 1
# 35 "./wtf/ByteArray.h"
namespace WTF {
    class ByteArray : public RefCountedBase {
    public:
        unsigned length() const { return m_size; }

        void set(unsigned index, double value)
        {
            if (index >= m_size)
                return;
            if (!(value > 0))
                value = 0;
            else if (value > 255)
                value = 255;
            m_data[index] = static_cast<unsigned char>(value + 0.5);
        }

        void set(unsigned index, unsigned char value)
        {
            if (index >= m_size)
                return;
            m_data[index] = value;
        }

        bool get(unsigned index, unsigned char& result) const
        {
            if (index >= m_size)
                return false;
            result = m_data[index];
            return true;
        }

        unsigned char get(unsigned index) const
        {
            ((void)0);
            return m_data[index];
        }

        unsigned char* data() { return m_data; }

        void clear() { memset(m_data, 0, m_size); }

        void deref()
        {
            if (derefBase()) {


                this->~ByteArray();
                delete[] reinterpret_cast<unsigned char*>(this);
            }
        }

        static PassRefPtr<ByteArray> create(size_t size);

        static size_t offsetOfSize() { return (reinterpret_cast<ptrdiff_t>(&(reinterpret_cast<ByteArray*>(0x4000)->m_size)) - 0x4000); }
        static size_t offsetOfData() { return (reinterpret_cast<ptrdiff_t>(&(reinterpret_cast<ByteArray*>(0x4000)->m_data)) - 0x4000); }

    private:
        ByteArray(size_t size)
            : m_size(size)
        {
        }
        size_t m_size;






        unsigned char m_data[];

    };
}

using WTF::ByteArray;
# 32 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSByteArray.h" 2

namespace JSC {

    class JSByteArray : public JSNonFinalObject {
        friend class JSGlobalData;
    public:
        typedef JSNonFinalObject Base;

        bool canAccessIndex(unsigned i) { return i < m_storage->length(); }
        JSValue getIndex(ExecState*, unsigned i)
        {
            ((void)0);
            return jsNumber(m_storage->data()[i]);
        }

        void setIndex(unsigned i, int value)
        {
            ((void)0);
            if (value & ~0xFF) {
                if (value < 0)
                    value = 0;
                else
                    value = 255;
            }
            m_storage->data()[i] = static_cast<unsigned char>(value);
        }

        void setIndex(unsigned i, double value)
        {
            ((void)0);
            if (!(value > 0))
                value = 0;
            else if (value > 255)
                value = 255;
            m_storage->data()[i] = static_cast<unsigned char>(value + 0.5);
        }

        void setIndex(ExecState* exec, unsigned i, JSValue value)
        {
            double byteValue = value.toNumber(exec);
            if (exec->hadException())
                return;
            if (canAccessIndex(i))
                setIndex(i, byteValue);
        }

    private:
        JSByteArray(ExecState*, Structure*, ByteArray* storage);

    public:
        static JSByteArray* create(ExecState* exec, Structure* structure, ByteArray* storage)
        {
            JSByteArray* array = new (allocateCell<JSByteArray>(*exec->heap())) JSByteArray(exec, structure, storage);
            array->finishCreation(exec);
            return array;
        }

        static Structure* createStructure(JSGlobalData&, JSGlobalObject*, JSValue prototype, const JSC::ClassInfo* = &s_info);

        static bool getOwnPropertySlot(JSC::JSCell*, JSC::ExecState*, const JSC::Identifier& propertyName, JSC::PropertySlot&);
        static bool getOwnPropertySlotByIndex(JSC::JSCell*, JSC::ExecState*, unsigned propertyName, JSC::PropertySlot&);
        virtual bool getOwnPropertyDescriptor(ExecState*, const Identifier&, PropertyDescriptor&);
        static void put(JSC::JSCell*, JSC::ExecState*, const JSC::Identifier& propertyName, JSC::JSValue, JSC::PutPropertySlot&);
        static void putByIndex(JSC::JSCell*, JSC::ExecState*, unsigned propertyName, JSC::JSValue);

        virtual void getOwnPropertyNames(JSC::ExecState*, JSC::PropertyNameArray&, EnumerationMode mode = ExcludeDontEnumProperties);

        static const ClassInfo s_info;

        size_t length() const { return m_storage->length(); }

        WTF::ByteArray* storage() const { return m_storage.get(); }





        static size_t offsetOfStorage() { return (reinterpret_cast<ptrdiff_t>(&(reinterpret_cast<JSByteArray*>(0x4000)->m_storage)) - 0x4000); }

    protected:
        static const unsigned StructureFlags = OverridesGetOwnPropertySlot | OverridesGetPropertyNames | JSObject::StructureFlags;

        void finishCreation(ExecState* exec)
        {
            Base::finishCreation(exec->globalData());
            putDirect(exec->globalData(), exec->globalData().propertyNames->length, jsNumber(m_storage->length()), ReadOnly | DontDelete);
        }

    private:
        JSByteArray(VPtrStealingHackType)
            : JSNonFinalObject(VPtrStealingHack)
        {
        }

        RefPtr<WTF::ByteArray> m_storage;
    };

    JSByteArray* asByteArray(JSValue value);
    inline JSByteArray* asByteArray(JSValue value)
    {
        return static_cast<JSByteArray*>(value.asCell());
    }

    inline bool isJSByteArray(JSGlobalData* globalData, JSValue v) { return v.isCell() && v.asCell()->vptr() == globalData->jsByteArrayVPtr; }

}
# 48 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Interpreter.cpp" 2

# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSNotAnObject.h" 1
# 34 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSNotAnObject.h"
namespace JSC {




    class JSNotAnObject : public JSNonFinalObject {
    private:
        JSNotAnObject(ExecState* exec)
            : JSNonFinalObject(exec->globalData(), exec->globalData().notAnObjectStructure.get())
        {
        }

    public:
        typedef JSNonFinalObject Base;

        static JSNotAnObject* create(ExecState* exec)
        {
            JSNotAnObject* object = new (allocateCell<JSNotAnObject>(*exec->heap())) JSNotAnObject(exec);
            object->finishCreation(exec->globalData());
            return object;
        }

        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue prototype)
        {
            return Structure::create(globalData, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), &s_info);
        }

        static const ClassInfo s_info;

     private:

        static const unsigned StructureFlags = OverridesGetOwnPropertySlot | OverridesGetPropertyNames | JSObject::StructureFlags;


        virtual JSValue defaultValue(ExecState*, PreferredPrimitiveType) const;


        static bool getOwnPropertySlot(JSCell*, ExecState*, const Identifier& propertyName, PropertySlot&);
        static bool getOwnPropertySlotByIndex(JSCell*, ExecState*, unsigned propertyName, PropertySlot&);
        virtual bool getOwnPropertyDescriptor(ExecState*, const Identifier&, PropertyDescriptor&);

        static void put(JSCell*, ExecState*, const Identifier& propertyName, JSValue, PutPropertySlot&);
        static void putByIndex(JSCell*, ExecState*, unsigned propertyName, JSValue);

        static bool deleteProperty(JSCell*, ExecState*, const Identifier& propertyName);
        static bool deletePropertyByIndex(JSCell*, ExecState*, unsigned propertyName);

        virtual void getOwnPropertyNames(ExecState*, PropertyNameArray&, EnumerationMode mode = ExcludeDontEnumProperties);
    };

}
# 50 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Interpreter.cpp" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSPropertyNameIterator.h" 1
# 34 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSPropertyNameIterator.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/Operations.h" 1
# 30 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/Operations.h"
namespace JSC {

    __attribute__((__noinline__)) JSValue jsAddSlowCase(CallFrame*, JSValue, JSValue);
    JSValue jsTypeStringForValue(CallFrame*, JSValue);
    bool jsIsObjectType(JSValue);
    bool jsIsFunctionType(JSValue);

    inline __attribute__((__always_inline__)) JSValue jsString(ExecState* exec, JSString* s1, JSString* s2)
    {
        JSGlobalData& globalData = exec->globalData();

        unsigned length1 = s1->length();
        if (!length1)
            return s2;
        unsigned length2 = s2->length();
        if (!length2)
            return s1;
        if ((length1 + length2) < length1)
            return throwOutOfMemoryError(exec);

        return fixupVPtr(&globalData, JSString::create(globalData, s1, s2));
    }

    inline __attribute__((__always_inline__)) JSValue jsString(ExecState* exec, const UString& u1, const UString& u2, const UString& u3)
    {
        JSGlobalData* globalData = &exec->globalData();

        unsigned length1 = u1.length();
        unsigned length2 = u2.length();
        unsigned length3 = u3.length();
        if (!length1)
            return jsString(exec, jsString(globalData, u2), jsString(globalData, u3));
        if (!length2)
            return jsString(exec, jsString(globalData, u1), jsString(globalData, u3));
        if (!length3)
            return jsString(exec, jsString(globalData, u1), jsString(globalData, u2));

        if ((length1 + length2) < length1)
            return throwOutOfMemoryError(exec);
        if ((length1 + length2 + length3) < length3)
            return throwOutOfMemoryError(exec);

        return fixupVPtr(globalData, JSString::create(exec->globalData(), jsString(globalData, u1), jsString(globalData, u2), jsString(globalData, u3)));
    }

    inline __attribute__((__always_inline__)) JSValue jsString(ExecState* exec, Register* strings, unsigned count)
    {
        JSGlobalData* globalData = &exec->globalData();
        JSString::RopeBuilder ropeBuilder(*globalData);

        unsigned oldLength = 0;

        for (unsigned i = 0; i < count; ++i) {
            JSValue v = strings[i].jsValue();
            if (v.isString())
                ropeBuilder.append(asString(v));
            else
                ropeBuilder.append(jsString(globalData, v.toString(exec)));

            if (ropeBuilder.length() < oldLength)
                return throwOutOfMemoryError(exec);
        }

        return ropeBuilder.release();
    }

    inline __attribute__((__always_inline__)) JSValue jsStringFromArguments(ExecState* exec, JSValue thisValue)
    {
        JSGlobalData* globalData = &exec->globalData();
        JSString::RopeBuilder ropeBuilder(*globalData);

        if (thisValue.isString())
            ropeBuilder.append(asString(thisValue));
        else
            ropeBuilder.append(jsString(globalData, thisValue.toString(exec)));

        unsigned oldLength = 0;

        for (unsigned i = 0; i < exec->argumentCount(); ++i) {
            JSValue v = exec->argument(i);
            if (v.isString())
                ropeBuilder.append(asString(v));
            else
                ropeBuilder.append(jsString(globalData, v.toString(exec)));

            if (ropeBuilder.length() < oldLength)
                return throwOutOfMemoryError(exec);
        }

        return ropeBuilder.release();
    }


    inline bool JSValue::equal(ExecState* exec, JSValue v1, JSValue v2)
    {
        if (v1.isInt32() && v2.isInt32())
            return v1 == v2;

        return equalSlowCase(exec, v1, v2);
    }

    inline __attribute__((__always_inline__)) bool JSValue::equalSlowCaseInline(ExecState* exec, JSValue v1, JSValue v2)
    {
        do {
            if (v1.isNumber() && v2.isNumber())
                return v1.asNumber() == v2.asNumber();

            bool s1 = v1.isString();
            bool s2 = v2.isString();
            if (s1 && s2)
                return asString(v1)->value(exec) == asString(v2)->value(exec);

            if (v1.isUndefinedOrNull()) {
                if (v2.isUndefinedOrNull())
                    return true;
                if (!v2.isCell())
                    return false;
                return v2.asCell()->structure()->typeInfo().masqueradesAsUndefined();
            }

            if (v2.isUndefinedOrNull()) {
                if (!v1.isCell())
                    return false;
                return v1.asCell()->structure()->typeInfo().masqueradesAsUndefined();
            }

            if (v1.isObject()) {
                if (v2.isObject())
                    return v1 == v2;
                JSValue p1 = v1.toPrimitive(exec);
                if (exec->hadException())
                    return false;
                v1 = p1;
                if (v1.isInt32() && v2.isInt32())
                    return v1 == v2;
                continue;
            }

            if (v2.isObject()) {
                JSValue p2 = v2.toPrimitive(exec);
                if (exec->hadException())
                    return false;
                v2 = p2;
                if (v1.isInt32() && v2.isInt32())
                    return v1 == v2;
                continue;
            }

            if (s1 || s2) {
                double d1 = v1.toNumber(exec);
                double d2 = v2.toNumber(exec);
                return d1 == d2;
            }

            if (v1.isBoolean()) {
                if (v2.isNumber())
                    return static_cast<double>(v1.asBoolean()) == v2.asNumber();
            } else if (v2.isBoolean()) {
                if (v1.isNumber())
                    return v1.asNumber() == static_cast<double>(v2.asBoolean());
            }

            return v1 == v2;
        } while (true);
    }


    inline __attribute__((__always_inline__)) bool JSValue::strictEqualSlowCaseInline(ExecState* exec, JSValue v1, JSValue v2)
    {
        ((void)0);

        if (v1.asCell()->isString() && v2.asCell()->isString())
            return asString(v1)->value(exec) == asString(v2)->value(exec);

        return v1 == v2;
    }

    inline bool JSValue::strictEqual(ExecState* exec, JSValue v1, JSValue v2)
    {
        if (v1.isInt32() && v2.isInt32())
            return v1 == v2;

        if (v1.isNumber() && v2.isNumber())
            return v1.asNumber() == v2.asNumber();

        if (!v1.isCell() || !v2.isCell())
            return v1 == v2;

        return strictEqualSlowCaseInline(exec, v1, v2);
    }




    template<bool leftFirst>
    inline __attribute__((__always_inline__)) bool jsLess(CallFrame* callFrame, JSValue v1, JSValue v2)
    {
        if (v1.isInt32() && v2.isInt32())
            return v1.asInt32() < v2.asInt32();

        if (v1.isNumber() && v2.isNumber())
            return v1.asNumber() < v2.asNumber();

        JSGlobalData* globalData = &callFrame->globalData();
        if (isJSString(globalData, v1) && isJSString(globalData, v2))
            return asString(v1)->value(callFrame) < asString(v2)->value(callFrame);

        double n1;
        double n2;
        JSValue p1;
        JSValue p2;
        bool wasNotString1;
        bool wasNotString2;
        if (leftFirst) {
            wasNotString1 = v1.getPrimitiveNumber(callFrame, n1, p1);
            wasNotString2 = v2.getPrimitiveNumber(callFrame, n2, p2);
        } else {
            wasNotString2 = v2.getPrimitiveNumber(callFrame, n2, p2);
            wasNotString1 = v1.getPrimitiveNumber(callFrame, n1, p1);
        }

        if (wasNotString1 | wasNotString2)
            return n1 < n2;
        return asString(p1)->value(callFrame) < asString(p2)->value(callFrame);
    }




    template<bool leftFirst>
    inline __attribute__((__always_inline__)) bool jsLessEq(CallFrame* callFrame, JSValue v1, JSValue v2)
    {
        if (v1.isInt32() && v2.isInt32())
            return v1.asInt32() <= v2.asInt32();

        if (v1.isNumber() && v2.isNumber())
            return v1.asNumber() <= v2.asNumber();

        JSGlobalData* globalData = &callFrame->globalData();
        if (isJSString(globalData, v1) && isJSString(globalData, v2))
            return !(asString(v2)->value(callFrame) < asString(v1)->value(callFrame));

        double n1;
        double n2;
        JSValue p1;
        JSValue p2;
        bool wasNotString1;
        bool wasNotString2;
        if (leftFirst) {
            wasNotString1 = v1.getPrimitiveNumber(callFrame, n1, p1);
            wasNotString2 = v2.getPrimitiveNumber(callFrame, n2, p2);
        } else {
            wasNotString2 = v2.getPrimitiveNumber(callFrame, n2, p2);
            wasNotString1 = v1.getPrimitiveNumber(callFrame, n1, p1);
        }

        if (wasNotString1 | wasNotString2)
            return n1 <= n2;
        return !(asString(p2)->value(callFrame) < asString(p1)->value(callFrame));
    }
# 300 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/Operations.h"
    inline __attribute__((__always_inline__)) JSValue jsAdd(CallFrame* callFrame, JSValue v1, JSValue v2)
    {
        if (v1.isNumber() && v2.isNumber())
            return jsNumber(v1.asNumber() + v2.asNumber());

        if (v1.isString()) {
            return v2.isString()
                ? jsString(callFrame, asString(v1), asString(v2))
                : jsString(callFrame, asString(v1), v2.toPrimitiveString(callFrame));
        }


        return jsAddSlowCase(callFrame, v1, v2);
    }

    inline size_t normalizePrototypeChain(CallFrame* callFrame, JSValue base, JSValue slotBase, const Identifier& propertyName, size_t& slotOffset)
    {
        JSCell* cell = base.asCell();
        size_t count = 0;

        while (slotBase != cell) {
            JSValue v = cell->structure()->prototypeForLookup(callFrame);




            if (v.isNull())
                return 0;

            cell = v.asCell();



            if (cell->structure()->isDictionary()) {
                asObject(cell)->flattenDictionaryObject(callFrame->globalData());
                if (slotBase == cell)
                    slotOffset = cell->structure()->get(callFrame->globalData(), propertyName);
            }

            ++count;
        }

        ((void)0);
        return count;
    }

    inline size_t normalizePrototypeChain(CallFrame* callFrame, JSCell* base)
    {
        size_t count = 0;
        while (1) {
            JSValue v = base->structure()->prototypeForLookup(callFrame);
            if (v.isNull())
                return count;

            base = v.asCell();



            if (base->structure()->isDictionary())
                asObject(base)->flattenDictionaryObject(callFrame->globalData());

            ++count;
        }
    }

    inline __attribute__((__always_inline__)) JSValue resolveBase(CallFrame* callFrame, Identifier& property, ScopeChainNode* scopeChain, bool isStrictPut)
    {
        ScopeChainIterator iter = scopeChain->begin();
        ScopeChainIterator next = iter;
        ++next;
        ScopeChainIterator end = scopeChain->end();
        ((void)0);

        PropertySlot slot;
        JSObject* base;
        while (true) {
            base = iter->get();
            if (next == end) {
                if (isStrictPut && !base->getPropertySlot(callFrame, property, slot))
                    return JSValue();
                return base;
            }
            if (base->getPropertySlot(callFrame, property, slot))
                return base;

            iter = next;
            ++next;
        }

        ((void)0);
        return JSValue();
    }
}
# 35 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSPropertyNameIterator.h" 2


namespace JSC {

    class Identifier;
    class JSObject;

    class JSPropertyNameIterator : public JSCell {
        friend class JIT;

    public:
        typedef JSCell Base;

        static JSPropertyNameIterator* create(ExecState*, JSObject*);
        static JSPropertyNameIterator* create(ExecState* exec, PropertyNameArrayData* propertyNameArrayData, size_t numCacheableSlot)
        {
            JSPropertyNameIterator* iterator = new (allocateCell<JSPropertyNameIterator>(*exec->heap())) JSPropertyNameIterator(exec, propertyNameArrayData, numCacheableSlot);
            iterator->finishCreation(exec, propertyNameArrayData);
            return iterator;
        }

        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue prototype)
        {
            return Structure::create(globalData, globalObject, prototype, TypeInfo(CompoundType, OverridesVisitChildren), &s_info);
        }

        static void visitChildren(JSCell*, SlotVisitor&);

        bool getOffset(size_t i, int& offset)
        {
            if (i >= m_numCacheableSlots)
                return false;
            offset = i;
            return true;
        }

        JSValue get(ExecState*, JSObject*, size_t i);
        size_t size() { return m_jsStringsSize; }

        void setCachedStructure(JSGlobalData& globalData, Structure* structure)
        {
            ((void)0);
            ((void)0);
            m_cachedStructure.set(globalData, this, structure);
        }
        Structure* cachedStructure() { return m_cachedStructure.get(); }

        void setCachedPrototypeChain(JSGlobalData& globalData, StructureChain* cachedPrototypeChain) { m_cachedPrototypeChain.set(globalData, this, cachedPrototypeChain); }
        StructureChain* cachedPrototypeChain() { return m_cachedPrototypeChain.get(); }

        static const ClassInfo s_info;

    protected:
        void finishCreation(ExecState* exec, PropertyNameArrayData* propertyNameArrayData)
        {
            Base::finishCreation(exec->globalData());
            PropertyNameArrayData::PropertyNameVector& propertyNameVector = propertyNameArrayData->propertyNameVector();
            for (size_t i = 0; i < m_jsStringsSize; ++i)
                m_jsStrings[i].set(exec->globalData(), this, jsOwnedString(exec, propertyNameVector[i].ustring()));
        }

    private:
        JSPropertyNameIterator(ExecState*, PropertyNameArrayData* propertyNameArrayData, size_t numCacheableSlot);

        WriteBarrier<Structure> m_cachedStructure;
        WriteBarrier<StructureChain> m_cachedPrototypeChain;
        uint32_t m_numCacheableSlots;
        uint32_t m_jsStringsSize;
        OwnArrayPtr<WriteBarrier<Unknown> > m_jsStrings;
    };

    inline void Structure::setEnumerationCache(JSGlobalData& globalData, JSPropertyNameIterator* enumerationCache)
    {
        ((void)0);
        m_enumerationCache.set(globalData, this, enumerationCache);
    }

    inline JSPropertyNameIterator* Structure::enumerationCache()
    {
        return m_enumerationCache.get();
    }

    inline __attribute__((__always_inline__)) JSPropertyNameIterator* Register::propertyNameIterator() const
    {
        return static_cast<JSPropertyNameIterator*>(jsValue().asCell());
    }

}
# 51 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Interpreter.cpp" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/LiteralParser.h" 1
# 30 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/LiteralParser.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSGlobalObjectFunctions.h" 1
# 30 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSGlobalObjectFunctions.h"
namespace JSC {

    class ArgList;
    class ExecState;
    class JSObject;




    EncodedJSValue globalFuncEval(ExecState*);
    EncodedJSValue globalFuncParseInt(ExecState*);
    EncodedJSValue globalFuncParseFloat(ExecState*);
    EncodedJSValue globalFuncIsNaN(ExecState*);
    EncodedJSValue globalFuncIsFinite(ExecState*);
    EncodedJSValue globalFuncDecodeURI(ExecState*);
    EncodedJSValue globalFuncDecodeURIComponent(ExecState*);
    EncodedJSValue globalFuncEncodeURI(ExecState*);
    EncodedJSValue globalFuncEncodeURIComponent(ExecState*);
    EncodedJSValue globalFuncEscape(ExecState*);
    EncodedJSValue globalFuncUnescape(ExecState*);
    EncodedJSValue globalFuncThrowTypeError(ExecState*);

    static const double mantissaOverflowLowerBound = 9007199254740992.0;
    double parseIntOverflow(const char*, int length, int radix);
    double parseIntOverflow(const UChar*, int length, int radix);
    bool isStrWhiteSpace(UChar);
    double jsToNumber(const UString& s);

}
# 31 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/LiteralParser.h" 2



namespace JSC {

    class LiteralParser {
    public:
        typedef enum { StrictJSON, NonStrictJSON, JSONP } ParserMode;
        LiteralParser(ExecState* exec, const UChar* characters, unsigned length, ParserMode mode)
            : m_exec(exec)
            , m_lexer(characters, length, mode)
            , m_mode(mode)
        {
        }

        UString getErrorMessage()
        {
            if (!m_lexer.getErrorMessage().isEmpty())
                return String::format("JSON Parse error: %s", m_lexer.getErrorMessage().ascii().data()).impl();
            if (!m_parseErrorMessage.isEmpty())
                return String::format("JSON Parse error: %s", m_parseErrorMessage.ascii().data()).impl();
            return "JSON Parse error: Unable to parse JSON string";
        }

        JSValue tryLiteralParse()
        {
            m_lexer.next();
            JSValue result = parse(m_mode == StrictJSON ? StartParseExpression : StartParseStatement);
            if (m_lexer.currentToken().type == TokSemi)
                m_lexer.next();
            if (m_lexer.currentToken().type != TokEnd)
                return JSValue();
            return result;
        }

        enum JSONPPathEntryType {
            JSONPPathEntryTypeDeclare,
            JSONPPathEntryTypeDot,
            JSONPPathEntryTypeLookup,
            JSONPPathEntryTypeCall
        };

        struct JSONPPathEntry {
            JSONPPathEntryType m_type;
            Identifier m_pathEntryName;
            int m_pathIndex;
        };

        struct JSONPData {
            Vector<JSONPPathEntry> m_path;
            Strong<Unknown> m_value;
        };

        bool tryJSONPParse(Vector<JSONPData>&, bool needsFullSourceInfo);

    private:
        enum ParserState { StartParseObject, StartParseArray, StartParseExpression,
                           StartParseStatement, StartParseStatementEndStatement,
                           DoParseObjectStartExpression, DoParseObjectEndExpression,
                           DoParseArrayStartExpression, DoParseArrayEndExpression };
        enum TokenType { TokLBracket, TokRBracket, TokLBrace, TokRBrace,
                         TokString, TokIdentifier, TokNumber, TokColon,
                         TokLParen, TokRParen, TokComma, TokTrue, TokFalse,
                         TokNull, TokEnd, TokDot, TokAssign, TokSemi, TokError };

        class Lexer {
        public:
            struct LiteralParserToken {
                TokenType type;
                const UChar* start;
                const UChar* end;
                UString stringBuffer;
                union {
                    double numberToken;
                    struct {
                        const UChar* stringToken;
                        int stringLength;
                    };
                };
            };
            Lexer(const UChar* characters, unsigned length, ParserMode mode)
                : m_mode(mode)
                , m_ptr(characters)
                , m_end(characters + length)
            {
            }

            TokenType next();

            const LiteralParserToken& currentToken()
            {
                return m_currentToken;
            }

            UString getErrorMessage() { return m_lexErrorMessage; }

        private:
            UString m_lexErrorMessage;
            template <ParserMode mode> TokenType lex(LiteralParserToken&);
            template <ParserMode mode, UChar terminator> inline __attribute__((__always_inline__)) TokenType lexString(LiteralParserToken&);
            inline __attribute__((__always_inline__)) TokenType lexNumber(LiteralParserToken&);
            LiteralParserToken m_currentToken;
            UString m_string;
            ParserMode m_mode;
            const UChar* m_ptr;
            const UChar* m_end;
        };

        class StackGuard;
        JSValue parse(ParserState);

        ExecState* m_exec;
        LiteralParser::Lexer m_lexer;
        ParserMode m_mode;
        UString m_parseErrorMessage;
        static unsigned const MaximumCachableCharacter = 128;
        FixedArray<Identifier, MaximumCachableCharacter> m_shortIdentifiers;
        FixedArray<Identifier, MaximumCachableCharacter> m_recentIdentifiers;
        inline __attribute__((__always_inline__)) const Identifier makeIdentifier(const UChar* characters, size_t length);
    };

}
# 52 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Interpreter.cpp" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSStaticScopeObject.h" 1
# 31 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/JSStaticScopeObject.h"
namespace JSC{

    class JSStaticScopeObject : public JSVariableObject {
    public:
        typedef JSVariableObject Base;

        static JSStaticScopeObject* create(ExecState* exec, const Identifier& identifier, JSValue value, unsigned attributes)
        {
            JSStaticScopeObject* scopeObject = new (allocateCell<JSStaticScopeObject>(*exec->heap())) JSStaticScopeObject(exec);
            scopeObject->finishCreation(exec, identifier, value, attributes);
            return scopeObject;
        }

        static void visitChildren(JSCell*, SlotVisitor&);
        bool isDynamicScope(bool& requiresDynamicChecks) const;
        virtual JSObject* toThisObject(ExecState*) const;
        static bool getOwnPropertySlot(JSCell*, ExecState*, const Identifier&, PropertySlot&);
        static void put(JSCell*, ExecState*, const Identifier&, JSValue, PutPropertySlot&);

        void putWithAttributes(ExecState*, const Identifier&, JSValue, unsigned attributes);

        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue proto) { return Structure::create(globalData, globalObject, proto, TypeInfo(ObjectType, StructureFlags), &s_info); }

        static const ClassInfo s_info;

    protected:
        void finishCreation(ExecState* exec, const Identifier& identifier, JSValue value, unsigned attributes)
        {
            Base::finishCreation(exec->globalData());
            m_registerStore.set(exec->globalData(), this, value);
            symbolTable().add(identifier.impl(), SymbolTableEntry(-1, attributes));
        }
        static const unsigned StructureFlags = IsEnvironmentRecord | OverridesGetOwnPropertySlot | OverridesVisitChildren | OverridesGetPropertyNames | JSVariableObject::StructureFlags;

    private:
        JSStaticScopeObject(ExecState* exec)
            : JSVariableObject(exec->globalData(), exec->globalData().staticScopeStructure.get(), &m_symbolTable, reinterpret_cast<Register*>(&m_registerStore + 1))
        {
        }

        SymbolTable m_symbolTable;
        WriteBarrier<Unknown> m_registerStore;
    };

}
# 53 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Interpreter.cpp" 2

# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/ObjectPrototype.h" 1
# 26 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/ObjectPrototype.h"
namespace JSC {

    class ObjectPrototype : public JSNonFinalObject {
    public:
        typedef JSNonFinalObject Base;

        static ObjectPrototype* create(ExecState* exec, JSGlobalObject* globalObject, Structure* structure)
        {
            ObjectPrototype* prototype = new (allocateCell<ObjectPrototype>(*exec->heap())) ObjectPrototype(exec, structure);
            prototype->finishCreation(exec->globalData(), globalObject);
            return prototype;
        }

        static const ClassInfo s_info;

        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue prototype)
        {
            return Structure::create(globalData, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), &s_info);
        }

    protected:
        static const unsigned StructureFlags = OverridesGetOwnPropertySlot | JSNonFinalObject::StructureFlags;

        void finishCreation(JSGlobalData&, JSGlobalObject*);

    private:
        ObjectPrototype(ExecState*, Structure*);
        static void put(JSCell*, ExecState*, const Identifier&, JSValue, PutPropertySlot&);

        static bool getOwnPropertySlot(JSCell*, ExecState*, const Identifier&, PropertySlot&);
        static bool getOwnPropertySlotByIndex(JSCell*, ExecState*, unsigned propertyName, PropertySlot&);
        virtual bool getOwnPropertyDescriptor(ExecState*, const Identifier&, PropertyDescriptor&);

        bool m_hasNoPropertiesWithUInt32Names;
    };

    EncodedJSValue objectProtoFuncToString(ExecState*);

}
# 55 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Interpreter.cpp" 2




# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/RegExpPrototype.h" 1
# 27 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/RegExpPrototype.h"
namespace JSC {

    class RegExpPrototype : public RegExpObject {
    public:
        typedef RegExpObject Base;

        static RegExpPrototype* create(ExecState* exec, JSGlobalObject* globalObject, Structure* structure, RegExp* regExp)
        {
            RegExpPrototype* prototype = new (allocateCell<RegExpPrototype>(*exec->heap())) RegExpPrototype(globalObject, structure, regExp);
            prototype->finishCreation(globalObject);
            return prototype;
        }

        static const ClassInfo s_info;

        static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue prototype)
        {
            return Structure::create(globalData, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), &s_info);
        }

    protected:
        RegExpPrototype(JSGlobalObject*, Structure*, RegExp*);
        static const unsigned StructureFlags = OverridesGetOwnPropertySlot | RegExpObject::StructureFlags;

    private:
        static bool getOwnPropertySlot(JSCell*, ExecState*, const Identifier&, PropertySlot&);
        virtual bool getOwnPropertyDescriptor(ExecState*, const Identifier&, PropertyDescriptor&);
    };

}
# 60 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Interpreter.cpp" 2


# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/StrictEvalActivation.h" 1
# 31 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/StrictEvalActivation.h"
namespace JSC {

class StrictEvalActivation : public JSNonFinalObject {
public:
    typedef JSNonFinalObject Base;

    static StrictEvalActivation* create(ExecState* exec)
    {
        StrictEvalActivation* activation = new (allocateCell<StrictEvalActivation>(*exec->heap())) StrictEvalActivation(exec);
        activation->finishCreation(exec->globalData());
        return activation;
    }

    static bool deleteProperty(JSCell*, ExecState*, const Identifier&);
    virtual JSObject* toThisObject(ExecState*) const;

    static Structure* createStructure(JSGlobalData& globalData, JSGlobalObject* globalObject, JSValue prototype)
    {
        return Structure::create(globalData, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), &s_info);
    }

    static const ClassInfo s_info;

protected:
    static const unsigned StructureFlags = IsEnvironmentRecord | JSNonFinalObject::StructureFlags;

private:
    StrictEvalActivation(ExecState*);
};

}
# 63 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Interpreter.cpp" 2
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/UStringConcatenate.h" 1
# 32 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/runtime/UStringConcatenate.h"
namespace WTF {

template<>
class StringTypeAdapter<JSC::UString> {
public:
    StringTypeAdapter<JSC::UString>(JSC::UString& string)
        : m_data(string.characters())
        , m_length(string.length())
    {
    }

    unsigned length() { return m_length; }

    void writeTo(UChar* destination)
    {
        for (unsigned i = 0; i < m_length; ++i)
            destination[i] = m_data[i];
    }

private:
    const UChar* m_data;
    unsigned m_length;
};

};

namespace JSC {

template<typename StringType1, typename StringType2>
UString makeUString(StringType1 string1, StringType2 string2)
{
    PassRefPtr<StringImpl> resultImpl = WTF::tryMakeString(string1, string2);
    if (!resultImpl)
        do { WTFReportBacktrace(); *(int *)(uintptr_t)0xbbadbeef = 0; __builtin_trap(); } while (false);
    return resultImpl;
}

template<typename StringType1, typename StringType2, typename StringType3>
UString makeUString(StringType1 string1, StringType2 string2, StringType3 string3)
{
    PassRefPtr<StringImpl> resultImpl = WTF::tryMakeString(string1, string2, string3);
    if (!resultImpl)
        do { WTFReportBacktrace(); *(int *)(uintptr_t)0xbbadbeef = 0; __builtin_trap(); } while (false);
    return resultImpl;
}

template<typename StringType1, typename StringType2, typename StringType3, typename StringType4>
UString makeUString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4)
{
    PassRefPtr<StringImpl> resultImpl = WTF::tryMakeString(string1, string2, string3, string4);
    if (!resultImpl)
        do { WTFReportBacktrace(); *(int *)(uintptr_t)0xbbadbeef = 0; __builtin_trap(); } while (false);
    return resultImpl;
}

template<typename StringType1, typename StringType2, typename StringType3, typename StringType4, typename StringType5>
UString makeUString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5)
{
    PassRefPtr<StringImpl> resultImpl = WTF::tryMakeString(string1, string2, string3, string4, string5);
    if (!resultImpl)
        do { WTFReportBacktrace(); *(int *)(uintptr_t)0xbbadbeef = 0; __builtin_trap(); } while (false);
    return resultImpl;
}

template<typename StringType1, typename StringType2, typename StringType3, typename StringType4, typename StringType5, typename StringType6>
UString makeUString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6)
{
    PassRefPtr<StringImpl> resultImpl = WTF::tryMakeString(string1, string2, string3, string4, string5, string6);
    if (!resultImpl)
        do { WTFReportBacktrace(); *(int *)(uintptr_t)0xbbadbeef = 0; __builtin_trap(); } while (false);
    return resultImpl;
}

template<typename StringType1, typename StringType2, typename StringType3, typename StringType4, typename StringType5, typename StringType6, typename StringType7>
UString makeUString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6, StringType7 string7)
{
    PassRefPtr<StringImpl> resultImpl = WTF::tryMakeString(string1, string2, string3, string4, string5, string6, string7);
    if (!resultImpl)
        do { WTFReportBacktrace(); *(int *)(uintptr_t)0xbbadbeef = 0; __builtin_trap(); } while (false);
    return resultImpl;
}

template<typename StringType1, typename StringType2, typename StringType3, typename StringType4, typename StringType5, typename StringType6, typename StringType7, typename StringType8>
UString makeUString(StringType1 string1, StringType2 string2, StringType3 string3, StringType4 string4, StringType5 string5, StringType6 string6, StringType7 string7, StringType8 string8)
{
    PassRefPtr<StringImpl> resultImpl = WTF::tryMakeString(string1, string2, string3, string4, string5, string6, string7, string8);
    if (!resultImpl)
        do { WTFReportBacktrace(); *(int *)(uintptr_t)0xbbadbeef = 0; __builtin_trap(); } while (false);
    return resultImpl;
}

}
# 64 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Interpreter.cpp" 2





# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/jit/JIT.h" 1
# 50 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/jit/JIT.h"
# 1 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/jit/JSInterfaceJIT.h" 1
# 34 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/jit/JSInterfaceJIT.h"
# 1 "./wtf/AlwaysInline.h" 1
# 35 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/jit/JSInterfaceJIT.h" 2


namespace JSC {
    class JSInterfaceJIT : public MacroAssembler {
    public:
# 54 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/jit/JSInterfaceJIT.h"
        static const RegisterID returnValueRegister = X86Registers::eax;
        static const RegisterID cachedResultRegister = X86Registers::eax;
        static const RegisterID firstArgumentRegister = X86Registers::edi;


        static const RegisterID bucketCounterRegister = X86Registers::r10;


        static const RegisterID timeoutCheckRegister = X86Registers::r12;
        static const RegisterID callFrameRegister = X86Registers::r13;
        static const RegisterID tagTypeNumberRegister = X86Registers::r14;
        static const RegisterID tagMaskRegister = X86Registers::r15;

        static const RegisterID regT0 = X86Registers::eax;
        static const RegisterID regT1 = X86Registers::edx;
        static const RegisterID regT2 = X86Registers::ecx;
        static const RegisterID regT3 = X86Registers::ebx;

        static const FPRegisterID fpRegT0 = X86Registers::xmm0;
        static const FPRegisterID fpRegT1 = X86Registers::xmm1;
        static const FPRegisterID fpRegT2 = X86Registers::xmm2;
        static const FPRegisterID fpRegT3 = X86Registers::xmm3;
# 194 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/jit/JSInterfaceJIT.h"
        static const unsigned Int32Tag = 0xffff000000000000ll >> 32;

        inline Jump emitLoadJSCell(unsigned virtualRegisterIndex, RegisterID payload);
        inline Jump emitLoadInt32(unsigned virtualRegisterIndex, RegisterID dst);
        inline Jump emitLoadDouble(unsigned virtualRegisterIndex, FPRegisterID dst, RegisterID scratch);







        Jump emitJumpIfImmediateNumber(RegisterID reg);
        Jump emitJumpIfNotImmediateNumber(RegisterID reg);
        void emitFastArithImmToInt(RegisterID reg);


        inline Address payloadFor(int index, RegisterID base = callFrameRegister);
        inline Address intPayloadFor(int index, RegisterID base = callFrameRegister);
        inline Address intTagFor(int index, RegisterID base = callFrameRegister);
        inline Address addressFor(int index, RegisterID base = callFrameRegister);
    };

    struct ThunkHelpers {
        static unsigned stringImplDataOffset() { return StringImpl::dataOffset(); }
        static unsigned jsStringLengthOffset() { return (reinterpret_cast<ptrdiff_t>(&(reinterpret_cast<JSString*>(0x4000)->m_length)) - 0x4000); }
        static unsigned jsStringValueOffset() { return (reinterpret_cast<ptrdiff_t>(&(reinterpret_cast<JSString*>(0x4000)->m_value)) - 0x4000); }
    };
# 283 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/jit/JSInterfaceJIT.h"
    inline __attribute__((__always_inline__)) JSInterfaceJIT::Jump JSInterfaceJIT::emitJumpIfImmediateNumber(RegisterID reg)
    {
        return branchTestPtr(NonZero, reg, tagTypeNumberRegister);
    }
    inline __attribute__((__always_inline__)) JSInterfaceJIT::Jump JSInterfaceJIT::emitJumpIfNotImmediateNumber(RegisterID reg)
    {
        return branchTestPtr(Zero, reg, tagTypeNumberRegister);
    }
    inline JSInterfaceJIT::Jump JSInterfaceJIT::emitLoadJSCell(unsigned virtualRegisterIndex, RegisterID dst)
    {
        loadPtr(addressFor(virtualRegisterIndex), dst);
        return branchTestPtr(NonZero, dst, tagMaskRegister);
    }

    inline JSInterfaceJIT::Jump JSInterfaceJIT::emitLoadInt32(unsigned virtualRegisterIndex, RegisterID dst)
    {
        loadPtr(addressFor(virtualRegisterIndex), dst);
        Jump result = branchPtr(Below, dst, tagTypeNumberRegister);
        zeroExtend32ToPtr(dst, dst);
        return result;
    }

    inline JSInterfaceJIT::Jump JSInterfaceJIT::emitLoadDouble(unsigned virtualRegisterIndex, FPRegisterID dst, RegisterID scratch)
    {
        loadPtr(addressFor(virtualRegisterIndex), scratch);
        Jump notNumber = emitJumpIfNotImmediateNumber(scratch);
        Jump notInt = branchPtr(Below, scratch, tagTypeNumberRegister);
        convertInt32ToDouble(scratch, dst);
        Jump done = jump();
        notInt.link(this);
        addPtr(tagTypeNumberRegister, scratch);
        movePtrToDouble(scratch, dst);
        done.link(this);
        return notNumber;
    }

    inline __attribute__((__always_inline__)) void JSInterfaceJIT::emitFastArithImmToInt(RegisterID)
    {
    }




    inline JSInterfaceJIT::Address JSInterfaceJIT::payloadFor(int virtualRegisterIndex, RegisterID base)
    {
        ((void)0);
        return addressFor(virtualRegisterIndex, base);
    }

    inline JSInterfaceJIT::Address JSInterfaceJIT::intPayloadFor(int virtualRegisterIndex, RegisterID base)
    {
        ((void)0);
        return Address(base, (static_cast<unsigned>(virtualRegisterIndex) * sizeof(Register)) + (reinterpret_cast<ptrdiff_t>(&(reinterpret_cast<EncodedValueDescriptor*>(0x4000)->asBits.payload)) - 0x4000));
    }
    inline JSInterfaceJIT::Address JSInterfaceJIT::intTagFor(int virtualRegisterIndex, RegisterID base)
    {
        ((void)0);
        return Address(base, (static_cast<unsigned>(virtualRegisterIndex) * sizeof(Register)) + (reinterpret_cast<ptrdiff_t>(&(reinterpret_cast<EncodedValueDescriptor*>(0x4000)->asBits.tag)) - 0x4000));
    }


    inline JSInterfaceJIT::Address JSInterfaceJIT::addressFor(int virtualRegisterIndex, RegisterID base)
    {
        ((void)0);
        return Address(base, (static_cast<unsigned>(virtualRegisterIndex) * sizeof(Register)));
    }

}
# 51 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/jit/JIT.h" 2




namespace JSC {

    class CodeBlock;
    class FunctionExecutable;
    class JIT;
    class JSPropertyNameIterator;
    class Interpreter;
    class Register;
    class RegisterFile;
    class ScopeChainNode;
    class StructureChain;

    struct CallLinkInfo;
    struct Instruction;
    struct OperandTypes;
    struct PolymorphicAccessStructureList;
    struct SimpleJumpTable;
    struct StringJumpTable;
    struct StructureStubInfo;

    struct CallRecord {
        MacroAssembler::Call from;
        unsigned bytecodeOffset;
        void* to;

        CallRecord()
        {
        }

        CallRecord(MacroAssembler::Call from, unsigned bytecodeOffset, void* to = 0)
            : from(from)
            , bytecodeOffset(bytecodeOffset)
            , to(to)
        {
        }
    };

    struct JumpTable {
        MacroAssembler::Jump from;
        unsigned toBytecodeOffset;

        JumpTable(MacroAssembler::Jump f, unsigned t)
            : from(f)
            , toBytecodeOffset(t)
        {
        }
    };

    struct SlowCaseEntry {
        MacroAssembler::Jump from;
        unsigned to;
        unsigned hint;

        SlowCaseEntry(MacroAssembler::Jump f, unsigned t, unsigned h = 0)
            : from(f)
            , to(t)
            , hint(h)
        {
        }
    };

    struct SwitchRecord {
        enum Type {
            Immediate,
            Character,
            String
        };

        Type type;

        union {
            SimpleJumpTable* simpleJumpTable;
            StringJumpTable* stringJumpTable;
        } jumpTable;

        unsigned bytecodeOffset;
        unsigned defaultOffset;

        SwitchRecord(SimpleJumpTable* jumpTable, unsigned bytecodeOffset, unsigned defaultOffset, Type type)
            : type(type)
            , bytecodeOffset(bytecodeOffset)
            , defaultOffset(defaultOffset)
        {
            this->jumpTable.simpleJumpTable = jumpTable;
        }

        SwitchRecord(StringJumpTable* jumpTable, unsigned bytecodeOffset, unsigned defaultOffset)
            : type(String)
            , bytecodeOffset(bytecodeOffset)
            , defaultOffset(defaultOffset)
        {
            this->jumpTable.stringJumpTable = jumpTable;
        }
    };

    struct PropertyStubCompilationInfo {
        unsigned bytecodeIndex;
        MacroAssembler::Call callReturnLocation;
        MacroAssembler::Label hotPathBegin;







    };

    struct StructureStubCompilationInfo {
        MacroAssembler::DataLabelPtr hotPathBegin;
        MacroAssembler::Call hotPathOther;
        MacroAssembler::Call callReturnLocation;
        bool isCall;
        unsigned bytecodeIndex;
    };

    struct MethodCallCompilationInfo {
        MethodCallCompilationInfo(unsigned bytecodeIndex, unsigned propertyAccessIndex)
            : bytecodeIndex(bytecodeIndex)
            , propertyAccessIndex(propertyAccessIndex)
        {
        }

        unsigned bytecodeIndex;
        MacroAssembler::DataLabelPtr structureToCompare;
        unsigned propertyAccessIndex;
    };


    void ctiPatchNearCallByReturnAddress(CodeBlock* codeblock, ReturnAddressPtr returnAddress, MacroAssemblerCodePtr newCalleeFunction);
    void ctiPatchCallByReturnAddress(CodeBlock* codeblock, ReturnAddressPtr returnAddress, MacroAssemblerCodePtr newCalleeFunction);
    void ctiPatchCallByReturnAddress(CodeBlock* codeblock, ReturnAddressPtr returnAddress, FunctionPtr newCalleeFunction);

    class JIT : private JSInterfaceJIT {
        friend class JITStubCall;

        using MacroAssembler::Jump;
        using MacroAssembler::JumpList;
        using MacroAssembler::Label;

        static const int patchGetByIdDefaultStructure = -1;
        static const int patchGetByIdDefaultOffset = 0;


        static const int patchPutByIdDefaultOffset = 256;

    public:
        static JITCode compile(JSGlobalData* globalData, CodeBlock* codeBlock, CodePtr* functionEntryArityCheck = 0)
        {
            return JIT(globalData, codeBlock).privateCompile(functionEntryArityCheck);
        }

        static void compileGetByIdProto(JSGlobalData* globalData, CallFrame* callFrame, CodeBlock* codeBlock, StructureStubInfo* stubInfo, Structure* structure, Structure* prototypeStructure, const Identifier& ident, const PropertySlot& slot, size_t cachedOffset, ReturnAddressPtr returnAddress)
        {
            JIT jit(globalData, codeBlock);
            jit.privateCompileGetByIdProto(stubInfo, structure, prototypeStructure, ident, slot, cachedOffset, returnAddress, callFrame);
        }

        static void compileGetByIdSelfList(JSGlobalData* globalData, CodeBlock* codeBlock, StructureStubInfo* stubInfo, PolymorphicAccessStructureList* polymorphicStructures, int currentIndex, Structure* structure, const Identifier& ident, const PropertySlot& slot, size_t cachedOffset)
        {
            JIT jit(globalData, codeBlock);
            jit.privateCompileGetByIdSelfList(stubInfo, polymorphicStructures, currentIndex, structure, ident, slot, cachedOffset);
        }
        static void compileGetByIdProtoList(JSGlobalData* globalData, CallFrame* callFrame, CodeBlock* codeBlock, StructureStubInfo* stubInfo, PolymorphicAccessStructureList* prototypeStructureList, int currentIndex, Structure* structure, Structure* prototypeStructure, const Identifier& ident, const PropertySlot& slot, size_t cachedOffset)
        {
            JIT jit(globalData, codeBlock);
            jit.privateCompileGetByIdProtoList(stubInfo, prototypeStructureList, currentIndex, structure, prototypeStructure, ident, slot, cachedOffset, callFrame);
        }
        static void compileGetByIdChainList(JSGlobalData* globalData, CallFrame* callFrame, CodeBlock* codeBlock, StructureStubInfo* stubInfo, PolymorphicAccessStructureList* prototypeStructureList, int currentIndex, Structure* structure, StructureChain* chain, size_t count, const Identifier& ident, const PropertySlot& slot, size_t cachedOffset)
        {
            JIT jit(globalData, codeBlock);
            jit.privateCompileGetByIdChainList(stubInfo, prototypeStructureList, currentIndex, structure, chain, count, ident, slot, cachedOffset, callFrame);
        }

        static void compileGetByIdChain(JSGlobalData* globalData, CallFrame* callFrame, CodeBlock* codeBlock, StructureStubInfo* stubInfo, Structure* structure, StructureChain* chain, size_t count, const Identifier& ident, const PropertySlot& slot, size_t cachedOffset, ReturnAddressPtr returnAddress)
        {
            JIT jit(globalData, codeBlock);
            jit.privateCompileGetByIdChain(stubInfo, structure, chain, count, ident, slot, cachedOffset, returnAddress, callFrame);
        }

        static void compilePutByIdTransition(JSGlobalData* globalData, CodeBlock* codeBlock, StructureStubInfo* stubInfo, Structure* oldStructure, Structure* newStructure, size_t cachedOffset, StructureChain* chain, ReturnAddressPtr returnAddress, bool direct)
        {
            JIT jit(globalData, codeBlock);
            jit.privateCompilePutByIdTransition(stubInfo, oldStructure, newStructure, cachedOffset, chain, returnAddress, direct);
        }

        static PassRefPtr<ExecutableMemoryHandle> compileCTIMachineTrampolines(JSGlobalData* globalData, TrampolineStructure *trampolines)
        {
            if (!globalData->canUseJIT())
                return 0;
            JIT jit(globalData, 0);
            return jit.privateCompileCTIMachineTrampolines(globalData, trampolines);
        }

        static CodeRef compileCTINativeCall(JSGlobalData* globalData, NativeFunction func)
        {
            if (!globalData->canUseJIT())
                return CodeRef();
            JIT jit(globalData, 0);
            return jit.privateCompileCTINativeCall(globalData, func);
        }

        static void patchGetByIdSelf(CodeBlock* codeblock, StructureStubInfo*, Structure*, size_t cachedOffset, ReturnAddressPtr returnAddress);
        static void patchPutByIdReplace(CodeBlock* codeblock, StructureStubInfo*, Structure*, size_t cachedOffset, ReturnAddressPtr returnAddress, bool direct);
        static void patchMethodCallProto(JSGlobalData&, CodeBlock* codeblock, MethodCallLinkInfo&, JSObject*, Structure*, JSObject*, ReturnAddressPtr);

        static void compilePatchGetArrayLength(JSGlobalData* globalData, CodeBlock* codeBlock, ReturnAddressPtr returnAddress)
        {
            JIT jit(globalData, codeBlock);
            return jit.privateCompilePatchGetArrayLength(returnAddress);
        }

        static void linkFor(JSFunction* callee, CodeBlock* callerCodeBlock, CodeBlock* calleeCodeBlock, CodePtr, CallLinkInfo*, int callerArgCount, JSGlobalData*, CodeSpecializationKind);

    private:
        struct JSRInfo {
            DataLabelPtr storeLocation;
            Label target;

            JSRInfo(DataLabelPtr storeLocation, Label targetLocation)
                : storeLocation(storeLocation)
                , target(targetLocation)
            {
            }
        };

        JIT(JSGlobalData*, CodeBlock* = 0);

        void privateCompileMainPass();
        void privateCompileLinkPass();
        void privateCompileSlowCases();
        JITCode privateCompile(CodePtr* functionEntryArityCheck);
        void privateCompileGetByIdProto(StructureStubInfo*, Structure*, Structure* prototypeStructure, const Identifier&, const PropertySlot&, size_t cachedOffset, ReturnAddressPtr returnAddress, CallFrame* callFrame);
        void privateCompileGetByIdSelfList(StructureStubInfo*, PolymorphicAccessStructureList*, int, Structure*, const Identifier&, const PropertySlot&, size_t cachedOffset);
        void privateCompileGetByIdProtoList(StructureStubInfo*, PolymorphicAccessStructureList*, int, Structure*, Structure* prototypeStructure, const Identifier&, const PropertySlot&, size_t cachedOffset, CallFrame* callFrame);
        void privateCompileGetByIdChainList(StructureStubInfo*, PolymorphicAccessStructureList*, int, Structure*, StructureChain* chain, size_t count, const Identifier&, const PropertySlot&, size_t cachedOffset, CallFrame* callFrame);
        void privateCompileGetByIdChain(StructureStubInfo*, Structure*, StructureChain*, size_t count, const Identifier&, const PropertySlot&, size_t cachedOffset, ReturnAddressPtr returnAddress, CallFrame* callFrame);
        void privateCompilePutByIdTransition(StructureStubInfo*, Structure*, Structure*, size_t cachedOffset, StructureChain*, ReturnAddressPtr returnAddress, bool direct);

        PassRefPtr<ExecutableMemoryHandle> privateCompileCTIMachineTrampolines(JSGlobalData*, TrampolineStructure*);
        Label privateCompileCTINativeCall(JSGlobalData*, bool isConstruct = false);
        CodeRef privateCompileCTINativeCall(JSGlobalData*, NativeFunction);
        void privateCompilePatchGetArrayLength(ReturnAddressPtr returnAddress);

        void addSlowCase(Jump);
        void addSlowCase(JumpList);
        void addSlowCase();
        void addJump(Jump, int);
        void emitJumpSlowToHot(Jump, int);

        void compileOpCall(OpcodeID, Instruction* instruction, unsigned callLinkInfoIndex);
        void compileOpCallVarargs(Instruction* instruction);
        void compileOpCallInitializeCallFrame();
        void compileOpCallSlowCase(Instruction* instruction, Vector<SlowCaseEntry>::iterator& iter, unsigned callLinkInfoIndex, OpcodeID opcodeID);
        void compileOpCallVarargsSlowCase(Instruction* instruction, Vector<SlowCaseEntry>::iterator& iter);

        enum CompileOpStrictEqType { OpStrictEq, OpNStrictEq };
        void compileOpStrictEq(Instruction* instruction, CompileOpStrictEqType type);
        bool isOperandConstantImmediateDouble(unsigned src);

        void emitLoadDouble(unsigned index, FPRegisterID value);
        void emitLoadInt32ToDouble(unsigned index, FPRegisterID value);
        Jump emitJumpIfNotObject(RegisterID structureReg);
        Jump emitJumpIfNotType(RegisterID baseReg, RegisterID scratchReg, JSType);

        void testPrototype(JSValue, JumpList& failureCases);

        enum WriteBarrierMode { UnconditionalWriteBarrier, ShouldFilterImmediates };


        void emitWriteBarrier(RegisterID owner, RegisterID valueTag, RegisterID scratch, RegisterID scratch2, WriteBarrierMode, WriteBarrierUseKind);
        void emitWriteBarrier(JSCell* owner, RegisterID value, RegisterID scratch, WriteBarrierMode, WriteBarrierUseKind);

        template<typename ClassType, typename StructureType> void emitAllocateBasicJSObject(StructureType, void* vtable, RegisterID result, RegisterID storagePtr);
        template<typename T> void emitAllocateJSFinalObject(T structure, RegisterID result, RegisterID storagePtr);
        void emitAllocateJSFunction(FunctionExecutable*, RegisterID scopeChain, RegisterID result, RegisterID storagePtr);

        enum ValueProfilingSiteKind { FirstProfilingSite, SubsequentProfilingSite };



        void emitValueProfilingSite(ValueProfilingSiteKind);
# 564 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/jit/JIT.h"
        void emitGetVirtualRegister(int src, RegisterID dst);
        void emitGetVirtualRegisters(int src1, RegisterID dst1, int src2, RegisterID dst2);
        void emitPutVirtualRegister(unsigned dst, RegisterID from = regT0);
        void emitStoreCell(unsigned dst, RegisterID payload, bool = false)
        {
            emitPutVirtualRegister(dst, payload);
        }

        int32_t getConstantOperandImmediateInt(unsigned src);

        void killLastResultRegister();

        Jump emitJumpIfJSCell(RegisterID);
        Jump emitJumpIfBothJSCells(RegisterID, RegisterID, RegisterID);
        void emitJumpSlowCaseIfJSCell(RegisterID);
        Jump emitJumpIfNotJSCell(RegisterID);
        void emitJumpSlowCaseIfNotJSCell(RegisterID);
        void emitJumpSlowCaseIfNotJSCell(RegisterID, int VReg);
# 593 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/jit/JIT.h"
        Jump emitJumpIfImmediateInteger(RegisterID);
        Jump emitJumpIfNotImmediateInteger(RegisterID);
        Jump emitJumpIfNotImmediateIntegers(RegisterID, RegisterID, RegisterID);
        void emitJumpSlowCaseIfNotImmediateInteger(RegisterID);
        void emitJumpSlowCaseIfNotImmediateNumber(RegisterID);
        void emitJumpSlowCaseIfNotImmediateIntegers(RegisterID, RegisterID, RegisterID);





        void emitFastArithReTagImmediate(RegisterID src, RegisterID dest);
        void emitFastArithIntToImmNoCheck(RegisterID src, RegisterID dest);

        void emitTagAsBoolImmediate(RegisterID reg);
        void compileBinaryArithOp(OpcodeID, unsigned dst, unsigned src1, unsigned src2, OperandTypes opi);

        void compileBinaryArithOpSlowCase(OpcodeID, Vector<SlowCaseEntry>::iterator&, unsigned dst, unsigned src1, unsigned src2, OperandTypes, bool op1HasImmediateIntFastCase, bool op2HasImmediateIntFastCase);




        void compileGetByIdHotPath(int baseVReg, Identifier*);
        void compileGetByIdSlowCase(int resultVReg, int baseVReg, Identifier* ident, Vector<SlowCaseEntry>::iterator& iter, bool isMethodCheck = false);
        void compileGetDirectOffset(RegisterID base, RegisterID result, size_t cachedOffset);
        void compileGetDirectOffset(JSObject* base, RegisterID result, size_t cachedOffset);
        void compileGetDirectOffset(RegisterID base, RegisterID result, RegisterID offset, RegisterID scratch);
        void compilePutDirectOffset(RegisterID base, RegisterID value, size_t cachedOffset);



        static const int patchOffsetPutByIdStructure = 10;
        static const int patchOffsetPutByIdPropertyMapOffset = 31;

        static const int patchOffsetGetByIdStructure = 10;
        static const int patchOffsetGetByIdBranchToSlowCase = 20;
        static const int patchOffsetGetByIdPropertyMapOffset = 28;
        static const int patchOffsetGetByIdPutResult = 28;



        static const int patchOffsetGetByIdSlowCaseCall = 54;

        static const int patchOffsetOpCallCompareToJump = 9;

        static const int patchOffsetMethodCheckProtoObj = 20;
        static const int patchOffsetMethodCheckProtoStruct = 30;
        static const int patchOffsetMethodCheckPutFunction = 50;
# 765 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/jit/JIT.h"
        void emit_compareAndJump(OpcodeID, unsigned op1, unsigned op2, unsigned target, RelationalCondition);
        void emit_compareAndJumpSlow(unsigned op1, unsigned op2, unsigned target, DoubleCondition, int ( *stub)(void** args), bool invert, Vector<SlowCaseEntry>::iterator&);

        void emit_op_add(Instruction*);
        void emit_op_bitand(Instruction*);
        void emit_op_bitnot(Instruction*);
        void emit_op_bitor(Instruction*);
        void emit_op_bitxor(Instruction*);
        void emit_op_call(Instruction*);
        void emit_op_call_eval(Instruction*);
        void emit_op_call_varargs(Instruction*);
        void emit_op_call_put_result(Instruction*);
        void emit_op_catch(Instruction*);
        void emit_op_construct(Instruction*);
        void emit_op_get_callee(Instruction*);
        void emit_op_create_this(Instruction*);
        void emit_op_convert_this(Instruction*);
        void emit_op_create_arguments(Instruction*);
        void emit_op_debug(Instruction*);
        void emit_op_del_by_id(Instruction*);
        void emit_op_div(Instruction*);
        void emit_op_end(Instruction*);
        void emit_op_enter(Instruction*);
        void emit_op_create_activation(Instruction*);
        void emit_op_eq(Instruction*);
        void emit_op_eq_null(Instruction*);
        void emit_op_get_by_id(Instruction*);
        void emit_op_get_arguments_length(Instruction*);
        void emit_op_get_by_val(Instruction*);
        void emit_op_get_argument_by_val(Instruction*);
        void emit_op_get_by_pname(Instruction*);
        void emit_op_get_global_var(Instruction*);
        void emit_op_get_scoped_var(Instruction*);
        void emit_op_init_lazy_reg(Instruction*);
        void emit_op_check_has_instance(Instruction*);
        void emit_op_instanceof(Instruction*);
        void emit_op_jeq_null(Instruction*);
        void emit_op_jfalse(Instruction*);
        void emit_op_jmp(Instruction*);
        void emit_op_jmp_scopes(Instruction*);
        void emit_op_jneq_null(Instruction*);
        void emit_op_jneq_ptr(Instruction*);
        void emit_op_jless(Instruction*);
        void emit_op_jlesseq(Instruction*);
        void emit_op_jgreater(Instruction*);
        void emit_op_jgreatereq(Instruction*);
        void emit_op_jnless(Instruction*);
        void emit_op_jnlesseq(Instruction*);
        void emit_op_jngreater(Instruction*);
        void emit_op_jngreatereq(Instruction*);
        void emit_op_jsr(Instruction*);
        void emit_op_jtrue(Instruction*);
        void emit_op_load_varargs(Instruction*);
        void emit_op_loop(Instruction*);
        void emit_op_loop_hint(Instruction*);
        void emit_op_loop_if_less(Instruction*);
        void emit_op_loop_if_lesseq(Instruction*);
        void emit_op_loop_if_greater(Instruction*);
        void emit_op_loop_if_greatereq(Instruction*);
        void emit_op_loop_if_true(Instruction*);
        void emit_op_loop_if_false(Instruction*);
        void emit_op_lshift(Instruction*);
        void emit_op_method_check(Instruction*);
        void emit_op_mod(Instruction*);
        void emit_op_mov(Instruction*);
        void emit_op_mul(Instruction*);
        void emit_op_negate(Instruction*);
        void emit_op_neq(Instruction*);
        void emit_op_neq_null(Instruction*);
        void emit_op_new_array(Instruction*);
        void emit_op_new_array_buffer(Instruction*);
        void emit_op_new_func(Instruction*);
        void emit_op_new_func_exp(Instruction*);
        void emit_op_new_object(Instruction*);
        void emit_op_new_regexp(Instruction*);
        void emit_op_get_pnames(Instruction*);
        void emit_op_next_pname(Instruction*);
        void emit_op_not(Instruction*);
        void emit_op_nstricteq(Instruction*);
        void emit_op_pop_scope(Instruction*);
        void emit_op_post_dec(Instruction*);
        void emit_op_post_inc(Instruction*);
        void emit_op_pre_dec(Instruction*);
        void emit_op_pre_inc(Instruction*);
        void emit_op_profile_did_call(Instruction*);
        void emit_op_profile_will_call(Instruction*);
        void emit_op_push_new_scope(Instruction*);
        void emit_op_push_scope(Instruction*);
        void emit_op_put_by_id(Instruction*);
        void emit_op_put_by_index(Instruction*);
        void emit_op_put_by_val(Instruction*);
        void emit_op_put_getter(Instruction*);
        void emit_op_put_global_var(Instruction*);
        void emit_op_put_scoped_var(Instruction*);
        void emit_op_put_setter(Instruction*);
        void emit_op_resolve(Instruction*);
        void emit_op_resolve_base(Instruction*);
        void emit_op_ensure_property_exists(Instruction*);
        void emit_op_resolve_global(Instruction*, bool dynamic = false);
        void emit_op_resolve_global_dynamic(Instruction*);
        void emit_op_resolve_skip(Instruction*);
        void emit_op_resolve_with_base(Instruction*);
        void emit_op_resolve_with_this(Instruction*);
        void emit_op_ret(Instruction*);
        void emit_op_ret_object_or_this(Instruction*);
        void emit_op_rshift(Instruction*);
        void emit_op_sret(Instruction*);
        void emit_op_strcat(Instruction*);
        void emit_op_stricteq(Instruction*);
        void emit_op_sub(Instruction*);
        void emit_op_switch_char(Instruction*);
        void emit_op_switch_imm(Instruction*);
        void emit_op_switch_string(Instruction*);
        void emit_op_tear_off_activation(Instruction*);
        void emit_op_tear_off_arguments(Instruction*);
        void emit_op_throw(Instruction*);
        void emit_op_throw_reference_error(Instruction*);
        void emit_op_to_jsnumber(Instruction*);
        void emit_op_to_primitive(Instruction*);
        void emit_op_unexpected_load(Instruction*);
        void emit_op_urshift(Instruction*);




        void emitSlow_op_add(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_bitand(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_bitnot(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_bitor(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_bitxor(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_call(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_call_eval(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_call_varargs(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_construct(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_convert_this(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_create_this(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_div(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_eq(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_get_by_id(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_get_arguments_length(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_get_by_val(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_get_argument_by_val(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_get_by_pname(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_check_has_instance(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_instanceof(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_jfalse(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_jless(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_jlesseq(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_jgreater(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_jgreatereq(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_jnless(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_jnlesseq(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_jngreater(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_jngreatereq(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_jtrue(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_load_varargs(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_loop_if_less(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_loop_if_lesseq(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_loop_if_greater(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_loop_if_greatereq(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_loop_if_true(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_loop_if_false(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_lshift(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_method_check(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_mod(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_mul(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_negate(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_neq(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_new_object(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_not(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_nstricteq(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_post_dec(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_post_inc(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_pre_dec(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_pre_inc(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_put_by_id(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_put_by_val(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_resolve_global(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_resolve_global_dynamic(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_rshift(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_stricteq(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_sub(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_to_jsnumber(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_to_primitive(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_urshift(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_new_func(Instruction*, Vector<SlowCaseEntry>::iterator&);
        void emitSlow_op_new_func_exp(Instruction*, Vector<SlowCaseEntry>::iterator&);


        void emitRightShift(Instruction*, bool isUnsigned);
        void emitRightShiftSlowCase(Instruction*, Vector<SlowCaseEntry>::iterator&, bool isUnsigned);


        void emitGetJITStubArg(unsigned argumentNumber, RegisterID dst);

        void emitInitRegister(unsigned dst);

        void emitPutToCallFrameHeader(RegisterID from, RegisterFile::CallFrameHeaderEntry entry);
        void emitPutCellToCallFrameHeader(RegisterID from, RegisterFile::CallFrameHeaderEntry);
        void emitPutIntToCallFrameHeader(RegisterID from, RegisterFile::CallFrameHeaderEntry);
        void emitPutImmediateToCallFrameHeader(void* value, RegisterFile::CallFrameHeaderEntry entry);
        void emitGetFromCallFrameHeaderPtr(RegisterFile::CallFrameHeaderEntry entry, RegisterID to, RegisterID from = callFrameRegister);
        void emitGetFromCallFrameHeader32(RegisterFile::CallFrameHeaderEntry entry, RegisterID to, RegisterID from = callFrameRegister);

        JSValue getConstantOperand(unsigned src);
        bool isOperandConstantImmediateInt(unsigned src);
        bool isOperandConstantImmediateChar(unsigned src);

        bool atJumpTarget();

        Jump getSlowCase(Vector<SlowCaseEntry>::iterator& iter)
        {
            return iter++->from;
        }
        void linkSlowCase(Vector<SlowCaseEntry>::iterator& iter)
        {
            iter->from.link(this);
            ++iter;
        }
        void linkDummySlowCase(Vector<SlowCaseEntry>::iterator& iter)
        {
            ((void)0);
            ++iter;
        }
        void linkSlowCaseIfNotJSCell(Vector<SlowCaseEntry>::iterator&, int vReg);

        Jump checkStructure(RegisterID reg, Structure* structure);

        void restoreArgumentReference();
        void restoreArgumentReferenceForTrampoline();
        void updateTopCallFrame();

        Call emitNakedCall(CodePtr function = CodePtr());

        void preserveReturnAddressAfterCall(RegisterID);
        void restoreReturnAddressBeforeReturn(RegisterID);
        void restoreReturnAddressBeforeReturn(Address);


        void emitLoadCharacterString(RegisterID src, RegisterID dst, JumpList& failures);

        enum OptimizationCheckKind { LoopOptimizationCheck, RetOptimizationCheck };

        void emitOptimizationCheck(OptimizationCheckKind);




        void emitTimeoutCheck();
# 1034 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/jit/JIT.h"
        void sampleCodeBlock(CodeBlock*) {}



        bool canBeOptimized() { return m_canBeOptimized; }
        bool shouldEmitProfiling() { return m_canBeOptimized; }







        Interpreter* m_interpreter;
        JSGlobalData* m_globalData;
        CodeBlock* m_codeBlock;

        Vector<CallRecord> m_calls;
        Vector<Label> m_labels;
        Vector<PropertyStubCompilationInfo> m_propertyAccessCompilationInfo;
        Vector<StructureStubCompilationInfo> m_callStructureStubCompilationInfo;
        Vector<MethodCallCompilationInfo> m_methodCallCompilationInfo;
        Vector<JumpTable> m_jmpTable;

        unsigned m_bytecodeOffset;
        Vector<JSRInfo> m_jsrSites;
        Vector<SlowCaseEntry> m_slowCases;
        Vector<SwitchRecord> m_switches;

        unsigned m_propertyAccessInstructionIndex;
        unsigned m_globalResolveInfoIndex;
        unsigned m_callLinkInfoIndex;
# 1074 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/jit/JIT.h"
        int m_lastResultBytecodeRegister;

        unsigned m_jumpTargetsPosition;







        WeakRandom m_randomGenerator;
        static CodeRef stringGetByValStubGenerator(JSGlobalData*);


        bool m_canBeOptimized;


        Label m_startOfCode;


        CompactJITCodeMap::Encoder m_jitCodeMapEncoder;

    } __attribute__ ((aligned (32)));

    inline void JIT::emit_op_loop(Instruction* currentInstruction)
    {
        emitTimeoutCheck();
        emit_op_jmp(currentInstruction);
    }

    inline void JIT::emit_op_loop_hint(Instruction*)
    {
        emitOptimizationCheck(LoopOptimizationCheck);
    }

    inline void JIT::emit_op_loop_if_true(Instruction* currentInstruction)
    {
        emitTimeoutCheck();
        emit_op_jtrue(currentInstruction);
    }

    inline void JIT::emitSlow_op_loop_if_true(Instruction* currentInstruction, Vector<SlowCaseEntry>::iterator& iter)
    {
        emitSlow_op_jtrue(currentInstruction, iter);
    }

    inline void JIT::emit_op_loop_if_false(Instruction* currentInstruction)
    {
        emitTimeoutCheck();
        emit_op_jfalse(currentInstruction);
    }

    inline void JIT::emitSlow_op_loop_if_false(Instruction* currentInstruction, Vector<SlowCaseEntry>::iterator& iter)
    {
        emitSlow_op_jfalse(currentInstruction, iter);
    }

    inline void JIT::emit_op_loop_if_less(Instruction* currentInstruction)
    {
        emitTimeoutCheck();
        emit_op_jless(currentInstruction);
    }

    inline void JIT::emitSlow_op_loop_if_less(Instruction* currentInstruction, Vector<SlowCaseEntry>::iterator& iter)
    {
        emitSlow_op_jless(currentInstruction, iter);
    }

    inline void JIT::emit_op_loop_if_lesseq(Instruction* currentInstruction)
    {
        emitTimeoutCheck();
        emit_op_jlesseq(currentInstruction);
    }

    inline void JIT::emitSlow_op_loop_if_lesseq(Instruction* currentInstruction, Vector<SlowCaseEntry>::iterator& iter)
    {
        emitSlow_op_jlesseq(currentInstruction, iter);
    }

    inline void JIT::emit_op_loop_if_greater(Instruction* currentInstruction)
    {
        emitTimeoutCheck();
        emit_op_jgreater(currentInstruction);
    }

    inline void JIT::emitSlow_op_loop_if_greater(Instruction* currentInstruction, Vector<SlowCaseEntry>::iterator& iter)
    {
        emitSlow_op_jgreater(currentInstruction, iter);
    }

    inline void JIT::emit_op_loop_if_greatereq(Instruction* currentInstruction)
    {
        emitTimeoutCheck();
        emit_op_jgreatereq(currentInstruction);
    }

    inline void JIT::emitSlow_op_loop_if_greatereq(Instruction* currentInstruction, Vector<SlowCaseEntry>::iterator& iter)
    {
        emitSlow_op_jgreatereq(currentInstruction, iter);
    }

}
# 70 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Interpreter.cpp" 2




using namespace std;

namespace JSC {


static int depth(CodeBlock* codeBlock, ScopeChainNode* sc)
{
    if (!codeBlock->needsFullScopeChain())
        return 0;
    return sc->localDepth();
}
# 370 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Interpreter.cpp"
inline __attribute__((__always_inline__)) CallFrame* Interpreter::slideRegisterWindowForCall(CodeBlock* newCodeBlock, RegisterFile* registerFile, CallFrame* callFrame, size_t registerOffset, int argc)
{
    Register* r = callFrame->registers();
    Register* newEnd = r + registerOffset + newCodeBlock->m_numCalleeRegisters;

    if (__builtin_expect((argc == newCodeBlock->m_numParameters), 1)) {
        if (__builtin_expect((!registerFile->grow(newEnd)), 0))
            return 0;
        r += registerOffset;
    } else if (argc < newCodeBlock->m_numParameters) {
        size_t omittedArgCount = newCodeBlock->m_numParameters - argc;
        registerOffset += omittedArgCount;
        newEnd += omittedArgCount;
        if (!registerFile->grow(newEnd))
            return 0;
        r += registerOffset;

        Register* argv = r - RegisterFile::CallFrameHeaderSize - omittedArgCount;
        for (size_t i = 0; i < omittedArgCount; ++i)
            argv[i] = jsUndefined();
    } else {
        size_t numParameters = newCodeBlock->m_numParameters;
        registerOffset += numParameters;
        newEnd += numParameters;

        if (!registerFile->grow(newEnd))
            return 0;
        r += registerOffset;

        Register* argv = r - RegisterFile::CallFrameHeaderSize - numParameters - argc;
        for (size_t i = 0; i < numParameters; ++i)
            argv[i + argc] = argv[i];
    }

    return CallFrame::create(r);
}
# 425 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Interpreter.cpp"
__attribute__((__noinline__)) JSValue Interpreter::callEval(CallFrame* callFrame, RegisterFile* registerFile, Register* argv, int argc, int registerOffset)
{
    if (argc < 2)
        return jsUndefined();

    JSValue program = argv[1].jsValue();

    if (!program.isString())
        return program;

    UString programSource = asString(program)->value(callFrame);
    if (callFrame->hadException())
        return JSValue();

    CodeBlock* codeBlock = callFrame->codeBlock();

    ScopeChainNode* scopeChain = callFrame->scopeChain();
    EvalExecutable* eval = codeBlock->evalCodeCache().tryGet(codeBlock->isStrictMode(), programSource, scopeChain);

    if (!eval) {
        if (!codeBlock->isStrictMode()) {


            LiteralParser preparser(callFrame, programSource.characters(), programSource.length(), LiteralParser::NonStrictJSON);
            if (JSValue parsedObject = preparser.tryLiteralParse())
                return parsedObject;
        }

        JSValue exceptionValue;
        eval = codeBlock->evalCodeCache().getSlow(callFrame, codeBlock->ownerExecutable(), codeBlock->isStrictMode(), programSource, scopeChain, exceptionValue);

        ((void)0);
        if (__builtin_expect((!eval), 0))
            return throwError(callFrame, exceptionValue);
    }

    JSValue thisValue = callFrame->uncheckedR(codeBlock->thisRegister()).jsValue();
    ((void)0);
    return callFrame->globalData().interpreter->execute(eval, callFrame, thisValue, callFrame->registers() - registerFile->begin() + registerOffset, scopeChain);
}

Interpreter::Interpreter()
    : m_sampleEntryDepth(0)
    , m_reentryDepth(0)
{
# 480 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Interpreter.cpp"
}
# 565 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Interpreter.cpp"
bool Interpreter::isOpcode(Opcode opcode)
{





    return opcode >= 0 && opcode <= op_end;

}

__attribute__((__noinline__)) bool Interpreter::unwindCallFrame(CallFrame*& callFrame, JSValue exceptionValue, unsigned& bytecodeOffset, CodeBlock*& codeBlock)
{
    CodeBlock* oldCodeBlock = codeBlock;
    ScopeChainNode* scopeChain = callFrame->scopeChain();

    if (Debugger* debugger = callFrame->dynamicGlobalObject()->debugger()) {
        DebuggerCallFrame debuggerCallFrame(callFrame, exceptionValue);
        if (callFrame->callee())
            debugger->returnEvent(debuggerCallFrame, codeBlock->ownerExecutable()->sourceID(), codeBlock->ownerExecutable()->lastLine());
        else
            debugger->didExecuteProgram(debuggerCallFrame, codeBlock->ownerExecutable()->sourceID(), codeBlock->ownerExecutable()->lastLine());
    }


    if (oldCodeBlock->codeType() == FunctionCode && oldCodeBlock->needsFullScopeChain()) {
        if (!callFrame->uncheckedR(oldCodeBlock->activationRegister()).jsValue()) {
            oldCodeBlock->createActivation(callFrame);
            scopeChain = callFrame->scopeChain();
        }
        while (!scopeChain->object->inherits(&JSActivation::s_info))
            scopeChain = scopeChain->pop();

        callFrame->setScopeChain(scopeChain);
        JSActivation* activation = asActivation(scopeChain->object.get());
        activation->copyRegisters(*scopeChain->globalData);
        if (JSValue arguments = callFrame->uncheckedR(unmodifiedArgumentsRegister(oldCodeBlock->argumentsRegister())).jsValue()) {
            if (!oldCodeBlock->isStrictMode())
                asArguments(arguments)->setActivation(callFrame->globalData(), activation);
        }
    } else if (oldCodeBlock->usesArguments() && !oldCodeBlock->isStrictMode()) {
        if (JSValue arguments = callFrame->uncheckedR(unmodifiedArgumentsRegister(oldCodeBlock->argumentsRegister())).jsValue())
            asArguments(arguments)->copyRegisters(callFrame->globalData());
    }

    CallFrame* callerFrame = callFrame->callerFrame();
    callFrame->globalData().topCallFrame = callerFrame;
    if (callerFrame->hasHostCallFrameFlag())
        return false;

    codeBlock = callerFrame->codeBlock();
# 630 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Interpreter.cpp"
    bytecodeOffset = codeBlock->bytecodeOffset(callFrame->returnPC());




    callFrame = callerFrame;
    return true;
}

static void appendSourceToError(CallFrame* callFrame, ErrorInstance* exception, unsigned bytecodeOffset)
{
    exception->clearAppendSourceToMessage();

    if (!callFrame->codeBlock()->hasExpressionInfo())
        return;

    int startOffset = 0;
    int endOffset = 0;
    int divotPoint = 0;

    CodeBlock* codeBlock = callFrame->codeBlock();
    codeBlock->expressionRangeForBytecodeOffset(bytecodeOffset, divotPoint, startOffset, endOffset);

    int expressionStart = divotPoint - startOffset;
    int expressionStop = divotPoint + endOffset;

    if (!expressionStop || expressionStart > codeBlock->source()->length())
        return;

    JSGlobalData* globalData = &callFrame->globalData();
    JSValue jsMessage = exception->getDirect(*globalData, globalData->propertyNames->message);
    if (!jsMessage || !jsMessage.isString())
        return;

    UString message = asString(jsMessage)->value(callFrame);

    if (expressionStart < expressionStop)
        message = makeUString(message, " (evaluating '", codeBlock->source()->getRange(expressionStart, expressionStop), "')");
    else {

        const UChar* data = codeBlock->source()->data();
        int dataLength = codeBlock->source()->length();
        int start = expressionStart;
        int stop = expressionStart;


        while (start > 0 && (expressionStart - start < 20) && data[start - 1] != '\n')
            start--;
        while (start < (expressionStart - 1) && isStrWhiteSpace(data[start]))
            start++;
        while (stop < dataLength && (stop - expressionStart < 20) && data[stop] != '\n')
            stop++;
        while (stop > expressionStart && isStrWhiteSpace(data[stop - 1]))
            stop--;
        message = makeUString(message, " (near '...", codeBlock->source()->getRange(start, stop), "...')");
    }

    exception->putDirect(*globalData, globalData->propertyNames->message, jsString(globalData, message));
}

__attribute__((__noinline__)) HandlerInfo* Interpreter::throwException(CallFrame*& callFrame, JSValue& exceptionValue, unsigned bytecodeOffset)
{
    CodeBlock* codeBlock = callFrame->codeBlock();
    bool isInterrupt = false;


    if (exceptionValue.isObject()) {
        JSObject* exception = asObject(exceptionValue);

        if (exception->isErrorInstance() && static_cast<ErrorInstance*>(exception)->appendSourceToMessage())
            appendSourceToError(callFrame, static_cast<ErrorInstance*>(exception), bytecodeOffset);


        if (codeBlock->hasExpressionInfo() && !hasErrorInfo(callFrame, exception)) {
            ((void)0);



            addErrorInfo(callFrame, exception, codeBlock->lineNumberForBytecodeOffset(bytecodeOffset), codeBlock->ownerExecutable()->source());
        }

        isInterrupt = isInterruptedExecutionException(exception) || isTerminatedExecutionException(exception);
    }

    if (Debugger* debugger = callFrame->dynamicGlobalObject()->debugger()) {
        DebuggerCallFrame debuggerCallFrame(callFrame, exceptionValue);
        bool hasHandler = codeBlock->handlerForBytecodeOffset(bytecodeOffset);
        debugger->exception(debuggerCallFrame, codeBlock->ownerExecutable()->sourceID(), codeBlock->lineNumberForBytecodeOffset(bytecodeOffset), hasHandler);
    }


    HandlerInfo* handler = 0;
    while (isInterrupt || !(handler = codeBlock->handlerForBytecodeOffset(bytecodeOffset))) {
        if (!unwindCallFrame(callFrame, exceptionValue, bytecodeOffset, codeBlock)) {
            if (Profiler* profiler = *Profiler::enabledProfilerReference())
                profiler->exceptionUnwind(callFrame);
            return 0;
        }
    }

    if (Profiler* profiler = *Profiler::enabledProfilerReference())
        profiler->exceptionUnwind(callFrame);


    Register* highWaterMark = 0;
    for (CallFrame* callerFrame = callFrame; callerFrame; callerFrame = callerFrame->callerFrame()->removeHostCallFrameFlag()) {
        CodeBlock* codeBlock = callerFrame->codeBlock();
        if (!codeBlock)
            continue;
        Register* callerHighWaterMark = callerFrame->registers() + codeBlock->m_numCalleeRegisters;
        highWaterMark = max(highWaterMark, callerHighWaterMark);
    }
    m_registerFile.shrink(highWaterMark);


    ScopeChainNode* scopeChain = callFrame->scopeChain();
    int scopeDelta = 0;
    if (!codeBlock->needsFullScopeChain() || codeBlock->codeType() != FunctionCode
        || callFrame->uncheckedR(codeBlock->activationRegister()).jsValue())
        scopeDelta = depth(codeBlock, scopeChain) - handler->scopeDepth;
    ((void)0);
    while (scopeDelta--)
        scopeChain = scopeChain->pop();
    callFrame->setScopeChain(scopeChain);

    return handler;
}

static inline JSValue checkedReturn(JSValue returnValue)
{
    ((void)0);
    return returnValue;
}

static inline JSObject* checkedReturn(JSObject* returnValue)
{
    ((void)0);
    return returnValue;
}

JSValue Interpreter::execute(ProgramExecutable* program, CallFrame* callFrame, ScopeChainNode* scopeChain, JSObject* thisObj)
{
    ((void)0);
    ((void)0);
    ((void)0);
    if (callFrame->globalData().isCollectorBusy())
        return jsNull();

    if (m_reentryDepth >= MaxSmallThreadReentryDepth && m_reentryDepth >= callFrame->globalData().maxReentryDepth)
        return checkedReturn(throwStackOverflowError(callFrame));

    DynamicGlobalObjectScope globalObjectScope(*scopeChain->globalData, scopeChain->globalObject.get());
    LiteralParser literalParser(callFrame, program->source().data(), program->source().length(), LiteralParser::JSONP);
    Vector<LiteralParser::JSONPData> JSONPData;
    if (literalParser.tryJSONPParse(JSONPData, scopeChain->globalObject->supportsRichSourceInfo())) {
        JSGlobalObject* globalObject = scopeChain->globalObject.get();
        JSValue result;
        for (unsigned entry = 0; entry < JSONPData.size(); entry++) {
            Vector<LiteralParser::JSONPPathEntry> JSONPPath;
            JSONPPath.swap(JSONPData[entry].m_path);
            JSValue JSONPValue = JSONPData[entry].m_value.get();
            if (JSONPPath.size() == 1 && JSONPPath[0].m_type == LiteralParser::JSONPPathEntryTypeDeclare) {
                if (globalObject->hasProperty(callFrame, JSONPPath[0].m_pathEntryName)) {
                    PutPropertySlot slot;
                    globalObject->methodTable()->put(globalObject, callFrame, JSONPPath[0].m_pathEntryName, JSONPValue, slot);
                } else
                    globalObject->putWithAttributes(callFrame, JSONPPath[0].m_pathEntryName, JSONPValue, DontEnum | DontDelete);

                result = jsUndefined();
                continue;
            }
            JSValue baseObject(globalObject);
            for (unsigned i = 0; i < JSONPPath.size() - 1; i++) {
                ((void)0);
                switch (JSONPPath[i].m_type) {
                case LiteralParser::JSONPPathEntryTypeDot: {
                    if (i == 0) {
                        PropertySlot slot(globalObject);
                        if (!globalObject->getPropertySlot(callFrame, JSONPPath[i].m_pathEntryName, slot)) {
                            if (entry)
                                return throwError(callFrame, createUndefinedVariableError(globalObject->globalExec(), JSONPPath[i].m_pathEntryName));
                            goto failedJSONP;
                        }
                        baseObject = slot.getValue(callFrame, JSONPPath[i].m_pathEntryName);
                    } else
                        baseObject = baseObject.get(callFrame, JSONPPath[i].m_pathEntryName);
                    if (callFrame->hadException())
                        return jsUndefined();
                    continue;
                }
                case LiteralParser::JSONPPathEntryTypeLookup: {
                    baseObject = baseObject.get(callFrame, JSONPPath[i].m_pathIndex);
                    if (callFrame->hadException())
                        return jsUndefined();
                    continue;
                }
                default:
                    ((void)0);
                    return jsUndefined();
                }
            }
            PutPropertySlot slot;
            switch (JSONPPath.last().m_type) {
            case LiteralParser::JSONPPathEntryTypeCall: {
                JSValue function = baseObject.get(callFrame, JSONPPath.last().m_pathEntryName);
                if (callFrame->hadException())
                    return jsUndefined();
                CallData callData;
                CallType callType = getCallData(function, callData);
                if (callType == CallTypeNone)
                    return throwError(callFrame, createNotAFunctionError(callFrame, function));
                MarkedArgumentBuffer jsonArg;
                jsonArg.append(JSONPValue);
                JSValue thisValue = JSONPPath.size() == 1 ? jsUndefined(): baseObject;
                JSONPValue = JSC::call(callFrame, function, callType, callData, thisValue, jsonArg);
                if (callFrame->hadException())
                    return jsUndefined();
                break;
            }
            case LiteralParser::JSONPPathEntryTypeDot: {
                baseObject.put(callFrame, JSONPPath.last().m_pathEntryName, JSONPValue, slot);
                if (callFrame->hadException())
                    return jsUndefined();
                break;
            }
            case LiteralParser::JSONPPathEntryTypeLookup: {
                baseObject.put(callFrame, JSONPPath.last().m_pathIndex, JSONPValue);
                if (callFrame->hadException())
                    return jsUndefined();
                break;
            }
            default:
                ((void)0);
                    return jsUndefined();
            }
            result = JSONPValue;
        }
        return result;
    }
failedJSONP:
    JSObject* error = program->compile(callFrame, scopeChain);
    if (error)
        return checkedReturn(throwError(callFrame, error));
    CodeBlock* codeBlock = &program->generatedBytecode();

    Register* oldEnd = m_registerFile.end();
    Register* newEnd = oldEnd + codeBlock->m_numParameters + RegisterFile::CallFrameHeaderSize + codeBlock->m_numCalleeRegisters;
    if (!m_registerFile.grow(newEnd))
        return checkedReturn(throwStackOverflowError(callFrame));

    CallFrame* newCallFrame = CallFrame::create(oldEnd + codeBlock->m_numParameters + RegisterFile::CallFrameHeaderSize);
    ((void)0);
    newCallFrame->init(codeBlock, 0, scopeChain, CallFrame::noCaller(), codeBlock->m_numParameters, 0);
    newCallFrame->uncheckedR(newCallFrame->hostThisRegister()) = JSValue(thisObj);
    TopCallFrameSetter topCallFrame(callFrame->globalData(), newCallFrame);

    Profiler** profiler = Profiler::enabledProfilerReference();
    if (*profiler)
        (*profiler)->willExecute(callFrame, program->sourceURL(), program->lineNo());

    JSValue result;
    {
        SamplingTool::CallRecord callRecord(m_sampler.get());

        m_reentryDepth++;

        if (callFrame->globalData().canUseJIT())
            result = program->generatedJITCode().execute(&m_registerFile, newCallFrame, scopeChain->globalData);
        else

            result = privateExecute(Normal, &m_registerFile, newCallFrame);

        m_reentryDepth--;
    }

    if (*profiler)
        (*profiler)->didExecute(callFrame, program->sourceURL(), program->lineNo());

    m_registerFile.shrink(oldEnd);

    return checkedReturn(result);
}

JSValue Interpreter::executeCall(CallFrame* callFrame, JSObject* function, CallType callType, const CallData& callData, JSValue thisValue, const ArgList& args)
{
    ((void)0);
    ((void)0);
    ((void)0);
    if (callFrame->globalData().isCollectorBusy())
        return jsNull();

    if (m_reentryDepth >= MaxSmallThreadReentryDepth && m_reentryDepth >= callFrame->globalData().maxReentryDepth)
        return checkedReturn(throwStackOverflowError(callFrame));

    Register* oldEnd = m_registerFile.end();
    int argCount = 1 + args.size();
    size_t registerOffset = argCount + RegisterFile::CallFrameHeaderSize;

    if (!m_registerFile.grow(oldEnd + registerOffset))
        return checkedReturn(throwStackOverflowError(callFrame));

    CallFrame* newCallFrame = CallFrame::create(oldEnd);
    size_t dst = 0;
    newCallFrame->uncheckedR(0) = thisValue;
    ArgList::const_iterator end = args.end();
    for (ArgList::const_iterator it = args.begin(); it != end; ++it)
        newCallFrame->uncheckedR(++dst) = *it;

    if (callType == CallTypeJS) {
        ScopeChainNode* callDataScopeChain = callData.js.scopeChain;

        DynamicGlobalObjectScope globalObjectScope(*callDataScopeChain->globalData, callDataScopeChain->globalObject.get());

        JSObject* compileError = callData.js.functionExecutable->compileForCall(callFrame, callDataScopeChain);
        if (__builtin_expect((!!compileError), 0)) {
            m_registerFile.shrink(oldEnd);
            return checkedReturn(throwError(callFrame, compileError));
        }

        CodeBlock* newCodeBlock = &callData.js.functionExecutable->generatedBytecodeForCall();
        newCallFrame = slideRegisterWindowForCall(newCodeBlock, &m_registerFile, newCallFrame, registerOffset, argCount);
        if (__builtin_expect((!newCallFrame), 0)) {
            m_registerFile.shrink(oldEnd);
            return checkedReturn(throwStackOverflowError(callFrame));
        }

        newCallFrame->init(newCodeBlock, 0, callDataScopeChain, callFrame->addHostCallFrameFlag(), argCount, function);

        TopCallFrameSetter topCallFrame(callFrame->globalData(), newCallFrame);

        Profiler** profiler = Profiler::enabledProfilerReference();
        if (*profiler)
            (*profiler)->willExecute(callFrame, function);

        JSValue result;
        {
            SamplingTool::CallRecord callRecord(m_sampler.get());

            m_reentryDepth++;

            if (callFrame->globalData().canUseJIT())
                result = callData.js.functionExecutable->generatedJITCodeForCall().execute(&m_registerFile, newCallFrame, callDataScopeChain->globalData);
            else

                result = privateExecute(Normal, &m_registerFile, newCallFrame);
            m_reentryDepth--;
        }

        if (*profiler)
            (*profiler)->didExecute(callFrame, function);

        m_registerFile.shrink(oldEnd);
        return checkedReturn(result);
    }

    ((void)0);
    ScopeChainNode* scopeChain = callFrame->scopeChain();
    newCallFrame = CallFrame::create(newCallFrame->registers() + registerOffset);
    newCallFrame->init(0, 0, scopeChain, callFrame->addHostCallFrameFlag(), argCount, function);

    TopCallFrameSetter topCallFrame(callFrame->globalData(), newCallFrame);

    DynamicGlobalObjectScope globalObjectScope(*scopeChain->globalData, scopeChain->globalObject.get());

    Profiler** profiler = Profiler::enabledProfilerReference();
    if (*profiler)
        (*profiler)->willExecute(callFrame, function);

    JSValue result;
    {
        SamplingTool::HostCallRecord callRecord(m_sampler.get());
        result = JSValue::decode(callData.native.function(newCallFrame));
    }

    if (*profiler)
        (*profiler)->didExecute(callFrame, function);

    m_registerFile.shrink(oldEnd);
    return checkedReturn(result);
}

JSObject* Interpreter::executeConstruct(CallFrame* callFrame, JSObject* constructor, ConstructType constructType, const ConstructData& constructData, const ArgList& args)
{
    ((void)0);
    ((void)0);


    if (callFrame->globalData().isCollectorBusy())
        return checkedReturn(throwStackOverflowError(callFrame));

    if (m_reentryDepth >= MaxSmallThreadReentryDepth && m_reentryDepth >= callFrame->globalData().maxReentryDepth)
        return checkedReturn(throwStackOverflowError(callFrame));

    Register* oldEnd = m_registerFile.end();
    int argCount = 1 + args.size();
    size_t registerOffset = argCount + RegisterFile::CallFrameHeaderSize;

    if (!m_registerFile.grow(oldEnd + registerOffset))
        return checkedReturn(throwStackOverflowError(callFrame));

    CallFrame* newCallFrame = CallFrame::create(oldEnd);
    size_t dst = 0;
    ArgList::const_iterator end = args.end();
    for (ArgList::const_iterator it = args.begin(); it != end; ++it)
        newCallFrame->uncheckedR(++dst) = *it;

    if (constructType == ConstructTypeJS) {
        ScopeChainNode* constructDataScopeChain = constructData.js.scopeChain;

        DynamicGlobalObjectScope globalObjectScope(*constructDataScopeChain->globalData, constructDataScopeChain->globalObject.get());

        JSObject* compileError = constructData.js.functionExecutable->compileForConstruct(callFrame, constructDataScopeChain);
        if (__builtin_expect((!!compileError), 0)) {
            m_registerFile.shrink(oldEnd);
            return checkedReturn(throwError(callFrame, compileError));
        }

        CodeBlock* newCodeBlock = &constructData.js.functionExecutable->generatedBytecodeForConstruct();
        newCallFrame = slideRegisterWindowForCall(newCodeBlock, &m_registerFile, newCallFrame, registerOffset, argCount);
        if (__builtin_expect((!newCallFrame), 0)) {
            m_registerFile.shrink(oldEnd);
            return checkedReturn(throwStackOverflowError(callFrame));
        }

        newCallFrame->init(newCodeBlock, 0, constructDataScopeChain, callFrame->addHostCallFrameFlag(), argCount, constructor);

        TopCallFrameSetter topCallFrame(callFrame->globalData(), newCallFrame);

        Profiler** profiler = Profiler::enabledProfilerReference();
        if (*profiler)
            (*profiler)->willExecute(callFrame, constructor);

        JSValue result;
        {
            SamplingTool::CallRecord callRecord(m_sampler.get());

            m_reentryDepth++;

            if (callFrame->globalData().canUseJIT())
                result = constructData.js.functionExecutable->generatedJITCodeForConstruct().execute(&m_registerFile, newCallFrame, constructDataScopeChain->globalData);
            else

                result = privateExecute(Normal, &m_registerFile, newCallFrame);
            m_reentryDepth--;
        }

        if (*profiler)
            (*profiler)->didExecute(callFrame, constructor);

        m_registerFile.shrink(oldEnd);
        if (callFrame->hadException())
            return 0;
        ((void)0);
        return checkedReturn(asObject(result));
    }

    ((void)0);
    ScopeChainNode* scopeChain = callFrame->scopeChain();
    newCallFrame = CallFrame::create(newCallFrame->registers() + registerOffset);
    newCallFrame->init(0, 0, scopeChain, callFrame->addHostCallFrameFlag(), argCount, constructor);

    TopCallFrameSetter topCallFrame(callFrame->globalData(), newCallFrame);

    DynamicGlobalObjectScope globalObjectScope(*scopeChain->globalData, scopeChain->globalObject.get());

    Profiler** profiler = Profiler::enabledProfilerReference();
    if (*profiler)
        (*profiler)->willExecute(callFrame, constructor);

    JSValue result;
    {
        SamplingTool::HostCallRecord callRecord(m_sampler.get());
        result = JSValue::decode(constructData.native.function(newCallFrame));
    }

    if (*profiler)
        (*profiler)->didExecute(callFrame, constructor);

    m_registerFile.shrink(oldEnd);
    if (callFrame->hadException())
        return 0;
    ((void)0);
    return checkedReturn(asObject(result));
}

CallFrameClosure Interpreter::prepareForRepeatCall(FunctionExecutable* FunctionExecutable, CallFrame* callFrame, JSFunction* function, int argCount, ScopeChainNode* scopeChain)
{
    ((void)0);

    if (m_reentryDepth >= MaxSmallThreadReentryDepth) {
        if (m_reentryDepth >= callFrame->globalData().maxReentryDepth) {
            throwStackOverflowError(callFrame);
            return CallFrameClosure();
        }
    }

    Register* oldEnd = m_registerFile.end();
    int argc = 1 + argCount;

    if (!m_registerFile.grow(oldEnd + argc)) {
        throwStackOverflowError(callFrame);
        return CallFrameClosure();
    }

    CallFrame* newCallFrame = CallFrame::create(oldEnd);

    size_t dst = 0;
    for (int i = 0; i < argc; ++i)
        newCallFrame->uncheckedR(dst++) = jsUndefined();

    JSObject* error = FunctionExecutable->compileForCall(callFrame, scopeChain);
    if (error) {
        throwError(callFrame, error);
        m_registerFile.shrink(oldEnd);
        return CallFrameClosure();
    }
    CodeBlock* codeBlock = &FunctionExecutable->generatedBytecodeForCall();

    newCallFrame = slideRegisterWindowForCall(codeBlock, &m_registerFile, newCallFrame, argc + RegisterFile::CallFrameHeaderSize, argc);
    if (__builtin_expect((!newCallFrame), 0)) {
        throwStackOverflowError(callFrame);
        m_registerFile.shrink(oldEnd);
        return CallFrameClosure();
    }
    newCallFrame->init(codeBlock, 0, scopeChain, callFrame->addHostCallFrameFlag(), argc, function);
    scopeChain->globalData->topCallFrame = newCallFrame;
    CallFrameClosure result = { callFrame, newCallFrame, function, FunctionExecutable, scopeChain->globalData, oldEnd, scopeChain, codeBlock->m_numParameters, argc };
    return result;
}

JSValue Interpreter::execute(CallFrameClosure& closure)
{
    ((void)0);
    if (closure.oldCallFrame->globalData().isCollectorBusy())
        return jsNull();
    closure.resetCallFrame();
    Profiler** profiler = Profiler::enabledProfilerReference();
    if (*profiler)
        (*profiler)->willExecute(closure.oldCallFrame, closure.function);

    TopCallFrameSetter topCallFrame(*closure.globalData, closure.newCallFrame);

    JSValue result;
    {
        SamplingTool::CallRecord callRecord(m_sampler.get());

        m_reentryDepth++;




            result = closure.functionExecutable->generatedJITCodeForCall().execute(&m_registerFile, closure.newCallFrame, closure.globalData);







        m_reentryDepth--;
    }

    if (*profiler)
        (*profiler)->didExecute(closure.oldCallFrame, closure.function);
    return checkedReturn(result);
}

void Interpreter::endRepeatCall(CallFrameClosure& closure)
{
    closure.globalData->topCallFrame = closure.oldCallFrame;
    m_registerFile.shrink(closure.oldEnd);
}

JSValue Interpreter::execute(EvalExecutable* eval, CallFrame* callFrame, JSValue thisValue, ScopeChainNode* scopeChain)
{
    JSObject* compileError = eval->compile(callFrame, scopeChain);
    if (__builtin_expect((!!compileError), 0))
        return checkedReturn(throwError(callFrame, compileError));
    return execute(eval, callFrame, thisValue, m_registerFile.size() + eval->generatedBytecode().m_numParameters + RegisterFile::CallFrameHeaderSize, scopeChain);
}

JSValue Interpreter::execute(EvalExecutable* eval, CallFrame* callFrame, JSValue thisValue, int globalRegisterOffset, ScopeChainNode* scopeChain)
{
    ((void)0);
    ((void)0);
    ((void)0);
    if (callFrame->globalData().isCollectorBusy())
        return jsNull();

    DynamicGlobalObjectScope globalObjectScope(*scopeChain->globalData, scopeChain->globalObject.get());

    if (m_reentryDepth >= MaxSmallThreadReentryDepth && m_reentryDepth >= callFrame->globalData().maxReentryDepth)
        return checkedReturn(throwStackOverflowError(callFrame));

    JSObject* compileError = eval->compile(callFrame, scopeChain);
    if (__builtin_expect((!!compileError), 0))
        return checkedReturn(throwError(callFrame, compileError));
    EvalCodeBlock* codeBlock = &eval->generatedBytecode();

    JSObject* variableObject;
    for (ScopeChainNode* node = scopeChain; ; node = node->next.get()) {
        ((void)0);
        if (node->object->isVariableObject()) {
            variableObject = static_cast<JSVariableObject*>(node->object.get());
            break;
        }
    }

    unsigned numVariables = codeBlock->numVariables();
    int numFunctions = codeBlock->numberOfFunctionDecls();
    bool pushedScope = false;
    if (numVariables || numFunctions) {
        if (codeBlock->isStrictMode()) {
            variableObject = StrictEvalActivation::create(callFrame);
            scopeChain = scopeChain->push(variableObject);
            pushedScope = true;
        }

        BatchedTransitionOptimizer optimizer(callFrame->globalData(), variableObject);

        for (unsigned i = 0; i < numVariables; ++i) {
            const Identifier& ident = codeBlock->variable(i);
            if (!variableObject->hasProperty(callFrame, ident)) {
                PutPropertySlot slot;
                variableObject->methodTable()->put(variableObject, callFrame, ident, jsUndefined(), slot);
            }
        }

        for (int i = 0; i < numFunctions; ++i) {
            FunctionExecutable* function = codeBlock->functionDecl(i);
            PutPropertySlot slot;
            variableObject->methodTable()->put(variableObject, callFrame, function->name(), function->make(callFrame, scopeChain), slot);
        }
    }

    Register* oldEnd = m_registerFile.end();
    Register* newEnd = m_registerFile.begin() + globalRegisterOffset + codeBlock->m_numCalleeRegisters;
    if (!m_registerFile.grow(newEnd)) {
        if (pushedScope)
            scopeChain->pop();
        return checkedReturn(throwStackOverflowError(callFrame));
    }

    CallFrame* newCallFrame = CallFrame::create(m_registerFile.begin() + globalRegisterOffset);

    ((void)0);
    newCallFrame->init(codeBlock, 0, scopeChain, callFrame->addHostCallFrameFlag(), codeBlock->m_numParameters, 0);
    newCallFrame->uncheckedR(newCallFrame->hostThisRegister()) = thisValue;

    TopCallFrameSetter topCallFrame(callFrame->globalData(), newCallFrame);

    Profiler** profiler = Profiler::enabledProfilerReference();
    if (*profiler)
        (*profiler)->willExecute(callFrame, eval->sourceURL(), eval->lineNo());

    JSValue result;
    {
        SamplingTool::CallRecord callRecord(m_sampler.get());

        m_reentryDepth++;





            result = eval->generatedJITCode().execute(&m_registerFile, newCallFrame, scopeChain->globalData);







        m_reentryDepth--;
    }

    if (*profiler)
        (*profiler)->didExecute(callFrame, eval->sourceURL(), eval->lineNo());

    m_registerFile.shrink(oldEnd);
    if (pushedScope)
        scopeChain->pop();
    return checkedReturn(result);
}

__attribute__((__noinline__)) void Interpreter::debug(CallFrame* callFrame, DebugHookID debugHookID, int firstLine, int lastLine)
{
    Debugger* debugger = callFrame->dynamicGlobalObject()->debugger();
    if (!debugger)
        return;

    switch (debugHookID) {
        case DidEnterCallFrame:
            debugger->callEvent(callFrame, callFrame->codeBlock()->ownerExecutable()->sourceID(), firstLine);
            return;
        case WillLeaveCallFrame:
            debugger->returnEvent(callFrame, callFrame->codeBlock()->ownerExecutable()->sourceID(), lastLine);
            return;
        case WillExecuteStatement:
            debugger->atStatement(callFrame, callFrame->codeBlock()->ownerExecutable()->sourceID(), firstLine);
            return;
        case WillExecuteProgram:
            debugger->willExecuteProgram(callFrame, callFrame->codeBlock()->ownerExecutable()->sourceID(), firstLine);
            return;
        case DidExecuteProgram:
            debugger->didExecuteProgram(callFrame, callFrame->codeBlock()->ownerExecutable()->sourceID(), lastLine);
            return;
        case DidReachBreakpoint:
            debugger->didReachBreakpoint(callFrame, callFrame->codeBlock()->ownerExecutable()->sourceID(), lastLine);
            return;
    }
}
# 1578 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Interpreter.cpp"
JSValue Interpreter::privateExecute(ExecutionFlag flag, RegisterFile* registerFile, CallFrame* callFrame)
{


    if (__builtin_expect((flag == InitializeAndReturn), 0)) {







        return JSValue();
    }






        ((void)0);



    (void)registerFile;
    (void)callFrame;
    return JSValue();
# 5120 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Interpreter.cpp"
}

JSValue Interpreter::retrieveArguments(CallFrame* callFrame, JSFunction* function) const
{
    CallFrame* functionCallFrame = findFunctionCallFrame(callFrame, function);
    if (!functionCallFrame)
        return jsNull();

    CodeBlock* codeBlock = functionCallFrame->codeBlock();
    if (codeBlock->usesArguments()) {
        ((void)0);
        int argumentsRegister = codeBlock->argumentsRegister();
        int realArgumentsRegister = unmodifiedArgumentsRegister(argumentsRegister);
        if (JSValue arguments = functionCallFrame->uncheckedR(argumentsRegister).jsValue())
            return arguments;
        JSValue arguments = JSValue(Arguments::create(callFrame->globalData(), functionCallFrame));
        functionCallFrame->r(argumentsRegister) = arguments;
        functionCallFrame->r(realArgumentsRegister) = arguments;
        return arguments;
    }

    return Arguments::createAndCopyRegisters(functionCallFrame->globalData(), functionCallFrame);
}

JSValue Interpreter::retrieveCaller(CallFrame* callFrame, JSFunction* function) const
{
    CallFrame* functionCallFrame = findFunctionCallFrame(callFrame, function);
    if (!functionCallFrame)
        return jsNull();

    CallFrame* callerFrame = functionCallFrame->callerFrame();
    if (callerFrame->hasHostCallFrameFlag())
        return jsNull();

    JSValue caller = callerFrame->callee();
    if (!caller)
        return jsNull();

    return caller;
}

void Interpreter::retrieveLastCaller(CallFrame* callFrame, int& lineNumber, intptr_t& sourceID, UString& sourceURL, JSValue& function) const
{
    function = JSValue();
    lineNumber = -1;
    sourceURL = UString();

    CallFrame* callerFrame = callFrame->callerFrame();
    if (callerFrame->hasHostCallFrameFlag())
        return;

    CodeBlock* callerCodeBlock = callerFrame->codeBlock();
    if (!callerCodeBlock)
        return;
    unsigned bytecodeOffset = 0;
# 5183 "/Users/ddunbar/rt/10614661/SANDBOX/Sources/JavaScriptCore/JavaScriptCore/interpreter/Interpreter.cpp"
    bytecodeOffset = callerCodeBlock->bytecodeOffset(callFrame->returnPC());

    lineNumber = callerCodeBlock->lineNumberForBytecodeOffset(bytecodeOffset - 1);
    sourceID = callerCodeBlock->ownerExecutable()->sourceID();
    sourceURL = callerCodeBlock->ownerExecutable()->sourceURL();
    function = callerFrame->callee();
}

CallFrame* Interpreter::findFunctionCallFrame(CallFrame* callFrame, JSFunction* function)
{
    for (CallFrame* candidate = callFrame; candidate; candidate = candidate->trueCallerFrame()) {
        if (candidate->callee() == function)
            return candidate;
    }
    return 0;
}

void Interpreter::enableSampler()
{






}
void Interpreter::dumpSampleData(ExecState* exec)
{




    (void)exec;

}
void Interpreter::startSampling()
{






}
void Interpreter::stopSampling()
{





}

}
