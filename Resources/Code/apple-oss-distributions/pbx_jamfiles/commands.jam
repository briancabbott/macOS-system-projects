# Copyright (c) 1999-2003 Apple Computer, Inc.
# All rights reserved.

# !!!cmolick:20000821 hardcoded tool paths because variables not set yet
# !!!:rballard:20061219 I'm not sure which variables the above comment refers to; $(SYSTEM_DEVELOPER_DIR) et al seem to work fine
APPLE_INTERNAL_TOOLS default = /AppleInternal/Developer/Tools ;
SYSTEM_DEVELOPER_TOOLS default = "$(SYSTEM_DEVELOPER_DIR)/Tools" ;
# Variables for invoking commands using explict paths
# except where built in shell functions should be used
ASM		    default = "$(DEVELOPER_BIN_DIR)/as" ;
BRIDGET     default = "$(DEVELOPER_BIN_DIR)/bridget" ;
# CC defined in BeginProduct rule based on value of GCC_VERSION and other settings
CD		default = cd ;
CHMOD		default = /bin/chmod ;
CHOWN		default = /usr/sbin/chown ;
CP		default = /bin/cp ;
DITTO		default = /usr/bin/ditto ;
ECHO            default = echo ;
EGREP		default = /usr/bin/egrep ;
FASTCP		default = /usr/lib/fastcp ;
FIXPRECOMPS	default = /usr/bin/fixPrecomps ;
FIND		default = /usr/bin/find ;
GATHERHEADERDOC default = "$(DEVELOPER_BIN_DIR)/gatherHeaderDoc" ;
HEADERDOC2HTML	default = "$(DEVELOPER_BIN_DIR)/headerdoc2html" ;
INTERFACER	default = $(APPLE_INTERNAL_TOOLS)/Interfacer ;
JAR		default = /usr/bin/jar ;
export JAVA_COMPILER	default = /usr/bin/javac ;
export JAVACONFIG	default = "$(DEVELOPER_BIN_DIR)/javaconfig" ;
# LD defined in BeginProduct rule based value of GCC_VERSION and other settings
LEX		    default = "$(DEVELOPER_BIN_DIR)/lex" ;
LIBTOOL		default = "$(DEVELOPER_BIN_DIR)/libtool" ;
LN		default = /bin/ln ;
LNRESOLVE   default = "$(SYSTEM_DEVELOPER_TOOLS)/lnresolve" ;
MAKEPSEUDOLIB	default = $(APPLE_INTERNAL_TOOLS)/MakePseudoLibrary ;
MERGEINFO	default = /usr/lib/mergeInfo ;
MKDIR		default = /bin/mkdir ;
MIG		    default = "$(DEVELOPER_BIN_DIR)/mig" ;
MV		default = /bin/mv ;
NMEDIT		default = "$(DEVELOPER_BIN_DIR)/nmedit" ;
OSAC		default = /usr/bin/osacompile ;
OSAL		default = /usr/bin/osalang ;
OSAS		default = /usr/bin/osascript ;
PBXCP		default = "$(SYSTEM_DEVELOPER_DIR)/Library/PrivateFrameworks/DevToolsCore.framework/Resources/pbxcp" ;
RANLIB		default = "$(DEVELOPER_BIN_DIR)/ranlib" ;
REGGEN		default = reggen ;
RESMERGER	default = "$(SYSTEM_DEVELOPER_TOOLS)/ResMerger" ;
RESOURCE_PRESERVING_CP default = "$(SYSTEM_DEVELOPER_TOOLS)/CpMac" ;
REZ		default = "$(SYSTEM_DEVELOPER_TOOLS)/Rez" ;
RM		default = /bin/rm ;
RPCGEN		default = "$(DEVELOPER_BIN_DIR)/rpcgen" ;
SED		default = /usr/bin/sed ;
SETFILE		default = "$(SYSTEM_DEVELOPER_TOOLS)/SetFile" ;
SH		default = /bin/sh ;
STRIP		default = "$(DEVELOPER_BIN_DIR)/strip" ;
TOUCH		default = /usr/bin/touch ;
UNZIP		default = /usr/bin/unzip ;
XARGS		default = /usr/bin/xargs ;
YACC		default = "$(DEVELOPER_BIN_DIR)/yacc" ;
ZIP		default = /usr/bin/zip ;

# Basic operations:

# Rm <files>
# Removes <files> from the filesystem.  Note that the actions are only
# executed once, no matter how many times the rule is invoked.
actions together piecemeal Rm
{
    $(RM) -r $(1:Q)
}

# Mkdir <directory>
# Creates <directory>
rule Mkdir
{
    # Only existence of the directory matters
    NOUPDATE $(1) ;
}
actions together piecemeal Mkdir
{
    $(MKDIR) -p $(1:Q)
}

# MkEmptyDir <directory>
# Makes a directory if necessary, and insures it is empty
actions together MkEmptyDir
{
    ( $(MKDIR) -p $(1:Q) && $(CD) $(1:Q) && $(RM) -rf "*" )
}

# ForceMkdir <directory>
# Unconditionally creates <directory>, and bumps it's timestamp
actions together piecemeal ForceMkdir
{
    $(MKDIR) -p $(1:Q)
    $(TOUCH) $(1:Q)
}

# SymLink <link> : <to>
# Makes a symbolic link to the path indicated.
# Link target is treated as a nonfile to preserve the value
rule SymLink
{
    if ! $(2) in $(PRODUCT_FILES) && $(2) != $(PRODUCT_CLASS_FILE_DIR) {
        NOTFILE $(2) ;
    }
}
actions SymLink
{
    $(LN) -sf $(2:Q) $(1:Q)
}

# Touch <files>
# Touches files in the filesystem.
actions Touch
{
    $(TOUCH) $(1:Q)
}

# TouchConditionally <fileToTouch> : <fileToCompareAgainst>
# Touches a file in the filesystem if <fileToCompareAgainst> is newer.
rule TouchConditionally
{
	DEPENDS $(1) : $(2) ;
}
actions TouchConditionally
{
    $(TOUCH) $(1:G=:Q)
}

# Echo <file> : <text>
# Echoes text into a file.
rule Echo
{
    local FILE ;
    NOTFILE $(2) ;
    Echo.remove $(1) ;
    for FILE in $(2) {
        Echo.append $(1) : $(FILE) ;
    }
}
actions together piecemeal quietly Echo.remove
{
    $(RM) -rf $(1:Q)
}
actions quietly Echo.append
{
    $(ECHO) $(2:Q) >> $(1:Q)
}

# ChangeOwnerAndGroup and ChangeMode to use when installing files
# All these use the -H option to avoid traversing bad symbolic links
rule ChangeOwnerAndGroup
{
    if $(INSTALL_OWNER) {
        if $(INSTALL_GROUP) {
            ChangeOwnerAndGroup.Action $(1) ;
        }
        else {
            ChangeOwner.Action $(1) ;
        }
    }
}
actions ChangeOwnerAndGroup.Action
{
    if [ -e $(1:Q) ]
      then $(CHOWN) -RH $(INSTALL_OWNER):$(INSTALL_GROUP) $(1:Q)
    fi
}
actions ChangeOwner.Action
{
    if [ -e $(1:Q) ]
      then $(CHOWN) -RH $(INSTALL_OWNER) $(1:Q)
    fi
}
actions ChangeMode
{
    if [ -e $(1:Q) ]
      then $(CHMOD) -RH $(INSTALL_MODE_FLAG) $(1:Q)
    fi
}

# Strip <target>
# Runs strip to remove debugging symbols from the executable of the target
actions Strip
{
    $(STRIP) $(STRIPFLAGS:Q) $(1:Q)
}

# SetFile <fork file>
# Appends type and creator to a file
rule SetFile
{
    local MACOS_TYPE_ARG ;
    local MACOS_CREATOR_ARG ;
    if $(MACOS_TYPE) {
        MACOS_TYPE_ARG = -t '$(MACOS_TYPE)' ;
    }
    if $(MACOS_CREATOR) {
        MACOS_CREATOR_ARG = -c '$(MACOS_CREATOR)' ;
    }
    SETFILEFLAGS on $(1) = $(MACOS_TYPE_ARG) $(MACOS_CREATOR_ARG) ;
}
actions SetFile
{
    $(SETFILE) $(SETFILEFLAGS:Q) "$(OTHER_SETFILEFLAGS)" $(1:Q)
}

# Rez <fork file> : <target file>
# Appends resource fork data to a file
rule Rez
{
    local MACOS_TYPE_ARG ;
    local MACOS_CREATOR_ARG ;
    DEPENDS $(1) : $(2) ;
    if $(MACOS_TYPE) {
        MACOS_TYPE_ARG = -t '$(MACOS_TYPE)' ;
    }
    if $(MACOS_CREATOR) {
        MACOS_CREATOR_ARG = -c '$(MACOS_CREATOR)' ;
    }
    REZFLAGS on $(1) = -append $(ARCH_FLAGS) -d SystemSevenOrLater=1 $(MACOS_TYPE_ARG) $(MACOS_CREATOR_ARG) "$(OTHER_REZFLAGS)" ;
    if ! $(REZ_EXECUTABLE) = "YES" {
        # by default use data forks
        REZFLAGS on $(1) += -useDF ;
    }
}
actions Rez
{
    $(REZ) $(2:Q) $(REZFLAGS) -o $(1:Q)
}

# ResMerge <fork file> : <rsrc file>
# Merges the resources from binary resource file 'rsrc file' into 'fork file'
# CAUTION: OTHER_RESMERGERFLAGS (with R) are used for RESMERGEFLAGS (no R)
rule ResMerge
{
    local MACOS_TYPE_ARG ;
    local MACOS_CREATOR_ARG ;
    DEPENDS $(1) : $(2) ;
    if $(MACOS_TYPE) {
        MACOS_TYPE_ARG = -fileType '$(MACOS_TYPE)' ;
    }
    if $(MACOS_CREATOR) {
        MACOS_CREATOR_ARG = -fileCreator '$(MACOS_CREATOR)' ;
    }
    RESMERGEFLAGS on $(1) = -append $(MACOS_TYPE_ARG) $(MACOS_CREATOR_ARG) "$(OTHER_RESMERGERFLAGS)" ;
    if ! $(REZ_EXECUTABLE) = "YES" {
        # by default use data forks
        RESMERGEFLAGS on $(1) += -dstIs DF ;
    }
}
actions ResMerge
{
    $(RESMERGER) $(2:Q) $(RESMERGEFLAGS) -o $(1:Q)
}

# RezCollector and ResMergerCollector either compile
# resource manager resources together, or split compiles
# by file with the first compile being treated differently.
# This code assumes collectors will be declared product files
# only after the first Collector rule evaluation.
rule RezCollector
{
    DEPENDS $(1) : $(2) ;
    REZFLAGS on $(1) = $(ARCH_FLAGS) -d SystemSevenOrLater=1 -useDF ;
    REZPATHFLAGS on $(1) = ;
    for _REZ_PATH in $(REZ_SEARCH_PATHS) {
        REZPATHFLAGS on $(1) += -i $(_REZ_PATH) ;
    }
    if $(REZ_TOGETHER) = YES {
        RezCollector.together $(1) : $(2) ;
    }
    else {
        if ! $(1) in $(PRODUCT_FILES) {
            RezCollector.initial $(1) : $(2) ;
        }
        else {
            RezCollector.append $(1) : $(2) ;
        }
    }
}
actions together piecemeal RezCollector.together
{
    if [ -f $(1:Q) ]; then
        _appendoption=-append
    fi
    $(REZ) -o $(1:Q) $_appendoption $(REZFLAGS:Q) "$(OTHER_REZFLAGS)" $(REZPATHFLAGS:Q) $(2:Q)
}
actions RezCollector.initial
{
    $(RM) -f $(1:Q) && \
    $(REZ) -o $(1:Q) $(REZFLAGS:Q) "$(OTHER_REZFLAGS)" $(REZPATHFLAGS:Q) $(2:Q)
}
actions RezCollector.append
{
    $(REZ) -o $(1:Q) -append $(REZFLAGS:Q) "$(OTHER_REZFLAGS)" $(REZPATHFLAGS:Q) $(2:Q)
}

rule ResMergerCollector
{
    DEPENDS $(1) : $(2) ;
    RESMERGEFLAGS on $(1) = -dstIs DF ;
    if $(REZ_TOGETHER) = YES {
        ResMergerCollector.together $(1) : $(2) ;
    }
    else {
        if ! $(1) in $(PRODUCT_FILES) {
            ResMergerCollector.initial $(1) : $(2) ;
        }
        else {
            ResMergerCollector.append $(1) : $(2) ;
        }
    }
}
actions together piecemeal ResMergerCollector.together
{
    if [ -f $(1:Q) ]; then
        _appendoption=-append
    fi
    $(RESMERGER) -o $(1:Q) $_appendoption $(RESMERGEFLAGS:Q) "$(OTHER_RESMERGERFLAGS)" $(2:Q)
}
actions ResMergerCollector.initial
{
    $(RM) -f $(1:Q) && $(RESMERGER) -o $(1:Q) $(RESMERGEFLAGS:Q) "$(OTHER_RESMERGERFLAGS)" $(2:Q)
}
actions ResMergerCollector.append
{
    $(RESMERGER) -o $(1:Q) -append $(RESMERGEFLAGS:Q) "$(OTHER_RESMERGERFLAGS)" $(2:Q)
}

# ResMergerProduct - used to transfer collector resources to final destination
rule ResMergerProduct
{
    local MACOS_TYPE_ARG ;
    local MACOS_CREATOR_ARG ;
    DEPENDS $(1) : $(2) ;
    if $(MACOS_TYPE) {
        MACOS_TYPE_ARG = -fileType '$(MACOS_TYPE)' ;
    }
    if $(MACOS_CREATOR) {
        MACOS_CREATOR_ARG = -fileCreator '$(MACOS_CREATOR)' ;
    }
    RESMERGEFLAGS on $(1) = $(MACOS_TYPE_ARG) $(MACOS_CREATOR_ARG) -srcIs DF "$(OTHER_RESMERGERFLAGS)" ;
    if $(REZ_EXECUTABLE) = "YES" {
        ResMergerProductResourceFork $(1) : $(2) ;
    }
    else {
        RESMERGEFLAGS on $(1) += -dstIs DF ;
        ResMergerProductDataFork $(1) : $(2) ;
    }
}
actions ResMergerProductResourceFork
{
    $(REZ) -o $(1:Q) < /dev/null && \
    $(RESMERGER) $(2:Q) $(RESMERGEFLAGS) -o $(1:Q)
}
actions ResMergerProductDataFork
{
    $(RM) -f $(1:Q) && \
    $(RESMERGER) $(2:Q) $(RESMERGEFLAGS) -o $(1:Q)
}

# Fixprecomps <precomp> : <header>
# Ensures that the precompiled header is up to date
if $(FIXPRECOMPS) {
    rule Fixprecomps
    {
        DEPENDS $(1) : $(2) ;
    }
    actions Fixprecomps
    {
        $(FIXPRECOMPS) -precomps $(1:Q)
    }
} else {
    rule Fixprecomps
    {
        # if we don't have a fixprecomps command, we'll just
        # quietly do nothing
        NOTFILE $(1) ;
    }
}


# Copy operations:

# Cp <destination> : <source>
# Reliably copies files only.
# Leaf names of the source and destination are expected to match.
rule Cp
{
    DEPENDS $(1) : $(2) ;
}
actions together piecemeal Cp
{
    $(CP) $(CPFLAGS:Q) $(2:Q) $(1:Q)
}

# PBXCp <destination-file> : <source-file>
# Reliably copies files only.  Does not currently respect Mac OS
# Finder info or resource forks, but it does skip CVS directories
# and it does optionally strip Mach-O executables.
# Leaf names of the source and destination are expected to match.
rule PBXCp
{
    if $(ACTION) != installhdrs {
        DEPENDS $(1) : $(2) ;
    }
    PBXCP_FLAGS on $(1) = ;
    VERBOSE_PBXCP default = NO ;
    if $(VERBOSE_PBXCP) = YES {
        PBXCP_FLAGS on $(1) += -V ;
    }
    PBXCP_FLAGS on $(1) += -exclude .DS_Store ;
    if $(REMOVE_CVS_FROM_RESOURCES) = YES {
        PBXCP_FLAGS on $(1) += -exclude CVS ;
    }
    if $(REMOVE_SVN_FROM_RESOURCES) = YES {
        PBXCP_FLAGS on $(1) += -exclude .svn ;
    }
    if $(COPY_PHASE_STRIP) = YES  &&  $(ACTION) != installhdrs {
        PBXCP_FLAGS on $(1) += -strip-debug-symbols ;
    }
    # Because any content copied may have been generated, and so may be
    # in the form of a symlink to the actual content, it is necessary
    # to resolve one level of symbolic link for all sources copied.
    PBXCP_FLAGS on $(1) += -resolve-src-symlinks ;
}
actions together piecemeal PBXCp
{
    $(PBXCP) $(PBXCP_FLAGS:Q) $(2:Q) $(1:DQ)
}

# Ditto <destination> : <source>
# Directory to directory copies.
rule Ditto
{
    DEPENDS $(1) : $(2) ;
}
actions Ditto
{
    $(DITTO) $(2:Q) $(1:Q)
}

# RobustCp <destination> : <source>
# RobustCp is like Cp, but is made more robust by first removing
# any previous copy results and then conditionally removing CVS
# directories from the destination.
rule RobustCp
{
    if ! $(ACTION) = installhdrs {
        DEPENDS $(1) : $(2) ;
    }
    if $(REMOVE_CVS_FROM_RESOURCES) = YES && $(DEPLOYMENT_POSTPROCESSING) = YES {
        RobustCp.CleanBeforeAndAfter $(1) : $(2) ;
    }
    else {
        RobustCp.CleanBefore $(1) : $(2) ;
    }
    if $(COPY_PHASE_STRIP) = YES && ! $(ACTION) = installhdrs {
        StripBinaries $(1) ;
    }
}
actions RobustCp.CleanBeforeAndAfter
{
    if [ -d $(1:Q) ]
        then $(RM) -r $(1:Q)
    fi
    if [ -e $(2:Q) ]
        then
        _source=`$(LNRESOLVE) $(2:Q)`
        $(CP) -fRP "$_source" $(1:Q)
        if [ -d "$_source" ]
            then
            $(FIND) $(1:Q) -name CVS -type d -prune -print0 | $(XARGS) -0 rm -r
        fi
    fi
}
actions RobustCp.CleanBefore
{
    if [ -d $(1:Q) ]
        then $(RM) -r $(1:Q)
    fi
    if [ -e $(2:Q) ]
        then _source=`$(LNRESOLVE) $(2:Q)`
        $(CP) -fRP "$_source" $(1:Q)
    fi
}

# StripBinaries <starting directory>
# Uses find to run strip -s on all binaries starting from a file or directory
actions StripBinaries
{
    if [ -f $(1:Q) ]; then
        filetype=`file $(1:Q)`
        macho=`echo $filetype | fgrep Mach-O | sed 's/:.*//'`
        ararch=`echo $filetype | fgrep ar\ archive | sed 's/:.*//'`
        if [ "x$macho" != "x" ]; then
            $(STRIP) -S "$macho"
        fi
        if [ "x$ararch" != "x" ]; then
            $(STRIP) -S "$ararch"
        fi
    else
        machos=`cd $(1:Q); $(FIND) . -type f -print0 | xargs -0 file | fgrep Mach-O | sed 's/:.*//'`
        ararchs=`cd $(1:Q); $(FIND) . -type f -print0 | xargs -0 file | fgrep ar\ archive | sed 's/:.*//'`
        if [ "x$machos" != "x" ]; then
            cd $(1:Q); 
	    origIFS=$IFS
	    IFS="
"
	    for curbinary in $machos ; do
	    	$(STRIP) -S "$curbinary"
	    done
	    IFS=$oldIFS
        fi
        if [ "x$ararchs" != "x" ]; then
            cd $(1:Q); 
	    origIFS=$IFS
	    IFS="
"
	    for curbinary in $ararchs ; do
	    	$(STRIP) -S "$curbinary"
	    done
	    IFS=$oldIFS
        fi
    fi
}

# ResourcePreservingCp <destination> : <source>
# where the leaf names of <destination> and <source> are the same
# and CpMac is to be used to insure resources are preserved.
# Although CpMac is invoked with -r, this command is only reliable
# for individual file copies becaues there is no preremove of
# a directory destination which could cause nesting of the copy.
rule ResourcePreservingCp
{
    DEPENDS $(1) : $(2) ;
}
actions together piecemeal ResourcePreservingCp
{
    $(RESOURCE_PRESERVING_CP) -r $(2:Q) $(1:Q)
}

# ResourcePreservingMv <destination> : <source> : <junk>
# where the leaf names of <destination> and <source> are the same
# and CpMac is to be used to insure resources are preserved.
# The <junk> is removed after copying.
rule ResourcePreservingMv
{
    DEPENDS $(1) : $(2) ;
}
actions together piecemeal ResourcePreservingMv
{
    $(RESOURCE_PRESERVING_CP) -r $(2:Q) $(1:Q)
}

# AbsolutePathImportStub <stub file> : <stub import file>
# Generates a file with one line which is an #import directive
# and the second parameter quoted which should be a full path
# to the real file to be imported.
# If $2 is not an absolute path, $(SRCROOT) will be prepended to make 
# it absolute.
rule AbsolutePathImportStub
{
    DEPENDS $(1) : $(2) ;
    NOUPDATE $(1) ;
}
actions AbsolutePathImportStub
{
    firstChar=`echo "$(2)" | colrm 2`
    if [ z$firstChar = z"/" -o z$firstChar = z"~" ] ; then
        includePath="$(2)"
    else
        includePath="$(SRCROOT)/$(2)"
    fi
    echo "#include" \""${includePath}"\" > "$(1)"
}

# HeaderDoc <headerdoc target (table of contents for header)> : <header>
rule HeaderDoc
{
    DEPENDS $(1) : $(2) ;
}
actions HeaderDoc
{
    $(HEADERDOC2HTML) -o $(HEADERDOC_DIR:Q) $(2:Q)
}

# GatheredHeaderDoc <gathered headerdoc target>
rule GatheredHeaderDoc
{
}
actions GatheredHeaderDoc
{
    $(GATHERHEADERDOC) $(HEADERDOC_DIR:Q)
}

# Source derivation operations:

# Lex <file>.{c|m} : <file>.l[m]
# Runs lex to generate <file>.c or <file>.m based on scanner input
rule Lex
{
    DEPENDS $(1) : $(2) ;
}

actions Lex
{
    $(LEX) $(LEXFLAGS) "-o$(1)" $(2:Q)
}

# Yacc <file>.{c|m} <file>.h : <file>.y[m]
# Uses yacc to generate parser from description
rule Yacc
{
    DEPENDS $(1) : $(2) ;
}

actions Yacc
# Generate result by noting location, going to derived source directory,
# running yacc, then copying the results to what is desired.
{
    origin=`/bin/pwd` && $(CD) "$(1[1]:D)" && $(YACC) $(YACCFLAGS) -d "$origin/$(2)" && $(CP) y.tab.h "$(1[2])" && $(CP) y.tab.c "$(1[1])"
}

# RPCGen <proto>_xdr.c <proto>.h : <proto>.x
# Generates RPC stubs from specifications
#
rule RPCGen
{
    DEPENDS $(1) : $(2) ;
}

# Generate header and C code with two calls to rpcgen
actions RPCGen
{
    $(RPCGEN) $(RPCGENFLAGS) -h -o "$(1[2])" $(2:Q)
    $(RPCGEN) $(RPCGENFLAGS) -c -o "$(1[1])" $(2:Q)
}

# Mig <file>User.c <file>.h : <file>.defs OR
# Mig <file>Server.c <file>Server.h : <file>.defs
# Runs mig to create client and server files from a definition file.
rule Mig
{
    DEPENDS $(1) : $(2) ;
    if Server in $($(2)_ATTRIBUTES) {
        Mig.server $(1) : $(2) ;
    }
    else {
        Mig.client $(1) : $(2) ;
    }
}
actions Mig.client
{
    origin=`pwd` && $(CD) "$(1[1]:D)" && $(MIG) "$(OTHER_MIGFLAGS)" "$origin/$(2)"
}
actions Mig.server
{
    origin=`pwd` && $(CD) "$(1[1]:D)" && $(MIG) "$(OTHER_MIGFLAGS)" -sheader "$(2:B)Server.h" "$origin/$(2)"
}

# Bridget <primary target> : <jobs file>
rule Bridget
{
    # set up common settings and paths needed for bridget usage
    JAVA_HEADERS default = /Developer/Java/Headers /System/Library/Frameworks/JavaVM.framework/Headers ;
    if ! $(BRIDGET_FILES_DIR) {
        BRIDGET_FILES_DIR = $(DERIVED_FILE_DIR)$(/)JavaBridgeFiles ;
        Mkdir $(BRIDGET_FILES_DIR) ;
        ProductFile $(BRIDGET_FILES_DIR) ;
    }
    if $(BRIDGE_JAVA) = YES {
        # produce the file list draft
        # conditionally update the file list from the draft
        BRIDGET_DERIVED_JAVA_FILE_LIST = $(FILE_LIST:G=BridgetDerivedJavaFileList)BridgetDerivedJavaFileList ;
        NOTFILE $(BRIDGET_DERIVED_JAVA_FILE_LIST) ;
        DEPENDS $(1) : $(BRIDGET_DERIVED_JAVA_FILE_LIST) ;
        DEPENDS $(BRIDGET_DERIVED_JAVA_FILE_LIST) : $(2) ;
        DEPENDS $(BRIDGET_DERIVED_JAVA_FILE_LIST) : $(BRIDGET_FILES_DIR) ;
        DEPENDS $(BRIDGET_DERIVED_JAVA_FILE_LIST) : $(OBJECT_FILE_DIR) ;
        Bridget.UpdateJavaFileList $(BRIDGET_DERIVED_JAVA_FILE_LIST) : $(2) ;
        # derive files using file list
        # compile derived files (nonfile target?)
        BRIDGET_DERIVE_AND_COMPILE_JAVA_TAG = $(FILE_LIST:G=BridgetDeriveAndCompileJavaTag)BridgetDeriveAndCompileJavaTag ;
        ProductFile $(BRIDGET_DERIVE_AND_COMPILE_JAVA_TAG) ;
        DEPENDS $(1) : $(BRIDGET_DERIVE_AND_COMPILE_JAVA_TAG) ;
        DEPENDS $(BRIDGET_DERIVE_AND_COMPILE_JAVA_TAG) : $(BRIDGET_DERIVED_JAVA_FILE_LIST) ;
        DEPENDS $(BRIDGET_DERIVE_AND_COMPILE_JAVA_TAG) : $(BRIDGET_FILES_DIR) ;
        DEPENDS $(BRIDGET_DERIVE_AND_COMPILE_JAVA_TAG) : $(CLASS_FILE_DIR) ;
        DEPENDS $(BRIDGET_DERIVE_AND_COMPILE_JAVA_TAG) : $(2) ;
        if $(JAVA_COMPILER:B) = jikes {
            Bridget. DeriveAndCompileJava.jikes $(BRIDGET_DERIVE_AND_COMPILE_JAVA_TAG) : $(2) ;
        }
        else {
            Bridget.DeriveAndCompileJava.javac $(BRIDGET_DERIVE_AND_COMPILE_JAVA_TAG) : $(2) ;
        }
    }
    if $(BRIDGE_OBJC) = YES {
        # Produce the derived C file list draft
        # and conditionally update the file list from the draft.
        BRIDGET_DERIVED_C_FILE_LIST = $(FILE_LIST:G=BridgetDerivedCFileList)BridgetDerivedCFileList ;
        NOTFILE $(BRIDGET_DERIVED_C_FILE_LIST) ;
        DEPENDS $(1) : $(BRIDGET_DERIVED_C_FILE_LIST) ;
        DEPENDS $(BRIDGET_DERIVED_C_FILE_LIST) : $(2) ;
        DEPENDS $(BRIDGET_DERIVED_C_FILE_LIST) : $(BRIDGET_FILES_DIR) ;
        DEPENDS $(BRIDGET_DERIVED_C_FILE_LIST) : $(OBJECT_FILE_DIR) ;
        Bridget.UpdateCFileList $(BRIDGET_DERIVED_C_FILE_LIST) : $(2) ;
        BRIDGET_DERIVE_AND_COMPILE_C_TAG = $(FILE_LIST:G=BridgetDeriveAndCompileCTag)BridgetDeriveAndCompileCTag ;
        ProductFile $(BRIDGET_DERIVE_AND_COMPILE_C_TAG) ;
        DEPENDS $(1) : $(BRIDGET_DERIVE_AND_COMPILE_C_TAG) ;
        DEPENDS $(BRIDGET_DERIVE_AND_COMPILE_C_TAG) : $(BRIDGET_DERIVED_C_FILE_LIST) ;
        DEPENDS $(BRIDGET_DERIVE_AND_COMPILE_C_TAG) : $(BRIDGET_FILES_DIR) ;
        DEPENDS $(BRIDGET_DERIVE_AND_COMPILE_C_TAG) : $(OBJECT_FILE_DIR) ;
        DEPENDS $(BRIDGET_DERIVE_AND_COMPILE_C_TAG) : $(2) ;
        # derive files using file list
        # compile derived files (nonfile target?)
        BRIDGET_FILE_LIST default = $(FILE_LIST)Bridget ;
        BRIDGET_CFLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CFLAGS) -fno-common -fpascal-strings $(OPTIMIZATION_CFLAGS) $(WARNING_CFLAGS) ;
        BRIDGET_CFLAGS on $(1) += -pipe ;

        # seed search paths with target-wide values
        HEADER_SEARCH_PATHS on $(1) = $(HEADER_SEARCH_PATHS) ;
        FRAMEWORK_SEARCH_PATHS on $(1) = $(FRAMEWORK_SEARCH_PATHS) ;

        # We must compile with the extension-specific build flags
        BRIDGET_CFLAGS on $(1) += $($(2:S)_CFLAGS) ;
        # Add debug flags, if appropriate.
        if $(DEBUGGING_SYMBOLS) = YES {
            BRIDGET_CFLAGS on $(1) += -g ;
        }
        # Add profiling flags, if appropriate.
        if $(PROFILING_CODE) = YES {
            BRIDGET_CFLAGS on $(1) += -pg ;
        }
        # Pass the trusted-precomp file name to the compiler to keep track
        # of which precompiled headers it has already sanity checked.
        if $(OS) in MACOS DARWIN {
            BRIDGET_CFLAGS on $(1) += -precomp-trustfile $(PRECOMP_TRUSTFILE) ;
        }

        # Pass headermap and/or header symlinks directory.
        if $(CPP_HEADERMAP_FILE) {
            if $(GCC_VERSION) <= 3.3 {
                CPP_HEADERMAP_FLAGS on $(1) = -Wp,-header-mapfile,$(CPP_HEADERMAP_FILE) ;
            }
            else if $(GCC_VERSION) >= 4.0 {
                CPP_HEADERMAP_FLAGS on $(1) = -I$(CPP_HEADERMAP_FILE) ;
            }
            else {
                ECHO jam: warning: GCC v$(GCC_VERSION) does not support headermaps ;
            }
        }

        if YES in $(GENERATE_CPP_ILOG_FILES) {
            local INCLUSION_LOG_FILE default = $(OBJECT_FILE_DIR)-$(VARIANT)$(/)$(ARCH)$(/)$(1:DB).ilog ;
            BRIDGET_CFLAGS on $(1) += "-Wp,-inclusion-log-file,$(INCLUSION_LOG_FILE)" ;
        }
        if $(PREFIX_HEADER) {
            PREFIX_HEADER_CFLAGS on $(1) += -include $(PREFIX_HEADER) ;
        }
        Bridget.DeriveAndCompileC $(BRIDGET_DERIVE_AND_COMPILE_C_TAG) : $(2) ;
    }
}
# Bridget.UpdateJavaFileList <list update target> <bridget file> generates draft
# and updates definitive list if it is missing or out of date
actions Bridget.UpdateJavaFileList
{
    $(BRIDGET) -listjava "-I$(BRIDGET_FILES_DIR)" "-I$(SOURCE_ROOT)" "-I$(HEADER_SEARCH_PATHS)" "-F$(FRAMEWORK_SEARCH_PATHS)" "-I$(JAVA_HEADERS_DIR)" "$(BRIDGETFLAGS)" "$(OTHER_BRIDGETFLAGS)" "$(2)" >> "$(1:G=)Draft" && \
    if [ ! -e "$(1:G=)" ]; then
        cp "$(1:G=)Draft" "$(1:G=)"
    else 
        _file_list_diffs=`diff --brief "$(1:G=)Draft" "$(1:G=)"`
        if [ "x$_file_list_diffs" != "x" ]; then
            cp "$(1:G=)Draft" "$(1:G=)"
        fi
    fi
}
actions Bridget.DeriveAndCompileJava.javac
{
    $(BRIDGET) -java -o "$(BRIDGET_FILES_DIR)" "-I$(BRIDGET_FILES_DIR)" "-I$(SOURCE_ROOT)" "-I$(HEADER_SEARCH_PATHS)" "-F$(FRAMEWORK_SEARCH_PATHS)" "-I$(JAVA_HEADERS_DIR)" "$(BRIDGETFLAGS)" "$(OTHER_BRIDGETFLAGS)" "$(2)" && \
    frameworkjars="" && \
    for i in `echo $(JAVA_FRAMEWORK_JARS)/*.jar $(JAVA_FRAMEWORK_JARS)/*.zip ` ; do if [ -f "$i" ] ; then frameworkjars="$frameworkjars":"$i" ; fi ; done && \
    classpath="$(CLASS_FILE_DIR)$(LINKED_CLASS_ARCHIVES)$frameworkjars:"`$(JAVACONFIG) DefaultClasspath` && \
    cd "$(BRIDGET_FILES_DIR)" && \
    $(JAVA_COMPILER) $(JAVAC_FLAGS) -sourcepath "$(JAVA_SOURCE_PATH)" -classpath "$classpath" -d "$(CLASS_FILE_DIR)" @"$(BRIDGET_DERIVED_JAVA_FILE_LIST:G=)" && \
    /usr/bin/touch "$(1:G=)"
}
actions Bridget.DeriveAndCompileJava.jikes
{
    $(BRIDGET) -java -o "$(BRIDGET_FILES_DIR)" "-I$(BRIDGET_FILES_DIR)" "-I$(SOURCE_ROOT)" "-I$(HEADER_SEARCH_PATHS)" "-F$(FRAMEWORK_SEARCH_PATHS)" "-I$(JAVA_HEADERS_DIR)" "$(BRIDGETFLAGS)" "$(OTHER_BRIDGETFLAGS)" "$(2)" && \
    frameworkjars="" && \
    for i in `echo $(JAVA_FRAMEWORK_JARS)/*.jar $(JAVA_FRAMEWORK_JARS)/*.zip ` ; do if [ -f "$i" ] ; then frameworkjars="$frameworkjars":"$i" ; fi ; done && \
    classpath="$(CLASS_FILE_DIR)$(LINKED_CLASS_ARCHIVES)$frameworkjars:"`$(JAVACONFIG) DefaultClasspath` && \
    cd "$(BRIDGET_FILES_DIR)" && \
    $(JAVA_COMPILER) +E $(JAVAC_FLAGS) -classpath "$classpath" -d "$(CLASS_FILE_DIR)" `cat "$(BRIDGET_DERIVED_JAVA_FILE_LIST:G=)"` && \
    /usr/bin/touch "$(1:G=)"
}

# Bridget.CompileC.UpdateFileList <list update target> <bridget file> generates draft
# and updates definitive list if it is missing or out of date
actions Bridget.UpdateCFileList
{
    $(BRIDGET) -listobjc "-I$(BRIDGET_FILES_DIR)" "-I$(SOURCE_ROOT)" "-I$(HEADER_SEARCH_PATHS)" "-F$(FRAMEWORK_SEARCH_PATHS)" "-I$(JAVA_HEADERS_DIR)" "$(BRIDGETFLAGS)" "$(OTHER_BRIDGETFLAGS)" "$(2)" >> "$(1:G=)Draft" && \
    if [ ! -e "$(1:G=)" ]; then
        cp "$(1:G=)Draft" "$(1:G=)"
    else 
        _file_list_diffs=`diff --brief "$(1:G=)Draft" "$(1:G=)"`
        if [ "x$_file_list_diffs" != "x" ]; then
            cp "$(1:G=)Draft" "$(1:G=)"
        fi
    fi
}
actions Bridget.DeriveAndCompileC
{
    $(BRIDGET) -stub -init -o "$(BRIDGET_FILES_DIR)" "-I$(BRIDGET_FILES_DIR)" "-I$(SOURCE_ROOT)" "-I$(HEADER_SEARCH_PATHS)" "-F$(FRAMEWORK_SEARCH_PATHS)" "-I$(JAVA_HEADERS_DIR)" "$(BRIDGETFLAGS)" "$(OTHER_BRIDGETFLAGS)" "$(2)" && \
    cd "$(BRIDGET_FILES_DIR)" && \
    $(CC) -c $(ARCH_FLAGS) $(CPP_HEADERMAP_FLAGS:Q) -I$(CPP_HEADER_SYMLINKS_DIR:Q) -O -fno-common -no-cpp-precomp -dynamic "$(FLAGS)" $(GLOBAL_CFLAGS) "-I$(DERIVED_PATHS)" "-I$(HEADER_SEARCH_PATHS)" "-I$(JAVA_HEADERS)" "-F$(FRAMEWORK_SEARCH_PATHS)" "-I$(TARGET_BUILD_DIR)/$(PUBLIC_HEADER_DIR:G=)" "-I$(TARGET_BUILD_DIR)/$(PRIVATE_HEADER_DIR:G=)" "$(BRIDGET_CFLAGS)" $(PREFIX_HEADER_CFLAGS) `cat "$(BRIDGET_DERIVED_C_FILE_LIST:G=)"` && \
    find "$(BRIDGET_FILES_DIR)" -type f -name '*.o' -print > "$(BRIDGET_FILE_LIST:G=)" && \
    /usr/bin/touch "$(1:G=)"
}

# GenerateVectorLibraryIntermediates <vector stub> <vector object file> : <exports file>
# Generates and compiles vector stub
rule GenerateVectorLibraryIntermediates
{
    DEPENDS $(1) : $(2) ;
    LOCATE on $(2) = $(SOURCE_ROOT) ;
    VECTOR_STUB on $(1) = $(VECTOR_STUB) ;
    VECTOR_OBJECT_FILE on $(1) = $(VECTOR_OBJECT_FILE) ;
    VECTOR_FRAGMENT_NAME on $(1) = $(VECTOR_FRAGMENT_NAME) ;
    DYLIB_INSTALLED_NAME on $(1) = $(DYLIB_INSTALLED_NAME) ;
    DEPENDS $(VECTOR_STUB) : $(DERIVED_FILE_DIR) ;
}
actions GenerateVectorLibraryIntermediates
{
    $(MAKEPSEUDOLIB) $(2:Q) -p -strip -fragname $(VECTOR_FRAGMENT_NAME:Q) -vector $(VECTOR_STUB:Q) -dylibpath "$(DYLIB_INSTALLED_NAME)"
    $(CC) -Wa,-L -c $(ARCH_FLAGS) -O -fno-common -no-cpp-precomp -dynamic "$(FLAGS)" $(GLOBAL_CFLAGS) -o $(VECTOR_OBJECT_FILE:Q) $(VECTOR_STUB:Q)
}

MASTER_INTERFACES default = /AppleInternal/Carbon/interfaces ;
# !!!:cmolick:20010412 Apple internal RC_ settings nonempty in offical builds
INTERFACER_TARGET_UPDATE default = \"$(RC_ProjectName)-$(RC_ProjectSourceVersion)~$(RC_ProjectBuildVersion)\" ;

rule InterfacerHeaders
{
    INTERFACER_CACHE default = $(TEMP_DIR)$(/)InterfacerCache ;
    local BUILD_DIR_AND_SEPARATOR = $(TARGET_BUILD_DIR)$(/) ;
    INTERFACER_HEADERS = $(1:G=InterfacerHeaders) ;
    if $(INTERFACER_TARGET_UPDATE) {
        INTERFACER_HEADER_OPTIONS += -externalHeader $(INTERFACER_TARGET_UPDATE) ;
    }
    FULL_PUBLIC_HEADER_DIR = $(BUILD_DIR_AND_SEPARATOR)$(PUBLIC_HEADER_DIR:G=) ;
    FULL_PUBLIC_HEADER_DIR on $(INTERFACER_HEADERS) = $(FULL_PUBLIC_HEADER_DIR) ;
    FULL_PRIVATE_HEADER_DIR = $(BUILD_DIR_AND_SEPARATOR)$(PRIVATE_HEADER_DIR:G=) ;
    FULL_PRIVATE_HEADER_DIR on $(INTERFACER_HEADERS) = $(FULL_PRIVATE_HEADER_DIR) ;
   # Create symlink to public header dir in versioned frameworks
    if $(PUBLIC_HEADER_LINK)
      && ! $(PUBLIC_HEADER_LINK) in $(PRODUCT_FILES) {
        SymLink $(PUBLIC_HEADER_LINK) : $(PUBLIC_HEADER_LINK_PATH) ;
        ProductFile $(PUBLIC_HEADER_LINK) ;
        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
            ASIDE_PUBLIC_HEADER_LINK default = $(PUBLIC_HEADER_LINK:G=aside) ;
            SymLink $(ASIDE_PUBLIC_HEADER_LINK) : $(PUBLIC_HEADER_LINK_PATH) ;
            ProductFileAside $(ASIDE_PUBLIC_HEADER_LINK) ;
        }
        NOUPDATE $(PUBLIC_HEADER_LINK) ;
    }
    # Create symlink to private header dir in versioned frameworks
    if $(PRIVATE_HEADER_LINK)
      && ! $(PRIVATE_HEADER_LINK) in $(PRODUCT_FILES) {
        SymLink $(PRIVATE_HEADER_LINK) : $(PRIVATE_HEADER_LINK_PATH) ;
        ProductFile $(PRIVATE_HEADER_LINK) ;
        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
            ASIDE_PRIVATE_HEADER_LINK default = $(PRIVATE_HEADER_LINK:G=aside) ;
            SymLink $(ASIDE_PRIVATE_HEADER_LINK) : $(PRIVATE_HEADER_LINK_PATH) ;
            ProductFileAside $(ASIDE_PRIVATE_HEADER_LINK) ;
        }
        NOUPDATE $(PRIVATE_HEADER_LINK) ;
    }

    if $(_BUILD_PHASING) = YES {
        BUILD_PHASE_PRODUCTS += $(INTERFACER_HEADERS) ;
    }
    # Create a public header directory
    if ! $(PUBLIC_HEADER_DIR) in $(PRODUCT_FILES) {
        Mkdir $(PUBLIC_HEADER_DIR) ;
        ProductFile $(PUBLIC_HEADER_DIR) ;
        DEPENDS $(INTERFACER_HEADERS) : $(PUBLIC_HEADER_DIR) ;
        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
            ASIDE_PUBLIC_HEADER_DIR default = $(PUBLIC_HEADER_DIR:G=aside) ;
            Mkdir $(ASIDE_PUBLIC_HEADER_DIR) ;
            ProductFileAside $(ASIDE_PUBLIC_HEADER_DIR) ;
        }
    }
    # Create a private header directory
    if ! $(PRIVATE_HEADER_DIR) in $(PRODUCT_FILES) {
        Mkdir $(PRIVATE_HEADER_DIR) ;
        ProductFile $(PRIVATE_HEADER_DIR) ;
        DEPENDS $(INTERFACER_HEADERS) : $(PRIVATE_HEADER_DIR) ;
        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
            ASIDE_PRIVATE_HEADER_DIR default = $(PRIVATE_HEADER_DIR:G=aside) ;
            Mkdir $(ASIDE_PRIVATE_HEADER_DIR) ;
            ProductFileAside $(ASIDE_PRIVATE_HEADER_DIR) ;
        }
    }

       # install .i files if requested
    if $(FRAMEWORK_INTERFACES) {
        INTERFACER_INSTALL_OPTIONS = -frameworkInterfaces $(SRCROOT)$(/)$(FRAMEWORK_INTERFACES)$(/) -installMasterInterfaces $(DSTROOT)/AppleInternal/Carbon/interfaces/ ;
    }

    Interfacer.Headers $(INTERFACER_HEADERS) ;
    # Interfacer headers are required (ideally these should be phase products)
    DEPENDS $(1) : $(INTERFACER_HEADERS) ;
}

actions Interfacer.Headers
{
    $(INTERFACER) -masterInterfaces "$(MASTER_INTERFACES)/" -cacheFolder "$(INTERFACER_CACHE)/" $(INTERFACER_HEADER_OPTIONS) -c -rez -framework "$(1:D=:S=:G=)" -p -generated "c=$(FULL_PUBLIC_HEADER_DIR:G=)/" -generatedPriv "c=$(FULL_PRIVATE_HEADER_DIR:G=)/" -generated "rez=$(FULL_PUBLIC_HEADER_DIR:G=)/" -generatedPriv "rez=$(FULL_PRIVATE_HEADER_DIR:G=)/" $(INTERFACER_INSTALL_OPTIONS)
}

rule InterfacerExportSetsAndGlue
{
    INTERFACER_CACHE default = $(TEMP_DIR)$(/)InterfacerCache ;
    EXPORT_SETS_DIR default = $(DERIVED_FILE_DIR)$(/)ExportSets ;
    UPP_GLUE_DIR default = $(DERIVED_FILE_DIR)$(/)UPPGlue ;
    COMPONENT_GLUE_DIR default = $(DERIVED_FILE_DIR)$(/)ComponentGlue ;
    RAW_GENERATED_EXPORTS_FILE default = $(EXPORT_SETS_DIR)$(/)fw_$(PRODUCT_NAME)_X.exp ;
    RAW_GENERATED_PRIVATE_EXPORTS_FILE default = $(EXPORT_SETS_DIR)$(/)fw_$(PRODUCT_NAME)Priv_X.exp ;
    # !!!:cmolick:20000602 private exports file optional...bad depend?
    PROCESSED_EXPORTS_FILE default = $(DERIVED_FILE_DIR)$(/)$(PRODUCT_NAME).exp ;
    DEPENDS $(RAW_GENERATED_EXPORTS_FILE) : $(DERIVED_FILE_DIR) ;
    DEPENDS $(RAW_GENERATED_PRIVATE_EXPORTS_FILE) : $(DERIVED_FILE_DIR) ;
    DEPENDS $(PROCESSED_EXPORTS_FILE) : $(DERIVED_FILE_DIR) ;
    # object file dir needs to be in place for glue object file list
    # !!!:cmolick:20020105 this dependence appears superfluous
    # DEPENDS $(PROCESSED_EXPORTS_FILE) : $(RAW_GENERATED_EXPORTS_FILE) ;
    DEPENDS $(1) : $(PROCESSED_EXPORTS_FILE) ;
    if $(GENERATE_HEADERS) = YES {
        DEPENDS $(RAW_GENERATED_EXPORTS_FILE) : $(INTERFACER_HEADERS) ;
        DEPENDS $(PROCESSED_EXPORTS_FILE) : $(INTERFACER_HEADERS) ;
    }
    if $(_BUILD_PHASING) = YES {
        BUILD_PHASE_PRODUCTS += $(RAW_GENERATED_EXPORTS_FILE) $(PROCESSED_EXPORTS_FILE) ;
    }
    HEADER_SEARCH_PATHS on $(RAW_GENERATED_EXPORTS_FILE) = $(HEADER_SEARCH_PATHS) ;
    FRAMEWORK_SEARCH_PATHS on $(RAW_GENERATED_EXPORTS_FILE) = $(FRAMEWORK_SEARCH_PATHS) ;
    if $(GENERATE_COMPONENT_GLUE) = YES {
        INTERFACER_FLAGS += -componentGlueC ;
        INTERFACER_COMPONENT_GLUE_FLAGS = -generated "componentGlueC=$(COMPONENT_GLUE_DIR)/" -generatedPriv "componentGlueC=$(COMPONENT_GLUE_DIR)/" ;
    }
    for VARIANT in $(BUILD_VARIANTS) {
        DEPENDS $(PROCESSED_EXPORTS_FILE) : $(OBJECT_FILE_DIR_$(VARIANT)) ;
    }
    GLUE_FILE_LIST default = $(TEMP_DIR)$(/)GlueFileList ;
    Interfacer.RawExportSetsAndGlue $(RAW_GENERATED_EXPORTS_FILE) $(GLUE_FILE_LIST) : $(1) ;
    ProductFile $(RAW_GENERATED_EXPORTS_FILE) ;
    ProductFile $(GLUE_FILE_LIST) ;
    ADDITIONAL_EXPORTS_FILE on $(PROCESSED_EXPORTS_FILE) = $(ADDITIONAL_EXPORTS_FILE) ;
    ADDITIONAL_TRADITIONAL_EXPORTS_FILE on $(PROCESSED_EXPORTS_FILE) = $(ADDITIONAL_TRADITIONAL_EXPORTS_FILE) ;
    Interfacer.PrepareExportList $(PROCESSED_EXPORTS_FILE) : $(RAW_GENERATED_EXPORTS_FILE) ;
    ProductFile $(PROCESSED_EXPORTS_FILE) ;
    #!!!:cmolick:200203019 this dependence is necessary to ensure correct order
    DEPENDS $(PROCESSED_EXPORTS_FILE) : $(RAW_GENERATED_EXPORTS_FILE) ;
    EXPORTED_SYMBOLS_FILE default = $(PROCESSED_EXPORTS_FILE) ;
    ProcessFile $(1) : $(EXPORTED_SYMBOLS_FILE) ;
}

actions Interfacer.RawExportSetsAndGlue
# Generates export sets and UPP glue with Interfacer,
# then attempts to compile UPP glue and add resulting
# object files to a list to use at link time.
{
    $(INTERFACER) -masterInterfaces "$(MASTER_INTERFACES)/" -cacheFolder "$(INTERFACER_CACHE)/" -uppGlueC "$(INTERFACER_FLAGS)" -framework "$(2[1]:G=:D=:S=)" -frameworkExports -p -generated "frameworkExports=$(EXPORT_SETS_DIR)/" -generatedPriv "frameworkExports=$(EXPORT_SETS_DIR)/" -generated "uppGlueC=$(UPP_GLUE_DIR)/" -generatedPriv "uppGlueC=$(UPP_GLUE_DIR)/" $(INTERFACER_COMPONENT_GLUE_FLAGS) $(INTERFACER_INSTALL_OPTIONS)
    if [ -e "$(UPP_GLUE_DIR)" ]; then
        _upp_glue_modules=`ls "$(UPP_GLUE_DIR)"`
        if [ ! "$_upp_glue_modules" = x"$_upp_glue_modules" ]; then
            cd "$(UPP_GLUE_DIR)"
            for _upp_glue in *.c ; do
                $(CC) -c $(ARCH_FLAGS) $(CPP_HEADERMAP_FLAGS:Q) -I$(CPP_HEADER_SYMLINKS_DIR:Q) -O -fno-common -no-cpp-precomp -dynamic -Wmost -Wno-four-char-constants -fpascal-strings -fwritable-strings -fexceptions -DCARBON_THRASH=1 -DforCarbon=1 -DACCESSORS_CALLS_ARE_FUNCTIONS=1 -DUSE_INVOKEUPP_C_GLUE=1 "$(FLAGS)" $(GLOBAL_CFLAGS) "-I$(DERIVED_PATHS)" "-I$(HEADER_SEARCH_PATHS)" "-F$(FRAMEWORK_SEARCH_PATHS)" "-I$(BUILT_PRODUCTS_DIR)/$(PUBLIC_HEADER_DIR:G=)" "-I$(BUILT_PRODUCTS_DIR)/$(PRIVATE_HEADER_DIR:G=)" $_upp_glue
            done
            find "$(UPP_GLUE_DIR)" -type f -name '*.i.o' -print > "$(GLUE_FILE_LIST)"
        fi
    fi
    if [ -e "$(COMPONENT_GLUE_DIR)" ]; then
        _component_glue_modules=`ls "$(COMPONENT_GLUE_DIR)"`
        if [ ! "$_component_glue_modules" = x"$_component_glue_modules" ]; then
            cd "$(COMPONENT_GLUE_DIR)"
            for _component_glue in *.c ; do
                $(CC) -c $(ARCH_FLAGS) $(CPP_HEADERMAP_FLAGS:Q) -I$(CPP_HEADER_SYMLINKS_DIR:Q) -O -fno-common -no-cpp-precomp -dynamic -Wmost -Wno-four-char-constants -fpascal-strings -fwritable-strings -fexceptions -DCARBON_THRASH=1 -DforCarbon=1 -DACCESSORS_CALLS_ARE_FUNCTIONS=1 -DUSE_INVOKEUPP_C_GLUE=1 "$(FLAGS)" $(GLOBAL_CFLAGS) "-I$(DERIVED_PATHS)" "-I$(HEADER_SEARCH_PATHS)" "-F$(FRAMEWORK_SEARCH_PATHS)" "-I$(BUILT_PRODUCTS_DIR)/$(PUBLIC_HEADER_DIR:G=)" "-I$(BUILT_PRODUCTS_DIR)/$(PRIVATE_HEADER_DIR:G=)" $_component_glue
            done
            find "$(COMPONENT_GLUE_DIR)" -type f -name '*.i.o' -print >> "$(GLUE_FILE_LIST)"
        fi
    fi
}

actions Interfacer.PrepareExportList
# Translates PEF-oriented Interfacer export list output into
# nmedit-compatible export lists for use with mach-o.
{
    cat "$(EXPORT_SETS_DIR)$(/)$(PRODUCT_NAME).exp" "$(EXPORT_SETS_DIR)$(/)$(PRODUCT_NAME)Priv.exp" > $(1:Q)
    _additional_exports_file="$(ADDITIONAL_EXPORTS_FILE)"
    if [ "x$_additional_exports_file" != "x" ]; then
        if [ -f "$_additional_exports_file" ]; then
            cat "$_additional_exports_file" >> $(1:Q)
        fi
    fi
    _additional_traditional_exports_file="$(ADDITIONAL_TRADITIONAL_EXPORTS_FILE)"
    if [ "x$_additional_traditional_exports_file" != "x" ]; then
        if [ -f "$_additional_traditional_exports_file" ]; then
            cat "$_additional_traditional_exports_file" |
             grep -v ^\* | grep -v ^# | grep -v ^\$ | sort | uniq -u | sed -e '1,$ s/^/_/' >> "$(1)"
        fi
    fi
}


# Linking, class archive generation, and related operations:
#
# Variables used by linking operations:
# FLAGS.o of target, LDFLAGS, SECTORDER_FLAGS
# LIBRARY_SEARCH_PATHS, FRAMEWORK_SEARCH_PATHS,
# and optionally LINK_FILE_LIST and INIT_ROUTINE

# ClassArchive <archive> : <class file dir>
# Generates an archive that stores class files in the given directory
rule ClassArchive {
    if $(JAVA_ARCHIVE_TYPE) = JAR {
        local JARFLAGS = $(JAVA_JAR_FLAGS) ;
        if $(JAVA_MANIFEST_FILE) {
            DEPENDS $(1) : $(JAVA_MANIFEST_FILE) ;
            JAVA_MANIFEST_FILE on $(1) = $(SOURCE_ROOT)$(/)$(JAVA_MANIFEST_FILE) ;
            JARFLAGS = $(JARFLAGS)m ;
        }
        JARFLAGS = $(JARFLAGS)f ;
        if $(JAVA_ARCHIVE_COMPRESSION) != YES {
            JARFLAGS = $(JARFLAGS)0 ;
        }
        JARFLAGS += -J-Dfile.encoding=UTF8 ;
        JARFLAGS on $(1) = $(JARFLAGS) ;
	CLASS_FILE_DIR on $(1) = $(CLASS_FILE_DIR) ;
        ClassArchive.jarArchive $(1) : $(2) ;
    }
    else {
        if $(JAVA_ARCHIVE_TYPE) = ZIP {
            local ZIPFLAGS = $(JAVA_ZIP_FLAGS) ;
            if $(JAVA_ARCHIVE_COMPRESSION) != YES {
                ZIPFLAGS = $(ZIPFLAGS)0 ;
            }
            ZIPFLAGS on $(1) = $(ZIPFLAGS) ;
	    CLASS_FILE_DIR on $(1) = $(CLASS_FILE_DIR) ;
            ClassArchive.zipArchive $(1) : $(2) ;
        }
    }
}
# Use jar command to generate an archive
# from the class file list after removing "./" from each file path
actions ClassArchive.jarArchive {
    cd $(2:Q) && $(MKDIR) -p $(1:DQ) && $(JAR) $(JARFLAGS:Q) "$(OTHER_JARFLAGS)" $(JAVA_MANIFEST_FILE:Q) $(1:Q) .
}
# Use zip command to generate an archive
# from the class file list after removing "./" from each file path
actions ClassArchive.zipArchive {
    cd $(2:Q) && $(MKDIR) -p $(1:DQ) && $(ZIP) $(ZIPFLAGS:Q) "$(OTHER_ZIPFLAGS)" $(1:Q) .
}

# Unarchive <location> : <archive>
rule Unarchive
{
    _DESTINATION_DIR = $(1:G=) ;
    if ! $(_DESTINATION_DIR) in $(PRODUCT_FILES) {
        Mkdir $(_DESTINATION_DIR) ;
        ProductFile $(_DESTINATION_DIR) ;
    }
    DEPENDS $(1) : $(_DESTINATION_DIR) ;
    DEPENDS $(1) : $(2) ;
    switch $(2:S) {
        case ".jar" : UnarchiveJar $(1) : $(2) ;
        case ".zip" : UnarchiveZip $(1) : $(2) ;
    }
}

# we use unzip to unarchive jars since it's much faster than jar, and we can exclude the manifest file
actions UnarchiveJar
{
    $(UNZIP) -oq $(2:Q) -x META-INF/MANIFEST.MF -d $(1:G=:Q)
}

actions UnarchiveZip
{
    $(UNZIP) -oq $(2:Q) -d $(1:G=:Q)
}

# ProcessSingleObjectLink <executable> : <inputs> : <rule>
# Calls link rule which then calls ProcessLink
# in order to generate a master object file
# which is also used for symbol editing
rule ProcessSingleObjectLink
{
    local OTHER_LINKED_FILES ;
    # Master object file kept in other directory to avoid name conflict

    MASTER_OBJECT_FILE_$(VARIANT) default = $(OBJECT_FILE_DIR_$(VARIANT))$(/)ProjectBuilderMasterObjectFile.o ;
    NonObjectFiles OTHER_LINKED_FILES : $(LINKED_FILES_$(VARIANT)) ;
    MasterObjectFile $(MASTER_OBJECT_FILE_$(VARIANT)) : $(OBJECT_FILES_$(VARIANT)) : $(EXPORTED_SYMBOLS_FILE) ;
    if $(OTHER_LINKED_FILES) = "" {
        OTHER_LINKED_FILES = $(MASTER_OBJECT_FILE_$(VARIANT)) ;
    }
    else {
        OTHER_LINKED_FILES += $(MASTER_OBJECT_FILE_$(VARIANT)) ;
    }
    if $(VECTOR_OBJECT_FILE) {
        OTHER_LINKED_FILES += $(VECTOR_OBJECT_FILE) ;
    }
    $(3) $(INNER_PRODUCT_$(VARIANT)) : $(OTHER_LINKED_FILES) ;
}

# ProcessLinkWithArchitectureSpecificEditing <executable> : <inputs> : <rule>
# !!!:cmolick:20021115 arch-specific editing is no longer used because symbols should uniform on all architectures
rule ProcessLinkWithArchitectureSpecificEditing
{
    for ARCH in $(ARCHS) {
        MASTER_OBJECT_FILE_$(ARCH)_$(VARIANT) default = $(OBJECT_FILE_DIR_$(VARIANT))$(/)ProjectBuilderMasterObjectFile$(ARCH).o ;
        MasterObjectFile $(MASTER_OBJECT_FILE_$(ARCH)_$(VARIANT)) : $(OBJECT_FILES_$(ARCH)_$(VARIANT)) : $(EXPORTED_SYMBOLS_FILE_$(ARCH)) ;
    }
    NonObjectFiles OTHER_LINKED_FILES : $(LINKED_FILES_$(VARIANT)) ;
    for ARCH in $(ARCHS) {
        if $(OTHER_LINKED_FILES) = "" {
            OTHER_LINKED_FILES = $(MASTER_OBJECT_FILE_$(ARCH)_$(VARIANT)) ;
        }
        else {
            OTHER_LINKED_FILES += $(MASTER_OBJECT_FILE_$(ARCH)_$(VARIANT)) ;
        }
    }
    if $(VECTOR_OBJECT_FILE) {
        OTHER_LINKED_FILES += $(VECTOR_OBJECT_FILE) ;
    }
    $(3) $(INNER_PRODUCT_$(VARIANT)) : $(OTHER_LINKED_FILES) ;
}

# ProcessLink <executable> : <inputs> : <rule>
# Processes <inputs> into <rule>.ARGUMENTS for later use by the <rule> rule
# where <inputs> are object files, libraries, frameworks, object file lists,
# and such and where <rule> is one of StaticLibrary, DynamicLibrary, or
# StandaloneExecutable.
rule ProcessLink
{
    local RULE = $(3) ;
    # Link as standalone executable unless another rule is specified
    RULE default = StandaloneExecutable ;
    # Set rule-specific flags such as StandaloneExecutable.FILELIST_FLAG
    # and store the values in local variables
    local FILELIST_FLAG = $($(RULE).FILELIST_FLAG:G=) ;
    local LIBRARY_FLAG = $($(RULE).LIBRARY_FLAG:G=) ;
    local FRAMEWORK_FLAG = $($(RULE).FRAMEWORK_FLAG:G=) ;
    local FILELIST_NOSPACE = $($(RULE).FILELIST_FLAG:G) ;
    local LIBRARY_NOSPACE = $($(RULE).LIBRARY_FLAG:G) ;
    local FRAMEWORK_NOSPACE = $($(RULE).FRAMEWORK_FLAG:G) ;
    local BATCH_OFILES = $($(RULE).BATCH_OFILES) ;
    # The product depends on all of the input files, although
    # library and framework references may not be resolvable.
    DEPENDS $(1) : $(2) ;
    # link depends on file list
    LINK_FILE_LIST_$(VARIANT) = $(FILE_LIST_$(VARIANT)) ;
    DEPENDS $(1) : $(LINK_FILE_LIST_$(VARIANT)) ;
    # Deal with each input file in turn
    local LINKED ;
    local ARGUMENT ;
    for LINKED in $(2) {
        $(RULE).FILES$(LINKED:S) on $(1) += $(LINKED) ;
        switch $(LINKED:BS) {
            case *.o :
                # If $(BATCH_OFILES) is true then object file lists are generated.
                if $(BATCH_OFILES) != NO {
                    ClearFileList $(LINK_FILE_LIST_$(VARIANT)) ;
                    AppendToFileList $(LINK_FILE_LIST_$(VARIANT)) : $(LINKED) ;
                    DEPENDS $(LINK_FILE_LIST_$(VARIANT)) : $(LINKED) ;
                } else {
                    $(RULE).ARGUMENTS on $(1) += $(LINKED) ;
                }
            case *.objects :
                if $(FILELIST_NOSPACE) {
                    ARGUMENT = $(FILELIST_FLAG)$(LINKED) ;
                    NOTFILE $(ARGUMENT) ;
                } else {
                    NOTFILE $(FILELIST_FLAG) ;
                    ARGUMENT = $(FILELIST_FLAG) $(LINKED) ;
                }
                $(RULE).ARGUMENTS on $(1) += $(ARGUMENT) ;
            case lib*.a :
                if $(LIBRARY_FLAG) {
                    LINKED = $(LINKED:A) ;
                }
                NOCARE $(LINKED) ;
                if $(LIBRARY_NOSPACE) {
                    ARGUMENT = $(LIBRARY_FLAG)$(LINKED) ;
                } else {
                    ARGUMENT = $(LIBRARY_FLAG) $(LINKED) ;
                }
                $(RULE).ARGUMENTS on $(1) += $(ARGUMENT) ;
                NOTFILE $(ARGUMENT) ;
            case *.lib :
                NOCARE $(LINKED) ;
                if $(LIBRARY_FLAG) {
                    if $(LIBRARY_NOSPACE) {
                        ARGUMENT = $(LIBRARY_FLAG)$(LINKED:A) ;
                    } else {
                        ARGUMENT = $(LIBRARY_FLAG) $(LINKED:A) ;
                    }
                    $(RULE).ARGUMENTS on $(1) += $(ARGUMENT) ;
                    NOTFILE $(ARGUMENT) ;
                } else {
                    ECHO jam: warning: For target $(1), rule $(RULE) will ignore $(LINKED) ;
                }
            case *.dylib :
                NOCARE $(LINKED) ;
                if $(LIBRARY_FLAG) {
                    if $(LIBRARY_NOSPACE) {
                        ARGUMENT = $(LIBRARY_FLAG)$(LINKED:A) ;
                    } else {
                        ARGUMENT = $(LIBRARY_FLAG) $(LINKED:A) ;
                    }
                    $(RULE).ARGUMENTS on $(1) += $(ARGUMENT) ;
                    NOTFILE $(ARGUMENT) ;
                } else {
                    ECHO jam: warning: For target $(1), rule $(RULE) will ignore $(LINKED) ;
                }
            case *.framework :
                NOCARE $(LINKED) ;
                if $(FRAMEWORK_FLAG) {
                    if $(FRAMEWORK_NOSPACE) {
                        ARGUMENT = $(FRAMEWORK_FLAG)$(LINKED:B) ;
                    } else {
                        ARGUMENT = $(FRAMEWORK_FLAG) $(LINKED:B) ;
                    }
                    $(RULE).ARGUMENTS on $(1) += $(ARGUMENT) ;
                    NOTFILE $(ARGUMENT) ;
                } else {
                    ECHO jam: warning: For target $(1), rule $(RULE) will ignore $(LINKED) ;
                }
	    case *.jar :
		# silently ignore Java archives since they are valid, but not used for native linking
	    case *.zip :
		# silently ignore Java archives since they are valid, but not used for native linking
            case * :
                ECHO Warning: $(RULE): Unknown extension on "$(LINKED:BS)" when linking with $(RULE) ;
        }
    }
    # include any object files compiled from objc generated with bridget
    if $(BRIDGET_FILE_LIST) {
        AppendFileToFileList $(LINK_FILE_LIST_$(VARIANT)) : $(BRIDGET_FILE_LIST) ;
    }
    if $(BATCH_OFILES) != NO {
        $(RULE).LinkUsingFileList $(1) : $(LINK_FILE_LIST_$(VARIANT)) ;
    }
    else {
        $(RULE).Link $(1) ;
    }
}

actions quietly together piecemeal ClearFileList
{
    $(RM) -rf "$(1)"
}

actions quietly together piecemeal AppendToFileList
{
    for file_reference in "$(2)"
    do
        $(ECHO) "$file_reference" >> "$(1)"
    done
}

actions quietly together piecemeal AppendFileToFileList
{
    cat "$(2)" >> "$(1)"
}

# StaticLibrary <library> : <inputs>
# Stores <inputs> in <library> where <inputs> are object files,
# libraries, frameworks, object file lists, and such
rule StaticLibrary
{
    LIBRARY_SEARCH_PATHS on $(1) = $(LIBRARY_SEARCH_PATHS) ;
    ProcessLink $(1) : $(2) : StaticLibrary ;
    FLAGS.o on $(1) = $(LDFLAGS) $(SECTORDER_FLAGS) ;
}
actions together StaticLibrary
{
}
actions quietly together piecemeal StaticLibrary.Link bind StaticLibrary.ARGUMENTS
{
    ( $(LIBTOOL) -o $(1:Q) $(2:Q) "-L$(LIBRARY_SEARCH_PATHS)" "$(StaticLibrary.ARGUMENTS)" "$(FLAGS.o)" $(INSTALLED_NAME_FLAG) && $(RANLIB) $(1:Q) )
}
actions quietly together piecemeal StaticLibrary.LinkUsingFileList bind StaticLibrary.ARGUMENTS
{
    ( $(LIBTOOL) -o $(1:Q) "-L$(LIBRARY_SEARCH_PATHS)" -filelist $(2:Q) "$(StaticLibrary.ARGUMENTS)" "$(FLAGS.o)" $(INSTALLED_NAME_FLAG) && $(RANLIB) $(1:Q) )
}
StaticLibrary.FRAMEWORK_FLAG = ;
StaticLibrary.LIBRARY_FLAG = ;
StaticLibrary.BATCH_OFILES default = YES ;

# StandaloneExecutable <executable> : <inputs>
# Links <inputs> to produce <executable>, where <inputs> are objects,
# libraries, frameworks, and such.
rule StandaloneExecutable
{
    ProcessLink $(1) : $(2) ;
    FRAMEWORK_SEARCH_PATHS on $(1) = $(FRAMEWORK_SEARCH_PATHS) ;
    LIBRARY_SEARCH_PATHS on $(1) = $(LIBRARY_SEARCH_PATHS) ;
    FLAGS.o on $(1) = $(ARCH_FLAGS) $(LDFLAGS) $(SECTORDER_FLAGS) ;
    if $(INIT_ROUTINE) {
        FLAGS.o on $(1) += -init $(INIT_ROUTINE) ;
    }
}
StandaloneExecutable.FILELIST_FLAG = -filelist ;
StandaloneExecutable.FRAMEWORK_FLAG = -framework ;
StandaloneExecutable.LIBRARY_FLAG = <nospace>-l ;
StandaloneExecutable.BATCH_OFILES default = YES ;
actions together StandaloneExecutable
{
}
actions quietly together StandaloneExecutable.Link bind StandaloneExecutable.ARGUMENTS
{
    $(_LD_FOR_LINKING) -o $(1:Q) "-L$(LIBRARY_SEARCH_PATHS)" "-F$(FRAMEWORK_SEARCH_PATHS)" "$(FLAGS.o)" $(INSTALLED_NAME_FLAG) "$(StandaloneExecutable.ARGUMENTS)"
}
actions quietly together StandaloneExecutable.LinkUsingFileList bind StandaloneExecutable.ARGUMENTS
{
    $(_LD_FOR_LINKING) -o $(1:Q) "-L$(LIBRARY_SEARCH_PATHS)" "-F$(FRAMEWORK_SEARCH_PATHS)" -filelist $(2:Q) "$(FLAGS.o)" $(INSTALLED_NAME_FLAG) "$(StandaloneExecutable.ARGUMENTS)"
}


# DynamicLibrary <library> : <objects> : <libraries>
# Links <objects> and <libraries> to produce <library>, using $(FLAGS.o)
rule DynamicLibrary
{
    LIBRARY_SEARCH_PATHS on $(1) = $(LIBRARY_SEARCH_PATHS) ;
    FRAMEWORK_SEARCH_PATHS on $(1) = $(FRAMEWORK_SEARCH_PATHS) ;
    ProcessLink $(1) : $(2) : DynamicLibrary ;
    FLAGS.o on $(1) = $(ARCH_FLAGS) $(LDFLAGS) $(SECTORDER_FLAGS) ;
    if $(INIT_ROUTINE) {
        FLAGS.o on $(1) += -init $(INIT_ROUTINE) ;
    }
}
actions together DynamicLibrary
{
}
actions quietly together DynamicLibrary.Link bind DynamicLibrary.ARGUMENTS DynamicLibrary.DEFFILE
{
    $(_LD_FOR_LINKING) -o $(1:Q) $(DynamicLibrary.DEFFILE_FLAG)"$(DynamicLibrary.DEFFILE)" "-L$(LIBRARY_SEARCH_PATHS)" "-F$(FRAMEWORK_SEARCH_PATHS)" "$(DynamicLibrary.ARGUMENTS)" "$(FLAGS.o)" $(INSTALLED_NAME_FLAG)
}
actions quietly together DynamicLibrary.LinkUsingFileList bind DynamicLibrary.ARGUMENTS DynamicLibrary.DEFFILE
{
    $(_LD_FOR_LINKING) -o $(1:Q) $(DynamicLibrary.DEFFILE_FLAG)"$(DynamicLibrary.DEFFILE)" "-L$(LIBRARY_SEARCH_PATHS)" "-F$(FRAMEWORK_SEARCH_PATHS)" -filelist $(2:Q) "$(DynamicLibrary.ARGUMENTS)" "$(FLAGS.o)" $(INSTALLED_NAME_FLAG)
}
DynamicLibrary.DEFFILE_FLAG = "-Xlinker -DEF:" ;
DynamicLibrary.FILELIST_FLAG = -filelist ;
DynamicLibrary.FRAMEWORK_FLAG = -framework ;
DynamicLibrary.LIBRARY_FLAG = <nospace>-l ;
DynamicLibrary.BATCH_OFILES default = YES ;

# MasterObjectFile <master object file> : <object files> : <exports file> : [<arch>]
# Merges many object files into one in order to edit
# the list of exported symbols
rule MasterObjectFile
{
    local OBJECT_FILE ;
    if $(4) {
        LINK_FILE_LIST_$(VARIANT) = $(FILE_LIST_$(VARIANT))Prelink_$(4) ;
    }
    else {
        LINK_FILE_LIST_$(VARIANT) = $(FILE_LIST_$(VARIANT))Prelink ;
    }
    # object files must be present before master can be assembled
    DEPENDS $(1) : $(2) ;
    # list object files in a file to limit link line length
    DEPENDS $(1) : $(LINK_FILE_LIST_$(VARIANT)) ;
    ClearFileList $(LINK_FILE_LIST_$(VARIANT)) ;
    for LINKED in $(2) {
        AppendToFileList $(LINK_FILE_LIST_$(VARIANT)) : $(LINKED) ;
        DEPENDS $(LINK_FILE_LIST_$(VARIANT)) : $(LINKED) ;
    }
    if $(KEEP_PRIVATE_EXTERNS) != NO {
        KEEP_PRIVATE_EXTERNS_FLAG on $(1) = -keep_private_externs ;
    }
    if $(GLUE_FILE_LIST) {
        DEPENDS $(LINK_FILE_LIST_$(VARIANT)) : $(GLUE_FILE_LIST) ;
        AppendFileToFileList $(LINK_FILE_LIST_$(VARIANT)) : $(GLUE_FILE_LIST) ;
    }
    PRELINK_FLAGS on $(1) = $(PRELINK_FLAGS) ;
    PRELINK_LIBS on $(1) = $(PRELINK_LIBS) ;
    # !!!:cmolick:20021021 provide an optional way for the target to depend on the PRELINK_LIBS?
    if $(_BUILD_PHASING) = YES {
        BUILD_PHASE_PRODUCTS += $(1) ;
    }
    MasterObjectFile.Combine $(1) : $(LINK_FILE_LIST_$(VARIANT)) ;
    if $(3) {
        INCLUDES $(1) : $(3) ;
        MasterObjectFile.EditExports $(1) : $(3) ;
    }
}
actions MasterObjectFile.Combine
{
    $(_LD_FOR_LINKING) $(ARCH_FLAGS) $(KEEP_PRIVATE_EXTERNS_FLAG) $(GLOBAL_CFLAGS) -L$(LIBRARY_SEARCH_PATHS:Q) -F$(FRAMEWORK_SEARCH_PATHS:Q) $(PRELINK_FLAGS:Q) $(WARNING_LDFLAGS) -nostdlib -filelist $(2:Q) -r -o $(1:Q) $(PRELINK_LIBS:Q)
}
actions MasterObjectFile.EditExports
{
    $(NMEDIT) -s $(2:Q) $(1:Q) -o $(1:Q)
}

# EditSymbols <binary> : <symbols file>
# !!!:cmolick:20021022 rule for invoking nmedit needed until exported symbols flags available for linker
rule EditSymbols
{
    DEPENDS $(1) : $(2) ;
}
actions EditSymbols
{
    $(NMEDIT) -s $(2:Q) $(1:Q) -o $(1:Q)
}

# Ranlib <library>
# Ranlib for static library
actions Ranlib
{
    $(RANLIB) $(1:Q)
}

# VersioningSystem_next-cvs <product>
# Handles automatic generation of CVSVersionInfo.txt file for projects that use NeXT CVS-style versioning.
rule VersioningSystem_next-cvs
{
    local VERSION_INFO_FILE ;
    VERSION_INFO_FILE default = $(1:B)_vers.c ;
    # Make sure that the C file containing the version string gets created.
    VersioningSystem_next-cvs.Create $(VERSION_INFO_FILE) : $(1:B) ;
    DerivedFiles $(VERSION_INFO_FILE) ;
    SUPPRESS_PREFIX_HEADER = YES ;
    ProcessFile $(1) : $(VERSION_INFO_FILE) ;
    SUPPRESS_PREFIX_HEADER = NO ;

    # Set up default values for the variables.
    CVS_VERS_FILE default = CVSVersionInfo.txt ;
}
rule VersioningSystem_next-cvs.Create
{
    DEPENDS $(1) : $(CVS_VERS_FILE) ;
}
actions VersioningSystem_next-cvs.Create
{
    versFile="$(CVS_VERS_FILE)"
    awk=/usr/bin/awk
    user=`$awk '/\\$\Id:/ {print $7;}' $versFile`
    timestamp=`$awk '/\\$\Id:/ {print $5 " " $6;}' $versFile`
    fileVers=`$awk '/\\$\Id:/ {print $4;}' $versFile`
    name=`$awk '/^ProjectName:/ {print $2;}' $versFile`
    tag=`$awk '/\\$\Name:/ {print $3;}' $versFile`
    versNum=`$awk '/^ProjectVersion:/ {print $2;}' $versFile`
    proj="$(2:B)"
    clean_proj_name=`echo $proj | sed 's/[^0-9A-Za-z]/_/g'`
    # the keyword name is the current tag and only gets filled in if the files are extracted at
    # that tag. If the tag has a value, then it is a released version, if the tag is '$' then
    # it has no value and is a development version.
    case $tag in '$') vers="$versNum.dev";; *) vers=$versNum;; esac
    q='"'
    vers_str="Project:$proj Version:$vers (Checkpoint by:$user on:$timestamp revision:$fileVers)"
    vers_suffix="$(CURRENT_PROJECT_VERSION_SUFFIX)"
    echo "const char "$clean_proj_name"_VERS_STRING[] = $q@(#)$vers_str$q;" > "$(1)"
    echo "const char "$clean_proj_name"_VERS_NUM[] = $q$vers$vers_suffix$q;" >> "$(1)"
}

# VersioningSystem_apple-generic <product>
# Generates <product>_vers.c to define version symbol
rule VersioningSystem_apple-generic
{
    # Set values to use
    local VERSION_INFO_FILE ;
    VERSION_INFO_FILE default = $(1:B)_vers.c ;

    # variables used need to be defined on the version info file target
    CURRENT_PROJECT_VERSION on $(VERSION_INFO_FILE) = $(CURRENT_PROJECT_VERSION) ;
    VERSION_INFO_EXPORT_DECL on $(VERSION_INFO_FILE) default = $(VERSION_INFO_EXPORT_DECL) ;
    VERSION_INFO_PREFIX on $(VERSION_INFO_FILE) default = $(VERSION_INFO_PREFIX) ;
    VERSION_INFO_SUFFIX on $(VERSION_INFO_FILE) default = $(VERSION_INFO_SUFFIX) ;
    VERSION_INFO_BUILDER on $(VERSION_INFO_FILE) default = $(USER) ;

    # Create versioning code
    VersioningSystem_apple-generic.Create $(VERSION_INFO_FILE) : $(1) ;
    DerivedFiles $(VERSION_INFO_FILE) ;
    SUPPRESS_PREFIX_HEADER = YES ;
    ProcessFile $(1) : $(VERSION_INFO_FILE) ;
    SUPPRESS_PREFIX_HEADER = NO ;
}
actions VersioningSystem_apple-generic.Create
{
    raw_project_name=$(PROJECT:Q)
    project_name=`echo $raw_project_name | sed 's/[^0-9A-Za-z]/_/g'`
    raw_target_name=$(2:BQ)
    target_name=`echo $raw_target_name | sed 's/[^0-9A-Za-z]/_/g'`
    project_vers="$(CURRENT_PROJECT_VERSION)"
    vers_info_export_decl="$(VERSION_INFO_EXPORT_DECL)"
    vers_info_prefix="$(VERSION_INFO_PREFIX)"
    vers_info_suffix="$(VERSION_INFO_SUFFIX)"
    vers_info_builder="$(VERSION_INFO_BUILDER)"
    printf "%s%s\n" ${vers_info_export_decl} " const unsigned char ${vers_info_prefix}${target_name}VersionString${vers_info_suffix}[] __attribute__ ((used)) = \"@(#)PROGRAM:${target_name}  PROJECT:${project_name}-${project_vers}  DEVELOPER:${vers_info_builder}  BUILT:\" __DATE__  \" \" __TIME__ \"\n\";" > "$(1)"
    printf "%s%s\n" ${vers_info_export_decl} " const double ${vers_info_prefix}${target_name}VersionNumber${vers_info_suffix} __attribute__ ((used)) = (double)${project_vers};" >> $(1:Q)
}

# KernelModuleGeneratedSource
# Creates a kernel module source stub based on the values
# of MODULE_VERSION, MODULE_START, and MODULE_STOP
rule KernelModuleGeneratedSource
{
    MODULE_INFO_FILE_$(VARIANT) default = $(1:B)_info.c ;
    DerivedFiles $(MODULE_INFO_FILE_$(VARIANT)) ;
    DEPENDS $(MODULE_INFO_FILE_$(VARIANT)) : $(MODULE_INFO_PLIST) ;
    MODULE_VERSION on $(MODULE_INFO_FILE_$(VARIANT)) = $(MODULE_VERSION) ;
    MODULE_NAME on $(MODULE_INFO_FILE_$(VARIANT)) = $(MODULE_NAME) ;
    if $(MODULE_IOKIT) = "YES" {
        MODULE_START on $(MODULE_INFO_FILE_$(VARIANT)) = 0 ;
        MODULE_STOP on $(MODULE_INFO_FILE_$(VARIANT)) = 0 ;
    }
    else {
        if $(MODULE_START) = "" {
            MODULE_START on $(MODULE_INFO_FILE_$(VARIANT)) = 0 ;
        } else {
            MODULE_START on $(MODULE_INFO_FILE_$(VARIANT)) = $(MODULE_START) ;
        }
        if $(MODULE_STOP) = "" {
            MODULE_STOP on $(MODULE_INFO_FILE_$(VARIANT)) = 0 ;
        } else {
            MODULE_STOP on $(MODULE_INFO_FILE_$(VARIANT)) = $(MODULE_STOP) ;
        }
    }
    KernelModuleGeneratedSource.Create $(MODULE_INFO_FILE_$(VARIANT)) ;
    SUPPRESS_PREFIX_HEADER = YES ;
    ProcessFile $(1) : $(MODULE_INFO_FILE_$(VARIANT)) ;
    SUPPRESS_PREFIX_HEADER = NO ;
}
actions KernelModuleGeneratedSource.Create
{
    /bin/echo "#include <mach/mach_types.h>" > $(1:Q)
    /bin/echo " " >> $(1:Q)
    /bin/echo "extern kern_return_t _start(kmod_info_t *ki, void *data);" >> $(1:Q)
    /bin/echo "extern kern_return_t _stop(kmod_info_t *ki, void *data);" >> $(1:Q)
    if [ $(MODULE_START) != 0 ]; then
        /bin/echo "__private_extern__ kern_return_t $(MODULE_START)(kmod_info_t *ki, void *data);" >> $(1:Q)
    fi
    if [ $(MODULE_STOP) != 0 ]; then
        /bin/echo "__private_extern__ kern_return_t $(MODULE_STOP)(kmod_info_t *ki, void *data);" >> $(1:Q)
    fi
    /bin/echo " " >> $(1:Q)
    /bin/echo "KMOD_EXPLICIT_DECL($(MODULE_NAME), \"$(MODULE_VERSION)\", _start, _stop)" >> $(1:Q)
    /bin/echo "__private_extern__ kmod_start_func_t *_realmain = $(MODULE_START);" >> $(1:Q)
    /bin/echo "__private_extern__ kmod_stop_func_t *_antimain = $(MODULE_STOP);" >> $(1:Q)
    /bin/echo "__private_extern__ int _kext_apple_cc = __APPLE_CC__ ;" >> $(1:Q)
}

# GenerateFrameworkStub <framework stub>
# Invokes a custom tool to generate a Mach-O framework executable stub at the specified path
# Also be sure to the FRAMEWORK_INSTALL_NAME variable on the <framework stub>
actions GenerateFrameworkStub
{
    $(MKDIR) -p $(DERIVED_FILE_DIR:Q)
    dummy_class_name=`echo -n $(1:B) | tr -c '[:alnum:]' '_'`
    $(ECHO) "@interface NSFramework_${dummy_class_name}" > $(DERIVED_FILE_DIR:Q)/framework_stub.m
    $(ECHO) "@end" >> $(DERIVED_FILE_DIR:Q)/framework_stub.m
    $(ECHO) "@implementation NSFramework_${dummy_class_name}" >> $(DERIVED_FILE_DIR:Q)/framework_stub.m
    $(ECHO) "@end" >> $(DERIVED_FILE_DIR:Q)/framework_stub.m
    $(CC) -c $(DERIVED_FILE_DIR:Q)/framework_stub.m $(ARCH_FLAGS) -o $(DERIVED_FILE_DIR:Q)/framework_stub.o
    $(_LD_FOR_LINKING) $(ARCH_FLAGS) -dynamiclib $(INSTALLED_NAME_FLAG) $(DYLIB_VERSION_FLAGS:Q) -L$(LIBRARY_SEARCH_PATHS:Q) -F$(FRAMEWORK_SEARCH_PATHS:Q) $(DynamicLibrary.ARGUMENTS:Q) $(DERIVED_FILE_DIR:Q)/framework_stub.o -o $(1:Q)
    $(STRIP) $(STRIPFLAGS:Q) $(1:Q)
}
