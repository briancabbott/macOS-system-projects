#!/usr/bin/perl
# $Copyright:
#
# Copyright 1998-2000 by the Massachusetts Institute of Technology.
# 
# All rights reserved.
# 
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose and without fee is hereby granted,
# provided that the above copyright notice appear in all copies and that
# both that copyright notice and this permission notice appear in
# supporting documentation, and that the name of M.I.T. not be used in
# advertising or publicity pertaining to distribution of the software
# without specific, written prior permission.  Furthermore if you modify
# this software you must label your software as modified software and not
# distribute it in such a fashion that it might be confused with the
# original MIT software. M.I.T. makes no representations about the
# suitability of this software for any purpose.  It is provided "as is"
# without express or implied warranty.
# 
# THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
# 
# Individual source code files are copyright MIT, Cygnus Support,
# OpenVision, Oracle, Sun Soft, FundsXpress, and others.
# 
# Project Athena, Athena, Athena MUSE, Discuss, Hesiod, Kerberos, Moira,
# and Zephyr are trademarks of the Massachusetts Institute of Technology
# (MIT).  No commercial use of these trademarks may be made without prior
# written permission of MIT.
# 
# "Commercial use" means use of a name in a product or other for-profit
# manner.  It does NOT prevent a commercial firm from referring to the MIT
# trademarks in order to convey information (although in doing so,
# recognition of their trademark status should be given).
# $
#

# $Header$

use strict;

my $errorCodeRange = 8;
my $charShift = 6;
my @NumberToChar = (' ', 
	'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 
	'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 

	'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 
	'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 
	
	'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '_',
);

my $errorList = shift @ARGV or die "$0: Usage: GenerateErrorList <ErrorList>\n";
my %ets;

open ERRORLIST, "$errorList" or die "$0: unable to open $errorList: $!\n";
while (<ERRORLIST>) {
	if (/\s*"([^"]+)"\s+(-?[0-9]+)\s+"([^"]+)"\s+"([^"]*)"\s*$/) {
		my $error = {};
		
		$error->{manager} = $1;
		$error->{code} = $2;
		$error->{short} = $3;
		$error->{long} = $4;
		
		push @{ $ets{$1} }, $error;
	} else {
		print "Warning: unable to parse line:\n${_}\n"; 
	}
}

close ERRORLIST;

my $etManager;
foreach $etManager (keys(%ets)) {
	my @et = @{ $ets{$etManager} };

	sub errorSort { 
		$a->{code} <=> $b->{code}; 
	}
	@et = sort errorSort @et;	
	
	my $etBase = ($et[0])->{code};
	my $etName = substr ($etManager, 0 , 4);
	$etName =~ s/ /_/g;
	
	my $errorTableFile = "${etManager}.et";
	print "Creating $errorTableFile...\n";
	
	open ERRORTABLE, ">$errorTableFile" or 
		die "$0: Unable to open $errorTableFile for writing:$!\n";
	
	print ERRORTABLE "#\n";
	print ERRORTABLE "# ${errorTableFile}:\n";
	print ERRORTABLE "# This file is automatically generated; please do not edit it.\n";
	print ERRORTABLE "#\n\n";
	print ERRORTABLE "error_table_base ${etBase}\n";
	print ERRORTABLE "error_table_manager \"${etManager}\"\n";
	print ERRORTABLE "error_table ${etName}\n\n";
	
	my $error = {};
	my $code = $etBase;
	my $offset = 0;
	for (my $i = 0; $i <= $#et; $i++) {
		if ($code > $et[$i]->{code}) {
			die "$0: Error!  Error table sorting failed!\n";
		}
		if ($code < $et[$i]->{code}) {
			my $skipStart = $code;
			while ($code < $et[$i]->{code}) {
				$code++; $offset++
			}
			printf ERRORTABLE "index %-4d # skipped %d", $offset, $skipStart;
			if ($skipStart < ($code - 1)) {
				printf ERRORTABLE " to %d", $code - 1;
			}
			print ERRORTABLE "\n";		
		}
		printf ERRORTABLE "error_code %-25s \"%s\"\n", 
					$et[$i]->{short} . ",", $et[$i]->{long};
		$code++; $offset++;
	}
	print ERRORTABLE "\nend\n";
	
	close ERRORTABLE;
}

