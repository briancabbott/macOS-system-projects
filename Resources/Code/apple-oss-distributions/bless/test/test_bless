#! /usr/bin/python3
#
# Copyright (c) 2020 Apple Inc. All rights reserved.
#
# Updated from Python 2 to Python 3 by Casey Hafley
#
# This program tests BLESS(8) Command Line Interface.
#
# To add a new test case:
#    (1) create a test_<testname> routine
#    (2) update TestListDictionary with the new test information
#
import sys
import os
import logging
import re
import plistlib
import subprocess
from subprocess import Popen, PIPE
from ShareModule import Source
from ShareModule import TYPE_SRC_ROSV, TYPE_SRC_OSVOL
from ShareModule import FLAG_SRC_SSV
from ShareModule import OSDIR, OSDIR_GOLDENGATE, OSDIR_JAZZ, OSDIR_LIB
from ShareModule import SWEDMGname, DMGDIR
from ShareModule import Startup, Teardown, testBegin, testEnd
from ShareModule import docmd, docmd_common, docmd_plist
from ShareModule import DeviceToMntpt, getSystemVolumeDev, get_nvram_value
from ShareModule import seal_source, log_cleanup, check_arm
from ShareModule import checkFileDirExist, verifyCmdOutputForStrngs, remSpecialChars
from ShareModule import getUniqName, addVolumeToContainer, createContainer
from ShareModule import skip_count

Debug = False
ErrorPause = False

# Check to see if system volume is blessed and bless it if not
# def checkBlessStatus():
#     bless_status = Popen(['nvram' ,'efi-boot-device'], stdout=PIPE, stderr=PIPE)
#     out, err = bless_status.communicate()
#     if bless_status.returncode == 0:
#        logging.info("System volume is blessed" + out)
#     else:
#         logging.error("System volume is not blessed" + err)
#     return bless_status.returncode

blessing_changed = False


def run_command(command):
    return subprocess.check_output(command)


def isBootVolumeSet():
    # Returns True / False based on nvram - p
    output = run_command(['nvram', '-p'])
    output = bytes.decode(output)
    search = r"^efi-boot-device"
    match = re.search(search, output, re.MULTILINE)
    return match is not None


def setBootVolume():
    # blessing the root volume
    run_command(['bless', '--setBoot', '--folder', '/System/Library/CoreServices'])
    global blessing_changed
    blessing_changed = True
    print("Setting boot volume with bless --setBoot --folder /System/Library/CoreServices")


def unsetBootVolume():
    # un-setting a blessed volume
    run_command(['nvram', '-d', 'efi-boot-device'])
    print("Unsetting Boot volume with nvram -d efi-boot-device")

# ================================================
#    HELPER FUNCTIONS
# ================================================

#
# test_bless program usage
#


def usage():
    print('Usage:')
    print('    test_bless all | presubmit | remote <option> (Run all or a subset of tests)')
    print('    test_bless <testname> <option> (Run a given <testname>)')
    print('    <option>')
    print('        -debug        (Exit right after bless command to debug)')
    print('        -errorpause   (Pause the process on error before clean up)')
    print('        -localmacos   (Get OS image from $HOME/Downloads/test_bless/)')
    print('    test_bless -l     (list all <testname>s)')
    print('    test_bless -c     (clean up all log directories)')
    print('')


#
# called by bless_basic test at the end for cleaning up
# It will call endTest
#
def endBlessBasic(returnCode, imgDisk, imgPath, bIS, bAS, savedNVRAM):
    global ErrorPause

    if returnCode != 0:
        logging.error("test exited ABNORMALLY")

    logging.info("at exit with result=" + str(returnCode))
    logging.info("cleaning up the test")

    if bIS:
        logging.info("Restore NVRAM efi-boot-device setting if needed")
        # breakpoint()
        if savedNVRAM[0] and len(savedNVRAM[0]) > 100 and savedNVRAM[0].find(b"efi-boot-device") >= 0:
            aStr = savedNVRAM[0][
                16:]  # Get rid of the left-hand-side plus spacer before the right-hand-side value of the nvram -p output
            logging.info(
                "doing NVRAM WRITE command of efi-boot-device setting; the efi-boot-device-data should automatically follow")
            aStr = bytes.decode(aStr)
            cmd = ['nvram', f'efi-boot-device={aStr}']
            logging.info("call: {}".format(cmd))
            result = Popen(cmd, stdout=PIPE, stderr=PIPE)
            out, err = result.communicate()
            out = out.strip(b'\n')
            out = bytes.decode(out)
            err = bytes.decode(err)
            if out:
                logging.info("NVRAM WRITE stdout=" + out)
                logging.info("NVRAM WRITE stderr=" + err)
    # breakpoint()
    if bAS:
        logging.info("Restore NVRAM boot-device setting if needed")
        if savedNVRAM[1] and len(savedNVRAM[1]) > 30 and savedNVRAM[1].find("boot-volume") >= 0:
            aStr = savedNVRAM[1][
                12:]  # Get rid of the left-hand-side plus spacer before the right-hand-side value of the nvram -p output
            logging.info(
                "doing NVRAM WRITE command of boot-volume setting; the boot-volume should automatically follow")
            cmd = ['nvram', 'boot-volume=' + aStr]
            logging.info("call: {}".format(cmd))
            result = Popen(cmd, stdout=PIPE, stderr=PIPE)
            out, err = result.communicate()
            out = out.strip(b'\n')
            out = bytes.decode(out)
            err = bytes.decode(err)
            if out:
                logging.info("NVRAM WRITE stdout=" + out)
                logging.info("NVRAM WRITE stderr=" + err)
    docmd(['diskutil', 'eject', imgDisk])
    docmd(['rm', '-r', imgPath + '.sparsebundle'])
    # imgPath is missing .sparsebundle at the end
    testEnd("bless_basic", None, None, returnCode, ErrorPause)
    return returnCode


# ================================================
#    CLASS: TEST
# ================================================
#
#  TEST CLASS
#
TESTFLAG_FOLDER = 1 << 1
TESTFLAG_MOUNT = 1 << 2
TESTFLAG_INFO = 1 << 3
TESTFLAG_Bootefi = 1 << 4
TESTFLAG_CreateSnap = 1 << 5
TESTFLAG_LastSealedSnap = 1 << 6
TESTFLAG_SetBoot = 1 << 7
TESTFLAG_GetBoot = 1 << 8
TESTFLAG_Verbose = 1 << 9
TESTFLAG_OnDataVol = 1 << 10


class Test:
    def __init__(self, testname, testflag, srcopts):
        self.testname = testname
        self.testflag = testflag
        self.srcopts = srcopts

    def do_bless(self, src):
        # breakpoint()
        cmd = ['bless']

        if src.flag & FLAG_SRC_SSV:
            err = seal_source(src)
            if err:
                return err

        if src.apfsVdev != '':
            err = docmd(['/usr/sbin/diskutil', 'mount', src.apfsVdev])
        if err == 0 and src.apfsDVdev != '':
            err = docmd(['/usr/sbin/diskutil', 'mount', src.apfsDVdev])
        if err:
            return err

        # FOLDER, MOUNT, INFO modes
        if self.testflag & TESTFLAG_OnDataVol:
            mntpt = src.apfsDVmntpt
        else:
            mntpt = src.apfsVmntpt
        if self.testflag & TESTFLAG_FOLDER:
            folder = mntpt + '/System/Library/CoreServices/'
            cmd = cmd + ['--folder', folder]
        if self.testflag & TESTFLAG_MOUNT:
            cmd = cmd + ['--mount', mntpt]
        if self.testflag & TESTFLAG_INFO:
            cmd = cmd + ['--info', mntpt]

        # Options
        if self.testflag & TESTFLAG_Bootefi:
            cmd = cmd + ['--bootefi']
        if self.testflag & TESTFLAG_CreateSnap:
            cmd = cmd + ['--create-snapshot']
        if self.testflag & TESTFLAG_LastSealedSnap:
            cmd = cmd + ['--last-sealed-snapshot']
        if self.testflag & TESTFLAG_SetBoot:
            cmd = cmd + ['--setBoot']
        if self.testflag & TESTFLAG_GetBoot:
            cmd = cmd + ['--getBoot']
        if self.testflag & TESTFLAG_Verbose:
            cmd = cmd + ['--verbose']

        err = docmd(cmd)
        return err

    def verify(self, src):
        #
        # XXX add a check for OS.dmg.root_hash file in preboot.
        # A system is considered ARV if preboot has root hash file
        # or sealed property is present.
        #
        if self.testflag & TESTFLAG_CreateSnap:
            logging.info('Verifying --create-snapshot ...')
            print('Verifying --create-snapshot ...\n')
            out, err = docmd_common(
                ['/usr/local/bin/apfs_snapshot', '-l', src.apfsVmntpt])
            out = bytes.decode(out)
            # err = bytes.decode(err) doesn't apply to int objects
            if err == 0 and out.startswith('com.apple.bless.') and ('Volume will be rooted from this snapshot on next mount' in out):
                logging.info('Verifying --create-snapshot Done')
                print('Verifying --create-snapshot Done\n')
                return 0
            else:
                logging.error('Verifying --create-snapshot Failed')
                print('Verifying --create-snapshot Failed\n')
                return 1

        return 0

    #
    # More verification - TBD
    #
    # XXX --create-snapshot
    #    . sealed system snapshot: Preboot volume should have
    #      <GroupUUID>/usr/standalone/OS.dmg.root_hash
    #      snapshot name: com.apple.os.update-*
    #    . a new snapshot is created
    #    . this snapshot is set to be next root
    #    . the boot object is copied from this snapshot to preboot
    #
    # If blessed-volume is ARV
    #    . KC files are copied with --create-snapshot
    #      or --last-sealed-snapshot
    #    . KC files are not copied without --create-snapshot
    #      or --last-sealed-snapshot
    # If blessed-volume is not ARV
    #    . KC files will be copied with or without --create-snapshot
    #      or --last-sealed-snapshot
    #
    # csrutil authenticated-root disable
    #    . Allow booting from non-sealed system snapshots
    # csrutil authenticated-root enable
    #    . Only allow booting from sealed system snapshots
    #
    # diskutil apfs list <disk>
    # diskutil apfs listsnapshots <mntpt>
    #
    # XXX --bootefi
    #    . check the boot loader, boot.efi, is copied
    #
    # XXX --setBoot
    #    . after verfiy, set back to the original system root
    #

    def run(self):
        # breakpoint()
        global Debug, skip_count, ErrorPause

        # Checking bless and setting if necessary
        if not isBootVolumeSet():
            setBootVolume()

        testBegin(self.testname)
        src = Source(self.srcopts)
        err = src.setup()
        if err:
            testEnd(self.testname, src, '', err, ErrorPause)
            return err

        err = self.do_bless(src)
        if Debug:
            exit(err)

        if err == 0 and not self.testname.startswith('neg_'):
            err = self.verify(src)

        testEnd(self.testname, src, '', err, ErrorPause)
        return err


# ===========================================================
#  BLESS FUNCTIONS TO TEST
#
#  Bless options review:
#  https://confluence.sd.apple.com/display/SM/Bless+options+-+Review
#
#  3 Modes: FOLDER, MOUNT, INFO
#
#  FOLDER mode options:
#     --folder directory
#     --bootefi [file]    (X86+AS support kc, boot.efit only for x86)
#     --label name        (x86, AS?)
#     --setBoot           (x86, AS should use bless2)
#     --nextonly          (x86, AS should use bless2)
#     --personalize       (X86+AS)
#     --create-snapshot   (x86+AS kc, boot.efi only for x86)
#     --last-sealed-snapshot (x86+AS)
#     --snapshot          (x86+AS)
#     --verbose
#     --apfsdriver?     (x86 only, not needed for T2, and AS)
#     --file?
#
#  MOUNT mode options:
#     --mount directory
#     --bootefi
#     --setBoot (XXX after verfiy, set it back to the original system root)
#     --nextonly
#     --personalize
#     --create-snapshot   (x86+AS kc, boot.efi only for x86)
#     --last-sealed-snapshot (x86+AS)
#     --verbose
#     --apfsdriver?     (x86 only, not needed for T2, and AS)
#     --noapfsdriver?   (x86 only)
#
#  INFO mode options: (x86 only)
#     --info [directory]
#     --getBoot
#     --plist
#     --verbose
#     --version
# ===========================================================


# ======================================
#    FOLDER MODE
# ======================================

#
# Set a folder of a dummy ROSV
#  --folder <volume-folder> --bootefi --verbose
#
def test_folder_rosv(testname):
    srcopts = ['', TYPE_SRC_ROSV, '', 0]
    testflag = TESTFLAG_FOLDER | TESTFLAG_Bootefi | TESTFLAG_Verbose
    test = Test(testname, testflag, srcopts)
    test.run()


#
# Set a folder of a dummy single volume OS
#  --folder <volume-folder> --bootefi --verbose
#
def test_folder_os(testname):
    srcopts = ['', TYPE_SRC_OSVOL, '', 0]
    testflag = TESTFLAG_FOLDER | TESTFLAG_Bootefi | TESTFLAG_Verbose
    test = Test(testname, testflag, srcopts)
    test.run()


#
# Create snapshot on a dummy ARV (Sealed System Volume)
# --folder <volume-folder> --create-snapshot --bootefi --verbose
#
def test_folder_snap_arv(testname):
    srcopts = ['', TYPE_SRC_ROSV, '', FLAG_SRC_SSV]
    testflag = TESTFLAG_FOLDER | TESTFLAG_CreateSnap | TESTFLAG_Bootefi | TESTFLAG_Verbose
    test = Test(testname, testflag, srcopts)
    test.run()


# ======================================
#    MOUNT MODE
# ======================================

#
# mount a dummy ROSV
#  --mount <mntpt> --bootefi --verbose
#
def test_mount_rosv(testname):
    srcopts = ['', TYPE_SRC_ROSV, '', 0]
    testflag = TESTFLAG_MOUNT | TESTFLAG_Bootefi | TESTFLAG_Verbose
    test = Test(testname, testflag, srcopts)
    test.run()


#
# mount a dummy single volume OS
#  --mount <mntpt> --bootefi --verbose
#
def test_mount_os(testname):
    srcopts = ['', TYPE_SRC_OSVOL, '', 0]
    testflag = TESTFLAG_MOUNT | TESTFLAG_Bootefi | TESTFLAG_Verbose
    test = Test(testname, testflag, srcopts)
    test.run()


#
# Create snapshot on a dummy ARV (Sealed System Volume)
# --mount <mntpt> --create-snapshot --bootefi --verbose
#
def test_mount_snap_arv(testname):
    srcopts = ['', TYPE_SRC_ROSV, '', FLAG_SRC_SSV]
    testflag = TESTFLAG_MOUNT | TESTFLAG_CreateSnap | TESTFLAG_Bootefi | TESTFLAG_Verbose
    test = Test(testname, testflag, srcopts)
    test.run()


# ======================================
#    INFO MODE - x86 only
# ======================================
#
# On a dummy ROSV OS
# --info <dir> --getBoot
#
def test_info_rosv(testname):
    srcopts = ['', TYPE_SRC_ROSV, '', 0]
    testflag = TESTFLAG_INFO | TESTFLAG_GetBoot
    test = Test(testname, testflag, srcopts)
    test.run()


#
# On a dummy ARV (Sealed System Volume)
# --info <dir> --getBoot
#
def test_info_arv(testname):
    srcopts = ['', TYPE_SRC_ROSV, '', FLAG_SRC_SSV]
    testflag = TESTFLAG_INFO | TESTFLAG_GetBoot
    test = Test(testname, testflag, srcopts)
    test.run()


#
# On a dummy single volume OS
# --info <dir> --getBoot
#
def test_info_os(testname):
    srcopts = ['', TYPE_SRC_OSVOL, '', 0]
    testflag = TESTFLAG_INFO | TESTFLAG_GetBoot
    test = Test(testname, testflag, srcopts)
    test.run()


# ======================================
#    NEGATIVE TEST CASES
# ======================================
#
# --create-snapshot is not allowed on a Data Volume of ARV (Sealed System Volume)
#
def test_neg_mount_snap_arvdata(testname):
    srcopts = ['', TYPE_SRC_ROSV, '', FLAG_SRC_SSV]
    testflag = TESTFLAG_MOUNT | TESTFLAG_OnDataVol | TESTFLAG_CreateSnap
    test = Test(testname, testflag, srcopts)
    test.run()


#
# --create-snapshot is not allowed on non-ARV system, nor Data roled volume
#
def test_neg_mount_snap_rosvdata(testname):
    srcopts = ['', TYPE_SRC_ROSV, '', 0]
    testflag = TESTFLAG_MOUNT | TESTFLAG_OnDataVol | TESTFLAG_CreateSnap
    test = Test(testname, testflag, srcopts)
    test.run()


#
# --create-snapshot is not allowed on non-ARV system
#
def test_neg_mount_snap_os(testname):
    srcopts = ['', TYPE_SRC_OSVOL, '', 0]
    testflag = TESTFLAG_MOUNT | TESTFLAG_CreateSnap
    test = Test(testname, testflag, srcopts)
    test.run()


#
# --folder --create-snapshot not allowed on a Data Volume of ARV (Sealed System Volume)
#
def test_neg_folder_snap_arvdata(testname):
    srcopts = ['', TYPE_SRC_ROSV, '', FLAG_SRC_SSV]
    testflag = TESTFLAG_FOLDER | TESTFLAG_OnDataVol | TESTFLAG_CreateSnap
    test = Test(testname, testflag, srcopts)
    test.run()


#
# --folder --create-snapshot not allowed on non-ARV system
#
def test_neg_folder_snap_rosv(testname):
    srcopts = ['', TYPE_SRC_ROSV, '', 0]
    testflag = TESTFLAG_FOLDER | TESTFLAG_CreateSnap | TESTFLAG_Bootefi
    test = Test(testname, testflag, srcopts)
    test.run()


#
# --folder --create-snapshot not allowed on non-ARV system
#
def test_neg_folder_snap_os(testname):
    srcopts = ['', TYPE_SRC_OSVOL, '', 0]
    testflag = TESTFLAG_FOLDER | TESTFLAG_CreateSnap | TESTFLAG_Bootefi
    test = Test(testname, testflag, srcopts)
    test.run()


#
# --mount <mntpt> --last-sealed-snapshot not allowed on non-ARV system
#
def test_neg_mount_lastsnap_rosv(testname):
    srcopts = ['', TYPE_SRC_ROSV, '', 0]
    testflag = TESTFLAG_MOUNT | TESTFLAG_LastSealedSnap
    test = Test(testname, testflag, srcopts)
    test.run()


#
# basic test ported from dmtest for verifying the basic functionalities
# XXX This was ported from dmtest. See if can convert this test into the
#     framework as other tests.
#
def test_bless_basic(testname):
    # breakpoint()
    testBegin("bless_basic")

    imgVol2Name = getUniqName()
    imgVol3Name = getUniqName()
    imgPath = "/tmp/" + imgVol2Name
    imgDiskVol2 = ""
    imgDisk = ""
    returnCode = 0
    savedNVRAM = [None, None]
    bAS = False
    bIS = False
    logging.info("ImagePath:" + imgPath)
    logging.info("ImageVol2Name:" + imgVol2Name +
                 "; ImageVol3Name:" + imgVol3Name)

    cmd = ['hdiutil', 'create', '-attach', '-type', 'SPARSEBUNDLE', '-size', '10g', '-fs', 'JHFS+', '-ov', '-volname',
           imgVol2Name, imgPath]
    logging.info("call: i{}".format(cmd))
    result = Popen(cmd, stdout=PIPE)
    result = Popen(['grep', imgVol2Name], stdin=result.stdout, stdout=PIPE)
    result = Popen(['grep', 'Apple_HFS'], stdin=result.stdout, stdout=PIPE)
    out, err = result.communicate()
    out = bytes.decode(out)
    # err = bytes.decode(err) doesn't apply to NoneType object
    logging.info("hdiutil create returned: " + out)
    if not out:
        logging.error("Error code " + str(result.returncode) +
                      " on 'hdiutil create'")
        return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

    out = out.strip()
    outs = out.split()
    imgDiskVol2 = outs[0].replace('/dev/', '')
    imgDisk = imgDiskVol2[:-2]
    logging.info("disk vol2: " + imgDiskVol2 + ", name: " + imgDisk)

    # sink the volume and create a other one
    docmd(['diskutil', 'resizeVolume', imgDiskVol2, '5G'])
    docmd(['diskutil', 'addPartition', imgDiskVol2, 'ExFAT', imgVol3Name, '0'])
    cmd = ['diskutil', 'list', imgDisk]
    result = Popen(cmd, stdout=PIPE)
    result = Popen(['grep', imgVol3Name], stdin=result.stdout, stdout=PIPE)
    out, err = result.communicate()
    out = bytes.decode(out)
    # err = bytes.decode(err) doesn't apply to NoneType object
    logging.info("diskutil resizeVolume/addPartition output: " + out)
    if not out:
        logging.error("diskutil resizeVolume/addPartition failed")
        return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

    outs = out.split()
    ind = len(outs)
    imgDiskVol3 = outs[ind - 1]
    logging.info("imgDiskVol3: " + imgDiskVol3)

    # create container with one volume in it
    ret, containerDisk, containerVol1Disk, containerVol1Name = createContainer(
        imgDisk, imgDiskVol3)
    print(f'ret {ret}')
    print(f'containerVol1Disk {containerVol1Disk}')
    print(f'containerVol1Name {containerVol1Name}')
    print(f'containerDisk {containerDisk}')
    logging.info(
        f'container created: {ret}, {containerDisk}, {containerVol1Disk}, {containerVol1Name}')
    # "container created: " + str(ret) + ", " + containerDisk + ", " + containerVol1Disk + ", " + containerVol1Name)
    if ret != 0:
        logging.error("Failed to create container")
        return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

    cmd = ['diskutil', 'mount', containerVol1Disk]
    docmd(cmd)

    result = Popen(['mount'], stdout=PIPE)
    result = Popen(['grep', containerVol1Disk],
                   stdin=result.stdout, stdout=PIPE)
    result = Popen(['grep', containerVol1Name],
                   stdin=result.stdout, stdout=PIPE)
    out, err = result.communicate()
    out = bytes.decode(out)
    #err = bytes.decode(err)
    logging.info("mount container volume1 result: " + out)
    if not out:
        logging.error("Failed to mount container volume 1: " +
                      containerVol1Disk)
        return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)
    # breakpoint()
    out = remSpecialChars(out, [chr(0xe2), chr(0x81), chr(0xa9), chr(0xa8)])
    outs = out.split()
    ind = len(outs)
    if ind < 3:
        logging.error(
            "Failed to find out mounted container volume 1: " + containerVol1Disk)
        return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

    mountPoint = outs[2]
    logging.info("mount point for '" + containerVol1Disk + " is " + mountPoint)

    docmd(['mkdir', '-p', mountPoint + '/System/Library/CoreServices'])
    docmd(['cp', '/System/Library/CoreServices/SystemVersion.plist',
           mountPoint + '/System/Library/CoreServices/'])

    # Failure here?
    # breakpoint()
    # check the file
    if not checkFileDirExist(mountPoint + '/System/Library/CoreServices/SystemVersion.plist'):
        return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

    plist, ret = docmd_plist(['diskutil', 'info', '-plist', containerVol1Disk])
    if ret != 0:
        logging.error(
            "'diskutil info -plist' faled with error code " + str(ret))
        return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

    containerVol1UUID = plist['VolumeUUID']
    logging.info("Volume1UUID: " + containerVol1UUID)

    docmd(['mkdir', '-p', mountPoint + '/System/Library/CoreServices'])
    docmd(['cp', '/System/Library/CoreServices/boot.efi',
           mountPoint + '/System/Library/CoreServices/'])
    # check the file
    if not checkFileDirExist(mountPoint + '/System/Library/CoreServices/boot.efi'):
        return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

    docmd(['mkdir', '-p', mountPoint + '/usr/standalone/i386'])
    docmd(['cp', '/usr/standalone/i386/apfs.efi',
           mountPoint + '/usr/standalone/i386/'])
    # check the file
    if not checkFileDirExist(mountPoint + '/usr/standalone/i386/apfs.efi'):
        return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

    # bless test start here
    cmd = ['bless', '--folder', mountPoint + '/usr/standalone/i386']
    logging.info("call: {}".format(cmd))
    result = Popen(cmd, stdout=PIPE, stderr=PIPE)
    out, err = result.communicate()

    if not result.returncode:
        logging.error("bless --folder should not return code 0")
        return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

    if not err:
        logging.error("bless command: {}".format(cmd) + " should return error")
        return endBlessBasic(-1, imgDisk, bIS, bAS, savedNVRAM)
    else:
        msgs = ['No preboot volume associated with device',
                containerVol1Disk, mountPoint]
        if not verifyCmdOutputForStrngs(err, msgs, "verifying error message from 'bless --folder'"):
            return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

    # add preboot volume to the container
    # breakpoint()
    ############################################
    ret, containerVol2Disk, containerVol2Name = addVolumeToContainer(
        containerDisk, 'B')
    if ret != 0:
        logging.error(
            "Failed to create preboot voloume in container: " + containerDisk)
        return endBlessBasic(-1, imgDisk, bIS, bAS, savedNVRAM)

    cmd = ['diskutil', 'mount', containerVol2Disk]
    docmd(cmd)

    result = Popen(['mount'], stdout=PIPE)
    result = Popen(['grep', containerVol2Disk],
                   stdin=result.stdout, stdout=PIPE)
    result = Popen(['grep', containerVol2Name],
                   stdin=result.stdout, stdout=PIPE)
    out, err = result.communicate()
    out = bytes.decode(out)
    # err = bytes.decode(err)
    logging.info("look for mount point for " + containerVol2Disk)
    logging.info("out: " + out)
    if not out or err:
        logging.error("failed to find the mount point")
        return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

    out = remSpecialChars(out, [chr(0xe2), chr(0x81), chr(0xa9), chr(0xa8)])
    outs = out.split()
    ind = len(outs)
    if ind < 3:
        logging.error("mount point not found")
        return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

    mountPointPreboot = outs[2]
    logging.info("mount point preboot: " + mountPointPreboot)

    docmd(['mkdir', '-p', mountPointPreboot + '/' +
           containerVol1UUID + '/System/Library/CoreServices'])
    docmd(['cp', '/System/Library/CoreServices/SystemVersion.plist',
           mountPointPreboot + '/' + containerVol1UUID + '/System/Library/CoreServices'])
    # check if uuid folder exists
    if not checkFileDirExist(mountPointPreboot + "/" + containerVol1UUID):
        return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

    # check SystemVersion.plist exists
    if not checkFileDirExist(
            mountPointPreboot + "/" + containerVol1UUID + '/System/Library/CoreServices/SystemVersion.plist'):
        return endBlessBasic(-1, imgDisk, bIS, bAS, savedNVRAM)

    # check boot.eif does not exist
    if checkFileDirExist(mountPointPreboot + "/" + containerVol1UUID + '/System/Library/CoreServices/boot.efi'):
        return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

    result = Popen(['nvram', '-p'], stdout=PIPE)
    result = Popen(['grep', 'efi-boot-device\t'],
                   stdin=result.stdout, stdout=PIPE)
    out, err = result.communicate()
    logging.info("search for 'efi-boot-device' in 'nvram -p' output")
    logging.info("out: {}".format(out))

    result = Popen(['nvram', '-p'], stdout=PIPE)
    result = Popen(['grep', 'boot-volume\t'], stdin=result.stdout, stdout=PIPE)
    out1, err = result.communicate()
    logging.info("search for 'boot-volume' in 'nvram -p' output")
    logging.info("out: {}".format(out1))
    savedNVRAM = [out, out1]

    if (out and len(out) > 100):
        needToRestoreNVRAM_EFIBOOTDEVICE_IS = True
    else:
        needToRestoreNVRAM_EFIBOOTDEVICE_IS = False

    if (out1 and len(out1) > 30):
        needToRestoreNVRAM_BOOTVOLUME_AS = True
    else:
        needToRestoreNVRAM_BOOTVOLUME_AS = False

    bIS = needToRestoreNVRAM_EFIBOOTDEVICE_IS
    bAS = needToRestoreNVRAM_BOOTVOLUME_AS

    logging.info("needToRestoreNVRAM_EFIBOOTDEVICE_IS: " +
                 str(needToRestoreNVRAM_EFIBOOTDEVICE_IS))
    logging.info("needToRestoreNVRAM_BOOTVOLUME_AS: " +
                 str(needToRestoreNVRAM_BOOTVOLUME_AS))
    if not needToRestoreNVRAM_EFIBOOTDEVICE_IS and not needToRestoreNVRAM_BOOTVOLUME_AS:
        logging.error("efi-boot or boot-volume info does not set in nvram")
        return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

    # Do the following set-nvram-feature-of-bless test for Intel Macintosh machines (Apple Silicon machines use a different,
    # new, "bless" program to be called bootutil):
    if needToRestoreNVRAM_EFIBOOTDEVICE_IS:
        # BEGIN SPECIFIC SECTION:
        logging.info("BEGIN: Intel Macintosh - specific section")
        print("BEGIN: Intel Macintosh - specific section")
        # bless --folder /Volumes/<SIMSYS>/System/Library/CoreServices --gootefi /Volumes/<SIMSYS>/System/Library/CoreServices/boot.efi -setBoo
        # We will expect that to succeed:
        cmd = ['bless', '--folder', mountPoint + '/System/Library/CoreServices', '--bootefi',
               mountPoint + '/System/Library/CoreServices/boot.efi', '--setBoot']
        logging.info("call: {}".format(cmd))
        result = Popen(cmd, stdout=PIPE, stderr=PIPE)
        out, err = result.communicate()
        out = bytes.decode(out)
        err = bytes.decode(err)
        logging.info("out: " + out)
        logging.info("err: " + err)

        if result.returncode != 0:
            logging.error(
                "'bless --folder --bootefi' failed with exit code: " + str(result.returncode))
            return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

        if out and len(out) > 0:
            logging.error("'bless --folder --bootefi' returned invalid data")
            return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

        # check if uuid folder exists
        if not checkFileDirExist(mountPointPreboot + "/" + containerVol1UUID):
            return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

        # check boot.eif does exist
        if not checkFileDirExist(mountPointPreboot + "/" + containerVol1UUID + '/System/Library/CoreServices/boot.efi'):
            return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

        # get volume 2 UUID
        plist, ret = docmd_plist(
            ['diskutil', 'info', '-plist', containerVol2Disk])
        if ret != 0:
            logging.error(
                "'diskutil info -plist' faled with error code " + str(ret))
            return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

        containerVol2UUID = plist['VolumeUUID']
        logging.error("Volume2UUID: " + containerVol2UUID)

        # Look at the current NVRAM EFI boot setting, now that bless has run successfully. It should be in dict format:
        logging.info("look at updated-by-bless NVRAM boot settings")
        result = Popen(['nvram', '-p'], stdout=PIPE, stderr=PIPE)
        result = Popen(['grep', 'efi-boot-device\\t'],
                       stdin=result.stdout, stdout=PIPE)
        out, err = result.communicate()
        out = bytes.decode(out)
        # err = bytes.decode(err)
        # Get output, loosely requiring a minimum amount of output chars of what should "nvram -p" output:
        logging.info("'nvram -p' output: " + out)
        if not out or len(out) < 100:
            logging.error("'nvram -p' output has no expected data")
            return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

        if out.find("efi-boot-device") != 0:
            logging.error("'nvram -p' output has no prefix 'efi-boot-device'")
            return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

        logging.info("nvram -p' output roughly OK")
        # We can check for more precise output later, but for now, do a few loose spot checks on dict content:
        strs = [containerVol1UUID, containerVol2UUID, containerVol2Disk]
        if not verifyCmdOutputForStrngs(out, strs, "verifying efi-boot-device setting ('nvram -p' output)"):
            return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

        logging.info("verify some efi-boot-device elements ")
        if out.find("\\System\\Library\\CoreServices\\boot.efi") < 0:
            logging.error(
                "'nvram -p' output has no element \\System\\Library\\CoreServices\\boot.efi")
            return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

        # Do a bless command:  bless --getBoot
        logging.info("test 'bless --getBoot'")
        result = Popen(['bless', '--getBoot'], stdout=PIPE, stderr=PIPE)
        out, err = result.communicate()
        out = bytes.decode(out)
        err = bytes.decode(err)

        logging.info(
            "verified that the exit status of the last bless command is ZERO thus indicates success")
        if result.returncode != 0:
            logging.error("'bless --getBoot' return error: " +
                          str(result.returncode) + ", " + err)
            return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

        logging.info("checking 'bless --getBoot' output: " + out)
        if not out or len(out) < 10 or len(out) > 16:
            logging.error("'bless --getBoot' output data not expected")
            return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

        logging.info(
            "verify that there is reasonable bless stdout for --getBoot")
        if out.find("/dev/" + containerVol1Disk) != 0:
            logging.error("'bless --getBoot' output data not expected")
            return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

        # Do a bless command:  bless --info
        logging.info("\ntest 'bless --info'")
        result = Popen(['bless', '--info'], stdout=PIPE, stderr=PIPE)
        out, err = result.communicate()
        out = bytes.decode(out)
        err = bytes.decode(err)

        logging.info(
            "verified that the exit status of the last bless command is ZERO thus indicates success")
        if result.returncode != 0:
            logging.error("'bless --info' return error: " +
                          str(result.returncode) + ", " + err)
            return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

        # Get the output string and check it very roughly for basic size:
        logging.info("verifying 'bless --info' output: " + out)
        if not out or len(out) < 100 or len(out) > 2500:
            logging.error("'bless --info' output data not expected")
            return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

        # check roughly for the bless --info output for some reasonal contents
        strs = ["Blessed System File is", "Blessed System Folder is", "The blessed volume in this APFS container is",
                containerVol1UUID + "/System/Library/CoreServices/boot.efi"]
        if not verifyCmdOutputForStrngs(out, strs, "verifying 'bless --info' output"):
            return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

        # Do a bless command:  bless --info /Volumes/SIMSYS/System/Library/CoreServices --plist
        logging.info(
            "bless --info /Volumes/SIMSYS/System/Library/CoreServices --plist")
        cmd = ['bless', '--info', mountPoint +
               '/System/Library/CoreServices', '--plist']
        logging.info("call: {}".format(cmd))
        result = Popen(cmd, stdout=PIPE, stderr=PIPE)
        out, err = result.communicate()
        outDecoded = bytes.decode(out)
        err = bytes.decode(err)

        logging.info(
            "verified that the exit status of the last bless command is ZERO thus indicates success")
        if result.returncode != 0:
            logging.error("'bless --info SLC --plist' return error: " +
                          str(result.returncode) + ", " + err)
            return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

        logging.info("'bless --info SLC --plist' output: " + outDecoded)
        logging.info("verify 'bless --info SLC --plist' output data size")
        if not out or len(out) < 100 or len(out) > 6000:
            logging.error(
                "'bless --info SLC --plist' output data not expected")
            return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

        logging.info("verifying 'bless --info SLC --plist' output stringr1")
        if outDecoded.find("plist version=") < 0:
            logging.error(
                "'bless --info SLC --plist' output should contains 'plist version='")
            return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

        logging.info("verifying 'bless --info SLC --plist' output stringr2")
        if outDecoded.find("</plist>") < 0:
            logging.error(
                "'bless --info SLC --plist' output should contains '</plist>'")
            return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

        logging.info("verifying 'bless --info SLC --plist' output stringr3")
        if outDecoded.find("Directory ID") < 0:
            logging.error(
                "'bless --info SLC --plist' output should contains 'Directory ID'")
            return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

        plist = plistlib.loads(out)
        logging.info("verifying 'bless --info SLC --plist' output as plist")
        if not plist:
            logging.error(
                "'bless --info SLC --plist' output should be plist dictionary")
            return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

        logging.info("verifying 'bless --info SLC --plist' output plist key1")
        aux = plist['Auxiliary Partitions'] != []
        if aux == None:
            logging.error(
                "'bless --info SLC --plist' output plist should have 'Auxiliary Partitions'")
            # return endBlessBasic (-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

        logging.info("verifying 'bless --info SLC --plist' output plist key2")
        arr = plist['Bless Info']
        if not arr:
            logging.error(
                "'bless --info SLC --plist' output plist should have 'Bless Info'")
            return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

        logging.info(
            "verifying 'bless --info SLC --plist' output plist key2 arr size")
        if len(arr) != 2:
            logging.error(
                "'bless --info SLC --plist' output plist should have 'Bless Info' as size two array")
            endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

        logging.info(
            "verifying 'bless --info SLC --plist' output plist key2 arr data1")
        if not arr[0]['Directory ID'] or not arr[1]['Directory ID']:
            logging.error(
                "'bless --info SLC --plist' output plist should have 'Bless Info' and both entries should have 'Directory ID'")
            return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

        logging.info(
            "verifying 'bless --info SLC --plist' output plist key2 arr data2")
        if not arr[0]['Path'] or not arr[1]['Path']:
            logging.error(
                "'bless --info SLC --plist' output plist should have 'Bless Info' and both entries should have 'Path'")
            return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

        logging.info(
            "verifying 'bless --info SLC --plist' output plist key2 arr data3")
        aPath = mountPointPreboot + "/" + containerVol1UUID + '/System/Library/CoreServices'
        if arr[0]['Path'].find(aPath) < 0 or arr[1]['Path'].find(aPath) < 0:
            logging.error(
                "'bless --info SLC --plist' output plist should have 'Bless Info' and both entries should have 'Path' and all the paths should have SLC")
            return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

        logging.info(
            "verifying 'bless --info SLC --plist' output plist key2 arr data4")
        aPath = mountPointPreboot + "/" + containerVol1UUID + \
            '/System/Library/CoreServices/boot.efi'
        # at least one path has boot.efi
        if arr[0]['Path'].find(aPath) < 0 and arr[1]['Path'].find(aPath) < 0:
            logging.error(
                "'bless --info SLC --plist' output plist should have 'Bless Info' and both entries should have 'Path' and one path should have boot.efi")
            return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

        logging.info(
            "verifying 'bless --info SLC --plist' output plist key2 arr data5")
        # only one path has boot.efi
        if arr[0]['Path'].find(aPath) >= 0 and arr[1]['Path'].find(aPath) >= 0:
            logging.error(
                "'bless --info SLC --plist' output plist should have 'Bless Info' and both entries should have 'Path' and only one path should have boot.efi")
            return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

        logging.info(
            "verifying 'bless --info SLC --plist' output plist Data Partitions")
        if not plist['Data Partitions']:
            logging.error(
                "'bless --info SLC --plist' output plist should have 'Data Partitions'")
            return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

        logging.info(
            "verifying 'bless --info SLC --plist' output plist Data Partitions array")
        if len(plist['Data Partitions']) != 1:
            logging.error(
                "'bless --info SLC --plist' output plist should have 'Data Partitions' with one elm")
            return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

        logging.info(
            "verifying 'bless --info SLC --plist' output plist Data Partitions array data")
        if plist['Data Partitions'][0] != containerVol1Disk:
            logging.error(
                "'bless --info SLC --plist' output plist should have 'Data Partitions' with one elm :" + containerVol1Disk)
            return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

        logging.info(
            "verifying 'bless --info SLC --plist' output plist Preboot Volumes")
        if not plist['Preboot Volumes']:
            logging.error(
                "'bless --info SLC --plist' output plist should have 'Preboot Volumes'")
            return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

        logging.info(
            "verifying 'bless --info SLC --plist' output plist Preboot Volumes array")
        if len(plist['Preboot Volumes']) != 1:
            logging.error(
                "'bless --info SLC --plist' output plist should have 'Preboot Volumes' with one elm")
            return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

        logging.info(
            "verifying 'bless --info SLC --plist' output plist Preboot Volumes array data")
        if plist['Preboot Volumes'][0] != containerVol2Disk:
            logging.error(
                "'bless --info SLC --plist' output plist should have 'Preboot Volumes' with one elm :" + containerVol2Disk)
            return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

        logging.info(
            "verifying 'bless --info SLC --plist' output plist Systen Partitions")
        if not plist['System Partitions']:
            logging.error(
                "'bless --info SLC --plist' output plist should have 'System Partitions'")
            return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

    if needToRestoreNVRAM_BOOTVOLUME_AS:
        # Apple Silicon Mac - specific section
        logging.info("Apple Silic Mac - specific section:")
        print("Apple Silic Mac - specific section:")
        logging.info("Apple Silic Mac - specific section:")
        result = Popen(['bless', '--info'], stdout=PIPE, stderr=PIPE)
        out, err = result.communicate()
        out = bytes.decode(out)
        err = bytes.decode(err)

        logging.info("verifying 'bless --info' return code ")
        if result.returncode != 1 and result.returncode != 2:
            logging.error("'bless --info' return exit status " +
                          str(result.returncode) + " but expected value is 2")
            return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

        logging.info("verifying 'bless --info' output error ")
        if not err or len(err) < 1:
            logging.error("'bless --info' should return errors")
            return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

        logging.info("error message from bless --info: " + err)
        if err.find("Can't interpret boot-volume") < 0 and \
                err.find("Unknown preboot environment") < 0 and \
                not (err.find("Volume for path ") == 0 and err.find(" is not available") > 0):
            logging.error(
                "last bless command does not return a specific error message")
            return endBlessBasic(-1, imgDisk, imgPath, bIS, bAS, savedNVRAM)

        logging.info("END: Apple Silicon Mac - specific section")

    if needToRestoreNVRAM_BOOTVOLUME_AS:
        logging.info("bootutil testing should go here in the future")

    # normal exit
    return endBlessBasic(0, imgDisk, imgPath, bIS, bAS, savedNVRAM)


# ======================================
#    USING REAL OS
# ======================================
#
# bless GoldenGate OS restored from asr
#
def test_mount_goldengate(testname):
    print('XXX TBD')


# ====================================================
#    MAIN
# ====================================================

#
# The list of avaiable test cases/suite
#
#    key = <testname>
#    value = (test function, flag, test description)
#
TestListDictionary = {
    'folder_rosv': (test_folder_rosv, 'presubmit',
                    'bless folder on a dummy ROSV'),
    'folder_os': (test_folder_os, 'presubmit',
                  'bless folder on a dummy single volume OS'),
    'folder_snap_arv': (test_folder_snap_arv, 'presubmit',
                        'bless folder create-snapshot on a dummy ARV'),
    'mount_rosv': (test_mount_rosv, 'presubmit',
                   'bless mount on a dummy ROSV'),
    'mount_os': (test_mount_os, 'presubmit',
                 'bless mount on a dummy single volume OS'),
    'mount_snap_arv': (test_mount_snap_arv, 'presubmit',
                       'bless mount create-snapshot on a dummy ARV'),
    'info_rosv': (test_info_rosv, 'presubmit',
                  'bless info on a dummy ROSV'),
    'info_arv': (test_info_arv, 'presubmit',
                 'bless info on a dummy ARV'),
    'info_os': (test_info_os, 'presubmit',
                'bless info on a dummy single volume OS'),
    'bless_basic': (test_bless_basic, 'presubmit',
                    'basic bless call for different volume types'),
    'neg_mount_snap_arvdata': (test_neg_mount_snap_arvdata, 'presubmit',
                               '--create-snapshot not allowed on Data Volume in ARV'),
    'neg_mount_snap_rosvdata': (test_neg_mount_snap_rosvdata, 'presubmit',
                                '--mount --create-snapshot not allowed on non-ARV system'),
    'neg_mount_snap_os': (test_neg_mount_snap_os, 'presubmit',
                          '--mount --create-snapshot not allowed on non-ARV system'),
    'neg_mount_lastsnap_rosv': (test_neg_mount_lastsnap_rosv, 'presubmit',
                                '--mount --last-sealed-snapshot not allowed on non-ARV system'),
    'neg_folder_snap_arvdata': (test_neg_folder_snap_arvdata, 'presubmit',
                                '--folder --create-snapshot not allowed on Data Volume in ARV'),
    'neg_folder_snap_rosv': (test_neg_folder_snap_rosv, 'presubmit',
                             '--folder --create-snapshot not allowed on Non-ARV system'),
    'neg_folder_snap_os': (test_neg_folder_snap_os, 'presubmit',
                           '--folder --create-snapshot not allowed on non-ARV system'),
    # XXX TBD
    #    'mount_goldengate': (test_mount_goldengate, 'remote',
    #        'bless after asr restores a GoldenGate ROSV'),
}


#
# For 'test_bless -l' command
#
def list_tests():
    print('')
    print('<testname>')
    count = 0
    for key in sorted(TestListDictionary):
        value = TestListDictionary[key]
        print(key + ' : ' + value[2] + ' (' + value[1] + ')')
        count = count + 1
    print('')
    print('Use ending "*" to run a subset of tests')
    print('e.g. "neg_*" ...etc')
    print('')
    print('Total number of test cases : %d' % count)
    print('')


#
# Run test cases with wildcard
#
def run_wildcard(tname):
    count = 0
    match_dict = {}

    tname_r = tname.replace("*", ".")
    regex = re.compile(tname_r)
    for key in TestListDictionary:
        if re.match(regex, key):
            match_dict[key] = TestListDictionary[key]
            count = count + 1
    if count == 0:
        return count

    Startup()
    for key in match_dict:
        func = match_dict[key][0]
        func(key)
    return count


#
# Run sub-group test cases
#
def run_subgroup(subgp):
    for key in TestListDictionary:
        value = TestListDictionary[key]
        if value[1] == subgp:
            func = value[0]
            func(key)
        # breakpoint() att


#
# Run all test cases
#
def run_all():
    for key in TestListDictionary:
        func = TestListDictionary[key][0]
        func(key)


def main():
    global TestListDictionary
    global Debug
    global LocalMacOS
    global ErrorPause
    global OSDIR, OSDIR_GOLDENGATE, OSDIR_JAZZ, OSDIR_LIB
    global SWEDMGname, DMGDIR

    LocalMacOS = False
    # XXX use getopt/argparse in Python?
    argcnt = len(sys.argv)
    if argcnt >= 3:
        for x in range(2, argcnt):
            if sys.argv[x] == '-debug':
                Debug = True
            elif sys.argv[x] == '-localmacos':
                LocalMacOS = True
            elif sys.argv[x] == '-errorpause':
                ErrorPause = True
            else:
                print('Unrecognized option ' + sys.argv[x])
                usage()
                exit(1)

    elif argcnt < 2:
        usage()
        exit(1)

    if sys.argv[1] == '-l':
        list_tests()
        exit(0)

    isArm = check_arm()
    if isArm:
        print('This program is for testing libbless on x86 systems.')
        print('Please try again on an x86 system.')
        exit(1)

    if os.getuid() != 0:
        print('Need to run as a super user')
        exit(1)

    if sys.argv[1] == '-c':
        log_cleanup()
        exit(0)

    # Make sure logging is setup before using it
    Startup()
    testname = sys.argv[1]

    # XXX TBD
    # if LocalMacOS == False and (testname == 'all' or testname == 'remote'):
    #
    # Copy remote dmg files to local location first.
    # If not enough space, let it skip and do it individually later.
    #
    # for dir in SweDMGname.keys():
    #    SWEDMGname[dir] = get_dmg_name(testname, dir)
    #    if SWEDMGname[dir] == '':
    #        exit(1)

    # XXX add test cases using local OS image
    if LocalMacOS == True:
        home = expanduser("~")
        OSDIR = home + '/Downloads/test_bless/'
        OSDIR_GOLDENGATE = OSDIR + 'GoldenGate/'
        OSDIR_JAZZ = OSDIR + 'macOSJazz/'
        OSDIR_LIB = OSDIR + 'macOSLiberty/'
        DMGDIR = OSDIR
        SWEDMGname = {OSDIR_GOLDENGATE: '', OSDIR_JAZZ: '', OSDIR_LIB: ''}
        print('Get macOS images from:')
        print(OSDIR_GOLDENGATE)
        print(OSDIR_JAZZ)
        print(OSDIR_LIB)

    # For Code Coverage output file name
    os.environ["LLVM_PROFILE_FILE"] = "test.%p.profraw"

    # Run tests
    if testname == 'all':
        run_all()
    elif testname == 'presubmit' or testname == 'remote':
        run_subgroup(testname)
    elif testname.endswith('*'):
        count = run_wildcard(testname)
        if count == 0:
            print('No matched test name')
            exit(1)
    elif testname in TestListDictionary:
        func = TestListDictionary[testname][0]
        func(testname)
    else:
        print('Unknown test name : ' + testname)
        exit(1)

    # if we made changes to blessing then change them back
    if blessing_changed:
        unsetBootVolume()

    Teardown()


#
# Run Program
#
main()
