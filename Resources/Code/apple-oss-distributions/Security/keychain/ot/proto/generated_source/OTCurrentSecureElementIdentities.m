// This file was automatically generated by protocompiler
// DO NOT EDIT!
// Compiled from OTSecureElementPeerIdentity.proto

#import "OTCurrentSecureElementIdentities.h"
#import <ProtocolBuffer/PBConstants.h>
#import <ProtocolBuffer/PBHashUtil.h>
#import <ProtocolBuffer/PBDataReader.h>

#import "OTSecureElementPeerIdentity.h"

#if !__has_feature(objc_arc)
# error This generated file depends on ARC but it is not enabled; turn on ARC, or use 'objc_use_arc' option to generate non-ARC code.
#endif

@implementation OTCurrentSecureElementIdentities

- (BOOL)hasLocalPeerIdentity
{
    return _localPeerIdentity != nil;
}
@synthesize localPeerIdentity = _localPeerIdentity;
@synthesize trustedPeerSecureElementIdentities = _trustedPeerSecureElementIdentities;
- (void)clearTrustedPeerSecureElementIdentities
{
    [_trustedPeerSecureElementIdentities removeAllObjects];
}
- (void)addTrustedPeerSecureElementIdentities:(OTSecureElementPeerIdentity *)i
{
    if (!_trustedPeerSecureElementIdentities)
    {
        _trustedPeerSecureElementIdentities = [[NSMutableArray alloc] init];
    }
    [_trustedPeerSecureElementIdentities addObject:i];
}
- (NSUInteger)trustedPeerSecureElementIdentitiesCount
{
    return [_trustedPeerSecureElementIdentities count];
}
- (OTSecureElementPeerIdentity *)trustedPeerSecureElementIdentitiesAtIndex:(NSUInteger)idx
{
    return [_trustedPeerSecureElementIdentities objectAtIndex:idx];
}
+ (Class)trustedPeerSecureElementIdentitiesType
{
    return [OTSecureElementPeerIdentity class];
}
- (BOOL)hasPendingLocalPeerIdentity
{
    return _pendingLocalPeerIdentity != nil;
}
@synthesize pendingLocalPeerIdentity = _pendingLocalPeerIdentity;

- (NSString *)description
{
    return [NSString stringWithFormat:@"%@ %@", [super description], [self dictionaryRepresentation]];
}

- (NSDictionary *)dictionaryRepresentation
{
    NSMutableDictionary *dict = [NSMutableDictionary dictionary];
    if (self->_localPeerIdentity)
    {
        [dict setObject:[_localPeerIdentity dictionaryRepresentation] forKey:@"localPeerIdentity"];
    }
    if ([self->_trustedPeerSecureElementIdentities count])
    {
        NSMutableArray *trustedPeerSecureElementIdentitiesDictReprs = [[NSMutableArray alloc] initWithCapacity:[self->_trustedPeerSecureElementIdentities count]];
        for (OTSecureElementPeerIdentity *i_trustedPeerSecureElementIdentities in self->_trustedPeerSecureElementIdentities)
        {
            [trustedPeerSecureElementIdentitiesDictReprs addObject:[i_trustedPeerSecureElementIdentities dictionaryRepresentation]];
        }
        [dict setObject:trustedPeerSecureElementIdentitiesDictReprs forKey:@"trustedPeerSecureElementIdentities"];
    }
    if (self->_pendingLocalPeerIdentity)
    {
        [dict setObject:[_pendingLocalPeerIdentity dictionaryRepresentation] forKey:@"pendingLocalPeerIdentity"];
    }
    return dict;
}

BOOL OTCurrentSecureElementIdentitiesReadFrom(__unsafe_unretained OTCurrentSecureElementIdentities *self, __unsafe_unretained PBDataReader *reader) {
    while (PBReaderHasMoreData(reader)) {
        uint32_t tag = 0;
        uint8_t aType = 0;

        PBReaderReadTag32AndType(reader, &tag, &aType);

        if (PBReaderHasError(reader))
            break;

        if (aType == TYPE_END_GROUP) {
            break;
        }

        switch (tag) {

            case 1 /* localPeerIdentity */:
            {
                OTSecureElementPeerIdentity *new_localPeerIdentity = [[OTSecureElementPeerIdentity alloc] init];
                self->_localPeerIdentity = new_localPeerIdentity;
                PBDataReaderMark mark_localPeerIdentity;
                BOOL markError = !PBReaderPlaceMark(reader, &mark_localPeerIdentity);
                if (markError)
                {
                    return NO;
                }
                BOOL inError = !OTSecureElementPeerIdentityReadFrom(new_localPeerIdentity, reader);
                if (inError)
                {
                    return NO;
                }
                PBReaderRecallMark(reader, &mark_localPeerIdentity);
            }
            break;
            case 2 /* trustedPeerSecureElementIdentities */:
            {
                OTSecureElementPeerIdentity *new_trustedPeerSecureElementIdentities = [[OTSecureElementPeerIdentity alloc] init];
                [self addTrustedPeerSecureElementIdentities:new_trustedPeerSecureElementIdentities];
                PBDataReaderMark mark_trustedPeerSecureElementIdentities;
                BOOL markError = !PBReaderPlaceMark(reader, &mark_trustedPeerSecureElementIdentities);
                if (markError)
                {
                    return NO;
                }
                BOOL inError = !OTSecureElementPeerIdentityReadFrom(new_trustedPeerSecureElementIdentities, reader);
                if (inError)
                {
                    return NO;
                }
                PBReaderRecallMark(reader, &mark_trustedPeerSecureElementIdentities);
            }
            break;
            case 3 /* pendingLocalPeerIdentity */:
            {
                OTSecureElementPeerIdentity *new_pendingLocalPeerIdentity = [[OTSecureElementPeerIdentity alloc] init];
                self->_pendingLocalPeerIdentity = new_pendingLocalPeerIdentity;
                PBDataReaderMark mark_pendingLocalPeerIdentity;
                BOOL markError = !PBReaderPlaceMark(reader, &mark_pendingLocalPeerIdentity);
                if (markError)
                {
                    return NO;
                }
                BOOL inError = !OTSecureElementPeerIdentityReadFrom(new_pendingLocalPeerIdentity, reader);
                if (inError)
                {
                    return NO;
                }
                PBReaderRecallMark(reader, &mark_pendingLocalPeerIdentity);
            }
            break;
            default:
                if (!PBReaderSkipValueWithTag(reader, tag, aType))
                    return NO;
                break;
        }
    }
    return !PBReaderHasError(reader);
}

- (BOOL)readFrom:(PBDataReader *)reader
{
    return OTCurrentSecureElementIdentitiesReadFrom(self, reader);
}
- (void)writeTo:(PBDataWriter *)writer
{
    /* localPeerIdentity */
    {
        if (self->_localPeerIdentity != nil)
        {
            PBDataWriterWriteSubmessage(writer, self->_localPeerIdentity, 1);
        }
    }
    /* trustedPeerSecureElementIdentities */
    {
        for (OTSecureElementPeerIdentity *i_trustedPeerSecureElementIdentities in self->_trustedPeerSecureElementIdentities)
        {
            PBDataWriterWriteSubmessage(writer, i_trustedPeerSecureElementIdentities, 2);
        }
    }
    /* pendingLocalPeerIdentity */
    {
        if (self->_pendingLocalPeerIdentity != nil)
        {
            PBDataWriterWriteSubmessage(writer, self->_pendingLocalPeerIdentity, 3);
        }
    }
}

- (void)copyTo:(OTCurrentSecureElementIdentities *)other
{
    if (_localPeerIdentity)
    {
        other.localPeerIdentity = _localPeerIdentity;
    }
    if ([self trustedPeerSecureElementIdentitiesCount])
    {
        [other clearTrustedPeerSecureElementIdentities];
        NSUInteger trustedPeerSecureElementIdentitiesCnt = [self trustedPeerSecureElementIdentitiesCount];
        for (NSUInteger i = 0; i < trustedPeerSecureElementIdentitiesCnt; i++)
        {
            [other addTrustedPeerSecureElementIdentities:[self trustedPeerSecureElementIdentitiesAtIndex:i]];
        }
    }
    if (_pendingLocalPeerIdentity)
    {
        other.pendingLocalPeerIdentity = _pendingLocalPeerIdentity;
    }
}

- (id)copyWithZone:(NSZone *)zone
{
    OTCurrentSecureElementIdentities *copy = [[[self class] allocWithZone:zone] init];
    copy->_localPeerIdentity = [_localPeerIdentity copyWithZone:zone];
    for (OTSecureElementPeerIdentity *v in _trustedPeerSecureElementIdentities)
    {
        OTSecureElementPeerIdentity *vCopy = [v copyWithZone:zone];
        [copy addTrustedPeerSecureElementIdentities:vCopy];
    }
    copy->_pendingLocalPeerIdentity = [_pendingLocalPeerIdentity copyWithZone:zone];
    return copy;
}

- (BOOL)isEqual:(id)object
{
    OTCurrentSecureElementIdentities *other = (OTCurrentSecureElementIdentities *)object;
    return [other isMemberOfClass:[self class]]
    &&
    ((!self->_localPeerIdentity && !other->_localPeerIdentity) || [self->_localPeerIdentity isEqual:other->_localPeerIdentity])
    &&
    ((!self->_trustedPeerSecureElementIdentities && !other->_trustedPeerSecureElementIdentities) || [self->_trustedPeerSecureElementIdentities isEqual:other->_trustedPeerSecureElementIdentities])
    &&
    ((!self->_pendingLocalPeerIdentity && !other->_pendingLocalPeerIdentity) || [self->_pendingLocalPeerIdentity isEqual:other->_pendingLocalPeerIdentity])
    ;
}

- (NSUInteger)hash
{
    return 0
    ^
    [self->_localPeerIdentity hash]
    ^
    [self->_trustedPeerSecureElementIdentities hash]
    ^
    [self->_pendingLocalPeerIdentity hash]
    ;
}

- (void)mergeFrom:(OTCurrentSecureElementIdentities *)other
{
    if (self->_localPeerIdentity && other->_localPeerIdentity)
    {
        [self->_localPeerIdentity mergeFrom:other->_localPeerIdentity];
    }
    else if (!self->_localPeerIdentity && other->_localPeerIdentity)
    {
        [self setLocalPeerIdentity:other->_localPeerIdentity];
    }
    for (OTSecureElementPeerIdentity *iter_trustedPeerSecureElementIdentities in other->_trustedPeerSecureElementIdentities)
    {
        [self addTrustedPeerSecureElementIdentities:iter_trustedPeerSecureElementIdentities];
    }
    if (self->_pendingLocalPeerIdentity && other->_pendingLocalPeerIdentity)
    {
        [self->_pendingLocalPeerIdentity mergeFrom:other->_pendingLocalPeerIdentity];
    }
    else if (!self->_pendingLocalPeerIdentity && other->_pendingLocalPeerIdentity)
    {
        [self setPendingLocalPeerIdentity:other->_pendingLocalPeerIdentity];
    }
}

@end

