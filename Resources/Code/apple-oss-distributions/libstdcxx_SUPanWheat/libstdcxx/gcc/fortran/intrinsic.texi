@ignore
Copyright (C) 2005
Free Software Foundation, Inc.
This is part of the GFORTRAN manual.   
For copying conditions, see the file gfortran.texi.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``GNU General Public License'' and ``Funding
Free Software'', the Front-Cover texts being (a) (see below), and with
the Back-Cover Texts being (b) (see below).  A copy of the license is
included in the gfdl(7) man page.


Some basic guidelines for editing this document:

  (1) The intrinsic procedures are to be listed in alphabetical order.
  (2) The generic name is to be use.
  (3) The specific names are included in the function index and in a
      table at the end of the node (See ABS entry).
  (4) Try to maintain the same style for each entry.


@end ignore

@node Intrinsic Procedures
@chapter Intrinsic Procedures
@cindex Intrinsic Procedures

This portion of the document is incomplete and undergoing massive expansion 
and editing.  All contributions and corrections are strongly encouraged. 

@menu
* Introduction:     Introduction
* @code{ABORT}:     ABORT,     Abort the program     
* @code{ABS}:       ABS,       Absolute value     
* @code{ACHAR}:     ACHAR,     Character in @acronym{ASCII} collating sequence
* @code{ACOS}:      ACOS,      Arccosine function
* @code{ADJUSTL}:   ADJUSTL,   Left adjust a string
* @code{ADJUSTR}:   ADJUSTR,   Right adjust a string
* @code{AIMAG}:     AIMAG,     Imaginary part of complex number
* @code{AINT}:      AINT,      Truncate to a whole number
* @code{ALL}:       ALL,       Determine if all values are true
* @code{ALLOCATED}: ALLOCATED, Status of allocatable entity
* @code{ANINT}:     ANINT,     Nearest whole number
* @code{ANY}:       ANY,       Determine if any values are true
* @code{ASIN}:      ASIN,      Arcsine function
* @code{ATAN}:      ATAN,      Arctangent function
* @code{BESJ0}:     BESJ0,     Bessel function of the first kind of order 0
* @code{BESJ1}:     BESJ1,     Bessel function of the first kind of order 1
* @code{BESJN}:     BESJN,     Bessel function of the first kind
* @code{BESY0}:     BESY0,     Bessel function of the second kind of order 0
* @code{BESY1}:     BESY1,     Bessel function of the second kind of order 1
* @code{BESYN}:     BESYN,     Bessel function of the second kind
* @code{COS}:       COS,       Cosine function
* @code{COSH}:      COSH,      Hyperbolic cosine function
* @code{ERF}:       ERF,       Error function
* @code{ERFC}:      ERFC,      Complementary error function
* @code{EXP}:       EXP,       Cosine function
* @code{LOG}:       LOG,       Logarithm function
* @code{LOG10}:     LOG10,     Base 10 logarithm function 
* @code{SQRT}:      SQRT,      Square-root function
* @code{SIN}:       SIN,       Sine function
* @code{SINH}:      SINH,      Hyperbolic sine function
* @code{TAN}:       TAN,       Tangent function
* @code{TANH}:      TANH,      Hyperbolic tangent function
@end menu

@node Introduction
@section Introduction to intrinsic procedures

Gfortran provides a rich set of intrinsic procedures that includes all
the intrinsic procedures required by the Fortran 95 standard, a set of
intrinsic procedures for backwards compatibility with Gnu Fortran 77
(i.e., @command{g77}), and a small selection of intrinsic procedures
from the Fortran 2003 standard.  Any description here, which conflicts with a 
description in either the Fortran 95 standard or the Fortran 2003 standard,
is unintentional and the standard(s) should be considered authoritative.

The enumeration of the @code{KIND} type parameter is processor defined in
the Fortran 95 standard.  Gfortran defines the default integer type and
default real type by @code{INTEGER(KIND=4)} and @code{REAL(KIND=4)},
respectively.  The standard mandates that both data types shall have
another kind, which have more precision.  On typical target architectures
supports by @command{gfortran}, this kind type parameter is @code{KIND=8}.
Hence, @code{REAL(KIND=8)} and @code{DOUBLE PRECISION} are equivalent.
In the description of generic intrinsic procedures, the kind type parameter
will be specified by @code{KIND=*}, and in the description of specific
names for an intrinsic procedure the kind type parameter will be explicitly
given (e.g., @code{REAL(KIND=4)} or @code{REAL(KIND=8)}).  Finally, for
brevity the optional @code{KIND=} syntax will be omitted.

Many of the intrinsics procedures take one or more optional arguments.
This document follows the convention used in the Fortran 95 standard,
and denotes such arguments by square brackets.

@command{Gfortran} offers the @option{-std=f95} and @option{-std=gnu} options,
which can be used to restrict the set of intrinsic procedures to a 
given standard.  By default, @command{gfortran} sets the @option{-std=gnu}
option, and so all intrinsic procedures describe here are accepted.  There
is one caveat.  For a select group of intrinsic procedures, @command{g77}
implemented both a function and a subroutine.  Both classes 
have been implemented in @command{gfortran} for backwards compatibility
with @command{g77}.  It is noted here that these functions and subroutines
cannot be intermixed in a given subprogram.  In the descriptions that follow,
the applicable option(s) is noted.



@node ABORT
@section @code{ABORT} --- Abort the program  
@findex @code{ABORT}
@cindex abort

@table @asis
@item @emph{Description}:
@code{ABORT} causes immediate termination of the program.  On operating
systems that support a core dump, @code{ABORT} will produce a core dump,
which is suitable for debugging purposes.

@item @emph{Option}:
gnu

@item @emph{Type}:
non-elemental subroutine

@item @emph{Syntax}:
@code{CALL ABORT}

@item @emph{Return value}:
Does not return.

@item @emph{Example}:
@smallexample
program test_abort
  integer :: i = 1, j = 2
  if (i /= j) call abort
end program test_abort
@end smallexample
@end table



@node ABS
@section @code{ABS} --- Absolute value  
@findex @code{ABS} intrinsic
@findex @code{CABS} intrinsic
@findex @code{DABS} intrinsic
@findex @code{IABS} intrinsic
@findex @code{ZABS} intrinsic
@findex @code{CDABS} intrinsic
@cindex absolute value

@table @asis
@item @emph{Description}:
@code{ABS(X)} computes the absolute value of @code{X}.

@item @emph{Option}:
f95, gnu

@item @emph{Type}:
elemental function

@item @emph{Syntax}:
@code{X = ABS(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type of the argument shall be an @code{INTEGER(*)},
@code{REAL(*)}, or @code{COMPLEX(*)}.
@end multitable

@item @emph{Return value}:
The return value is of the same type and
kind as the argument except the return value is @code{REAL(*)} for a
@code{COMPLEX(*)} argument.

@item @emph{Example}:
@smallexample
program test_abs
  integer :: i = -1
  real :: x = -1.e0
  complex :: z = (-1.e0,0.e0)
  i = abs(i)
  x = abs(x)
  x = abs(z)
end program test_abs
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument            @tab Return type       @tab Option
@item @code{CABS(Z)}  @tab @code{COMPLEX(4) Z} @tab @code{REAL(4)}    @tab f95, gnu
@item @code{DABS(X)}  @tab @code{REAL(8)    X} @tab @code{REAL(8)}    @tab f95, gnu
@item @code{IABS(I)}  @tab @code{INTEGER(4) I} @tab @code{INTEGER(4)} @tab f95, gnu
@item @code{ZABS(Z)}  @tab @code{COMPLEX(8) Z} @tab @code{COMPLEX(8)} @tab gnu
@item @code{CDABS(Z)} @tab @code{COMPLEX(8) Z} @tab @code{COMPLEX(8)} @tab gnu
@end multitable
@end table



@node ACHAR
@section @code{ACHAR} --- Character in @acronym{ASCII} collating sequence 
@findex @code{ACHAR} intrinsic
@cindex @acronym{ASCII} collating sequence

@table @asis
@item @emph{Description}:
@code{ACHAR(I)} returns the character located at position @code{I}
in the @acronym{ASCII} collating sequence.

@item @emph{Option}:
f95, gnu

@item @emph{Type}:
elemental function

@item @emph{Syntax}:
@code{C = ACHAR(I)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{I} @tab The type shall be an @code{INTEGER(*)}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{CHARACTER} with a length of one.  The
kind type parameter is the same as  @code{KIND('A')}.

@item @emph{Example}:
@smallexample
program test_achar
  character c
  c = achar(32)
end program test_achar
@end smallexample
@end table



@node ACOS
@section @code{ACOS} --- Arccosine function 
@findex @code{ACOS} intrinsic
@findex @code{DACOS} intrinsic
@cindex arccosine

@table @asis
@item @emph{Description}:
@code{ACOS(X)} computes the arccosine of its @var{X}.

@item @emph{Option}:
f95, gnu

@item @emph{Type}:
elemental function

@item @emph{Syntax}:
@code{X = ACOS(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be an @code{REAL(*)}, and a magnitude that is
less than one.
@end multitable

@item @emph{Return value}:
The return value is of type @code{REAL(*)} and it lies in the
range @math{ 0 \leq \arccos (x) \leq \pi}.  The kind type
parameter is the same as @var{X}.

@item @emph{Example}:
@smallexample
program test_acos
  real(8) :: x = 0.866_8
  x = achar(x)
end program test_acos
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{DACOS(X)} @tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab f95, gnu
@end multitable
@end table



@node ADJUSTL
@section @code{ADJUSTL} --- Left adjust a string 
@findex @code{ADJUSTL} intrinsic
@cindex adjust string

@table @asis
@item @emph{Description}:
@code{ADJUSTL(STR)} will left adjust a string by removing leading spaces.
Spaces are inserted at the end of the string as needed.

@item @emph{Option}:
f95, gnu

@item @emph{Type}:
elemental function

@item @emph{Syntax}:
@code{STR = ADJUSTL(STR)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{STR} @tab The type shall be @code{CHARACTER}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{CHARACTER} where leading spaces 
are removed and the same number of spaces are inserted on the end
of @var{STR}.

@item @emph{Example}:
@smallexample
program test_adjustl
  character(len=20) :: str = '   gfortran'
  str = adjustl(str)
  print *, str
end program test_adjustl
@end smallexample
@end table


@node ADJUSTR
@section @code{ADJUSTR} --- Right adjust a string 
@findex @code{ADJUSTR} intrinsic
@cindex adjust string

@table @asis
@item @emph{Description}:
@code{ADJUSTR(STR)} will right adjust a string by removing trailing spaces.
Spaces are inserted at the start of the string as needed.

@item @emph{Option}:
f95, gnu

@item @emph{Type}:
elemental function

@item @emph{Syntax}:
@code{STR = ADJUSTR(STR)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{STR} @tab The type shall be @code{CHARACTER}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{CHARACTER} where trailing spaces 
are removed and the same number of spaces are inserted at the start
of @var{STR}.

@item @emph{Example}:
@smallexample
program test_adjustr
  character(len=20) :: str = 'gfortran'
  str = adjustr(str)
  print *, str
end program test_adjustr
@end smallexample
@end table


@node AIMAG
@section @code{AIMAG} --- Imaginary part of complex number  
@findex @code{AIMAG} intrinsic
@findex @code{DIMAG} intrinsic
@cindex Imaginary part

@table @asis
@item @emph{Description}:
@code{AIMAG(Z)} yields the imaginary part of complex argument @code{Z}.

@item @emph{Option}:
f95, gnu

@item @emph{Type}:
elemental function

@item @emph{Syntax}:
@code{X = AIMAG(Z)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{Z} @tab The type of the argument shall be @code{COMPLEX(*)}.
@end multitable

@item @emph{Return value}:
The return value is of type real with the
kind type parameter of the argument.

@item @emph{Example}:
@smallexample
program test_aimag
  complex(4) z4
  complex(8) z8
  z4 = cmplx(1.e0_4, 0.e0_4)
  z8 = cmplx(0.e0_8, 1.e0_8)
  print *, aimag(z4), dimag(z8)
end program test_aimag
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument            @tab Return type       @tab Option
@item @code{DIMAG(Z)} @tab @code{COMPLEX(8) Z} @tab @code{REAL(8)}    @tab f95, gnu
@end multitable
@end table


@node AINT
@section @code{AINT} --- Imaginary part of complex number  
@findex @code{AINT} intrinsic
@findex @code{DINT} intrinsic
@cindex whole number

@table @asis
@item @emph{Description}:
@code{AINT(X [, KIND])} truncates its argument to a whole number.

@item @emph{Option}:
f95, gnu

@item @emph{Type}:
elemental function

@item @emph{Syntax}:
@code{X = AINT(X)} @*
@code{X = AINT(X, KIND)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X}    @tab The type of the argument shall be @code{REAL(*)}.
@item @var{KIND} @tab (Optional) @var{KIND} shall be a scalar integer
initialization expression.
@end multitable

@item @emph{Return value}:
The return value is of type real with the kind type parameter of the
argument if the optional @var{KIND} is absence; otherwise, the kind
type parameter will be given by @var{KIND}.  If the magnitude of 
@var{X} is less than one, then @code{AINT(X)} returns zero.  If the
magnitude is equal to or greater than one, then it returns the largest
whole number that does not exceed its magnitude.  The sign is the same
as the sign of @var{X}. 

@item @emph{Example}:
@smallexample
program test_aint
  real(4) x4
  real(8) x8
  x4 = 1.234E0_4
  x8 = 4.321_8
  print *, aint(x4), dint(x8)
  x8 = aint(x4,8)
end program test_aint
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name           @tab Argument         @tab Return type      @tab Option
@item @code{DINT(X)} @tab @code{REAL(8) X} @tab @code{REAL(8)}   @tab f95, gnu
@end multitable
@end table


@node ALL
@section @code{ALL} --- All values in @var{MASK} along @var{DIM} are true 
  @findex @code{ALL} intrinsic
@cindex true values

@table @asis
@item @emph{Description}:
@code{ALL(MASK [, DIM])} determines if all the values are true in @var{MASK}
in the array along dimension @var{DIM}.

@item @emph{Option}:
f95, gnu

@item @emph{Type}:
transformational function

@item @emph{Syntax}:
@code{L = ALL(MASK)} @*
@code{L = ALL(MASK, DIM)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{MASK} @tab The type of the argument shall be @code{LOGICAL(*)} and
it shall not be scalar.
@item @var{DIM}  @tab (Optional) @var{DIM} shall be a scalar integer
with a value that lies between one and the rank of @var{MASK}.
@end multitable

@item @emph{Return value}:
@code{ALL(MASK)} returns a scalar value of type @code{LOGICAL(*)} where
the kind type parameter is the same as the kind type parameter of
@var{MASK}.  If @var{DIM} is present, then @code{ALL(MASK, DIM)} returns
an array with the rank of @var{MASK} minus 1.  The shape is determined from
the shape of @var{MASK} where the @var{DIM} dimension is elided. 

@table @asis
@item (A)
@code{ALL(MASK)} is true if all elements of @var{MASK} are true.
It also is true if @var{MASK} has zero size; otherwise, it is false.
@item (B)
If the rank of @var{MASK} is one, then @code{ALL(MASK,DIM)} is equivalent
to @code{ALL(MASK)}.  If the rank is greater than one, then @code{ALL(MASK,DIM)}
is determined by applying @code{ALL} to the array sections.
@end table

@item @emph{Example}:
@smallexample
program test_all
  logical l
  l = all((/.true., .true., .true./))
  print *, l
  call section
  contains
    subroutine section
      integer a(2,3), b(2,3)
      a = 1
      b = 1
      b(2,2) = 2
      print *, all(a .eq. b, 1)
      print *, all(a .eq. b, 2)
    end subroutine section
end program test_all
@end smallexample
@end table


@node ALLOCATED
@section @code{ALLOCATED} --- Status of an allocatable entity
@findex @code{ALLOCATED} intrinsic
@cindex allocation status

@table @asis
@item @emph{Description}:
@code{ALLOCATED(X)} checks the status of wether @var{X} is allocated.

@item @emph{Option}:
f95, gnu

@item @emph{Type}:
inquiry function

@item @emph{Syntax}:
@code{L = ALLOCATED(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X}    @tab The argument shall be an @code{ALLOCATABLE} array.
@end multitable

@item @emph{Return value}:
The return value is a scalar @code{LOGICAL} with the default logical
kind type parameter.  If @var{X} is allocated, @code{ALLOCATED(X)}
is @code{.TRUE.}; otherwise, it returns the @code{.TRUE.} 

@item @emph{Example}:
@smallexample
program test_allocated
  integer :: i = 4
  real(4), allocatable :: x(:)
  if (allocated(x) .eqv. .false.) allocate(x(i)
end program test_allocated
@end smallexample
@end table


@node ANINT
@section @code{ANINT} --- Imaginary part of complex number  
@findex @code{ANINT} intrinsic
@findex @code{DNINT} intrinsic
@cindex whole number

@table @asis
@item @emph{Description}:
@code{ANINT(X [, KIND])} rounds its argument to the nearest whole number.

@item @emph{Option}:
f95, gnu

@item @emph{Type}:
elemental function

@item @emph{Syntax}:
@code{X = ANINT(X)} @*
@code{X = ANINT(X, KIND)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X}    @tab The type of the argument shall be @code{REAL(*)}.
@item @var{KIND} @tab (Optional) @var{KIND} shall be a scalar integer
initialization expression.
@end multitable

@item @emph{Return value}:
The return value is of type real with the kind type parameter of the
argument if the optional @var{KIND} is absence; otherwise, the kind
type parameter will be given by @var{KIND}.  If @var{X} is greater than
zero, then @code{ANINT(X)} returns @code{AINT(X+0.5)}.  If @var{X} is
less than or equal to zero, then return @code{AINT(X-0.5)}.

@item @emph{Example}:
@smallexample
program test_anint
  real(4) x4
  real(8) x8
  x4 = 1.234E0_4
  x8 = 4.321_8
  print *, anint(x4), dnint(x8)
  x8 = anint(x4,8)
end program test_anint
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument         @tab Return type      @tab Option
@item @code{DNINT(X)} @tab @code{REAL(8) X} @tab @code{REAL(8)}   @tab f95, gnu
@end multitable
@end table


@node ANY
@section @code{ANY} --- Any value in @var{MASK} along @var{DIM} is true 
  @findex @code{ANY} intrinsic
@cindex true values

@table @asis
@item @emph{Description}:
@code{ANY(MASK [, DIM])} determines if any of the values is true in @var{MASK}
in the array along dimension @var{DIM}.

@item @emph{Option}:
f95, gnu

@item @emph{Type}:
transformational function

@item @emph{Syntax}:
@code{L = ANY(MASK)} @*
@code{L = ANY(MASK, DIM)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{MASK} @tab The type of the argument shall be @code{LOGICAL(*)} and
it shall not be scalar.
@item @var{DIM}  @tab (Optional) @var{DIM} shall be a scalar integer
with a value that lies between one and the rank of @var{MASK}.
@end multitable

@item @emph{Return value}:
@code{ANY(MASK)} returns a scalar value of type @code{LOGICAL(*)} where
the kind type parameter is the same as the kind type parameter of
@var{MASK}.  If @var{DIM} is present, then @code{ANY(MASK, DIM)} returns
an array with the rank of @var{MASK} minus 1.  The shape is determined from
the shape of @var{MASK} where the @var{DIM} dimension is elided. 

@table @asis
@item (A)
@code{ANY(MASK)} is true if any element of @var{MASK} is true;
otherwise, it is false.  It also is false if @var{MASK} has zero size.
@item (B)
If the rank of @var{MASK} is one, then @code{ANY(MASK,DIM)} is equivalent
to @code{ANY(MASK)}.  If the rank is greater than one, then @code{ANY(MASK,DIM)}
is determined by applying @code{ANY} to the array sections.
@end table

@item @emph{Example}:
@smallexample
program test_any
  logical l
  l = any((/.true., .true., .true./))
  print *, l
  call section
  contains
    subroutine section
      integer a(2,3), b(2,3)
      a = 1
      b = 1
      b(2,2) = 2
      print *, any(a .eq. b, 1)
      print *, any(a .eq. b, 2)
    end subroutine section
end program test_any
@end smallexample
@end table


@node ASIN
@section @code{ASIN} --- Arcsine function 
@findex @code{ASIN} intrinsic
@findex @code{DASIN} intrinsic
@cindex arcsine

@table @asis
@item @emph{Description}:
@code{ASIN(X)} computes the arcsine of its @var{X}.

@item @emph{Option}:
f95, gnu

@item @emph{Type}:
elemental function

@item @emph{Syntax}:
@code{X = ASIN(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be an @code{REAL(*)}, and a magnitude that is
less than one.
@end multitable

@item @emph{Return value}:
The return value is of type @code{REAL(*)} and it lies in the
range @math{ \pi / 2 \leq \arccos (x) \leq \pi / 2}.  The kind type
parameter is the same as @var{X}.

@item @emph{Example}:
@smallexample
program test_asin
  real(8) :: x = 0.866_8
  x = asin(x)
end program test_asin
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{DASIN(X)} @tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab f95, gnu
@end multitable
@end table


@node ATAN
@section @code{ATAN} --- Arctangent function 
@findex @code{ATAN} intrinsic
@findex @code{DATAN} intrinsic
@cindex arctangent

@table @asis
@item @emph{Description}:
@code{ATAN(X)} computes the arctangent of @var{X}.

@item @emph{Option}:
f95, gnu

@item @emph{Type}:
elemental function

@item @emph{Syntax}:
@code{X = ATAN(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be an @code{REAL(*)}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{REAL(*)} and it lies in the
range @math{ - \pi / 2 \leq \arcsin (x) \leq \pi / 2}.

@item @emph{Example}:
@smallexample
program test_atan
  real(8) :: x = 2.866_8
  x = atan(x)
end program test_atan
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{DATAN(X)} @tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab f95, gnu
@end multitable
@end table



@node BESJ0
@section @code{BESJ0} --- Bessel function of the first kind of order 0
@findex @code{BESJ0} intrinsic
@findex @code{DBESJ0} intrinsic
@cindex Bessel

@table @asis
@item @emph{Description}:
@code{BESJ0(X)} computes the Bessel function of the first kind of order 0
of @var{X}.

@item @emph{Option}:
gnu

@item @emph{Type}:
elemental function

@item @emph{Syntax}:
@code{X = BESJ0(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be an @code{REAL(*)}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{REAL(*)} and it lies in the
range @math{ - 0.4027... \leq Bessel (0,x) \leq 1}.

@item @emph{Example}:
@smallexample
program test_besj0
  real(8) :: x = 0.0_8
  x = besj0(x)
end program test_besj0
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{DBESJ0(X)} @tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab gnu
@end multitable
@end table



@node BESJ1
@section @code{BESJ1} --- Bessel function of the first kind of order 1
@findex @code{BESJ1} intrinsic
@findex @code{DBESJ1} intrinsic
@cindex Bessel

@table @asis
@item @emph{Description}:
@code{BESJ1(X)} computes the Bessel function of the first kind of order 1
of @var{X}.

@item @emph{Option}:
gnu

@item @emph{Type}:
elemental function

@item @emph{Syntax}:
@code{X = BESJ1(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be an @code{REAL(*)}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{REAL(*)} and it lies in the
range @math{ - 0.5818... \leq Bessel (0,x) \leq 0.5818 }.

@item @emph{Example}:
@smallexample
program test_besj1
  real(8) :: x = 1.0_8
  x = besj1(x)
end program test_besj1
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{DBESJ1(X)}@tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab gnu
@end multitable
@end table



@node BESJN
@section @code{BESJN} --- Bessel function of the first kind
@findex @code{BESJN} intrinsic
@findex @code{DBESJN} intrinsic
@cindex Bessel

@table @asis
@item @emph{Description}:
@code{BESJN(N, X)} computes the Bessel function of the first kind of order
@var{N} of @var{X}.

@item @emph{Option}:
gnu

@item @emph{Type}:
elemental function

@item @emph{Syntax}:
@code{Y = BESJN(N, X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{N} @tab The type shall be an @code{INTEGER(*)}.
@item @var{X} @tab The type shall be an @code{REAL(*)}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{REAL(*)}.

@item @emph{Example}:
@smallexample
program test_besjn
  real(8) :: x = 1.0_8
  x = besjn(5,x)
end program test_besjn
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{DBESJN(X)}@tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab gnu
@end multitable
@end table



@node BESY0
@section @code{BESY0} --- Bessel function of the second kind of order 0
@findex @code{BESY0} intrinsic
@findex @code{DBESY0} intrinsic
@cindex Bessel

@table @asis
@item @emph{Description}:
@code{BESY0(X)} computes the Bessel function of the second kind of order 0
of @var{X}.

@item @emph{Option}:
gnu

@item @emph{Type}:
elemental function

@item @emph{Syntax}:
@code{X = BESY0(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be an @code{REAL(*)}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{REAL(*)}.

@item @emph{Example}:
@smallexample
program test_besy0
  real(8) :: x = 0.0_8
  x = besy0(x)
end program test_besy0
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{DBESY0(X)}@tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab gnu
@end multitable
@end table



@node BESY1
@section @code{BESY1} --- Bessel function of the second kind of order 1
@findex @code{BESY1} intrinsic
@findex @code{DBESY1} intrinsic
@cindex Bessel

@table @asis
@item @emph{Description}:
@code{BESY1(X)} computes the Bessel function of the second kind of order 1
of @var{X}.

@item @emph{Option}:
gnu

@item @emph{Type}:
elemental function

@item @emph{Syntax}:
@code{X = BESY1(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be an @code{REAL(*)}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{REAL(*)}.

@item @emph{Example}:
@smallexample
program test_besy1
  real(8) :: x = 1.0_8
  x = besy1(x)
end program test_besy1
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{DBESY1(X)}@tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab gnu
@end multitable
@end table



@node BESYN
@section @code{BESYN} --- Bessel function of the second kind
@findex @code{BESYN} intrinsic
@findex @code{DBESYN} intrinsic
@cindex Bessel

@table @asis
@item @emph{Description}:
@code{BESYN(N, X)} computes the Bessel function of the second kind of order
@var{N} of @var{X}.

@item @emph{Option}:
gnu

@item @emph{Type}:
elemental function

@item @emph{Syntax}:
@code{Y = BESYN(N, X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{N} @tab The type shall be an @code{INTEGER(*)}.
@item @var{X} @tab The type shall be an @code{REAL(*)}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{REAL(*)}.

@item @emph{Example}:
@smallexample
program test_besyn
  real(8) :: x = 1.0_8
  x = besyn(5,x)
end program test_besyn
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{DBESYN(X)}@tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab gnu
@end multitable
@end table


@node COS
@section @code{COS} --- Cosine function 
@findex @code{COS} intrinsic
@findex @code{DCOS} intrinsic
@findex @code{ZCOS} intrinsic
@findex @code{CDCOS} intrinsic
@cindex cosine

@table @asis
@item @emph{Description}:
@code{COS(X)} computes the cosine of @var{X}.

@item @emph{Option}:
f95, gnu

@item @emph{Type}:
elemental function

@item @emph{Syntax}:
@code{X = COS(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be an @code{REAL(*)} or
@code{COMPLEX(*)}.
@end multitable

@item @emph{Return value}:
The return value has same type and kind than @var{X}.

@item @emph{Example}:
@smallexample
program test_cos
  real :: x = 0.0
  x = cos(x)
end program test_cos
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{DCOS(X)}  @tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab f95, gnu
@item @code{CCOS(X)}  @tab @code{COMPLEX(4) X}  @tab @code{COMPLEX(4)}    @tab f95, gnu
@item @code{ZCOS(X)}  @tab @code{COMPLEX(8) X}  @tab @code{COMPLEX(8)}    @tab f95, gnu
@item @code{CDCOS(X)} @tab @code{COMPLEX(8) X}  @tab @code{COMPLEX(8)}    @tab f95, gnu
@end multitable
@end table


@node COSH
@section @code{COSH} --- Hyperbolic cosine function 
@findex @code{COSH} intrinsic
@findex @code{DCOSH} intrinsic
@cindex hyperbolic cosine

@table @asis
@item @emph{Description}:
@code{COSH(X)} computes the hyperbolic cosine of @var{X}.

@item @emph{Option}:
f95, gnu

@item @emph{Type}:
elemental function

@item @emph{Syntax}:
@code{X = COSH(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be an @code{REAL(*)}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{REAL(*)} and it is positive
(@math{ \cosh (x) \geq 0 }.

@item @emph{Example}:
@smallexample
program test_cosh
  real(8) :: x = 1.0_8
  x = cosh(x)
end program test_cosh
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{DCOSH(X)} @tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab f95, gnu
@end multitable
@end table


@node ERF
@section @code{ERF} --- Error function 
@findex @code{ERF} intrinsic
@cindex error

@table @asis
@item @emph{Description}:
@code{ERF(X)} computes the error function of @var{X}.

@item @emph{Option}:
gnu

@item @emph{Type}:
elemental function

@item @emph{Syntax}:
@code{X = ERF(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be an @code{REAL(*)}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{REAL(*)} and it is positive
(@math{ - 1 \leq erf (x) \leq 1 }.

@item @emph{Example}:
@smallexample
program test_erf
  real(8) :: x = 0.17_8
  x = erf(x)
end program test_erf
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{DERF(X)}  @tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab gnu
@end multitable
@end table



@node ERFC
@section @code{ERFC} --- Error function 
@findex @code{ERFC} intrinsic
@cindex error

@table @asis
@item @emph{Description}:
@code{ERFC(X)} computes the complementary error function of @var{X}.

@item @emph{Option}:
gnu

@item @emph{Type}:
elemental function

@item @emph{Syntax}:
@code{X = ERFC(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be an @code{REAL(*)}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{REAL(*)} and it is positive
(@math{ 0 \leq erfc (x) \leq 2 }.

@item @emph{Example}:
@smallexample
program test_erfc
  real(8) :: x = 0.17_8
  x = erfc(x)
end program test_erfc
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{DERFC(X)} @tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab gnu
@end multitable
@end table



@node EXP
@section @code{EXP} --- Exponential function 
@findex @code{EXP} intrinsic
@findex @code{DEXP} intrinsic
@findex @code{ZEXP} intrinsic
@findex @code{CDEXP} intrinsic
@cindex exponential

@table @asis
@item @emph{Description}:
@code{EXP(X)} computes the base @math{e} exponential of @var{X}.

@item @emph{Option}:
f95, gnu

@item @emph{Type}:
elemental function

@item @emph{Syntax}:
@code{X = EXP(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be an @code{REAL(*)} or
@code{COMPLEX(*)}.
@end multitable

@item @emph{Return value}:
The return value has same type and kind than @var{X}.

@item @emph{Example}:
@smallexample
program test_exp
  real :: x = 1.0
  x = exp(x)
end program test_exp
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{DEXP(X)}  @tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab f95, gnu
@item @code{CEXP(X)}  @tab @code{COMPLEX(4) X}  @tab @code{COMPLEX(4)}    @tab f95, gnu
@item @code{ZEXP(X)}  @tab @code{COMPLEX(8) X}  @tab @code{COMPLEX(8)}    @tab f95, gnu
@item @code{CDEXP(X)} @tab @code{COMPLEX(8) X}  @tab @code{COMPLEX(8)}    @tab f95, gnu
@end multitable
@end table


@node LOG
@section @code{LOG} --- Logarithm function
@findex @code{LOG} intrinsic
@findex @code{ALOG} intrinsic
@findex @code{DLOG} intrinsic
@findex @code{CLOG} intrinsic
@findex @code{ZLOG} intrinsic
@findex @code{CDLOG} intrinsic
@cindex logarithm

@table @asis
@item @emph{Description}:
@code{LOG(X)} computes the logarithm of @var{X}.

@item @emph{Option}:
f95, gnu

@item @emph{Type}:
elemental function

@item @emph{Syntax}:
@code{X = LOG(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be an @code{REAL(*)} or
@code{COMPLEX(*)}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{REAL(*)} or @code{COMPLEX(*)}.
The kind type parameter is the same as @var{X}.

@item @emph{Example}:
@smallexample
program test_log
  real(8) :: x = 1.0_8
  complex :: z = (1.0, 2.0)
  x = log(x)
  z = log(z)
end program test_log
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{ALOG(X)}  @tab @code{REAL(4) X}  @tab @code{REAL(4)}    @tab f95, gnu
@item @code{DLOG(X)}  @tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab f95, gnu
@item @code{CLOG(X)}  @tab @code{COMPLEX(4) X}  @tab @code{COMPLEX(4)}    @tab f95, gnu
@item @code{ZLOG(X)}  @tab @code{COMPLEX(8) X}  @tab @code{COMPLEX(8)}    @tab f95, gnu
@item @code{CDLOG(X)} @tab @code{COMPLEX(8) X}  @tab @code{COMPLEX(8)}    @tab f95, gnu
@end multitable
@end table



@node LOG10
@section @code{LOG10} --- Base 10 logarithm function
@findex @code{LOG10} intrinsic
@findex @code{ALOG10} intrinsic
@findex @code{DLOG10} intrinsic
@cindex logarithm

@table @asis
@item @emph{Description}:
@code{LOG10(X)} computes the base 10 logarithm of @var{X}.

@item @emph{Option}:
f95, gnu

@item @emph{Type}:
elemental function

@item @emph{Syntax}:
@code{X = LOG10(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be an @code{REAL(*)} or
@code{COMPLEX(*)}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{REAL(*)} or @code{COMPLEX(*)}.
The kind type parameter is the same as @var{X}.

@item @emph{Example}:
@smallexample
program test_log10
  real(8) :: x = 10.0_8
  x = log10(x)
end program test_log10
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{ALOG10(X)}  @tab @code{REAL(4) X}  @tab @code{REAL(4)}    @tab f95, gnu
@item @code{DLOG10(X)}  @tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab f95, gnu
@end multitable
@end table



@node SIN
@section @code{SIN} --- Sine function 
@findex @code{SIN} intrinsic
@findex @code{DSIN} intrinsic
@findex @code{ZSIN} intrinsic
@findex @code{CDSIN} intrinsic
@cindex sine

@table @asis
@item @emph{Description}:
@code{SIN(X)} computes the sine of @var{X}.

@item @emph{Option}:
f95, gnu

@item @emph{Type}:
elemental function

@item @emph{Syntax}:
@code{X = SIN(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be an @code{REAL(*)} or
@code{COMPLEX(*)}.
@end multitable

@item @emph{Return value}:
The return value has same type and king than @var{X}.

@item @emph{Example}:
@smallexample
program test_sin
  real :: x = 0.0
  x = sin(x)
end program test_sin
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{DSIN(X)}  @tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab f95, gnu
@item @code{CSIN(X)}  @tab @code{COMPLEX(4) X}  @tab @code{COMPLEX(4)}    @tab f95, gnu
@item @code{ZSIN(X)}  @tab @code{COMPLEX(8) X}  @tab @code{COMPLEX(8)}    @tab f95, gnu
@item @code{CDSIN(X)} @tab @code{COMPLEX(8) X}  @tab @code{COMPLEX(8)}    @tab f95, gnu
@end multitable
@end table




@node SINH
@section @code{SINH} --- Hyperbolic sine function 
@findex @code{SINH} intrinsic
@findex @code{DSINH} intrinsic
@cindex hyperbolic sine

@table @asis
@item @emph{Description}:
@code{SINH(X)} computes the hyperbolic sine of @var{X}.

@item @emph{Option}:
f95, gnu

@item @emph{Type}:
elemental function

@item @emph{Syntax}:
@code{X = SINH(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be an @code{REAL(*)}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{REAL(*)}.

@item @emph{Example}:
@smallexample
program test_sinh
  real(8) :: x = - 1.0_8
  x = sinh(x)
end program test_sinh
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{DSINH(X)} @tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab f95, gnu
@end multitable
@end table



@node SQRT
@section @code{SQRT} --- Square-root function
@findex @code{SQRT} intrinsic
@findex @code{DSQRT} intrinsic
@findex @code{CSQRT} intrinsic
@findex @code{ZSQRT} intrinsic
@findex @code{CDSQRT} intrinsic
@cindex square-root

@table @asis
@item @emph{Description}:
@code{SQRT(X)} computes the square root of @var{X}.

@item @emph{Option}:
f95, gnu

@item @emph{Type}:
elemental function

@item @emph{Syntax}:
@code{X = SQRT(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be an @code{REAL(*)} or
@code{COMPLEX(*)}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{REAL(*)} or @code{COMPLEX(*)}.
The kind type parameter is the same as @var{X}.

@item @emph{Example}:
@smallexample
program test_sqrt
  real(8) :: x = 2.0_8
  complex :: z = (1.0, 2.0)
  x = sqrt(x)
  z = sqrt(z)
end program test_sqrt
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{DSQRT(X)}  @tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab f95, gnu
@item @code{CSQRT(X)}  @tab @code{COMPLEX(4) X}  @tab @code{COMPLEX(4)}    @tab f95, gnu
@item @code{ZSQRT(X)}  @tab @code{COMPLEX(8) X}  @tab @code{COMPLEX(8)}    @tab f95, gnu
@item @code{CDSQRT(X)} @tab @code{COMPLEX(8) X}  @tab @code{COMPLEX(8)}    @tab f95, gnu
@end multitable
@end table



@node TAN
@section @code{TAN} --- Tangent function
@findex @code{TAN} intrinsic
@findex @code{DTAN} intrinsic
@cindex tangent

@table @asis
@item @emph{Description}:
@code{TAN(X)} computes the tangent of @var{X}.

@item @emph{Option}:
f95, gnu

@item @emph{Type}:
elemental function

@item @emph{Syntax}:
@code{X = TAN(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be an @code{REAL(*)}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{REAL(*)}.  The kind type parameter is
the same as @var{X}.

@item @emph{Example}:
@smallexample
program test_tan
  real(8) :: x = 0.165_8
  x = tan(x)
end program test_tan
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{DTAN(X)}  @tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab f95, gnu
@end multitable
@end table


@node TANH
@section @code{TANH} --- Hyperbolic tangent function 
@findex @code{TANH} intrinsic
@findex @code{DTANH} intrinsic
@cindex hyperbolic tangent

@table @asis
@item @emph{Description}:
@code{TANH(X)} computes the hyperbolic tangent of @var{X}.

@item @emph{Option}:
f95, gnu

@item @emph{Type}:
elemental function

@item @emph{Syntax}:
@code{X = TANH(X)}

@item @emph{Arguments}:
@multitable @columnfractions .15 .80
@item @var{X} @tab The type shall be an @code{REAL(*)}.
@end multitable

@item @emph{Return value}:
The return value is of type @code{REAL(*)} and lies in the range
@math{ - 1 \leq tanh(x) \leq 1 }.

@item @emph{Example}:
@smallexample
program test_tanh
  real(8) :: x = 2.1_8
  x = tanh(x)
end program test_tanh
@end smallexample

@item @emph{Specific names}:
@multitable @columnfractions .24 .24 .24 .24
@item Name            @tab Argument          @tab Return type       @tab Option
@item @code{DTANH(X)} @tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab f95, gnu
@end multitable
@end table



@comment gen   associated
@comment 
@comment gen   atan2
@comment       datan2
@comment 
@comment gen   bit_size 
@comment 
@comment gen   btest
@comment 
@comment gen   ceiling
@comment 
@comment gen   char
@comment 
@comment gen   cmplx 
@comment 
@comment gen   command_argument_count
@comment 
@comment gen   conjg
@comment       dconjg
@comment 
@comment gen   count
@comment 
@comment sub   cpu_time
@comment 
@comment gen   cshift
@comment 
@comment sub   date_and_time
@comment 
@comment gen   dble 
@comment       dfloat
@comment 
@comment gen   dcmplx
@comment 
@comment gen   digits
@comment 
@comment gen   dim
@comment       idim
@comment       ddim
@comment 
@comment gen   dot_product
@comment 
@comment gen   dprod
@comment 
@comment gen   dreal 
@comment 
@comment sub   dtime
@comment 
@comment gen   eoshift
@comment 
@comment gen   epsilon
@comment 
@comment gen   etime
@comment sub   etime
@comment 
@comment sub   exit
@comment 
@comment gen   exponent
@comment 
@comment gen   floor
@comment 
@comment sub   flush
@comment 
@comment gen   fnum
@comment 
@comment gen   fraction
@comment 
@comment gen   fstat
@comment sub   fstat
@comment 
@comment sub   getarg
@comment 
@comment gen   getcwd
@comment sub   getcwd
@comment 
@comment sub   getenv
@comment 
@comment gen   getgid
@comment 
@comment gen   getpid
@comment 
@comment gen   getuid
@comment 
@comment sub   get_command
@comment 
@comment sub   get_command_argument
@comment 
@comment sub   get_environment_variable
@comment 
@comment gen   huge
@comment 
@comment gen   iachar
@comment 
@comment gen   iand
@comment 
@comment gen   iargc
@comment 
@comment gen   ibclr
@comment 
@comment gen   ibits
@comment 
@comment gen   ibset
@comment 
@comment gen   ichar
@comment 
@comment gen   ieor
@comment 
@comment gen   index
@comment 
@comment gen   int
@comment       ifix
@comment       idint
@comment 
@comment gen   ior
@comment 
@comment gen   irand
@comment 
@comment gen   ishft
@comment 
@comment gen   ishftc
@comment 
@comment gen   kind
@comment 
@comment gen   lbound
@comment 
@comment gen   len
@comment 
@comment gen   len_trim
@comment 
@comment gen   lge
@comment 
@comment gen   lgt
@comment 
@comment gen   lle
@comment 
@comment gen   llt
@comment 
@comment gen   logical
@comment 
@comment gen   matmul
@comment 
@comment gen   max
@comment       max0
@comment       amax0
@comment       amax1
@comment       max1
@comment       dmax1
@comment 
@comment gen   maxexponent
@comment 
@comment gen   maxloc
@comment 
@comment gen   maxval
@comment 
@comment gen   merge
@comment 
@comment gen   min
@comment       min0
@comment       amin0
@comment       amin1
@comment       min1
@comment       dmin1
@comment 
@comment gen   minexponent
@comment 
@comment gen   minloc
@comment 
@comment gen   minval
@comment 
@comment gen   mod
@comment       amod
@comment       dmod
@comment 
@comment gen   modulo
@comment 
@comment sub   mvbits
@comment 
@comment gen   nearest
@comment 
@comment gen   nint
@comment       idnint
@comment 
@comment gen   not
@comment 
@comment gen   null
@comment 
@comment gen   pack
@comment 
@comment gen   precision
@comment 
@comment gen   present
@comment 
@comment gen   product
@comment 
@comment gen   radix
@comment 
@comment gen   rand
@comment       ran 
@comment 
@comment sub   random_number
@comment 
@comment sub   random_seed
@comment 
@comment gen   range
@comment 
@comment gen   real
@comment       float
@comment       sngl
@comment 
@comment gen   repeat
@comment 
@comment gen   reshape
@comment 
@comment gen   rrspacing
@comment 
@comment gen   scale
@comment 
@comment gen   scan
@comment 
@comment gen   second
@comment sub   second
@comment 
@comment gen   selected_int_kind
@comment 
@comment gen   selected_real_kind
@comment 
@comment gen   set_exponent
@comment 
@comment gen   shape
@comment 
@comment gen   sign
@comment       isign
@comment       dsign
@comment 
@comment gen   size
@comment 
@comment gen   spacing
@comment 
@comment gen   spread
@comment 
@comment sub   srand
@comment 
@comment gen   stat
@comment sub   stat
@comment 
@comment gen   sum
@comment 
@comment gen   system
@comment sub   system
@comment 
@comment sub system_clock
@comment 
@comment gen   tiny
@comment 
@comment gen   transfer
@comment 
@comment gen   transpose
@comment 
@comment gen   trim
@comment 
@comment gen   ubound
@comment 
@comment gen   umask
@comment sub   umask
@comment 
@comment gen   unlink
@comment sub   unlink
@comment 
@comment gen   unpack
@comment 
@comment gen   verify

