<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libgimpprint API Reference: src/main/print-weave.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>src/main/print-weave.c</h1><a href="print-weave_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * "$Id: print-weave_8c-source.html,v 1.1.1.2 2004/12/22 23:49:11 jlovell Exp $"</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> *   Softweave calculator for gimp-print.</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> *   Copyright 2000 Charles Briscoe-Smith &lt;cpbs@debian.org&gt;</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> *   This program is free software; you can redistribute it and/or modify it</span>
00009 <span class="comment"> *   under the terms of the GNU General Public License as published by the Free</span>
00010 <span class="comment"> *   Software Foundation; either version 2 of the License, or (at your option)</span>
00011 <span class="comment"> *   any later version.</span>
00012 <span class="comment"> *</span>
00013 <span class="comment"> *   This program is distributed in the hope that it will be useful, but</span>
00014 <span class="comment"> *   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY</span>
00015 <span class="comment"> *   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</span>
00016 <span class="comment"> *   for more details.</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> *   You should have received a copy of the GNU General Public License</span>
00019 <span class="comment"> *   along with this program; if not, write to the Free Software</span>
00020 <span class="comment"> *   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
00021 <span class="comment"> */</span>
00022 
00023 <span class="comment">/*</span>
00024 <span class="comment"> * This file must include only standard C header files.  The core code must</span>
00025 <span class="comment"> * compile on generic platforms that don't support glib, gimp, gtk, etc.</span>
00026 <span class="comment"> */</span>
00027 
00028 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
00029 <span class="preprocessor"></span><span class="preprocessor">#include &lt;config.h&gt;</span>
00030 <span class="preprocessor">#endif</span>
00031 <span class="preprocessor"></span><span class="preprocessor">#include &lt;string.h&gt;</span>
00032 <span class="preprocessor">#include &lt;<a class="code" href="gimp-print_8h.html">gimp-print/gimp-print.h</a>&gt;</span>
00033 <span class="preprocessor">#include "<a class="code" href="gimp-print-internal_8h.html">gimp-print-internal.h</a>"</span>
00034 <span class="preprocessor">#include &lt;<a class="code" href="gimp-print-intl-internal_8h.html">gimp-print/gimp-print-intl-internal.h</a>&gt;</span>
00035 <span class="preprocessor">#ifdef HAVE_LIMITS_H</span>
00036 <span class="preprocessor"></span><span class="preprocessor">#include &lt;limits.h&gt;</span>
00037 <span class="preprocessor">#endif</span>
00038 <span class="preprocessor"></span>
00039 <span class="preprocessor">#if 1</span>
<a name="l00040"></a><a class="code" href="print-weave_8c.html#a0">00040</a> <span class="preprocessor"></span><span class="preprocessor">#define ASSERTIONS</span>
00041 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00042 <span class="preprocessor"></span>
00043 <span class="preprocessor">#ifdef ASSERTIONS</span>
<a name="l00044"></a><a class="code" href="print-weave_8c.html#a1">00044</a> <span class="preprocessor"></span><span class="preprocessor">#define assert(x,v)                                                     \</span>
00045 <span class="preprocessor">do                                                                      \</span>
00046 <span class="preprocessor">{                                                                       \</span>
00047 <span class="preprocessor">  if (!(x))                                                             \</span>
00048 <span class="preprocessor">    {                                                                   \</span>
00049 <span class="preprocessor">      stp_eprintf(v, "Assertion %s failed! file %s, line %d.\n",        \</span>
00050 <span class="preprocessor">                  #x, __FILE__, __LINE__);                              \</span>
00051 <span class="preprocessor">      stp_abort();                                                      \</span>
00052 <span class="preprocessor">    }                                                                   \</span>
00053 <span class="preprocessor">} while (0)</span>
00054 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00055 <span class="preprocessor"></span><span class="preprocessor">#define assert(x,v) do {} while (0)</span>
00056 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00057 <span class="preprocessor"></span>
00058 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00059"></a><a class="code" href="print-weave_8c.html#a5">00059</a> <a class="code" href="print-weave_8c.html#a5">gcd</a>(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y)
00060 {
00061         <span class="keywordflow">if</span> (y == 0)
00062                 <span class="keywordflow">return</span> x;
00063         <span class="keywordflow">while</span> (x != 0) {
00064                 <span class="keywordflow">if</span> (y &gt; x) {
00065                         <span class="keywordtype">int</span> t = x;
00066                         x = y;
00067                         y = t;
00068                 }
00069                 x %= y;
00070         }
00071         <span class="keywordflow">return</span> y;
00072 }
00073 
<a name="l00074"></a><a class="code" href="structstpi__softweave.html">00074</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structstpi__softweave.html">stpi_softweave</a>
00075 {
<a name="l00076"></a><a class="code" href="structstpi__softweave.html#o0">00076</a>   <a class="code" href="structstp__linebufs__t.html">stp_linebufs_t</a> *<a class="code" href="structstpi__softweave.html#o0">linebases</a>;    <span class="comment">/* Base address of each row buffer */</span>
<a name="l00077"></a><a class="code" href="structstpi__softweave.html#o1">00077</a>   <a class="code" href="structstp__lineoff__t.html">stp_lineoff_t</a> *<a class="code" href="structstpi__softweave.html#o1">lineoffsets</a>;   <span class="comment">/* Offsets within each row buffer */</span>
<a name="l00078"></a><a class="code" href="structstpi__softweave.html#o2">00078</a>   <a class="code" href="structstp__lineactive__t.html">stp_lineactive_t</a> *<a class="code" href="structstpi__softweave.html#o2">lineactive</a>; <span class="comment">/* Does this line have anything printed? */</span>
<a name="l00079"></a><a class="code" href="structstpi__softweave.html#o3">00079</a>   <a class="code" href="structstp__linecount__t.html">stp_linecount_t</a> *<a class="code" href="structstpi__softweave.html#o3">linecounts</a>;  <span class="comment">/* How many rows we've printed this pass */</span>
<a name="l00080"></a><a class="code" href="structstpi__softweave.html#o4">00080</a>   <a class="code" href="structstp__linebounds__t.html">stp_linebounds_t</a> *<a class="code" href="structstpi__softweave.html#o4">linebounds</a>; <span class="comment">/* Starting and ending print column */</span>
<a name="l00081"></a><a class="code" href="structstpi__softweave.html#o5">00081</a>   <a class="code" href="structstp__pass__t.html">stp_pass_t</a> *<a class="code" href="structstpi__softweave.html#o5">passes</a>;           <span class="comment">/* Circular list of pass numbers */</span>
<a name="l00082"></a><a class="code" href="structstpi__softweave.html#o6">00082</a>   <span class="keywordtype">int</span> last_pass_offset;         <span class="comment">/* Starting row (offset from the start of */</span>
00083                                 <span class="comment">/* the page) of the most recently printed */</span>
00084                                 <span class="comment">/* pass (so we can determine how far to */</span>
00085                                 <span class="comment">/* advance the paper) */</span>
<a name="l00086"></a><a class="code" href="structstpi__softweave.html#o7">00086</a>   <span class="keywordtype">int</span> last_pass;                <span class="comment">/* Number of the most recently printed pass */</span>
00087 
<a name="l00088"></a><a class="code" href="structstpi__softweave.html#o8">00088</a>   <span class="keywordtype">int</span> jets;                     <span class="comment">/* Number of jets per color */</span>
<a name="l00089"></a><a class="code" href="structstpi__softweave.html#o9">00089</a>   <span class="keywordtype">int</span> <a class="code" href="structstpi__softweave.html#o9">virtual_jets</a>;             <span class="comment">/* Number of jets per color, taking into */</span>
00090                                 <span class="comment">/* account the head offset */</span>
<a name="l00091"></a><a class="code" href="structstpi__softweave.html#o10">00091</a>   <span class="keywordtype">int</span> <a class="code" href="structstpi__softweave.html#o10">separation</a>;               <span class="comment">/* Offset from one jet to the next in rows */</span>
<a name="l00092"></a><a class="code" href="structstpi__softweave.html#o11">00092</a>   <span class="keywordtype">void</span> *<a class="code" href="structstpi__softweave.html#o11">weaveparm</a>;              <span class="comment">/* Weave calculation parameter block */</span>
00093 
<a name="l00094"></a><a class="code" href="structstpi__softweave.html#o12">00094</a>   <span class="keywordtype">int</span> horizontal_weave;         <span class="comment">/* Number of horizontal passes required */</span>
00095                                 <span class="comment">/* This is &gt; 1 for some of the ultra-high */</span>
00096                                 <span class="comment">/* resolution modes */</span>
<a name="l00097"></a><a class="code" href="structstpi__softweave.html#o13">00097</a>   <span class="keywordtype">int</span> <a class="code" href="structstpi__softweave.html#o13">vertical_subpasses</a>;       <span class="comment">/* Number of passes per line (for better */</span>
00098                                 <span class="comment">/* quality) */</span>
<a name="l00099"></a><a class="code" href="structstpi__softweave.html#o14">00099</a>   <span class="keywordtype">int</span> <a class="code" href="structstpi__softweave.html#o14">vmod</a>;                     <span class="comment">/* Number of banks of passes */</span>
<a name="l00100"></a><a class="code" href="structstpi__softweave.html#o15">00100</a>   <span class="keywordtype">int</span> <a class="code" href="structstpi__softweave.html#o15">oversample</a>;               <span class="comment">/* Excess precision per row */</span>
<a name="l00101"></a><a class="code" href="structstpi__softweave.html#o16">00101</a>   <span class="keywordtype">int</span> <a class="code" href="structstpi__softweave.html#o16">repeat_count</a>;             <span class="comment">/* How many times a pass is repeated */</span>
<a name="l00102"></a><a class="code" href="structstpi__softweave.html#o17">00102</a>   <span class="keywordtype">int</span> ncolors;                  <span class="comment">/* How many colors */</span>
<a name="l00103"></a><a class="code" href="structstpi__softweave.html#o18">00103</a>   <span class="keywordtype">int</span> <a class="code" href="structstpi__softweave.html#o18">linewidth</a>;                <span class="comment">/* Line width in input pixels */</span>
<a name="l00104"></a><a class="code" href="structstpi__softweave.html#o19">00104</a>   <span class="keywordtype">int</span> <a class="code" href="structstpi__softweave.html#o19">vertical_height</a>;          <span class="comment">/* Image height in output pixels */</span>
<a name="l00105"></a><a class="code" href="structstpi__softweave.html#o20">00105</a>   <span class="keywordtype">int</span> <a class="code" href="structstpi__softweave.html#o20">firstline</a>;                <span class="comment">/* Actual first line (referenced to paper) */</span>
00106 
<a name="l00107"></a><a class="code" href="structstpi__softweave.html#o21">00107</a>   <span class="keywordtype">int</span> bitwidth;                 <span class="comment">/* Bits per pixel */</span>
<a name="l00108"></a><a class="code" href="structstpi__softweave.html#o22">00108</a>   <span class="keywordtype">int</span> <a class="code" href="structstpi__softweave.html#o22">lineno</a>;
<a name="l00109"></a><a class="code" href="structstpi__softweave.html#o23">00109</a>   <span class="keywordtype">int</span> vertical_oversample;      <span class="comment">/* Vertical oversampling */</span>
<a name="l00110"></a><a class="code" href="structstpi__softweave.html#o24">00110</a>   <span class="keywordtype">int</span> <a class="code" href="structstpi__softweave.html#o24">current_vertical_subpass</a>;
<a name="l00111"></a><a class="code" href="structstpi__softweave.html#o25">00111</a>   <span class="keywordtype">int</span> <a class="code" href="structstpi__softweave.html#o25">horizontal_width</a>;         <span class="comment">/* Horizontal width, in bits */</span>
<a name="l00112"></a><a class="code" href="structstpi__softweave.html#o26">00112</a>   <span class="keywordtype">int</span> *head_offset;             <span class="comment">/* offset of printheads */</span>
<a name="l00113"></a><a class="code" href="structstpi__softweave.html#o27">00113</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *<a class="code" href="structstpi__softweave.html#o27">s</a>[<a class="code" href="weave_8h.html#a0">STP_MAX_WEAVE</a>];
<a name="l00114"></a><a class="code" href="structstpi__softweave.html#o28">00114</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *<a class="code" href="structstpi__softweave.html#o28">fold_buf</a>;
<a name="l00115"></a><a class="code" href="structstpi__softweave.html#o29">00115</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *comp_buf;
<a name="l00116"></a><a class="code" href="structstpi__softweave.html#o30">00116</a>   <a class="code" href="structstp__weave__t.html">stp_weave_t</a> <a class="code" href="structstpi__softweave.html#o30">wcache</a>;
<a name="l00117"></a><a class="code" href="structstpi__softweave.html#o31">00117</a>   <span class="keywordtype">int</span> <a class="code" href="structstpi__softweave.html#o31">rcache</a>;
<a name="l00118"></a><a class="code" href="structstpi__softweave.html#o32">00118</a>   <span class="keywordtype">int</span> <a class="code" href="structstpi__softweave.html#o32">vcache</a>;
<a name="l00119"></a><a class="code" href="structstpi__softweave.html#o33">00119</a>   <a class="code" href="weave_8h.html#a3">stp_flushfunc</a> *<a class="code" href="structstpi__softweave.html#o33">flushfunc</a>;
<a name="l00120"></a><a class="code" href="structstpi__softweave.html#o34">00120</a>   <a class="code" href="weave_8h.html#a2">stp_fillfunc</a> *<a class="code" href="structstpi__softweave.html#o34">fillfunc</a>;
<a name="l00121"></a><a class="code" href="structstpi__softweave.html#o35">00121</a>   <a class="code" href="weave_8h.html#a1">stp_packfunc</a> *<a class="code" href="structstpi__softweave.html#o35">pack</a>;
<a name="l00122"></a><a class="code" href="structstpi__softweave.html#o36">00122</a>   <a class="code" href="weave_8h.html#a4">stp_compute_linewidth_func</a> *<a class="code" href="structstpi__softweave.html#o36">compute_linewidth</a>;
00123 } <a class="code" href="structstpi__softweave.html">stpi_softweave_t</a>;
00124 
00125 <span class="comment">/* RAW WEAVE */</span>
00126 
<a name="l00127"></a><a class="code" href="structraw.html">00127</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structraw.html">raw</a> {
<a name="l00128"></a><a class="code" href="structraw.html#o0">00128</a>         <span class="keywordtype">int</span> separation;
<a name="l00129"></a><a class="code" href="structraw.html#o1">00129</a>         <span class="keywordtype">int</span> jets;
<a name="l00130"></a><a class="code" href="structraw.html#o2">00130</a>         <span class="keywordtype">int</span> <a class="code" href="structraw.html#o2">oversampling</a>;
<a name="l00131"></a><a class="code" href="structraw.html#o3">00131</a>         <span class="keywordtype">int</span> <a class="code" href="structraw.html#o3">advancebasis</a>;
<a name="l00132"></a><a class="code" href="structraw.html#o4">00132</a>         <span class="keywordtype">int</span> <a class="code" href="structraw.html#o4">subblocksperpassblock</a>;
<a name="l00133"></a><a class="code" href="structraw.html#o5">00133</a>         <span class="keywordtype">int</span> <a class="code" href="structraw.html#o5">passespersubblock</a>;
<a name="l00134"></a><a class="code" href="structraw.html#o6">00134</a>         <a class="code" href="weave_8h.html#a26">stp_weave_strategy_t</a> <a class="code" href="structraw.html#o6">strategy</a>;
<a name="l00135"></a><a class="code" href="structraw.html#o7">00135</a>         <a class="code" href="structstp__vars.html">stp_vars_t</a> *v;
00136 } <a class="code" href="structraw.html">raw_t</a>;
00137 
00138 <span class="comment">/*</span>
00139 <span class="comment"> * Strategy types currently defined:</span>
00140 <span class="comment"> *</span>
00141 <span class="comment"> *  0: zig-zag type pass block filling</span>
00142 <span class="comment"> *  1: ascending pass block filling</span>
00143 <span class="comment"> *  2: descending pass block filling</span>
00144 <span class="comment"> *  3: ascending fill with 2x expansion</span>
00145 <span class="comment"> *  4: staggered zig-zag neighbour-avoidance fill</span>
00146 <span class="comment"> *  5: ascending fill with 3x expansion</span>
00147 <span class="comment"> *</span>
00148 <span class="comment"> * In theory, strategy 0 should be optimal; in practice, it can lead</span>
00149 <span class="comment"> * to visible areas of banding.  If it's necessary to avoid filling</span>
00150 <span class="comment"> * neighbouring rows in neighbouring passes, strategy 4 should be optimal,</span>
00151 <span class="comment"> * at least for some weaves.</span>
00152 <span class="comment"> */</span>
00153 
00154 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00155"></a><a class="code" href="print-weave_8c.html#a6">00155</a> <a class="code" href="print-weave_8c.html#a6">initialize_raw_weave</a>(<a class="code" href="structraw.html">raw_t</a> *w,  <span class="comment">/* I - weave struct to be filled in */</span>
00156                      <span class="keywordtype">int</span> separation,    <span class="comment">/* I - jet separation */</span>
00157                      <span class="keywordtype">int</span> jets,  <span class="comment">/* I - number of jets */</span>
00158                      <span class="keywordtype">int</span> oversample,    <span class="comment">/* I - oversampling factor */</span>
00159                      stp_weave_strategy_t strat,        <span class="comment">/* I - weave pattern variation to use */</span>
00160                      <a class="code" href="structstp__vars.html">stp_vars_t</a> *v)
00161 {
00162         w-&gt;<a class="code" href="structraw.html#o0">separation</a> = separation;
00163         w-&gt;<a class="code" href="structraw.html#o1">jets</a> = jets;
00164         w-&gt;<a class="code" href="structraw.html#o2">oversampling</a> = oversample;
00165         w-&gt;<a class="code" href="structraw.html#o3">advancebasis</a> = jets / oversample;
00166         <span class="keywordflow">if</span> (w-&gt;<a class="code" href="structraw.html#o3">advancebasis</a> == 0)
00167           w-&gt;<a class="code" href="structraw.html#o3">advancebasis</a>++;
00168         w-&gt;<a class="code" href="structraw.html#o4">subblocksperpassblock</a> = <a class="code" href="print-weave_8c.html#a5">gcd</a>(separation, w-&gt;<a class="code" href="structraw.html#o3">advancebasis</a>);
00169         w-&gt;<a class="code" href="structraw.html#o5">passespersubblock</a> = separation / w-&gt;<a class="code" href="structraw.html#o4">subblocksperpassblock</a>;
00170         w-&gt;<a class="code" href="structraw.html#o6">strategy</a> = strat;
00171         w-&gt;<a class="code" href="structraw.html#o7">v</a> = v;
00172 }
00173 
00174 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00175"></a><a class="code" href="print-weave_8c.html#a7">00175</a> <a class="code" href="print-weave_8c.html#a7">calculate_raw_pass_parameters</a>(<a class="code" href="structraw.html">raw_t</a> *w,         <span class="comment">/* I - weave parameters */</span>
00176                               <span class="keywordtype">int</span> pass,         <span class="comment">/* I - pass number ( &gt;= 0) */</span>
00177                               <span class="keywordtype">int</span> *startrow,    <span class="comment">/* O - print head position */</span>
00178                               <span class="keywordtype">int</span> *subpass)     <span class="comment">/* O - subpass number */</span>
00179 {
00180         <span class="keywordtype">int</span> band, passinband, subpassblock, subpassoffset;
00181 
00182         band = pass / (w-&gt;<a class="code" href="structraw.html#o0">separation</a> * w-&gt;<a class="code" href="structraw.html#o2">oversampling</a>);
00183         passinband = pass % (w-&gt;<a class="code" href="structraw.html#o0">separation</a> * w-&gt;<a class="code" href="structraw.html#o2">oversampling</a>);
00184         subpassblock = pass % w-&gt;<a class="code" href="structraw.html#o0">separation</a>
00185                          * w-&gt;<a class="code" href="structraw.html#o4">subblocksperpassblock</a> / w-&gt;<a class="code" href="structraw.html#o0">separation</a>;
00186 
00187         <span class="keywordflow">switch</span> (w-&gt;<a class="code" href="structraw.html#o6">strategy</a>) {
00188         <span class="keywordflow">case</span> <a class="code" href="weave_8h.html#a26a11">STP_WEAVE_ZIGZAG</a>:
00189                 <span class="keywordflow">if</span> (subpassblock * 2 &lt; w-&gt;<a class="code" href="structraw.html#o4">subblocksperpassblock</a>)
00190                         subpassoffset = 2 * subpassblock;
00191                 <span class="keywordflow">else</span>
00192                         subpassoffset = 2 * (w-&gt;<a class="code" href="structraw.html#o4">subblocksperpassblock</a>
00193                                               - subpassblock) - 1;
00194                 <span class="keywordflow">break</span>;
00195         <span class="keywordflow">case</span> <a class="code" href="weave_8h.html#a26a12">STP_WEAVE_ASCENDING</a>:
00196                 subpassoffset = subpassblock;
00197                 <span class="keywordflow">break</span>;
00198         <span class="keywordflow">case</span> <a class="code" href="weave_8h.html#a26a13">STP_WEAVE_DESCENDING</a>:
00199                 subpassoffset = w-&gt;<a class="code" href="structraw.html#o4">subblocksperpassblock</a> - 1 - subpassblock;
00200                 <span class="keywordflow">break</span>;
00201         <span class="keywordflow">case</span> <a class="code" href="weave_8h.html#a26a14">STP_WEAVE_ASCENDING_2X</a>:
00202                 <span class="keywordflow">if</span> (subpassblock * 2 &lt; w-&gt;<a class="code" href="structraw.html#o4">subblocksperpassblock</a>)
00203                         subpassoffset = 2 * subpassblock;
00204                 <span class="keywordflow">else</span>
00205                         subpassoffset = 1 + 2 * (subpassblock
00206                                                   - (w-&gt;<a class="code" href="structraw.html#o4">subblocksperpassblock</a>
00207                                                       + 1) / 2);
00208                 <span class="keywordflow">break</span>;
00209         <span class="keywordflow">case</span> <a class="code" href="weave_8h.html#a26a16">STP_WEAVE_ASCENDING_3X</a>:
00210                 <span class="keywordflow">if</span> (subpassblock * 3 &lt; w-&gt;<a class="code" href="structraw.html#o4">subblocksperpassblock</a>)
00211                         subpassoffset = 3 * subpassblock;
00212                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (3 * (subpassblock - (w-&gt;<a class="code" href="structraw.html#o4">subblocksperpassblock</a> + 2) / 3)
00213                           &lt; w-&gt;<a class="code" href="structraw.html#o4">subblocksperpassblock</a> - 2)
00214                         subpassoffset = 2 + 3 * (subpassblock
00215                                                   - (w-&gt;<a class="code" href="structraw.html#o4">subblocksperpassblock</a>
00216                                                       + 2) / 3);
00217                 <span class="keywordflow">else</span>
00218                         subpassoffset = 1 + 3 * (subpassblock
00219                                                   - (w-&gt;<a class="code" href="structraw.html#o4">subblocksperpassblock</a>
00220                                                       + 2) / 3
00221                                                   - w-&gt;<a class="code" href="structraw.html#o4">subblocksperpassblock</a>
00222                                                       / 3);
00223                 <span class="keywordflow">break</span>;
00224         <span class="keywordflow">case</span> <a class="code" href="weave_8h.html#a26a15">STP_WEAVE_STAGGERED</a>:
00225                 <span class="keywordflow">if</span> (subpassblock * 2 &lt; w-&gt;<a class="code" href="structraw.html#o4">subblocksperpassblock</a>)
00226                         subpassoffset = 2 * subpassblock;
00227                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (subpassblock * 2 &lt; w-&gt;<a class="code" href="structraw.html#o4">subblocksperpassblock</a> + 2)
00228                         subpassoffset = 1;
00229                 <span class="keywordflow">else</span>
00230                         subpassoffset = 2 * (w-&gt;<a class="code" href="structraw.html#o4">subblocksperpassblock</a>
00231                                               - subpassblock) + 1;
00232                 <span class="keywordflow">break</span>;
00233         <span class="keywordflow">default</span>:
00234                 subpassoffset = subpassblock;
00235                 <span class="keywordflow">break</span>;
00236         }
00237 
00238         *startrow = w-&gt;<a class="code" href="structraw.html#o0">separation</a> * w-&gt;<a class="code" href="structraw.html#o1">jets</a> * band
00239                       + w-&gt;<a class="code" href="structraw.html#o3">advancebasis</a> * passinband + subpassoffset;
00240         *subpass = passinband / w-&gt;<a class="code" href="structraw.html#o0">separation</a>;
00241 }
00242 
00243 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00244"></a><a class="code" href="print-weave_8c.html#a8">00244</a> <a class="code" href="print-weave_8c.html#a8">calculate_raw_row_parameters</a>(<a class="code" href="structraw.html">raw_t</a> *w,          <span class="comment">/* I - weave parameters */</span>
00245                              <span class="keywordtype">int</span> row,           <span class="comment">/* I - row number */</span>
00246                              <span class="keywordtype">int</span> subpass,       <span class="comment">/* I - subpass number */</span>
00247                              <span class="keywordtype">int</span> *pass,         <span class="comment">/* O - pass number */</span>
00248                              <span class="keywordtype">int</span> *jet,          <span class="comment">/* O - jet number in pass */</span>
00249                              <span class="keywordtype">int</span> *startrow)     <span class="comment">/* O - starting row of pass */</span>
00250 {
00251         <span class="keywordtype">int</span> subblockoffset, subpassblock, band, baserow, passinband, offset;
00252         <span class="keywordtype">int</span> pass_div_separation;
00253         <span class="keywordtype">int</span> pass_mod_separation;
00254         <span class="keywordtype">int</span> off_mod_separation;
00255 
00256         subblockoffset = row % w-&gt;<a class="code" href="structraw.html#o4">subblocksperpassblock</a>;
00257         <span class="keywordflow">switch</span> (w-&gt;<a class="code" href="structraw.html#o6">strategy</a>) {
00258         <span class="keywordflow">case</span> <a class="code" href="weave_8h.html#a26a11">STP_WEAVE_ZIGZAG</a>:
00259                 <span class="keywordflow">if</span> (subblockoffset % 2 == 0)
00260                         subpassblock = subblockoffset / 2;
00261                 <span class="keywordflow">else</span>
00262                         subpassblock = w-&gt;<a class="code" href="structraw.html#o4">subblocksperpassblock</a>
00263                                          - (subblockoffset + 1) / 2;
00264                 <span class="keywordflow">break</span>;
00265         <span class="keywordflow">case</span> <a class="code" href="weave_8h.html#a26a12">STP_WEAVE_ASCENDING</a>:
00266                 subpassblock = subblockoffset;
00267                 <span class="keywordflow">break</span>;
00268         <span class="keywordflow">case</span> <a class="code" href="weave_8h.html#a26a13">STP_WEAVE_DESCENDING</a>:
00269                 subpassblock = w-&gt;<a class="code" href="structraw.html#o4">subblocksperpassblock</a> - 1 - subblockoffset;
00270                 <span class="keywordflow">break</span>;
00271         <span class="keywordflow">case</span> <a class="code" href="weave_8h.html#a26a14">STP_WEAVE_ASCENDING_2X</a>:
00272                 <span class="keywordflow">if</span> (subblockoffset % 2 == 0)
00273                         subpassblock = subblockoffset / 2;
00274                 <span class="keywordflow">else</span>
00275                         subpassblock = (subblockoffset - 1) / 2
00276                                        + (w-&gt;<a class="code" href="structraw.html#o4">subblocksperpassblock</a> + 1) / 2;
00277                 <span class="keywordflow">break</span>;
00278         <span class="keywordflow">case</span> <a class="code" href="weave_8h.html#a26a16">STP_WEAVE_ASCENDING_3X</a>:
00279                 <span class="keywordflow">if</span> (subblockoffset % 3 == 0)
00280                         subpassblock = subblockoffset / 3;
00281                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (subblockoffset % 3 == 1)
00282                         subpassblock = (subblockoffset - 1) / 3
00283                                          + (w-&gt;<a class="code" href="structraw.html#o4">subblocksperpassblock</a> + 2) / 3;
00284                 <span class="keywordflow">else</span>
00285                         subpassblock = (subblockoffset - 2) / 3
00286                                          + (w-&gt;<a class="code" href="structraw.html#o4">subblocksperpassblock</a> + 2) / 3
00287                                          + (w-&gt;<a class="code" href="structraw.html#o4">subblocksperpassblock</a> + 1) / 3;
00288                 <span class="keywordflow">break</span>;
00289         <span class="keywordflow">case</span> <a class="code" href="weave_8h.html#a26a15">STP_WEAVE_STAGGERED</a>:
00290                 <span class="keywordflow">if</span> (subblockoffset % 2 == 0)
00291                         subpassblock = subblockoffset / 2;
00292                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (subblockoffset == 1)
00293                         subpassblock = (w-&gt;<a class="code" href="structraw.html#o4">subblocksperpassblock</a> + 1) / 2;
00294                 <span class="keywordflow">else</span>
00295                         subpassblock = w-&gt;<a class="code" href="structraw.html#o4">subblocksperpassblock</a>
00296                                          - (subblockoffset - 1) / 2;
00297                 <span class="keywordflow">break</span>;
00298         <span class="keywordflow">default</span>:
00299                 subpassblock = subblockoffset;
00300                 <span class="keywordflow">break</span>;
00301         }
00302 
00303         band = row / (w-&gt;<a class="code" href="structraw.html#o0">separation</a> * w-&gt;<a class="code" href="structraw.html#o1">jets</a>);
00304         baserow = row - subblockoffset - band * w-&gt;<a class="code" href="structraw.html#o0">separation</a> * w-&gt;<a class="code" href="structraw.html#o1">jets</a>;
00305         passinband = baserow / w-&gt;<a class="code" href="structraw.html#o3">advancebasis</a>;
00306         offset = baserow % w-&gt;<a class="code" href="structraw.html#o3">advancebasis</a>;
00307         pass_div_separation = passinband / w-&gt;<a class="code" href="structraw.html#o0">separation</a>;
00308         pass_mod_separation = passinband % w-&gt;<a class="code" href="structraw.html#o0">separation</a>;
00309         off_mod_separation = offset % w-&gt;<a class="code" href="structraw.html#o0">separation</a>;
00310 
00311         <span class="keywordflow">while</span> (off_mod_separation != 0
00312                || pass_div_separation != subpass
00313                || pass_mod_separation / w-&gt;<a class="code" href="structraw.html#o5">passespersubblock</a>
00314                     != subpassblock)
00315           {
00316             offset += w-&gt;<a class="code" href="structraw.html#o3">advancebasis</a>;
00317             passinband--;
00318             <span class="keywordflow">if</span> (passinband &gt;= 0)
00319               {
00320                 pass_mod_separation--;
00321                 <span class="keywordflow">if</span> (pass_mod_separation &lt; 0)
00322                   {
00323                     pass_mod_separation += w-&gt;<a class="code" href="structraw.html#o0">separation</a>;
00324                     pass_div_separation--;
00325                   }
00326                 <span class="keywordflow">if</span> (w-&gt;<a class="code" href="structraw.html#o3">advancebasis</a> &lt; w-&gt;<a class="code" href="structraw.html#o0">separation</a>)
00327                   {
00328                     off_mod_separation += w-&gt;<a class="code" href="structraw.html#o3">advancebasis</a>;
00329                     <span class="keywordflow">if</span> (off_mod_separation &gt;= w-&gt;<a class="code" href="structraw.html#o0">separation</a>)
00330                       off_mod_separation -= w-&gt;<a class="code" href="structraw.html#o0">separation</a>;
00331                   }
00332                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (w-&gt;<a class="code" href="structraw.html#o3">advancebasis</a> &gt; w-&gt;<a class="code" href="structraw.html#o0">separation</a>)
00333                   off_mod_separation = offset % w-&gt;<a class="code" href="structraw.html#o0">separation</a>;
00334               }
00335             <span class="keywordflow">else</span>
00336               {
00337                 <span class="keyword">const</span> <span class="keywordtype">int</span> roundedjets =
00338                   (w-&gt;<a class="code" href="structraw.html#o3">advancebasis</a> * w-&gt;<a class="code" href="structraw.html#o2">oversampling</a>) % w-&gt;<a class="code" href="structraw.html#o1">jets</a>;
00339                 band--;
00340                 passinband += w-&gt;<a class="code" href="structraw.html#o0">separation</a> * w-&gt;<a class="code" href="structraw.html#o2">oversampling</a>;
00341                 offset += w-&gt;<a class="code" href="structraw.html#o0">separation</a> * (w-&gt;<a class="code" href="structraw.html#o1">jets</a> - roundedjets);
00342                 pass_div_separation = passinband / w-&gt;<a class="code" href="structraw.html#o0">separation</a>;
00343                 pass_mod_separation = passinband % w-&gt;<a class="code" href="structraw.html#o0">separation</a>;
00344                 off_mod_separation = offset % w-&gt;<a class="code" href="structraw.html#o0">separation</a>;
00345               }
00346           }
00347 
00348         *pass = band * w-&gt;<a class="code" href="structraw.html#o2">oversampling</a> * w-&gt;<a class="code" href="structraw.html#o0">separation</a> + passinband;
00349         *jet = (offset / w-&gt;<a class="code" href="structraw.html#o0">separation</a>) % w-&gt;<a class="code" href="structraw.html#o1">jets</a>;
00350         *startrow = row - (*jet * w-&gt;<a class="code" href="structraw.html#o0">separation</a>);
00351 }
00352 
00353 <span class="comment">/* COOKED WEAVE */</span>
00354 
<a name="l00355"></a><a class="code" href="structcooked.html">00355</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structcooked.html">cooked</a> {
<a name="l00356"></a><a class="code" href="structcooked.html#o0">00356</a>         <a class="code" href="structraw.html">raw_t</a> <a class="code" href="structcooked.html#o0">rw</a>;
<a name="l00357"></a><a class="code" href="structcooked.html#o1">00357</a>         <span class="keywordtype">int</span> <a class="code" href="structcooked.html#o1">first_row_printed</a>;
<a name="l00358"></a><a class="code" href="structcooked.html#o2">00358</a>         <span class="keywordtype">int</span> <a class="code" href="structcooked.html#o2">last_row_printed</a>;
00359 
<a name="l00360"></a><a class="code" href="structcooked.html#o3">00360</a>         <span class="keywordtype">int</span> <a class="code" href="structcooked.html#o3">first_premapped_pass</a>;       <span class="comment">/* First raw pass used by this page */</span>
<a name="l00361"></a><a class="code" href="structcooked.html#o4">00361</a>         <span class="keywordtype">int</span> <a class="code" href="structcooked.html#o4">first_normal_pass</a>;
<a name="l00362"></a><a class="code" href="structcooked.html#o5">00362</a>         <span class="keywordtype">int</span> <a class="code" href="structcooked.html#o5">first_postmapped_pass</a>;
<a name="l00363"></a><a class="code" href="structcooked.html#o6">00363</a>         <span class="keywordtype">int</span> <a class="code" href="structcooked.html#o6">first_unused_pass</a>;
00364 
<a name="l00365"></a><a class="code" href="structcooked.html#o7">00365</a>         <span class="keywordtype">int</span> *<a class="code" href="structcooked.html#o7">pass_premap</a>;
<a name="l00366"></a><a class="code" href="structcooked.html#o8">00366</a>         <span class="keywordtype">int</span> *<a class="code" href="structcooked.html#o8">stagger_premap</a>;
<a name="l00367"></a><a class="code" href="structcooked.html#o9">00367</a>         <span class="keywordtype">int</span> *<a class="code" href="structcooked.html#o9">pass_postmap</a>;
<a name="l00368"></a><a class="code" href="structcooked.html#o10">00368</a>         <span class="keywordtype">int</span> *<a class="code" href="structcooked.html#o10">stagger_postmap</a>;
00369 } <a class="code" href="structcooked.html">cooked_t</a>;
00370 
00371 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00372"></a><a class="code" href="print-weave_8c.html#a9">00372</a> <a class="code" href="print-weave_8c.html#a9">sort_by_start_row</a>(<span class="keywordtype">int</span> *map, <span class="keywordtype">int</span> *startrows, <span class="keywordtype">int</span> count)
00373 {
00374         <span class="comment">/*</span>
00375 <span class="comment">         * Yes, it's a bubble sort, but we do it no more than 4 times</span>
00376 <span class="comment">         * per page, and we are only sorting a small number of items.</span>
00377 <span class="comment">         */</span>
00378 
00379         <span class="keywordtype">int</span> dirty;
00380 
00381         <span class="keywordflow">do</span> {
00382                 <span class="keywordtype">int</span> x;
00383                 dirty = 0;
00384                 <span class="keywordflow">for</span> (x = 1; x &lt; count; x++) {
00385                         <span class="keywordflow">if</span> (startrows[x - 1] &gt; startrows[x]) {
00386                                 <span class="keywordtype">int</span> temp = startrows[x - 1];
00387                                 startrows[x - 1] = startrows[x];
00388                                 startrows[x] = temp;
00389                                 temp = map[x - 1];
00390                                 map[x - 1] = map[x];
00391                                 map[x] = temp;
00392                                 dirty = 1;
00393                         }
00394                 }
00395         } <span class="keywordflow">while</span> (dirty);
00396 }
00397 
00398 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00399"></a><a class="code" href="print-weave_8c.html#a10">00399</a> <a class="code" href="print-weave_8c.html#a10">calculate_stagger</a>(<a class="code" href="structraw.html">raw_t</a> *w, <span class="keywordtype">int</span> *map, <span class="keywordtype">int</span> *startrows_stagger, <span class="keywordtype">int</span> count)
00400 {
00401         <span class="keywordtype">int</span> i;
00402 
00403         <span class="keywordflow">for</span> (i = 0; i &lt; count; i++) {
00404                 <span class="keywordtype">int</span> startrow, subpass;
00405                 <a class="code" href="print-weave_8c.html#a7">calculate_raw_pass_parameters</a>(w, map[i], &amp;startrow, &amp;subpass);
00406                 startrow -= w-&gt;<a class="code" href="structraw.html#o0">separation</a> * w-&gt;<a class="code" href="structraw.html#o1">jets</a>;
00407                 startrows_stagger[i] = (startrows_stagger[i] - startrow)
00408                                          / w-&gt;<a class="code" href="structraw.html#o0">separation</a>;
00409         }
00410 }
00411 
00412 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00413"></a><a class="code" href="print-weave_8c.html#a11">00413</a> <a class="code" href="print-weave_8c.html#a11">invert_map</a>(<span class="keywordtype">int</span> *map, <span class="keywordtype">int</span> *stagger, <span class="keywordtype">int</span> count, <span class="keywordtype">int</span> oldfirstpass,
00414            <span class="keywordtype">int</span> newfirstpass)
00415 {
00416         <span class="keywordtype">int</span> i;
00417         <span class="keywordtype">int</span> *newmap, *newstagger;
00418         newmap = <a class="code" href="group__util.html#ga28">stp_malloc</a>(count * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00419         newstagger = <a class="code" href="group__util.html#ga28">stp_malloc</a>(count * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00420 
00421         <span class="keywordflow">for</span> (i = 0; i &lt; count; i++) {
00422                 newmap[map[i] - oldfirstpass] = i + newfirstpass;
00423                 newstagger[map[i] - oldfirstpass] = stagger[i];
00424         }
00425 
00426         memcpy(map, newmap, count * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00427         memcpy(stagger, newstagger, count * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00428         <a class="code" href="group__util.html#ga31">stp_free</a>(newstagger);
00429         <a class="code" href="group__util.html#ga31">stp_free</a>(newmap);
00430 }
00431 
00432 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00433"></a><a class="code" href="print-weave_8c.html#a12">00433</a> <a class="code" href="print-weave_8c.html#a12">make_passmap</a>(<a class="code" href="structraw.html">raw_t</a> *w, <span class="keywordtype">int</span> **map, <span class="keywordtype">int</span> **starts, <span class="keywordtype">int</span> first_pass_number,
00434              <span class="keywordtype">int</span> first_pass_to_map, <span class="keywordtype">int</span> first_pass_after_map,
00435              <span class="keywordtype">int</span> first_pass_to_stagger, <span class="keywordtype">int</span> first_pass_after_stagger,
00436              <span class="keywordtype">int</span> first_row_of_maximal_pass, <span class="keywordtype">int</span> separations_to_distribute)
00437 {
00438         <span class="keywordtype">int</span> *passmap, *startrows;
00439         <span class="keywordtype">int</span> passes_to_map = first_pass_after_map - first_pass_to_map;
00440         <span class="keywordtype">int</span> i;
00441 
00442         <a class="code" href="print-weave_8c.html#a1">assert</a>(first_pass_to_map &lt;= first_pass_after_map, w-&gt;v);
00443         <a class="code" href="print-weave_8c.html#a1">assert</a>(first_pass_to_stagger &lt;= first_pass_after_stagger, w-&gt;v);
00444 
00445         *map = passmap = <a class="code" href="group__util.html#ga28">stp_malloc</a>(passes_to_map * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00446         *starts = startrows = <a class="code" href="group__util.html#ga28">stp_malloc</a>(passes_to_map * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00447 
00448         <span class="keywordflow">for</span> (i = 0; i &lt; passes_to_map; i++) {
00449                 <span class="keywordtype">int</span> startrow, subpass;
00450                 <span class="keywordtype">int</span> pass = i + first_pass_to_map;
00451                 <a class="code" href="print-weave_8c.html#a7">calculate_raw_pass_parameters</a>(w, pass, &amp;startrow, &amp;subpass);
00452                 passmap[i] = pass;
00453                 <span class="keywordflow">if</span> (first_row_of_maximal_pass &gt;= 0)
00454                         startrow = first_row_of_maximal_pass - startrow
00455                                      + w-&gt;<a class="code" href="structraw.html#o0">separation</a> * w-&gt;<a class="code" href="structraw.html#o1">jets</a>;
00456                 <span class="keywordflow">else</span>
00457                         startrow -= w-&gt;<a class="code" href="structraw.html#o0">separation</a> * w-&gt;<a class="code" href="structraw.html#o1">jets</a>;
00458                 <span class="keywordflow">while</span> (startrow &lt; 0)
00459                         startrow += w-&gt;<a class="code" href="structraw.html#o0">separation</a>;
00460                 startrows[i] = startrow;
00461         }
00462 
00463         <a class="code" href="print-weave_8c.html#a9">sort_by_start_row</a>(passmap, startrows, passes_to_map);
00464 
00465         separations_to_distribute++;
00466 
00467         <span class="keywordflow">for</span> (i = 0; i &lt; first_pass_after_stagger - first_pass_to_stagger; i++) {
00468                 <span class="keywordtype">int</span> offset = first_pass_to_stagger - first_pass_to_map;
00469                 <span class="keywordflow">if</span> (startrows[i + offset] / w-&gt;<a class="code" href="structraw.html#o0">separation</a>
00470                       &lt; i % separations_to_distribute)
00471                 {
00472                         startrows[i + offset]
00473                           = startrows[i + offset] % w-&gt;<a class="code" href="structraw.html#o0">separation</a>
00474                              + w-&gt;<a class="code" href="structraw.html#o0">separation</a> * (i % separations_to_distribute);
00475                 }
00476         }
00477 
00478         <span class="keywordflow">if</span> (first_row_of_maximal_pass &gt;= 0) {
00479                 <span class="keywordflow">for</span> (i = 0; i &lt; passes_to_map; i++) {
00480                         startrows[i] = first_row_of_maximal_pass - startrows[i];
00481                 }
00482         }
00483 
00484         <a class="code" href="print-weave_8c.html#a9">sort_by_start_row</a>(passmap, startrows, passes_to_map);
00485         <a class="code" href="print-weave_8c.html#a10">calculate_stagger</a>(w, passmap, startrows, passes_to_map);
00486 
00487         <a class="code" href="print-weave_8c.html#a11">invert_map</a>(passmap, startrows, passes_to_map, first_pass_to_map,
00488                    first_pass_to_map - first_pass_number);
00489 }
00490 
00491 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00492"></a><a class="code" href="print-weave_8c.html#a13">00492</a> <a class="code" href="print-weave_8c.html#a13">calculate_pass_map</a>(<a class="code" href="structstp__vars.html">stp_vars_t</a> *v,
00493                    <a class="code" href="structcooked.html">cooked_t</a> *w,         <span class="comment">/* I - weave parameters */</span>
00494                    <span class="keywordtype">int</span> pageheight,      <span class="comment">/* I - number of rows on page */</span>
00495                    <span class="keywordtype">int</span> firstrow,        <span class="comment">/* I - first printed row */</span>
00496                    <span class="keywordtype">int</span> lastrow)         <span class="comment">/* I - last printed row */</span>
00497 {
00498         <span class="keywordtype">int</span> startrow, subpass;
00499         <span class="keywordtype">int</span> pass = -1;
00500 
00501         w-&gt;<a class="code" href="structcooked.html#o1">first_row_printed</a> = firstrow;
00502         w-&gt;<a class="code" href="structcooked.html#o2">last_row_printed</a> = lastrow;
00503 
00504         <span class="keywordflow">if</span> (pageheight &lt;= lastrow)
00505                 pageheight = lastrow + 1;
00506 
00507         <span class="keywordflow">do</span> {
00508                 <a class="code" href="print-weave_8c.html#a7">calculate_raw_pass_parameters</a>(&amp;w-&gt;<a class="code" href="structcooked.html#o0">rw</a>, ++pass,
00509                                               &amp;startrow, &amp;subpass);
00510         } <span class="keywordflow">while</span> (startrow - w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o0">separation</a> &lt; firstrow);
00511 
00512         w-&gt;<a class="code" href="structcooked.html#o3">first_premapped_pass</a> = pass;
00513 
00514         <span class="keywordflow">while</span> (startrow &lt; w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o0">separation</a> * w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o1">jets</a>
00515                &amp;&amp; startrow - w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o0">separation</a> &lt; pageheight
00516                &amp;&amp; startrow &lt;= lastrow + w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o0">separation</a> * w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o1">jets</a>)
00517         {
00518                 <a class="code" href="print-weave_8c.html#a7">calculate_raw_pass_parameters</a>(&amp;w-&gt;<a class="code" href="structcooked.html#o0">rw</a>, ++pass,
00519                                               &amp;startrow, &amp;subpass);
00520         }
00521         w-&gt;<a class="code" href="structcooked.html#o4">first_normal_pass</a> = pass;
00522 
00523         <span class="keywordflow">while</span> (startrow - w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o0">separation</a> &lt; pageheight
00524                &amp;&amp; startrow &lt;= lastrow + w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o0">separation</a> * w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o1">jets</a>)
00525         {
00526                 <a class="code" href="print-weave_8c.html#a7">calculate_raw_pass_parameters</a>(&amp;w-&gt;<a class="code" href="structcooked.html#o0">rw</a>, ++pass,
00527                                               &amp;startrow, &amp;subpass);
00528         }
00529         w-&gt;<a class="code" href="structcooked.html#o5">first_postmapped_pass</a> = pass;
00530 
00531         <span class="keywordflow">while</span> (startrow &lt;= lastrow + w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o0">separation</a> * w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o1">jets</a>) {
00532                 <a class="code" href="print-weave_8c.html#a7">calculate_raw_pass_parameters</a>(&amp;w-&gt;<a class="code" href="structcooked.html#o0">rw</a>, ++pass,
00533                                               &amp;startrow, &amp;subpass);
00534         }
00535         w-&gt;<a class="code" href="structcooked.html#o6">first_unused_pass</a> = pass;
00536 
00537         <a class="code" href="print-util_8c.html#a23">stp_dprintf</a>(<a class="code" href="group__util.html#ga39">STP_DBG_WEAVE_PARAMS</a>, v,
00538                     <span class="stringliteral">"first premapped %d first normal %d first postmapped %d "</span>
00539                     <span class="stringliteral">"first unused %d\n"</span>,
00540                     w-&gt;<a class="code" href="structcooked.html#o3">first_premapped_pass</a>, w-&gt;<a class="code" href="structcooked.html#o4">first_normal_pass</a>,
00541                     w-&gt;<a class="code" href="structcooked.html#o5">first_postmapped_pass</a>, w-&gt;<a class="code" href="structcooked.html#o6">first_unused_pass</a>);
00542         <span class="comment">/*</span>
00543 <span class="comment">         * FIXME: make sure first_normal_pass doesn't advance beyond</span>
00544 <span class="comment">         * first_postmapped_pass, or first_postmapped_pass doesn't</span>
00545 <span class="comment">         * retreat before first_normal_pass.</span>
00546 <span class="comment">         */</span>
00547 
00548         <span class="keywordflow">if</span> (w-&gt;<a class="code" href="structcooked.html#o4">first_normal_pass</a> &gt; w-&gt;<a class="code" href="structcooked.html#o3">first_premapped_pass</a>) {
00549                 <span class="keywordtype">int</span> spread, separations_to_distribute, normal_passes_mapped;
00550                 separations_to_distribute = firstrow / w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o0">separation</a>;
00551                 spread = (separations_to_distribute + 1) * w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o0">separation</a>;
00552                 normal_passes_mapped = (spread + w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o3">advancebasis</a> - 1)
00553                                             / w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o3">advancebasis</a>;
00554                 w-&gt;<a class="code" href="structcooked.html#o4">first_normal_pass</a> += normal_passes_mapped;
00555                 <a class="code" href="print-weave_8c.html#a12">make_passmap</a>(&amp;w-&gt;<a class="code" href="structcooked.html#o0">rw</a>, &amp;w-&gt;<a class="code" href="structcooked.html#o7">pass_premap</a>, &amp;w-&gt;<a class="code" href="structcooked.html#o8">stagger_premap</a>,
00556                              w-&gt;<a class="code" href="structcooked.html#o3">first_premapped_pass</a>,
00557                              w-&gt;<a class="code" href="structcooked.html#o3">first_premapped_pass</a>, w-&gt;<a class="code" href="structcooked.html#o4">first_normal_pass</a>,
00558                              w-&gt;<a class="code" href="structcooked.html#o3">first_premapped_pass</a>,
00559                              w-&gt;<a class="code" href="structcooked.html#o4">first_normal_pass</a> - normal_passes_mapped,
00560                              -1, separations_to_distribute);
00561         } <span class="keywordflow">else</span> {
00562                 w-&gt;<a class="code" href="structcooked.html#o7">pass_premap</a> = 0;
00563                 w-&gt;<a class="code" href="structcooked.html#o8">stagger_premap</a> = 0;
00564         }
00565 
00566         <span class="keywordflow">if</span> (w-&gt;<a class="code" href="structcooked.html#o6">first_unused_pass</a> &gt;= w-&gt;<a class="code" href="structcooked.html#o5">first_postmapped_pass</a>) {
00567                 <span class="keywordtype">int</span> spread, separations_to_distribute, normal_passes_mapped;
00568                 separations_to_distribute = (pageheight - lastrow - 1)
00569                                                      / w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o0">separation</a>;
00570                 spread = (separations_to_distribute + 1) * w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o0">separation</a>;
00571                 normal_passes_mapped = (spread + w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o3">advancebasis</a>)
00572                                              / w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o3">advancebasis</a>;
00573                 w-&gt;<a class="code" href="structcooked.html#o5">first_postmapped_pass</a> -= normal_passes_mapped;
00574                 <a class="code" href="print-weave_8c.html#a12">make_passmap</a>(&amp;w-&gt;<a class="code" href="structcooked.html#o0">rw</a>, &amp;w-&gt;<a class="code" href="structcooked.html#o9">pass_postmap</a>, &amp;w-&gt;<a class="code" href="structcooked.html#o10">stagger_postmap</a>,
00575                              w-&gt;<a class="code" href="structcooked.html#o3">first_premapped_pass</a>,
00576                              w-&gt;<a class="code" href="structcooked.html#o5">first_postmapped_pass</a>, w-&gt;<a class="code" href="structcooked.html#o6">first_unused_pass</a>,
00577                              w-&gt;<a class="code" href="structcooked.html#o5">first_postmapped_pass</a> + normal_passes_mapped,
00578                              w-&gt;<a class="code" href="structcooked.html#o6">first_unused_pass</a>,
00579                              pageheight - 1
00580                                  - w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o0">separation</a> * (w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o1">jets</a> - 1),
00581                              separations_to_distribute);
00582         } <span class="keywordflow">else</span> {
00583                 w-&gt;<a class="code" href="structcooked.html#o9">pass_postmap</a> = 0;
00584                 w-&gt;<a class="code" href="structcooked.html#o10">stagger_postmap</a> = 0;
00585         }
00586 }
00587 
00588 <span class="keyword">static</span> <span class="keywordtype">void</span> *                           <span class="comment">/* O - weave parameter block */</span>
<a name="l00589"></a><a class="code" href="print-weave_8c.html#a14">00589</a> <a class="code" href="print-weave_8c.html#a14">initialize_weave_params</a>(<span class="keywordtype">int</span> separation,         <span class="comment">/* I - jet separation */</span>
00590                         <span class="keywordtype">int</span> jets,               <span class="comment">/* I - number of jets */</span>
00591                         <span class="keywordtype">int</span> oversample,         <span class="comment">/* I - oversampling factor */</span>
00592                         <span class="keywordtype">int</span> firstrow,   <span class="comment">/* I - first row number to print */</span>
00593                         <span class="keywordtype">int</span> lastrow,    <span class="comment">/* I - last row number to print */</span>
00594                         <span class="keywordtype">int</span> pageheight, <span class="comment">/* I - number of rows on the whole</span>
00595 <span class="comment">                                               page, without using any</span>
00596 <span class="comment">                                               expanded margin facilities */</span>
00597                         stp_weave_strategy_t strategy,  <span class="comment">/* I - weave pattern variant to use */</span>
00598                         <a class="code" href="structstp__vars.html">stp_vars_t</a> *v)
00599 {
00600         <a class="code" href="structcooked.html">cooked_t</a> *w = <a class="code" href="group__util.html#ga28">stp_malloc</a>(<span class="keyword">sizeof</span>(<a class="code" href="structcooked.html">cooked_t</a>));
00601         <span class="keywordflow">if</span> (w) {
00602                 <a class="code" href="print-weave_8c.html#a6">initialize_raw_weave</a>(&amp;w-&gt;<a class="code" href="structcooked.html#o0">rw</a>, separation, jets, oversample, strategy, v);
00603                 <a class="code" href="print-weave_8c.html#a13">calculate_pass_map</a>(v, w, pageheight, firstrow, lastrow);
00604         }
00605         <span class="keywordflow">return</span> w;
00606 }
00607 
00608 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00609"></a><a class="code" href="print-weave_8c.html#a15">00609</a> <a class="code" href="print-weave_8c.html#a15">stpi_destroy_weave_params</a>(<span class="keywordtype">void</span> *vw)
00610 {
00611         <a class="code" href="structcooked.html">cooked_t</a> *w = (<a class="code" href="structcooked.html">cooked_t</a> *) vw;
00612 
00613         <span class="keywordflow">if</span> (w-&gt;<a class="code" href="structcooked.html#o7">pass_premap</a>) <a class="code" href="group__util.html#ga31">stp_free</a>(w-&gt;<a class="code" href="structcooked.html#o7">pass_premap</a>);
00614         <span class="keywordflow">if</span> (w-&gt;<a class="code" href="structcooked.html#o8">stagger_premap</a>) <a class="code" href="group__util.html#ga31">stp_free</a>(w-&gt;<a class="code" href="structcooked.html#o8">stagger_premap</a>);
00615         <span class="keywordflow">if</span> (w-&gt;<a class="code" href="structcooked.html#o9">pass_postmap</a>) <a class="code" href="group__util.html#ga31">stp_free</a>(w-&gt;<a class="code" href="structcooked.html#o9">pass_postmap</a>);
00616         <span class="keywordflow">if</span> (w-&gt;<a class="code" href="structcooked.html#o10">stagger_postmap</a>) <a class="code" href="group__util.html#ga31">stp_free</a>(w-&gt;<a class="code" href="structcooked.html#o10">stagger_postmap</a>);
00617         <a class="code" href="group__util.html#ga31">stp_free</a>(w);
00618 }
00619 
00620 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00621"></a><a class="code" href="print-weave_8c.html#a16">00621</a> <a class="code" href="print-weave_8c.html#a16">stpi_calculate_row_parameters</a>(<span class="keywordtype">void</span> *vw,         <span class="comment">/* I - weave parameters */</span>
00622                               <span class="keywordtype">int</span> row,          <span class="comment">/* I - row number */</span>
00623                               <span class="keywordtype">int</span> subpass,      <span class="comment">/* I - subpass */</span>
00624                               <span class="keywordtype">int</span> *pass,        <span class="comment">/* O - pass containing row */</span>
00625                               <span class="keywordtype">int</span> *jetnum,      <span class="comment">/* O - jet number of row */</span>
00626                               <span class="keywordtype">int</span> *startingrow, <span class="comment">/* O - phys start of pass */</span>
00627                               <span class="keywordtype">int</span> *ophantomrows, <span class="comment">/* O - missing rows @ start */</span>
00628                               <span class="keywordtype">int</span> *ojetsused)   <span class="comment">/* O - jets used by pass */</span>
00629 {
00630         <a class="code" href="structcooked.html">cooked_t</a> *w = (<a class="code" href="structcooked.html">cooked_t</a> *) vw;
00631         <span class="keywordtype">int</span> raw_pass, jet, startrow, phantomrows, jetsused;
00632         <span class="keywordtype">int</span> stagger = 0;
00633         <span class="keywordtype">int</span> extra;
00634 
00635         <a class="code" href="print-weave_8c.html#a1">assert</a>(row &gt;= w-&gt;<a class="code" href="structcooked.html#o1">first_row_printed</a>, w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o7">v</a>);
00636         <a class="code" href="print-weave_8c.html#a1">assert</a>(row &lt;= w-&gt;last_row_printed, w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o7">v</a>);
00637         <a class="code" href="print-weave_8c.html#a8">calculate_raw_row_parameters</a>(&amp;w-&gt;<a class="code" href="structcooked.html#o0">rw</a>,
00638                                      row + w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o0">separation</a> * w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o1">jets</a>,
00639                                      subpass, &amp;raw_pass, &amp;jet, &amp;startrow);
00640         startrow -= w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o0">separation</a> * w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o1">jets</a>;
00641         jetsused = w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o1">jets</a>;
00642         phantomrows = 0;
00643 
00644         <span class="keywordflow">if</span> (raw_pass &lt; w-&gt;<a class="code" href="structcooked.html#o4">first_normal_pass</a>) {
00645                 <a class="code" href="print-weave_8c.html#a1">assert</a>(raw_pass &gt;= w-&gt;<a class="code" href="structcooked.html#o3">first_premapped_pass</a>, w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o7">v</a>);
00646                 *pass = w-&gt;<a class="code" href="structcooked.html#o7">pass_premap</a>[raw_pass - w-&gt;<a class="code" href="structcooked.html#o3">first_premapped_pass</a>];
00647                 stagger = w-&gt;<a class="code" href="structcooked.html#o8">stagger_premap</a>[raw_pass - w-&gt;<a class="code" href="structcooked.html#o3">first_premapped_pass</a>];
00648         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (raw_pass &gt;= w-&gt;<a class="code" href="structcooked.html#o5">first_postmapped_pass</a>) {
00649                 <a class="code" href="print-weave_8c.html#a1">assert</a>(raw_pass &gt;= w-&gt;<a class="code" href="structcooked.html#o5">first_postmapped_pass</a>, w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o7">v</a>);
00650                 *pass = w-&gt;<a class="code" href="structcooked.html#o9">pass_postmap</a>[raw_pass - w-&gt;<a class="code" href="structcooked.html#o5">first_postmapped_pass</a>];
00651                 stagger = w-&gt;<a class="code" href="structcooked.html#o10">stagger_postmap</a>[raw_pass
00652                                              - w-&gt;<a class="code" href="structcooked.html#o5">first_postmapped_pass</a>];
00653         } <span class="keywordflow">else</span> {
00654                 *pass = raw_pass - w-&gt;<a class="code" href="structcooked.html#o3">first_premapped_pass</a>;
00655         }
00656 
00657         startrow += stagger * w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o0">separation</a>;
00658         *jetnum = jet - stagger;
00659         <span class="keywordflow">if</span> (stagger &lt; 0) {
00660                 stagger = -stagger;
00661                 phantomrows += stagger;
00662         }
00663         jetsused -= stagger;
00664 
00665         extra = w-&gt;<a class="code" href="structcooked.html#o1">first_row_printed</a>
00666                      - (startrow + w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o0">separation</a> * phantomrows);
00667         <span class="keywordflow">if</span> (extra &gt; 0) {
00668                 extra = (extra + w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o0">separation</a> - 1) / w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o0">separation</a>;
00669                 jetsused -= extra;
00670                 phantomrows += extra;
00671         }
00672 
00673         extra = startrow + w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o0">separation</a> * (phantomrows + jetsused - 1)
00674                   - w-&gt;<a class="code" href="structcooked.html#o2">last_row_printed</a>;
00675         <span class="keywordflow">if</span> (extra &gt; 0) {
00676                 extra = (extra + w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o0">separation</a> - 1) / w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o0">separation</a>;
00677                 jetsused -= extra;
00678         }
00679 
00680         *startingrow = startrow;
00681         *ophantomrows = phantomrows;
00682         *ojetsused = jetsused;
00683 }
00684 
00685 <span class="comment">/*</span>
00686 <span class="comment"> * "Soft" weave</span>
00687 <span class="comment"> *</span>
00688 <span class="comment"> * The Epson Stylus Color/Photo printers don't have memory to print</span>
00689 <span class="comment"> * using all of the nozzles in the print head.  For example, the Stylus Photo</span>
00690 <span class="comment"> * 700/EX has 32 nozzles.  At 720 dpi, with an 8" wide image, a single line</span>
00691 <span class="comment"> * requires (8 * 720 * 6 / 8) bytes, or 4320 bytes (because the Stylus Photo</span>
00692 <span class="comment"> * printers have 6 ink colors).  To use 32 nozzles would require 138240 bytes.</span>
00693 <span class="comment"> * It's actually worse than that, though, because the nozzles are spaced 8</span>
00694 <span class="comment"> * rows apart.  Therefore, in order to store enough data to permit sending the</span>
00695 <span class="comment"> * page as a simple raster, the printer would require enough memory to store</span>
00696 <span class="comment"> * 256 rows, or 1105920 bytes.  Considering that the Photo EX can print</span>
00697 <span class="comment"> * 11" wide, we're looking at more like 1.5 MB.  In fact, these printers are</span>
00698 <span class="comment"> * capable of 1440 dpi horizontal resolution.  This would require 3 MB.  The</span>
00699 <span class="comment"> * printers actually have 64K-256K.</span>
00700 <span class="comment"> *</span>
00701 <span class="comment"> * With the newer (740/750 and later) printers it's even worse, since these</span>
00702 <span class="comment"> * printers support multiple dot sizes.  But that's neither here nor there.</span>
00703 <span class="comment"> *</span>
00704 <span class="comment"> * Older Epson printers had a mode called MicroWeave (tm).  In this mode, the</span>
00705 <span class="comment"> * host fed the printer individual rows of dots, and the printer bundled them</span>
00706 <span class="comment"> * up and sent them to the print head in the correct order to achieve high</span>
00707 <span class="comment"> * quality.  This MicroWeave mode still works in new printers, but the</span>
00708 <span class="comment"> * implementation is very minimal: the printer uses exactly one nozzle of</span>
00709 <span class="comment"> * each color (the first one).  This makes printing extremely slow (more than</span>
00710 <span class="comment"> * 30 minutes for one 8.5x11" page), although the quality is extremely high</span>
00711 <span class="comment"> * with no visible banding whatsoever.  It's not good for the print head,</span>
00712 <span class="comment"> * though, since no ink is flowing through the other nozzles.  This leads to</span>
00713 <span class="comment"> * drying of ink and possible permanent damage to the print head.</span>
00714 <span class="comment"> *</span>
00715 <span class="comment"> * By the way, although the Epson manual says that microweave mode should be</span>
00716 <span class="comment"> * used at 720 dpi, 360 dpi continues to work in much the same way.  At 360</span>
00717 <span class="comment"> * dpi, data is fed to the printer one row at a time on all Epson printers.</span>
00718 <span class="comment"> * The pattern that the printer uses to print is very prone to banding.</span>
00719 <span class="comment"> * However, 360 dpi is inherently a low quality mode; if you're using it,</span>
00720 <span class="comment"> * presumably you don't much care about quality.</span>
00721 <span class="comment"> *</span>
00722 <span class="comment"> * Printers from roughly the Stylus Color 600 and later do not have the</span>
00723 <span class="comment"> * capability to do MicroWeave correctly.  Instead, the host must arrange</span>
00724 <span class="comment"> * the output in the order that it will be sent to the print head.  This</span>
00725 <span class="comment"> * is a very complex process; the jets in the print head are spaced more</span>
00726 <span class="comment"> * than one row (1/720") apart, so we can't simply send consecutive rows</span>
00727 <span class="comment"> * of dots to the printer.  Instead, we have to pass e. g. the first, ninth,</span>
00728 <span class="comment"> * 17th, 25th... rows in order for them to print in the correct position on</span>
00729 <span class="comment"> * the paper.  This interleaving process is called "soft" weaving.</span>
00730 <span class="comment"> *</span>
00731 <span class="comment"> * This decision was probably made to save money on memory in the printer.</span>
00732 <span class="comment"> * It certainly makes the driver code far more complicated than it would</span>
00733 <span class="comment"> * be if the printer could arrange the output.  Is that a bad thing?</span>
00734 <span class="comment"> * Usually this takes far less CPU time than the dithering process, and it</span>
00735 <span class="comment"> * does allow us more control over the printing process, e. g. to reduce</span>
00736 <span class="comment"> * banding.  Conceivably, we could even use this ability to map out bad</span>
00737 <span class="comment"> * jets.</span>
00738 <span class="comment"> *</span>
00739 <span class="comment"> * Interestingly, apparently the Windows (and presumably Macintosh) drivers</span>
00740 <span class="comment"> * for most or all Epson printers still list a "microweave" mode.</span>
00741 <span class="comment"> * Experiments have demonstrated that this does not in fact use the</span>
00742 <span class="comment"> * "microweave" mode of the printer.  Possibly it does nothing, or it uses</span>
00743 <span class="comment"> * a different weave pattern from what the non-"microweave" mode does.</span>
00744 <span class="comment"> * This is unnecessarily confusing.</span>
00745 <span class="comment"> *</span>
00746 <span class="comment"> * What makes this interesting is that there are many different ways of</span>
00747 <span class="comment"> * of accomplishing this goal.  The naive way would be to divide the image</span>
00748 <span class="comment"> * up into groups of 256 rows, and print all the mod8=0 rows in the first pass,</span>
00749 <span class="comment"> * mod8=1 rows in the second, and so forth.  The problem with this approach</span>
00750 <span class="comment"> * is that the individual ink jets are not perfectly uniform; some emit</span>
00751 <span class="comment"> * slightly bigger or smaller drops than others.  Since each group of 8</span>
00752 <span class="comment"> * adjacent rows is printed with the same nozzle, that means that there will</span>
00753 <span class="comment"> * be distinct streaks of lighter and darker bands within the image (8 rows</span>
00754 <span class="comment"> * is 1/90", which is visible; 1/720" is not).  Possibly worse is that these</span>
00755 <span class="comment"> * patterns will repeat every 256 rows.  This creates banding patterns that</span>
00756 <span class="comment"> * are about 1/3" wide.</span>
00757 <span class="comment"> *</span>
00758 <span class="comment"> * So we have to do something to break up this patterning.</span>
00759 <span class="comment"> *</span>
00760 <span class="comment"> * Epson does not publish the weaving algorithms that they use in their</span>
00761 <span class="comment"> * bundled drivers.  Indeed, their developer web site</span>
00762 <span class="comment"> * (http://www.ercipd.com/isv/edr_docs.htm) does not even describe how to</span>
00763 <span class="comment"> * do this weaving at all; it says that the only way to achieve 720 dpi</span>
00764 <span class="comment"> * is to use MicroWeave.  It does note (correctly) that 1440 dpi horizontal</span>
00765 <span class="comment"> * can only be achieved by the driver (i. e. in software).  The manual</span>
00766 <span class="comment"> * actually makes it fairly clear how to do this (it requires two passes</span>
00767 <span class="comment"> * with horizontal head movement between passes), and it is presumably</span>
00768 <span class="comment"> * possible to do this with MicroWeave.</span>
00769 <span class="comment"> *</span>
00770 <span class="comment"> * The information about how to do this is apparently available under NDA.</span>
00771 <span class="comment"> * It's actually easy enough to reverse engineer what's inside a print file</span>
00772 <span class="comment"> * with a simple Perl script.  There are presumably other printer commands</span>
00773 <span class="comment"> * that are not documented and may not be as easy to reverse engineer.</span>
00774 <span class="comment"> *</span>
00775 <span class="comment"> * I considered a few algorithms to perform the weave.  The first one I</span>
00776 <span class="comment"> * devised let me use only (jets - distance_between_jets + 1) nozzles, or</span>
00777 <span class="comment"> * 25.  This is OK in principle, but it's slower than using all nozzles.</span>
00778 <span class="comment"> * By playing around with it some more, I came up with an algorithm that</span>
00779 <span class="comment"> * lets me use all of the nozzles, except near the top and bottom of the</span>
00780 <span class="comment"> * page.</span>
00781 <span class="comment"> *</span>
00782 <span class="comment"> * This still produces some banding, though.  Even better quality can be</span>
00783 <span class="comment"> * achieved by using multiple nozzles on the same line.  How do we do this?</span>
00784 <span class="comment"> * In 1440x720 mode, we're printing two output lines at the same vertical</span>
00785 <span class="comment"> * position.  However, if we want four passes, we have to effectively print</span>
00786 <span class="comment"> * each line twice.  Actually doing this would increase the density, so</span>
00787 <span class="comment"> * what we do is print half the dots on each pass.  This produces near-perfect</span>
00788 <span class="comment"> * output, and it's far faster than using (pseudo) "MicroWeave".</span>
00789 <span class="comment"> *</span>
00790 <span class="comment"> * The current algorithm is not completely general.  The number of passes</span>
00791 <span class="comment"> * is limited to (nozzles / gap).  On the Photo EX class printers, that limits</span>
00792 <span class="comment"> * it to 4 -- 32 nozzles, an inter-nozzle gap of 8 lines.  Furthermore, there</span>
00793 <span class="comment"> * are a number of routines that are only coded up to 8 passes.  Fortunately,</span>
00794 <span class="comment"> * this is enough passes to get rid of most banding.  What's left is a very</span>
00795 <span class="comment"> * fine pattern that is sometimes described as "corduroy", since the pattern</span>
00796 <span class="comment"> * looks like that kind of fabric.</span>
00797 <span class="comment"> *</span>
00798 <span class="comment"> * Newer printers (those that support variable dot sizes, such as the 740,</span>
00799 <span class="comment"> * 1200, etc.) have an additional complication: when used in softweave mode,</span>
00800 <span class="comment"> * they operate at 360 dpi horizontal resolution.  This requires FOUR passes</span>
00801 <span class="comment"> * to achieve 1440x720 dpi.  Thus, to enable us to break up each row</span>
00802 <span class="comment"> * into separate sub-rows, we have to actually print each row eight times.</span>
00803 <span class="comment"> * Fortunately, all such printers have 48 nozzles and a gap of 6 rows,</span>
00804 <span class="comment"> * except for the high-speed 900, which uses 96 nozzles and a gap of 2 rows.</span>
00805 <span class="comment"> *</span>
00806 <span class="comment"> * I cannot let this entirely pass without commenting on the Stylus Color 440.</span>
00807 <span class="comment"> * This is a very low-end printer with 21 (!) nozzles and a separation of 8.</span>
00808 <span class="comment"> * The weave routine works correctly with single-pass printing, which is enough</span>
00809 <span class="comment"> * to minimally achieve 720 dpi output (it's physically a 720 dpi printer).</span>
00810 <span class="comment"> * However, the routine does not work correctly at more than one pass per row.</span>
00811 <span class="comment"> * Therefore, this printer bands badly.</span>
00812 <span class="comment"> *</span>
00813 <span class="comment"> * Yet another complication is how to get near the top and bottom of the page.</span>
00814 <span class="comment"> * This algorithm lets us print to within one head width of the top of the</span>
00815 <span class="comment"> * page, and a bit more than one head width from the bottom.  That leaves a</span>
00816 <span class="comment"> * lot of blank space.  Doing the weave properly outside of this region is</span>
00817 <span class="comment"> * increasingly difficult as we get closer to the edge of the paper; in the</span>
00818 <span class="comment"> * interior region, any nozzle can print any line, but near the top and</span>
00819 <span class="comment"> * bottom edges, only some nozzles can print.  We've handled this for now by</span>
00820 <span class="comment"> * using the naive way mentioned above near the borders, and switching over</span>
00821 <span class="comment"> * to the high quality method in the interior.  Unfortunately, this means</span>
00822 <span class="comment"> * that the quality is quite visibly degraded near the top and bottom of the</span>
00823 <span class="comment"> * page.  Algorithms that degrade more gracefully are more complicated.</span>
00824 <span class="comment"> * Epson does not advertise that the printers can print at the very top of the</span>
00825 <span class="comment"> * page, although in practice most or all of them can.  I suspect that the</span>
00826 <span class="comment"> * quality that can be achieved very close to the top is poor enough that</span>
00827 <span class="comment"> * Epson does not want to allow printing there.  That is a valid decision,</span>
00828 <span class="comment"> * although we have taken another approach.</span>
00829 <span class="comment"> *</span>
00830 <span class="comment"> * To compute the weave information, we need to start with the following</span>
00831 <span class="comment"> * information:</span>
00832 <span class="comment"> *</span>
00833 <span class="comment"> * 1) The number of jets the print head has for each color;</span>
00834 <span class="comment"> *</span>
00835 <span class="comment"> * 2) The separation in rows between the jets;</span>
00836 <span class="comment"> *</span>
00837 <span class="comment"> * 3) The horizontal resolution of the printer;</span>
00838 <span class="comment"> *</span>
00839 <span class="comment"> * 4) The desired horizontal resolution of the output;</span>
00840 <span class="comment"> *</span>
00841 <span class="comment"> * 5) The desired extra passes to reduce banding.</span>
00842 <span class="comment"> *</span>
00843 <span class="comment"> * As discussed above, each row is actually printed in one or more passes</span>
00844 <span class="comment"> * of the print head; we refer to these as subpasses.  For example, if we're</span>
00845 <span class="comment"> * printing at 1440(h)x720(v) on a printer with true horizontal resolution of</span>
00846 <span class="comment"> * 360 dpi, and we wish to print each line twice with different nozzles</span>
00847 <span class="comment"> * to reduce banding, we need to use 8 subpasses.  The dither routine</span>
00848 <span class="comment"> * will feed us a complete row of bits for each color; we have to split that</span>
00849 <span class="comment"> * up, first by round robining the bits to ensure that they get printed at</span>
00850 <span class="comment"> * the right micro-position, and then to split up the bits that are actually</span>
00851 <span class="comment"> * turned on into two equal chunks to reduce banding.</span>
00852 <span class="comment"> *</span>
00853 <span class="comment"> * Given the above information, and the desired row index and subpass (which</span>
00854 <span class="comment"> * together form a line number), we can compute:</span>
00855 <span class="comment"> *</span>
00856 <span class="comment"> * 1) Which pass this line belongs to.  Passes are numbered consecutively,</span>
00857 <span class="comment"> *    and each pass must logically (see #3 below) start at no smaller a row</span>
00858 <span class="comment"> *    number than the previous pass, as the printer cannot advance by a</span>
00859 <span class="comment"> *    negative amount.</span>
00860 <span class="comment"> *</span>
00861 <span class="comment"> * 2) Which jet will print this line.</span>
00862 <span class="comment"> *</span>
00863 <span class="comment"> * 3) The "logical" first line of this pass.  That is, what line would be</span>
00864 <span class="comment"> *    printed by jet 0 in this pass.  This number may be less than zero.</span>
00865 <span class="comment"> *    If it is, there are ghost lines that don't actually contain any data.</span>
00866 <span class="comment"> *    The difference between the logical first line of this pass and the</span>
00867 <span class="comment"> *    logical first line of the preceding pass tells us how many lines must</span>
00868 <span class="comment"> *    be advanced.</span>
00869 <span class="comment"> *</span>
00870 <span class="comment"> * 4) The "physical" first line of this pass.  That is, the first line index</span>
00871 <span class="comment"> *    that is actually printed in this pass.  This information lets us know</span>
00872 <span class="comment"> *    when we must prepare this pass.</span>
00873 <span class="comment"> *</span>
00874 <span class="comment"> * 5) The last line of this pass.  This lets us know when we must actually</span>
00875 <span class="comment"> *    send this pass to the printer.</span>
00876 <span class="comment"> *</span>
00877 <span class="comment"> * 6) The number of ghost rows this pass contains.  We must still send the</span>
00878 <span class="comment"> *    ghost data to the printer, so this lets us know how much data we must</span>
00879 <span class="comment"> *    fill in prior to the start of the pass.</span>
00880 <span class="comment"> *</span>
00881 <span class="comment"> * The bookkeeping to keep track of all this stuff is quite hairy, and needs</span>
00882 <span class="comment"> * to be documented separately.</span>
00883 <span class="comment"> *</span>
00884 <span class="comment"> * The routine initialize_weave calculates the basic parameters, given</span>
00885 <span class="comment"> * the number of jets and separation between jets, in rows.</span>
00886 <span class="comment"> *</span>
00887 <span class="comment"> * -- Robert Krawitz &lt;rlk@alum.mit.edu) November 3, 1999</span>
00888 <span class="comment"> */</span>
00889 
00890 <span class="keyword">static</span> <a class="code" href="structstp__lineoff__t.html">stp_lineoff_t</a> *
<a name="l00891"></a><a class="code" href="print-weave_8c.html#a17">00891</a> <a class="code" href="print-weave_8c.html#a17">allocate_lineoff</a>(<span class="keywordtype">int</span> count, <span class="keywordtype">int</span> ncolors)
00892 {
00893   <span class="keywordtype">int</span> i;
00894   <a class="code" href="structstp__lineoff__t.html">stp_lineoff_t</a> *retval = <a class="code" href="group__util.html#ga28">stp_malloc</a>(count * <span class="keyword">sizeof</span>(<a class="code" href="structstp__lineoff__t.html">stp_lineoff_t</a>));
00895   <span class="keywordflow">for</span> (i = 0; i &lt; count; i++)
00896     {
00897       retval[i].<a class="code" href="structstp__lineoff__t.html#o0">ncolors</a> = ncolors;
00898       retval[i].<a class="code" href="structstp__lineoff__t.html#o1">v</a> = <a class="code" href="group__util.html#ga29">stp_zalloc</a>(ncolors * <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>));
00899     }
00900   <span class="keywordflow">return</span> (retval);
00901 }
00902 
00903 <span class="keyword">static</span> <a class="code" href="structstp__lineactive__t.html">stp_lineactive_t</a> *
<a name="l00904"></a><a class="code" href="print-weave_8c.html#a18">00904</a> <a class="code" href="print-weave_8c.html#a18">allocate_lineactive</a>(<span class="keywordtype">int</span> count, <span class="keywordtype">int</span> ncolors)
00905 {
00906   <span class="keywordtype">int</span> i;
00907   <a class="code" href="structstp__lineactive__t.html">stp_lineactive_t</a> *retval = <a class="code" href="group__util.html#ga28">stp_malloc</a>(count * <span class="keyword">sizeof</span>(<a class="code" href="structstp__lineactive__t.html">stp_lineactive_t</a>));
00908   <span class="keywordflow">for</span> (i = 0; i &lt; count; i++)
00909     {
00910       retval[i].<a class="code" href="structstp__lineactive__t.html#o0">ncolors</a> = ncolors;
00911       retval[i].<a class="code" href="structstp__lineactive__t.html#o1">v</a> = <a class="code" href="group__util.html#ga29">stp_zalloc</a>(ncolors * <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
00912     }
00913   <span class="keywordflow">return</span> (retval);
00914 }
00915 
00916 <span class="keyword">static</span> <a class="code" href="structstp__linecount__t.html">stp_linecount_t</a> *
<a name="l00917"></a><a class="code" href="print-weave_8c.html#a19">00917</a> <a class="code" href="print-weave_8c.html#a19">allocate_linecount</a>(<span class="keywordtype">int</span> count, <span class="keywordtype">int</span> ncolors)
00918 {
00919   <span class="keywordtype">int</span> i;
00920   <a class="code" href="structstp__linecount__t.html">stp_linecount_t</a> *retval = <a class="code" href="group__util.html#ga28">stp_malloc</a>(count * <span class="keyword">sizeof</span>(<a class="code" href="structstp__linecount__t.html">stp_linecount_t</a>));
00921   <span class="keywordflow">for</span> (i = 0; i &lt; count; i++)
00922     {
00923       retval[i].<a class="code" href="structstp__linecount__t.html#o0">ncolors</a> = ncolors;
00924       retval[i].<a class="code" href="structstp__linecount__t.html#o1">v</a> = <a class="code" href="group__util.html#ga29">stp_zalloc</a>(ncolors * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00925     }
00926   <span class="keywordflow">return</span> (retval);
00927 }
00928 
00929 <span class="keyword">static</span> <a class="code" href="structstp__linebounds__t.html">stp_linebounds_t</a> *
<a name="l00930"></a><a class="code" href="print-weave_8c.html#a20">00930</a> <a class="code" href="print-weave_8c.html#a20">allocate_linebounds</a>(<span class="keywordtype">int</span> count, <span class="keywordtype">int</span> ncolors)
00931 {
00932   <span class="keywordtype">int</span> i;
00933   <a class="code" href="structstp__linebounds__t.html">stp_linebounds_t</a> *retval = <a class="code" href="group__util.html#ga28">stp_malloc</a>(count * <span class="keyword">sizeof</span>(<a class="code" href="structstp__linebounds__t.html">stp_linebounds_t</a>));
00934   <span class="keywordflow">for</span> (i = 0; i &lt; count; i++)
00935     {
00936       retval[i].<a class="code" href="structstp__linebounds__t.html#o0">ncolors</a> = ncolors;
00937       retval[i].<a class="code" href="structstp__linebounds__t.html#o1">start_pos</a> = <a class="code" href="group__util.html#ga29">stp_zalloc</a>(ncolors * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00938       retval[i].<a class="code" href="structstp__linebounds__t.html#o2">end_pos</a> = <a class="code" href="group__util.html#ga29">stp_zalloc</a>(ncolors * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00939     }
00940   <span class="keywordflow">return</span> (retval);
00941 }
00942 
00943 <span class="keyword">static</span> <a class="code" href="structstp__linebufs__t.html">stp_linebufs_t</a> *
<a name="l00944"></a><a class="code" href="print-weave_8c.html#a21">00944</a> <a class="code" href="print-weave_8c.html#a21">allocate_linebuf</a>(<span class="keywordtype">int</span> count, <span class="keywordtype">int</span> ncolors)
00945 {
00946   <span class="keywordtype">int</span> i;
00947   <a class="code" href="structstp__linebufs__t.html">stp_linebufs_t</a> *retval = <a class="code" href="group__util.html#ga28">stp_malloc</a>(count * <span class="keyword">sizeof</span>(<a class="code" href="structstp__linebufs__t.html">stp_linebufs_t</a>));
00948   <span class="keywordflow">for</span> (i = 0; i &lt; count; i++)
00949     {
00950       retval[i].<a class="code" href="structstp__linebufs__t.html#o0">ncolors</a> = ncolors;
00951       retval[i].<a class="code" href="structstp__linebufs__t.html#o1">v</a> = <a class="code" href="group__util.html#ga29">stp_zalloc</a>(ncolors * <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *));
00952     }
00953   <span class="keywordflow">return</span> (retval);
00954 }
00955 
00956 <span class="comment">/*</span>
00957 <span class="comment"> * Initialize the weave parameters</span>
00958 <span class="comment"> *</span>
00959 <span class="comment"> * Rules:</span>
00960 <span class="comment"> *</span>
00961 <span class="comment"> * 1) Currently, osample * v_subpasses * v_subsample &lt;= 8, and no one</span>
00962 <span class="comment"> *    of these variables may exceed 4.</span>
00963 <span class="comment"> *</span>
00964 <span class="comment"> * 2) first_line &gt;= 0</span>
00965 <span class="comment"> *</span>
00966 <span class="comment"> * 3) line_height &lt; physlines</span>
00967 <span class="comment"> *</span>
00968 <span class="comment"> * 4) page_height &gt;= 2 * jets * sep</span>
00969 <span class="comment"> */</span>
00970 
00971 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00972"></a><a class="code" href="print-weave_8c.html#a22">00972</a> <a class="code" href="print-weave_8c.html#a22">stpi_destroy_weave</a>(<span class="keywordtype">void</span> *vsw)
00973 {
00974   <span class="keywordtype">int</span> i, j;
00975   <a class="code" href="structstpi__softweave.html">stpi_softweave_t</a> *sw = (<a class="code" href="structstpi__softweave.html">stpi_softweave_t</a> *) vsw;
00976   <a class="code" href="group__util.html#ga31">stp_free</a>(sw-&gt;<a class="code" href="structstpi__softweave.html#o5">passes</a>);
00977   <span class="keywordflow">if</span> (sw-&gt;<a class="code" href="structstpi__softweave.html#o28">fold_buf</a>)
00978     <a class="code" href="group__util.html#ga31">stp_free</a>(sw-&gt;<a class="code" href="structstpi__softweave.html#o28">fold_buf</a>);
00979   <span class="keywordflow">if</span> (sw-&gt;<a class="code" href="structstpi__softweave.html#o29">comp_buf</a>)
00980     <a class="code" href="group__util.html#ga31">stp_free</a>(sw-&gt;<a class="code" href="structstpi__softweave.html#o29">comp_buf</a>);
00981   <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="weave_8h.html#a0">STP_MAX_WEAVE</a>; i++)
00982     <span class="keywordflow">if</span> (sw-&gt;<a class="code" href="structstpi__softweave.html#o27">s</a>[i])
00983       <a class="code" href="group__util.html#ga31">stp_free</a>(sw-&gt;<a class="code" href="structstpi__softweave.html#o27">s</a>[i]);
00984   <span class="keywordflow">for</span> (i = 0; i &lt; sw-&gt;<a class="code" href="structstpi__softweave.html#o14">vmod</a>; i++)
00985     {
00986       <span class="keywordflow">for</span> (j = 0; j &lt; sw-&gt;<a class="code" href="structstpi__softweave.html#o17">ncolors</a>; j++)
00987         {
00988           <span class="keywordflow">if</span> (sw-&gt;<a class="code" href="structstpi__softweave.html#o0">linebases</a>[i].<a class="code" href="structstp__linebufs__t.html#o1">v</a>[j])
00989             <a class="code" href="group__util.html#ga31">stp_free</a>(sw-&gt;<a class="code" href="structstpi__softweave.html#o0">linebases</a>[i].<a class="code" href="structstp__linebufs__t.html#o1">v</a>[j]);
00990         }
00991       <a class="code" href="group__util.html#ga31">stp_free</a>(sw-&gt;<a class="code" href="structstpi__softweave.html#o3">linecounts</a>[i].<a class="code" href="structstp__linecount__t.html#o1">v</a>);
00992       <a class="code" href="group__util.html#ga31">stp_free</a>(sw-&gt;<a class="code" href="structstpi__softweave.html#o0">linebases</a>[i].<a class="code" href="structstp__linebufs__t.html#o1">v</a>);
00993       <a class="code" href="group__util.html#ga31">stp_free</a>(sw-&gt;<a class="code" href="structstpi__softweave.html#o2">lineactive</a>[i].<a class="code" href="structstp__lineactive__t.html#o1">v</a>);
00994       <a class="code" href="group__util.html#ga31">stp_free</a>(sw-&gt;<a class="code" href="structstpi__softweave.html#o1">lineoffsets</a>[i].<a class="code" href="structstp__lineoff__t.html#o1">v</a>);
00995       <a class="code" href="group__util.html#ga31">stp_free</a>(sw-&gt;<a class="code" href="structstpi__softweave.html#o4">linebounds</a>[i].<a class="code" href="structstp__linebounds__t.html#o1">start_pos</a>);
00996       <a class="code" href="group__util.html#ga31">stp_free</a>(sw-&gt;<a class="code" href="structstpi__softweave.html#o4">linebounds</a>[i].<a class="code" href="structstp__linebounds__t.html#o2">end_pos</a>);
00997     }
00998   <a class="code" href="group__util.html#ga31">stp_free</a>(sw-&gt;<a class="code" href="structstpi__softweave.html#o3">linecounts</a>);
00999   <a class="code" href="group__util.html#ga31">stp_free</a>(sw-&gt;<a class="code" href="structstpi__softweave.html#o2">lineactive</a>);
01000   <a class="code" href="group__util.html#ga31">stp_free</a>(sw-&gt;<a class="code" href="structstpi__softweave.html#o1">lineoffsets</a>);
01001   <a class="code" href="group__util.html#ga31">stp_free</a>(sw-&gt;<a class="code" href="structstpi__softweave.html#o0">linebases</a>);
01002   <a class="code" href="group__util.html#ga31">stp_free</a>(sw-&gt;<a class="code" href="structstpi__softweave.html#o4">linebounds</a>);
01003   <a class="code" href="group__util.html#ga31">stp_free</a>(sw-&gt;<a class="code" href="structstpi__softweave.html#o26">head_offset</a>);
01004   <a class="code" href="print-weave_8c.html#a15">stpi_destroy_weave_params</a>(sw-&gt;<a class="code" href="structstpi__softweave.html#o11">weaveparm</a>);
01005   <a class="code" href="group__util.html#ga31">stp_free</a>(vsw);
01006 }
01007 
01008 <span class="keywordtype">void</span>
<a name="l01009"></a><a class="code" href="print-weave_8c.html#a23">01009</a> <a class="code" href="print-weave_8c.html#a23">stp_initialize_weave</a>(<a class="code" href="structstp__vars.html">stp_vars_t</a> *v,
01010                      <span class="keywordtype">int</span> jets,  <span class="comment">/* Width of print head */</span>
01011                      <span class="keywordtype">int</span> sep,   <span class="comment">/* Separation in rows between jets */</span>
01012                      <span class="keywordtype">int</span> osample,       <span class="comment">/* Horizontal oversample */</span>
01013                      <span class="keywordtype">int</span> v_subpasses, <span class="comment">/* Vertical passes */</span>
01014                      <span class="keywordtype">int</span> v_subsample, <span class="comment">/* Vertical oversampling */</span>
01015                      <span class="keywordtype">int</span> ncolors,
01016                      <span class="keywordtype">int</span> bitwidth,      <span class="comment">/* bits/pixel */</span>
01017                      <span class="keywordtype">int</span> linewidth,     <span class="comment">/* Width of a line, in pixels */</span>
01018                      <span class="keywordtype">int</span> line_count, <span class="comment">/* Lines that will be printed */</span>
01019                      <span class="keywordtype">int</span> first_line, <span class="comment">/* First line that will be printed */</span>
01020                      <span class="keywordtype">int</span> page_height, <span class="comment">/* Total height of the page in rows */</span>
01021                      <span class="keyword">const</span> <span class="keywordtype">int</span> *head_offset,
01022                      stp_weave_strategy_t weave_strategy,
01023                      <a class="code" href="weave_8h.html#a3">stp_flushfunc</a> flushfunc,
01024                      <a class="code" href="weave_8h.html#a2">stp_fillfunc</a> fillfunc,
01025                      <a class="code" href="weave_8h.html#a1">stp_packfunc</a> pack,
01026                      <a class="code" href="weave_8h.html#a4">stp_compute_linewidth_func</a> compute_linewidth)
01027 {
01028   <span class="keywordtype">int</span> i;
01029   <span class="keywordtype">int</span> last_line, maxHeadOffset;
01030   <a class="code" href="structstpi__softweave.html">stpi_softweave_t</a> *sw = <a class="code" href="group__util.html#ga29">stp_zalloc</a>(<span class="keyword">sizeof</span> (<a class="code" href="structstpi__softweave.html">stpi_softweave_t</a>));
01031 
01032   <span class="keywordflow">if</span> (jets &lt; 1)
01033     jets = 1;
01034   <span class="keywordflow">if</span> (jets == 1 || sep &lt; 1)
01035     sep = 1;
01036   <span class="keywordflow">if</span> (v_subpasses &lt; 1)
01037     v_subpasses = 1;
01038   <span class="keywordflow">if</span> (v_subsample &lt; 1)
01039     v_subsample = 1;
01040 
01041   sw-&gt;<a class="code" href="structstpi__softweave.html#o10">separation</a> = sep;
01042   sw-&gt;<a class="code" href="structstpi__softweave.html#o8">jets</a> = jets;
01043   sw-&gt;<a class="code" href="structstpi__softweave.html#o12">horizontal_weave</a> = osample;
01044   sw-&gt;<a class="code" href="structstpi__softweave.html#o15">oversample</a> = osample * v_subpasses * v_subsample;
01045   <span class="keywordflow">if</span> (sw-&gt;<a class="code" href="structstpi__softweave.html#o15">oversample</a> &gt; jets)
01046     {
01047       <span class="keywordtype">int</span> found = 0;
01048       <span class="keywordflow">for</span> (i = 2; i &lt;= osample; i++)
01049         {
01050           <span class="keywordflow">if</span> ((osample % i == 0) &amp;&amp; (sw-&gt;<a class="code" href="structstpi__softweave.html#o15">oversample</a> / i &lt;= jets))
01051             {
01052               sw-&gt;<a class="code" href="structstpi__softweave.html#o16">repeat_count</a> = i;
01053               osample /= i;
01054               found = 1;
01055               <span class="keywordflow">break</span>;
01056             }
01057         }
01058       <span class="keywordflow">if</span> (!found)
01059         {
01060           <a class="code" href="print-util_8c.html#a18">stp_eprintf</a>(v, <span class="stringliteral">"Weave error: oversample (%d) &gt; jets (%d)\n"</span>,
01061                       sw-&gt;<a class="code" href="structstpi__softweave.html#o15">oversample</a>, jets);
01062           <a class="code" href="group__util.html#ga31">stp_free</a>(sw);
01063           <span class="keywordflow">return</span>;
01064         }
01065     }
01066   <span class="keywordflow">else</span>
01067     sw-&gt;<a class="code" href="structstpi__softweave.html#o16">repeat_count</a> = 1;
01068 
01069   sw-&gt;<a class="code" href="structstpi__softweave.html#o23">vertical_oversample</a> = v_subsample;
01070   sw-&gt;<a class="code" href="structstpi__softweave.html#o13">vertical_subpasses</a> = v_subpasses;
01071   sw-&gt;<a class="code" href="structstpi__softweave.html#o15">oversample</a> = osample * v_subpasses * v_subsample;
01072   sw-&gt;<a class="code" href="structstpi__softweave.html#o20">firstline</a> = first_line;
01073   sw-&gt;<a class="code" href="structstpi__softweave.html#o22">lineno</a> = first_line;
01074   sw-&gt;<a class="code" href="structstpi__softweave.html#o33">flushfunc</a> = flushfunc;
01075 
01076   <span class="keywordflow">if</span> (sw-&gt;<a class="code" href="structstpi__softweave.html#o15">oversample</a> &gt; jets)
01077     {
01078       <a class="code" href="print-util_8c.html#a18">stp_eprintf</a>(v, <span class="stringliteral">"Weave error: oversample (%d) &gt; jets (%d)\n"</span>,
01079                   sw-&gt;<a class="code" href="structstpi__softweave.html#o15">oversample</a>, jets);
01080       <a class="code" href="group__util.html#ga31">stp_free</a>(sw);
01081       <span class="keywordflow">return</span>;
01082     }
01083 
01084   <span class="comment">/*</span>
01085 <span class="comment">   * setup printhead offsets.</span>
01086 <span class="comment">   * for monochrome (bw) printing, the offsets are 0.</span>
01087 <span class="comment">   */</span>
01088   sw-&gt;<a class="code" href="structstpi__softweave.html#o26">head_offset</a> = <a class="code" href="group__util.html#ga29">stp_zalloc</a>(ncolors * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
01089   <span class="keywordflow">if</span> (ncolors &gt; 1)
01090     <span class="keywordflow">for</span>(i = 0; i &lt; ncolors; i++)
01091       sw-&gt;<a class="code" href="structstpi__softweave.html#o26">head_offset</a>[i] = head_offset[i];
01092 
01093   maxHeadOffset = 0;
01094   <span class="keywordflow">for</span> (i = 0; i &lt; ncolors; i++)
01095     <span class="keywordflow">if</span> (sw-&gt;<a class="code" href="structstpi__softweave.html#o26">head_offset</a>[i] &gt; maxHeadOffset)
01096       maxHeadOffset = sw-&gt;<a class="code" href="structstpi__softweave.html#o26">head_offset</a>[i];
01097 
01098   sw-&gt;<a class="code" href="structstpi__softweave.html#o9">virtual_jets</a> = sw-&gt;<a class="code" href="structstpi__softweave.html#o8">jets</a>;
01099   <span class="keywordflow">if</span> (maxHeadOffset &gt; 0)
01100     sw-&gt;<a class="code" href="structstpi__softweave.html#o9">virtual_jets</a> += (maxHeadOffset + sw-&gt;<a class="code" href="structstpi__softweave.html#o10">separation</a> - 1) / sw-&gt;<a class="code" href="structstpi__softweave.html#o10">separation</a>;
01101   last_line = first_line + line_count - 1 + maxHeadOffset;
01102 
01103   sw-&gt;<a class="code" href="structstpi__softweave.html#o11">weaveparm</a> = <a class="code" href="print-weave_8c.html#a14">initialize_weave_params</a>(sw-&gt;<a class="code" href="structstpi__softweave.html#o10">separation</a>, sw-&gt;<a class="code" href="structstpi__softweave.html#o8">jets</a>,
01104                                           sw-&gt;<a class="code" href="structstpi__softweave.html#o15">oversample</a>, first_line, last_line,
01105                                           page_height, weave_strategy, v);
01106   <span class="comment">/*</span>
01107 <span class="comment">   * The value of vmod limits how many passes may be unfinished at a time.</span>
01108 <span class="comment">   * If pass x is not yet printed, pass x+vmod cannot be started.</span>
01109 <span class="comment">   *</span>
01110 <span class="comment">   * The multiplier of 2: 1 for the normal passes, 1 for the special passes</span>
01111 <span class="comment">   * at the start or end.</span>
01112 <span class="comment">   */</span>
01113   sw-&gt;<a class="code" href="structstpi__softweave.html#o14">vmod</a> = 2 * sw-&gt;<a class="code" href="structstpi__softweave.html#o10">separation</a> * sw-&gt;<a class="code" href="structstpi__softweave.html#o15">oversample</a> * sw-&gt;<a class="code" href="structstpi__softweave.html#o16">repeat_count</a>;
01114   <span class="keywordflow">if</span> (sw-&gt;<a class="code" href="structstpi__softweave.html#o9">virtual_jets</a> &gt; sw-&gt;<a class="code" href="structstpi__softweave.html#o8">jets</a>)
01115     sw-&gt;<a class="code" href="structstpi__softweave.html#o14">vmod</a> *= (sw-&gt;<a class="code" href="structstpi__softweave.html#o9">virtual_jets</a> + sw-&gt;<a class="code" href="structstpi__softweave.html#o8">jets</a> - 1) / sw-&gt;<a class="code" href="structstpi__softweave.html#o8">jets</a>;
01116 
01117   sw-&gt;<a class="code" href="structstpi__softweave.html#o21">bitwidth</a> = bitwidth;
01118   sw-&gt;<a class="code" href="structstpi__softweave.html#o6">last_pass_offset</a> = 0;
01119   sw-&gt;<a class="code" href="structstpi__softweave.html#o7">last_pass</a> = -1;
01120   sw-&gt;<a class="code" href="structstpi__softweave.html#o24">current_vertical_subpass</a> = 0;
01121   sw-&gt;<a class="code" href="structstpi__softweave.html#o17">ncolors</a> = ncolors;
01122   sw-&gt;<a class="code" href="structstpi__softweave.html#o18">linewidth</a> = linewidth;
01123   sw-&gt;<a class="code" href="structstpi__softweave.html#o19">vertical_height</a> = line_count;
01124   sw-&gt;<a class="code" href="structstpi__softweave.html#o1">lineoffsets</a> = <a class="code" href="print-weave_8c.html#a17">allocate_lineoff</a>(sw-&gt;<a class="code" href="structstpi__softweave.html#o14">vmod</a>, ncolors);
01125   sw-&gt;<a class="code" href="structstpi__softweave.html#o2">lineactive</a> = <a class="code" href="print-weave_8c.html#a18">allocate_lineactive</a>(sw-&gt;<a class="code" href="structstpi__softweave.html#o14">vmod</a>, ncolors);
01126   sw-&gt;<a class="code" href="structstpi__softweave.html#o0">linebases</a> = <a class="code" href="print-weave_8c.html#a21">allocate_linebuf</a>(sw-&gt;<a class="code" href="structstpi__softweave.html#o14">vmod</a>, ncolors);
01127   sw-&gt;<a class="code" href="structstpi__softweave.html#o4">linebounds</a> = <a class="code" href="print-weave_8c.html#a20">allocate_linebounds</a>(sw-&gt;<a class="code" href="structstpi__softweave.html#o14">vmod</a>, ncolors);
01128   sw-&gt;<a class="code" href="structstpi__softweave.html#o5">passes</a> = <a class="code" href="group__util.html#ga29">stp_zalloc</a>(sw-&gt;<a class="code" href="structstpi__softweave.html#o14">vmod</a> * <span class="keyword">sizeof</span>(<a class="code" href="structstp__pass__t.html">stp_pass_t</a>));
01129   sw-&gt;<a class="code" href="structstpi__softweave.html#o3">linecounts</a> = <a class="code" href="print-weave_8c.html#a19">allocate_linecount</a>(sw-&gt;<a class="code" href="structstpi__softweave.html#o14">vmod</a>, ncolors);
01130   sw-&gt;<a class="code" href="structstpi__softweave.html#o31">rcache</a> = -2;
01131   sw-&gt;<a class="code" href="structstpi__softweave.html#o32">vcache</a> = -2;
01132   sw-&gt;<a class="code" href="structstpi__softweave.html#o34">fillfunc</a> = fillfunc;
01133   sw-&gt;<a class="code" href="structstpi__softweave.html#o36">compute_linewidth</a> = compute_linewidth;
01134   sw-&gt;<a class="code" href="structstpi__softweave.html#o35">pack</a> = pack;
01135   sw-&gt;<a class="code" href="structstpi__softweave.html#o25">horizontal_width</a> =
01136     (sw-&gt;<a class="code" href="structstpi__softweave.html#o36">compute_linewidth</a>)(v, ((sw-&gt;<a class="code" href="structstpi__softweave.html#o18">linewidth</a> + sw-&gt;<a class="code" href="structstpi__softweave.html#o12">horizontal_weave</a> - 1) /
01137                                  sw-&gt;<a class="code" href="structstpi__softweave.html#o12">horizontal_weave</a>));
01138   sw-&gt;<a class="code" href="structstpi__softweave.html#o25">horizontal_width</a> = ((sw-&gt;<a class="code" href="structstpi__softweave.html#o25">horizontal_width</a> + 7) / 8);
01139 
01140   <span class="keywordflow">for</span> (i = 0; i &lt; sw-&gt;<a class="code" href="structstpi__softweave.html#o14">vmod</a>; i++)
01141     {
01142       <span class="keywordtype">int</span> j;
01143       sw-&gt;<a class="code" href="structstpi__softweave.html#o5">passes</a>[i].<a class="code" href="structstp__pass__t.html#o0">pass</a> = -1;
01144       <span class="keywordflow">for</span> (j = 0; j &lt; sw-&gt;<a class="code" href="structstpi__softweave.html#o17">ncolors</a>; j++)
01145         {
01146           sw-&gt;<a class="code" href="structstpi__softweave.html#o0">linebases</a>[i].<a class="code" href="structstp__linebufs__t.html#o1">v</a>[j] = NULL;
01147         }
01148     }
01149   <a class="code" href="group__vars.html#ga18">stp_allocate_component_data</a>(v, <span class="stringliteral">"Weave"</span>, NULL, <a class="code" href="print-weave_8c.html#a22">stpi_destroy_weave</a>, sw);
01150   <span class="keywordflow">return</span>;
01151 }
01152 
01153 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01154"></a><a class="code" href="print-weave_8c.html#a24">01154</a> <a class="code" href="print-weave_8c.html#a24">weave_parameters_by_row</a>(<span class="keyword">const</span> <a class="code" href="structstp__vars.html">stp_vars_t</a> *v, <span class="keyword">const</span> <a class="code" href="structstpi__softweave.html">stpi_softweave_t</a> *sw,
01155                         <span class="keywordtype">int</span> row, <span class="keywordtype">int</span> vertical_subpass, <a class="code" href="structstp__weave__t.html">stp_weave_t</a> *w)
01156 {
01157   <span class="keywordtype">int</span> jetsused;
01158   <span class="keywordtype">int</span> sub_repeat_count = vertical_subpass % sw-&gt;<a class="code" href="structstpi__softweave.html#o16">repeat_count</a>;
01159   <span class="comment">/*</span>
01160 <span class="comment">   * Conceptually, this does not modify the softweave state.  We cache</span>
01161 <span class="comment">   * the results, but this cache is considered hidden.</span>
01162 <span class="comment">   */</span>
01163   <a class="code" href="structstpi__softweave.html">stpi_softweave_t</a> *wsw = (<a class="code" href="structstpi__softweave.html">stpi_softweave_t</a> *) sw;
01164   vertical_subpass /= sw-&gt;<a class="code" href="structstpi__softweave.html#o16">repeat_count</a>;
01165 
01166   <span class="keywordflow">if</span> (sw-&gt;<a class="code" href="structstpi__softweave.html#o31">rcache</a> == row &amp;&amp; sw-&gt;<a class="code" href="structstpi__softweave.html#o32">vcache</a> == vertical_subpass)
01167     {
01168       memcpy(w, &amp;sw-&gt;<a class="code" href="structstpi__softweave.html#o30">wcache</a>, <span class="keyword">sizeof</span>(<a class="code" href="structstp__weave__t.html">stp_weave_t</a>));
01169       w-&gt;<a class="code" href="structstp__weave__t.html#o1">pass</a> = (w-&gt;<a class="code" href="structstp__weave__t.html#o1">pass</a> * sw-&gt;<a class="code" href="structstpi__softweave.html#o16">repeat_count</a>) + sub_repeat_count;
01170       <span class="keywordflow">return</span>;
01171     }
01172   wsw-&gt;<a class="code" href="structstpi__softweave.html#o31">rcache</a> = row;
01173   wsw-&gt;<a class="code" href="structstpi__softweave.html#o32">vcache</a> = vertical_subpass;
01174 
01175   w-&gt;<a class="code" href="structstp__weave__t.html#o0">row</a> = row;
01176   <a class="code" href="print-weave_8c.html#a16">stpi_calculate_row_parameters</a>(sw-&gt;<a class="code" href="structstpi__softweave.html#o11">weaveparm</a>, row, vertical_subpass,
01177                                 &amp;w-&gt;<a class="code" href="structstp__weave__t.html#o1">pass</a>, &amp;w-&gt;<a class="code" href="structstp__weave__t.html#o2">jet</a>, &amp;w-&gt;<a class="code" href="structstp__weave__t.html#o4">logicalpassstart</a>,
01178                                 &amp;w-&gt;<a class="code" href="structstp__weave__t.html#o3">missingstartrows</a>, &amp;jetsused);
01179 
01180   w-&gt;<a class="code" href="structstp__weave__t.html#o5">physpassstart</a> = w-&gt;<a class="code" href="structstp__weave__t.html#o4">logicalpassstart</a> + sw-&gt;<a class="code" href="structstpi__softweave.html#o10">separation</a> * w-&gt;<a class="code" href="structstp__weave__t.html#o3">missingstartrows</a>;
01181   w-&gt;<a class="code" href="structstp__weave__t.html#o6">physpassend</a> = w-&gt;<a class="code" href="structstp__weave__t.html#o5">physpassstart</a> + sw-&gt;<a class="code" href="structstpi__softweave.html#o10">separation</a> * (jetsused - 1);
01182 
01183   memcpy(&amp;(((<a class="code" href="structstpi__softweave.html">stpi_softweave_t</a> *) wsw)-&gt;wcache), w, <span class="keyword">sizeof</span>(<a class="code" href="structstp__weave__t.html">stp_weave_t</a>));
01184   w-&gt;<a class="code" href="structstp__weave__t.html#o1">pass</a> = (w-&gt;<a class="code" href="structstp__weave__t.html#o1">pass</a> * sw-&gt;<a class="code" href="structstpi__softweave.html#o16">repeat_count</a>) + sub_repeat_count;
01185   <a class="code" href="print-util_8c.html#a23">stp_dprintf</a>(<a class="code" href="group__util.html#ga39">STP_DBG_WEAVE_PARAMS</a>, v, <span class="stringliteral">"row %d, jet %d of pass %d "</span>
01186               <span class="stringliteral">"(pos %d, start %d, end %d, missing rows %d)\n"</span>,
01187               w-&gt;<a class="code" href="structstp__weave__t.html#o0">row</a>, w-&gt;<a class="code" href="structstp__weave__t.html#o2">jet</a>, w-&gt;<a class="code" href="structstp__weave__t.html#o1">pass</a>, w-&gt;<a class="code" href="structstp__weave__t.html#o4">logicalpassstart</a>, w-&gt;<a class="code" href="structstp__weave__t.html#o5">physpassstart</a>,
01188               w-&gt;<a class="code" href="structstp__weave__t.html#o6">physpassend</a>, w-&gt;<a class="code" href="structstp__weave__t.html#o3">missingstartrows</a>);
01189 }
01190 
01191 <span class="keywordtype">void</span>
<a name="l01192"></a><a class="code" href="print-weave_8c.html#a25">01192</a> <a class="code" href="print-weave_8c.html#a25">stp_weave_parameters_by_row</a>(<span class="keyword">const</span> <a class="code" href="structstp__vars.html">stp_vars_t</a> *v, <span class="keywordtype">int</span> row,
01193                             <span class="keywordtype">int</span> vertical_subpass, <a class="code" href="structstp__weave__t.html">stp_weave_t</a> *w)
01194 {
01195   <span class="keyword">const</span> <a class="code" href="structstpi__softweave.html">stpi_softweave_t</a> *sw =
01196     (<a class="code" href="structstpi__softweave.html">stpi_softweave_t</a> *) <a class="code" href="group__vars.html#ga20">stp_get_component_data</a>(v, <span class="stringliteral">"Weave"</span>);
01197   <a class="code" href="print-weave_8c.html#a24">weave_parameters_by_row</a>(v, sw, row, vertical_subpass, w);
01198 }
01199 
01200 
01201 <span class="keyword">static</span> <a class="code" href="structstp__lineoff__t.html">stp_lineoff_t</a> *
<a name="l01202"></a><a class="code" href="print-weave_8c.html#a26">01202</a> <a class="code" href="print-weave_8c.html#a26">stpi_get_lineoffsets</a>(<span class="keyword">const</span> <a class="code" href="structstp__vars.html">stp_vars_t</a> *v, <span class="keyword">const</span> <a class="code" href="structstpi__softweave.html">stpi_softweave_t</a> *sw,
01203                      <span class="keywordtype">int</span> row, <span class="keywordtype">int</span> subpass, <span class="keywordtype">int</span> offset)
01204 {
01205   <a class="code" href="structstp__weave__t.html">stp_weave_t</a> w;
01206   <a class="code" href="print-weave_8c.html#a24">weave_parameters_by_row</a>(v, sw, row + offset, subpass, &amp;w);
01207   <span class="keywordflow">return</span> &amp;(sw-&gt;<a class="code" href="structstpi__softweave.html#o1">lineoffsets</a>[w.<a class="code" href="structstp__weave__t.html#o1">pass</a> % sw-&gt;<a class="code" href="structstpi__softweave.html#o14">vmod</a>]);
01208 }
01209 
01210 <span class="keyword">static</span> <a class="code" href="structstp__lineactive__t.html">stp_lineactive_t</a> *
<a name="l01211"></a><a class="code" href="print-weave_8c.html#a27">01211</a> <a class="code" href="print-weave_8c.html#a27">stpi_get_lineactive</a>(<span class="keyword">const</span> <a class="code" href="structstp__vars.html">stp_vars_t</a> *v, <span class="keyword">const</span> <a class="code" href="structstpi__softweave.html">stpi_softweave_t</a> *sw,
01212                     <span class="keywordtype">int</span> row, <span class="keywordtype">int</span> subpass, <span class="keywordtype">int</span> offset)
01213 {
01214   <a class="code" href="structstp__weave__t.html">stp_weave_t</a> w;
01215   <a class="code" href="print-weave_8c.html#a24">weave_parameters_by_row</a>(v, sw, row + offset, subpass, &amp;w);
01216   <span class="keywordflow">return</span> &amp;(sw-&gt;<a class="code" href="structstpi__softweave.html#o2">lineactive</a>[w.<a class="code" href="structstp__weave__t.html#o1">pass</a> % sw-&gt;<a class="code" href="structstpi__softweave.html#o14">vmod</a>]);
01217 }
01218 
01219 <span class="keyword">static</span> <a class="code" href="structstp__linecount__t.html">stp_linecount_t</a> *
<a name="l01220"></a><a class="code" href="print-weave_8c.html#a28">01220</a> <a class="code" href="print-weave_8c.html#a28">stpi_get_linecount</a>(<span class="keyword">const</span> <a class="code" href="structstp__vars.html">stp_vars_t</a> *v, <span class="keyword">const</span> <a class="code" href="structstpi__softweave.html">stpi_softweave_t</a> *sw,
01221                    <span class="keywordtype">int</span> row, <span class="keywordtype">int</span> subpass, <span class="keywordtype">int</span> offset)
01222 {
01223   <a class="code" href="structstp__weave__t.html">stp_weave_t</a> w;
01224   <a class="code" href="print-weave_8c.html#a24">weave_parameters_by_row</a>(v, sw, row + offset, subpass, &amp;w);
01225   <span class="keywordflow">return</span> &amp;(sw-&gt;<a class="code" href="structstpi__softweave.html#o3">linecounts</a>[w.<a class="code" href="structstp__weave__t.html#o1">pass</a> % sw-&gt;<a class="code" href="structstpi__softweave.html#o14">vmod</a>]);
01226 }
01227 
01228 <span class="keyword">static</span> <a class="code" href="structstp__linebufs__t.html">stp_linebufs_t</a> *
<a name="l01229"></a><a class="code" href="print-weave_8c.html#a29">01229</a> <a class="code" href="print-weave_8c.html#a29">stpi_get_linebases</a>(<span class="keyword">const</span> <a class="code" href="structstp__vars.html">stp_vars_t</a> *v, <span class="keyword">const</span> <a class="code" href="structstpi__softweave.html">stpi_softweave_t</a> *sw,
01230                    <span class="keywordtype">int</span> row, <span class="keywordtype">int</span> subpass, <span class="keywordtype">int</span> offset)
01231 {
01232   <a class="code" href="structstp__weave__t.html">stp_weave_t</a> w;
01233   <a class="code" href="print-weave_8c.html#a24">weave_parameters_by_row</a>(v, sw, row + offset, subpass, &amp;w);
01234   <span class="keywordflow">return</span> &amp;(sw-&gt;<a class="code" href="structstpi__softweave.html#o0">linebases</a>[w.<a class="code" href="structstp__weave__t.html#o1">pass</a> % sw-&gt;<a class="code" href="structstpi__softweave.html#o14">vmod</a>]);
01235 }
01236 
01237 <span class="keyword">static</span> <a class="code" href="structstp__linebounds__t.html">stp_linebounds_t</a> *
<a name="l01238"></a><a class="code" href="print-weave_8c.html#a30">01238</a> <a class="code" href="print-weave_8c.html#a30">stpi_get_linebounds</a>(<span class="keyword">const</span> <a class="code" href="structstp__vars.html">stp_vars_t</a> *v, <span class="keyword">const</span> <a class="code" href="structstpi__softweave.html">stpi_softweave_t</a> *sw,
01239                     <span class="keywordtype">int</span> row, <span class="keywordtype">int</span> subpass, <span class="keywordtype">int</span> offset)
01240 {
01241   <a class="code" href="structstp__weave__t.html">stp_weave_t</a> w;
01242   <a class="code" href="print-weave_8c.html#a24">weave_parameters_by_row</a>(v, sw, row + offset, subpass, &amp;w);
01243   <span class="keywordflow">return</span> &amp;(sw-&gt;<a class="code" href="structstpi__softweave.html#o4">linebounds</a>[w.<a class="code" href="structstp__weave__t.html#o1">pass</a> % sw-&gt;<a class="code" href="structstpi__softweave.html#o14">vmod</a>]);
01244 }
01245 
01246 <span class="keyword">static</span> <a class="code" href="structstp__pass__t.html">stp_pass_t</a> *
<a name="l01247"></a><a class="code" href="print-weave_8c.html#a31">01247</a> <a class="code" href="print-weave_8c.html#a31">stpi_get_pass_by_row</a>(<a class="code" href="structstp__vars.html">stp_vars_t</a> *v, <span class="keyword">const</span> <a class="code" href="structstpi__softweave.html">stpi_softweave_t</a> *sw,
01248                      <span class="keywordtype">int</span> row, <span class="keywordtype">int</span> subpass,<span class="keywordtype">int</span> offset)
01249 {
01250   <a class="code" href="structstp__weave__t.html">stp_weave_t</a> w;
01251   <a class="code" href="print-weave_8c.html#a24">weave_parameters_by_row</a>(v, sw, row + offset, subpass, &amp;w);
01252   <span class="keywordflow">return</span> &amp;(sw-&gt;<a class="code" href="structstpi__softweave.html#o5">passes</a>[w.<a class="code" href="structstp__weave__t.html#o1">pass</a> % sw-&gt;<a class="code" href="structstpi__softweave.html#o14">vmod</a>]);
01253 }
01254 
01255 <a class="code" href="structstp__lineoff__t.html">stp_lineoff_t</a> *
<a name="l01256"></a><a class="code" href="print-weave_8c.html#a32">01256</a> <a class="code" href="print-weave_8c.html#a32">stp_get_lineoffsets_by_pass</a>(<span class="keyword">const</span> <a class="code" href="structstp__vars.html">stp_vars_t</a> *v, <span class="keywordtype">int</span> pass)
01257 {
01258   <span class="keyword">const</span> <a class="code" href="structstpi__softweave.html">stpi_softweave_t</a> *sw =
01259     (<a class="code" href="structstpi__softweave.html">stpi_softweave_t</a> *) <a class="code" href="group__vars.html#ga20">stp_get_component_data</a>(v, <span class="stringliteral">"Weave"</span>);
01260   <span class="keywordflow">return</span> &amp;(sw-&gt;<a class="code" href="structstpi__softweave.html#o1">lineoffsets</a>[pass % sw-&gt;<a class="code" href="structstpi__softweave.html#o14">vmod</a>]);
01261 }
01262 
01263 <a class="code" href="structstp__lineactive__t.html">stp_lineactive_t</a> *
<a name="l01264"></a><a class="code" href="print-weave_8c.html#a33">01264</a> <a class="code" href="print-weave_8c.html#a33">stp_get_lineactive_by_pass</a>(<span class="keyword">const</span> <a class="code" href="structstp__vars.html">stp_vars_t</a> *v, <span class="keywordtype">int</span> pass)
01265 {
01266   <span class="keyword">const</span> <a class="code" href="structstpi__softweave.html">stpi_softweave_t</a> *sw =
01267     (<a class="code" href="structstpi__softweave.html">stpi_softweave_t</a> *) <a class="code" href="group__vars.html#ga20">stp_get_component_data</a>(v, <span class="stringliteral">"Weave"</span>);
01268   <span class="keywordflow">return</span> &amp;(sw-&gt;<a class="code" href="structstpi__softweave.html#o2">lineactive</a>[pass % sw-&gt;<a class="code" href="structstpi__softweave.html#o14">vmod</a>]);
01269 }
01270 
01271 <a class="code" href="structstp__linecount__t.html">stp_linecount_t</a> *
<a name="l01272"></a><a class="code" href="print-weave_8c.html#a34">01272</a> <a class="code" href="print-weave_8c.html#a34">stp_get_linecount_by_pass</a>(<span class="keyword">const</span> <a class="code" href="structstp__vars.html">stp_vars_t</a> *v, <span class="keywordtype">int</span> pass)
01273 {
01274   <span class="keyword">const</span> <a class="code" href="structstpi__softweave.html">stpi_softweave_t</a> *sw =
01275     (<a class="code" href="structstpi__softweave.html">stpi_softweave_t</a> *) <a class="code" href="group__vars.html#ga20">stp_get_component_data</a>(v, <span class="stringliteral">"Weave"</span>);
01276   <span class="keywordflow">return</span> &amp;(sw-&gt;<a class="code" href="structstpi__softweave.html#o3">linecounts</a>[pass % sw-&gt;<a class="code" href="structstpi__softweave.html#o14">vmod</a>]);
01277 }
01278 
01279 <span class="keyword">const</span> <a class="code" href="structstp__linebufs__t.html">stp_linebufs_t</a> *
<a name="l01280"></a><a class="code" href="print-weave_8c.html#a35">01280</a> <a class="code" href="print-weave_8c.html#a35">stp_get_linebases_by_pass</a>(<span class="keyword">const</span> <a class="code" href="structstp__vars.html">stp_vars_t</a> *v, <span class="keywordtype">int</span> pass)
01281 {
01282   <span class="keyword">const</span> <a class="code" href="structstpi__softweave.html">stpi_softweave_t</a> *sw =
01283     (<a class="code" href="structstpi__softweave.html">stpi_softweave_t</a> *) <a class="code" href="group__vars.html#ga20">stp_get_component_data</a>(v, <span class="stringliteral">"Weave"</span>);
01284   <span class="keywordflow">return</span> &amp;(sw-&gt;<a class="code" href="structstpi__softweave.html#o0">linebases</a>[pass % sw-&gt;<a class="code" href="structstpi__softweave.html#o14">vmod</a>]);
01285 }
01286 
01287 <a class="code" href="structstp__pass__t.html">stp_pass_t</a> *
<a name="l01288"></a><a class="code" href="print-weave_8c.html#a36">01288</a> <a class="code" href="print-weave_8c.html#a36">stp_get_pass_by_pass</a>(<span class="keyword">const</span> <a class="code" href="structstp__vars.html">stp_vars_t</a> *v, <span class="keywordtype">int</span> pass)
01289 {
01290   <span class="keyword">const</span> <a class="code" href="structstpi__softweave.html">stpi_softweave_t</a> *sw =
01291     (<a class="code" href="structstpi__softweave.html">stpi_softweave_t</a> *) <a class="code" href="group__vars.html#ga20">stp_get_component_data</a>(v, <span class="stringliteral">"Weave"</span>);
01292   <span class="keywordflow">return</span> &amp;(sw-&gt;<a class="code" href="structstpi__softweave.html#o5">passes</a>[pass % sw-&gt;<a class="code" href="structstpi__softweave.html#o14">vmod</a>]);
01293 }
01294 
01295 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01296"></a><a class="code" href="print-weave_8c.html#a37">01296</a> <a class="code" href="print-weave_8c.html#a37">check_linebases</a>(<a class="code" href="structstp__vars.html">stp_vars_t</a> *v, <span class="keyword">const</span> <a class="code" href="structstpi__softweave.html">stpi_softweave_t</a> *sw,
01297                 <span class="keywordtype">int</span> row, <span class="keywordtype">int</span> cpass, <span class="keywordtype">int</span> head_offset, <span class="keywordtype">int</span> color)
01298 {
01299   <a class="code" href="structstp__linebufs__t.html">stp_linebufs_t</a> *bufs =
01300     (<a class="code" href="structstp__linebufs__t.html">stp_linebufs_t</a> *) <a class="code" href="print-weave_8c.html#a29">stpi_get_linebases</a>(v, sw, row, cpass, head_offset);
01301   <span class="keywordflow">if</span> (!(bufs[0].<a class="code" href="structstp__linebufs__t.html#o1">v</a>[color]))
01302     bufs[0].<a class="code" href="structstp__linebufs__t.html#o1">v</a>[color] =
01303       <a class="code" href="group__util.html#ga29">stp_zalloc</a> (sw-&gt;<a class="code" href="structstpi__softweave.html#o9">virtual_jets</a> * sw-&gt;<a class="code" href="structstpi__softweave.html#o21">bitwidth</a> * sw-&gt;<a class="code" href="structstpi__softweave.html#o25">horizontal_width</a>);
01304 }
01305 
01306 <span class="comment">/*</span>
01307 <span class="comment"> * If there are phantom rows at the beginning of a pass, fill them in so</span>
01308 <span class="comment"> * that the printer knows exactly what it doesn't have to print.  We're</span>
01309 <span class="comment"> * using RLE compression here.  Each line must be specified independently,</span>
01310 <span class="comment"> * so we have to compute how many full blocks (groups of 128 bytes, or 1024</span>
01311 <span class="comment"> * "off" pixels) and how much leftover is needed.  Note that we can only</span>
01312 <span class="comment"> * RLE-encode groups of 2 or more bytes; single bytes must be specified</span>
01313 <span class="comment"> * with a count of 1.</span>
01314 <span class="comment"> */</span>
01315 
01316 <span class="keywordtype">void</span>
<a name="l01317"></a><a class="code" href="print-weave_8c.html#a38">01317</a> <a class="code" href="print-weave_8c.html#a38">stp_fill_tiff</a>(<a class="code" href="structstp__vars.html">stp_vars_t</a> *v, <span class="keywordtype">int</span> row, <span class="keywordtype">int</span> subpass,
01318               <span class="keywordtype">int</span> width, <span class="keywordtype">int</span> missingstartrows, <span class="keywordtype">int</span> color)
01319 {
01320   <a class="code" href="structstpi__softweave.html">stpi_softweave_t</a> *sw =
01321     (<a class="code" href="structstpi__softweave.html">stpi_softweave_t</a> *) <a class="code" href="group__vars.html#ga20">stp_get_component_data</a>(v, <span class="stringliteral">"Weave"</span>);
01322   <a class="code" href="structstp__lineoff__t.html">stp_lineoff_t</a> *lineoffs;
01323   <a class="code" href="structstp__linecount__t.html">stp_linecount_t</a> *linecount;
01324   <span class="keyword">const</span> <a class="code" href="structstp__linebufs__t.html">stp_linebufs_t</a> *bufs;
01325   <span class="keywordtype">int</span> i = 0;
01326   <span class="keywordtype">int</span> k = 0;
01327 
01328   width = sw-&gt;<a class="code" href="structstpi__softweave.html#o21">bitwidth</a> * width * 8;
01329   <span class="keywordflow">for</span> (k = 0; k &lt; missingstartrows; k++)
01330     {
01331       <span class="keywordtype">int</span> bytes_to_fill = width;
01332       <span class="keywordtype">int</span> full_blocks = bytes_to_fill / (128 * 8);
01333       <span class="keywordtype">int</span> leftover = (7 + (bytes_to_fill % (128 * 8))) / 8;
01334       <span class="keywordtype">int</span> l = 0;
01335       bufs = <a class="code" href="print-weave_8c.html#a29">stpi_get_linebases</a>(v, sw, row, subpass, sw-&gt;<a class="code" href="structstpi__softweave.html#o26">head_offset</a>[color]);
01336 
01337       <span class="keywordflow">while</span> (l &lt; full_blocks)
01338         {
01339           (bufs[0].<a class="code" href="structstp__linebufs__t.html#o1">v</a>[color][2 * i]) = 129;
01340           (bufs[0].<a class="code" href="structstp__linebufs__t.html#o1">v</a>[color][2 * i + 1]) = 0;
01341           i++;
01342           l++;
01343         }
01344       <span class="keywordflow">if</span> (leftover == 1)
01345         {
01346           (bufs[0].<a class="code" href="structstp__linebufs__t.html#o1">v</a>[color][2 * i]) = 1;
01347           (bufs[0].<a class="code" href="structstp__linebufs__t.html#o1">v</a>[color][2 * i + 1]) = 0;
01348           i++;
01349         }
01350       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (leftover &gt; 0)
01351         {
01352           (bufs[0].<a class="code" href="structstp__linebufs__t.html#o1">v</a>[color][2 * i]) = 257 - leftover;
01353           (bufs[0].<a class="code" href="structstp__linebufs__t.html#o1">v</a>[color][2 * i + 1]) = 0;
01354           i++;
01355         }
01356     }
01357 
01358   lineoffs = <a class="code" href="print-weave_8c.html#a26">stpi_get_lineoffsets</a>(v, sw, row, subpass, sw-&gt;<a class="code" href="structstpi__softweave.html#o26">head_offset</a>[color]);
01359   linecount = <a class="code" href="print-weave_8c.html#a28">stpi_get_linecount</a>(v, sw, row, subpass, sw-&gt;<a class="code" href="structstpi__softweave.html#o26">head_offset</a>[color]);
01360   lineoffs[0].<a class="code" href="structstp__lineoff__t.html#o1">v</a>[color] = 2 * i;
01361   linecount[0].<a class="code" href="structstp__linecount__t.html#o1">v</a>[color] = missingstartrows;
01362 }
01363 
01364 <span class="keywordtype">void</span>
<a name="l01365"></a><a class="code" href="print-weave_8c.html#a39">01365</a> <a class="code" href="print-weave_8c.html#a39">stp_fill_uncompressed</a>(<a class="code" href="structstp__vars.html">stp_vars_t</a> *v, <span class="keywordtype">int</span> row, <span class="keywordtype">int</span> subpass,
01366                       <span class="keywordtype">int</span> width, <span class="keywordtype">int</span> missingstartrows, <span class="keywordtype">int</span> color)
01367 {
01368   <a class="code" href="structstpi__softweave.html">stpi_softweave_t</a> *sw =
01369     (<a class="code" href="structstpi__softweave.html">stpi_softweave_t</a> *) <a class="code" href="group__vars.html#ga20">stp_get_component_data</a>(v, <span class="stringliteral">"Weave"</span>);
01370   <a class="code" href="structstp__lineoff__t.html">stp_lineoff_t</a> *lineoffs;
01371   <a class="code" href="structstp__linecount__t.html">stp_linecount_t</a> *linecount;
01372   <span class="keyword">const</span> <a class="code" href="structstp__linebufs__t.html">stp_linebufs_t</a> *bufs;
01373 
01374   bufs = <a class="code" href="print-weave_8c.html#a29">stpi_get_linebases</a>(v, sw, row, subpass, sw-&gt;<a class="code" href="structstpi__softweave.html#o26">head_offset</a>[color]);
01375   lineoffs = <a class="code" href="print-weave_8c.html#a26">stpi_get_lineoffsets</a>(v, sw, row, subpass, sw-&gt;<a class="code" href="structstpi__softweave.html#o26">head_offset</a>[color]);
01376   linecount = <a class="code" href="print-weave_8c.html#a28">stpi_get_linecount</a>(v, sw, row, subpass, sw-&gt;<a class="code" href="structstpi__softweave.html#o26">head_offset</a>[color]);
01377   width *= sw-&gt;<a class="code" href="structstpi__softweave.html#o21">bitwidth</a> * missingstartrows;
01378   memset(bufs[0].v[color], 0, width);
01379   lineoffs[0].<a class="code" href="structstp__lineoff__t.html#o1">v</a>[color] = width;
01380   linecount[0].<a class="code" href="structstp__linecount__t.html#o1">v</a>[color] = missingstartrows;
01381 }
01382 
01383 <span class="keywordtype">int</span>
<a name="l01384"></a><a class="code" href="print-weave_8c.html#a40">01384</a> <a class="code" href="print-weave_8c.html#a40">stp_compute_tiff_linewidth</a>(<a class="code" href="structstp__vars.html">stp_vars_t</a> *v, <span class="keywordtype">int</span> n)
01385 {
01386   <span class="comment">/*</span>
01387 <span class="comment">   * It's possible for the "compression" to actually expand the line by</span>
01388 <span class="comment">   * roughly one part in 128.</span>
01389 <span class="comment">   */</span>
01390   <span class="keywordflow">return</span> ((n + 128 + 7) * 129 / 128);
01391 }
01392 
01393 <span class="keywordtype">int</span>
<a name="l01394"></a><a class="code" href="print-weave_8c.html#a41">01394</a> <a class="code" href="print-weave_8c.html#a41">stp_compute_uncompressed_linewidth</a>(<a class="code" href="structstp__vars.html">stp_vars_t</a> *v, <span class="keywordtype">int</span> n)
01395 {
01396   <span class="keywordflow">return</span> (8 * ((n + 7) / 8));
01397 }
01398 
01399 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01400"></a><a class="code" href="print-weave_8c.html#a42">01400</a> <a class="code" href="print-weave_8c.html#a42">initialize_row</a>(<a class="code" href="structstp__vars.html">stp_vars_t</a> *v, <a class="code" href="structstpi__softweave.html">stpi_softweave_t</a> *sw,
01401                <span class="keywordtype">int</span> row, <span class="keywordtype">int</span> width, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *<span class="keyword">const</span> cols[])
01402 {
01403   <a class="code" href="structstp__weave__t.html">stp_weave_t</a> w;
01404   <span class="keywordtype">int</span> i, j, jj;
01405   <a class="code" href="structstp__pass__t.html">stp_pass_t</a> *pass;
01406 
01407   <span class="keywordflow">for</span> (i = 0; i &lt; sw-&gt;<a class="code" href="structstpi__softweave.html#o15">oversample</a>; i++)
01408     {
01409       <span class="keywordflow">for</span> (j = 0; j &lt; sw-&gt;<a class="code" href="structstpi__softweave.html#o17">ncolors</a>; j++)
01410         {
01411           <span class="keywordflow">if</span> (cols[j])
01412             {
01413               <a class="code" href="structstp__lineoff__t.html">stp_lineoff_t</a> *lineoffs =
01414                 <a class="code" href="print-weave_8c.html#a26">stpi_get_lineoffsets</a>(v, sw, row, i, sw-&gt;<a class="code" href="structstpi__softweave.html#o26">head_offset</a>[j]);
01415               <a class="code" href="structstp__lineactive__t.html">stp_lineactive_t</a> *lineactive =
01416                 <a class="code" href="print-weave_8c.html#a27">stpi_get_lineactive</a>(v, sw, row, i, sw-&gt;<a class="code" href="structstpi__softweave.html#o26">head_offset</a>[j]);
01417               <a class="code" href="structstp__linecount__t.html">stp_linecount_t</a> *linecount =
01418                 <a class="code" href="print-weave_8c.html#a28">stpi_get_linecount</a>(v, sw, row, i, sw-&gt;<a class="code" href="structstpi__softweave.html#o26">head_offset</a>[j]);
01419               <a class="code" href="structstp__linebounds__t.html">stp_linebounds_t</a> *linebounds =
01420                 <a class="code" href="print-weave_8c.html#a30">stpi_get_linebounds</a>(v, sw, row, i, sw-&gt;<a class="code" href="structstpi__softweave.html#o26">head_offset</a>[j]);
01421               <a class="code" href="print-weave_8c.html#a37">check_linebases</a>(v, sw, row, i, sw-&gt;<a class="code" href="structstpi__softweave.html#o26">head_offset</a>[j], j);
01422               <a class="code" href="print-weave_8c.html#a24">weave_parameters_by_row</a>(v, sw, row+sw-&gt;<a class="code" href="structstpi__softweave.html#o26">head_offset</a>[j], i, &amp;w);
01423               pass = <a class="code" href="print-weave_8c.html#a31">stpi_get_pass_by_row</a>(v, sw, row, i, sw-&gt;<a class="code" href="structstpi__softweave.html#o26">head_offset</a>[j]);
01424 
01425               <span class="comment">/* initialize pass if not initialized yet */</span>
01426               <span class="keywordflow">if</span> (pass-&gt;<a class="code" href="structstp__pass__t.html#o0">pass</a> &lt; 0)
01427                 {
01428                   pass-&gt;<a class="code" href="structstp__pass__t.html#o0">pass</a> = w.<a class="code" href="structstp__weave__t.html#o1">pass</a>;
01429                   pass-&gt;<a class="code" href="structstp__pass__t.html#o1">missingstartrows</a> = w.<a class="code" href="structstp__weave__t.html#o3">missingstartrows</a>;
01430                   pass-&gt;<a class="code" href="structstp__pass__t.html#o2">logicalpassstart</a> = w.<a class="code" href="structstp__weave__t.html#o4">logicalpassstart</a>;
01431                   pass-&gt;<a class="code" href="structstp__pass__t.html#o3">physpassstart</a> = w.<a class="code" href="structstp__weave__t.html#o5">physpassstart</a>;
01432                   pass-&gt;<a class="code" href="structstp__pass__t.html#o4">physpassend</a> = w.<a class="code" href="structstp__weave__t.html#o6">physpassend</a>;
01433                   pass-&gt;<a class="code" href="structstp__pass__t.html#o5">subpass</a> = i;
01434 
01435                   <span class="keywordflow">for</span>(jj=0; jj&lt;sw-&gt;<a class="code" href="structstpi__softweave.html#o17">ncolors</a>; jj++)
01436                     {
01437                       <span class="keywordflow">if</span> (lineoffs[0].<a class="code" href="structstp__lineoff__t.html#o1">v</a>[jj] != 0)
01438                         <a class="code" href="print-util_8c.html#a18">stp_eprintf</a>(v, <span class="stringliteral">"WARNING: pass %d subpass %d row %d: "</span>
01439                                     <span class="stringliteral">"lineoffs %ld should be zero!\n"</span>,
01440                                     w.<a class="code" href="structstp__weave__t.html#o1">pass</a>, i, row, lineoffs[0].<a class="code" href="structstp__lineoff__t.html#o1">v</a>[jj]);
01441                       lineoffs[0].<a class="code" href="structstp__lineoff__t.html#o1">v</a>[jj] = 0;
01442                       lineactive[0].<a class="code" href="structstp__lineactive__t.html#o1">v</a>[jj] = 0;
01443                       <span class="keywordflow">if</span> (linecount[0].<a class="code" href="structstp__linecount__t.html#o1">v</a>[jj] != 0)
01444                         <a class="code" href="print-util_8c.html#a18">stp_eprintf</a>(v, <span class="stringliteral">"WARNING: pass %d subpass %d row %d: "</span>
01445                                     <span class="stringliteral">"linecount %d should be zero!\n"</span>,
01446                                     w.<a class="code" href="structstp__weave__t.html#o1">pass</a>, i, row, linecount[0].<a class="code" href="structstp__linecount__t.html#o1">v</a>[jj]);
01447                       linecount[0].<a class="code" href="structstp__linecount__t.html#o1">v</a>[jj] = 0;
01448                       linebounds[0].<a class="code" href="structstp__linebounds__t.html#o1">start_pos</a>[jj] = INT_MAX;
01449                       linebounds[0].<a class="code" href="structstp__linebounds__t.html#o2">end_pos</a>[jj] = -1;
01450                     }
01451                 }
01452 
01453               <span class="keywordflow">if</span>((linecount[0].<a class="code" href="structstp__linecount__t.html#o1">v</a>[j] == 0) &amp;&amp; (w.<a class="code" href="structstp__weave__t.html#o2">jet</a> &gt; 0))
01454                 {
01455                   (sw-&gt;<a class="code" href="structstpi__softweave.html#o34">fillfunc</a>)(v, row, i, width, w.<a class="code" href="structstp__weave__t.html#o2">jet</a>, j);
01456                 }
01457             }
01458         }
01459     }
01460 }
01461 
01462 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01463"></a><a class="code" href="print-weave_8c.html#a43">01463</a> <a class="code" href="print-weave_8c.html#a43">add_to_row</a>(<a class="code" href="structstp__vars.html">stp_vars_t</a> *v, <a class="code" href="structstpi__softweave.html">stpi_softweave_t</a> *sw, <span class="keywordtype">int</span> row, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *buf,
01464            size_t nbytes, <span class="keywordtype">int</span> color, <span class="keywordtype">int</span> setactive, <span class="keywordtype">int</span> h_pass)
01465 {
01466   <span class="keyword">const</span> <a class="code" href="structstp__linebufs__t.html">stp_linebufs_t</a> *bufs =
01467     <a class="code" href="print-weave_8c.html#a29">stpi_get_linebases</a>(v, sw, sw-&gt;<a class="code" href="structstpi__softweave.html#o22">lineno</a>, h_pass, sw-&gt;<a class="code" href="structstpi__softweave.html#o26">head_offset</a>[color]);
01468   <a class="code" href="structstp__lineoff__t.html">stp_lineoff_t</a> *lineoffs =
01469     <a class="code" href="print-weave_8c.html#a26">stpi_get_lineoffsets</a>(v, sw, sw-&gt;<a class="code" href="structstpi__softweave.html#o22">lineno</a>, h_pass, sw-&gt;<a class="code" href="structstpi__softweave.html#o26">head_offset</a>[color]);
01470   <a class="code" href="structstp__lineactive__t.html">stp_lineactive_t</a> *lineactive =
01471     <a class="code" href="print-weave_8c.html#a27">stpi_get_lineactive</a>(v, sw, sw-&gt;<a class="code" href="structstpi__softweave.html#o22">lineno</a>, h_pass, sw-&gt;<a class="code" href="structstpi__softweave.html#o26">head_offset</a>[color]);
01472   <a class="code" href="structstp__linecount__t.html">stp_linecount_t</a> *linecount =
01473     <a class="code" href="print-weave_8c.html#a28">stpi_get_linecount</a>(v, sw, sw-&gt;<a class="code" href="structstpi__softweave.html#o22">lineno</a>, h_pass, sw-&gt;<a class="code" href="structstpi__softweave.html#o26">head_offset</a>[color]);
01474   size_t place = lineoffs[0].<a class="code" href="structstp__lineoff__t.html#o1">v</a>[color];
01475   size_t count = linecount[0].<a class="code" href="structstp__linecount__t.html#o1">v</a>[color];
01476   <span class="keywordflow">if</span> (place + nbytes &gt; sw-&gt;<a class="code" href="structstpi__softweave.html#o9">virtual_jets</a> * sw-&gt;<a class="code" href="structstpi__softweave.html#o21">bitwidth</a> * sw-&gt;<a class="code" href="structstpi__softweave.html#o25">horizontal_width</a>)
01477     {
01478       <a class="code" href="print-util_8c.html#a18">stp_eprintf</a>(v, <span class="stringliteral">"Buffer overflow: limit %d, actual %d, count %d\n"</span>,
01479                   sw-&gt;<a class="code" href="structstpi__softweave.html#o9">virtual_jets</a> * sw-&gt;<a class="code" href="structstpi__softweave.html#o21">bitwidth</a> * sw-&gt;<a class="code" href="structstpi__softweave.html#o25">horizontal_width</a>,
01480                   place + nbytes, count);
01481       <a class="code" href="group__util.html#ga3">stp_abort</a>();
01482     }
01483   memcpy(bufs[0].v[color] + lineoffs[0].v[color], buf, nbytes);
01484   lineoffs[0].v[color] += nbytes;
01485   <span class="keywordflow">if</span> (setactive)
01486     lineactive[0].<a class="code" href="structstp__lineactive__t.html#o1">v</a>[color] = 1;
01487 }
01488 
01489 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01490"></a><a class="code" href="print-weave_8c.html#a44">01490</a> <a class="code" href="print-weave_8c.html#a44">stpi_flush_passes</a>(<a class="code" href="structstp__vars.html">stp_vars_t</a> *v, <span class="keywordtype">int</span> flushall)
01491 {
01492   <a class="code" href="structstpi__softweave.html">stpi_softweave_t</a> *sw =
01493     (<a class="code" href="structstpi__softweave.html">stpi_softweave_t</a> *) <a class="code" href="group__vars.html#ga20">stp_get_component_data</a>(v, <span class="stringliteral">"Weave"</span>);
01494   <span class="keywordflow">while</span> (1)
01495     {
01496       <a class="code" href="structstp__pass__t.html">stp_pass_t</a> *pass = <a class="code" href="print-weave_8c.html#a36">stp_get_pass_by_pass</a>(v, sw-&gt;<a class="code" href="structstpi__softweave.html#o7">last_pass</a> + 1);
01497       <span class="comment">/*</span>
01498 <span class="comment">       * This ought to be   pass-&gt;physpassend &gt;  sw-&gt;lineno</span>
01499 <span class="comment">       * but that causes rubbish to be output for some reason.</span>
01500 <span class="comment">       */</span>
01501       <span class="keywordflow">if</span> (pass-&gt;<a class="code" href="structstp__pass__t.html#o0">pass</a> &lt; 0 || (!flushall &amp;&amp; pass-&gt;<a class="code" href="structstp__pass__t.html#o4">physpassend</a> &gt;= sw-&gt;<a class="code" href="structstpi__softweave.html#o22">lineno</a>))
01502         <span class="keywordflow">return</span>;
01503       (sw-&gt;<a class="code" href="structstpi__softweave.html#o33">flushfunc</a>)(v, pass-&gt;<a class="code" href="structstp__pass__t.html#o0">pass</a>, pass-&gt;<a class="code" href="structstp__pass__t.html#o5">subpass</a>);
01504       sw-&gt;<a class="code" href="structstpi__softweave.html#o7">last_pass</a> = pass-&gt;<a class="code" href="structstp__pass__t.html#o0">pass</a>;
01505       pass-&gt;<a class="code" href="structstp__pass__t.html#o0">pass</a> = -1;
01506     }
01507 }
01508 
01509 <span class="keywordtype">void</span>
<a name="l01510"></a><a class="code" href="print-weave_8c.html#a45">01510</a> <a class="code" href="print-weave_8c.html#a45">stp_flush_all</a>(<a class="code" href="structstp__vars.html">stp_vars_t</a> *v)
01511 {
01512   <a class="code" href="print-weave_8c.html#a44">stpi_flush_passes</a>(v, 1);
01513 }
01514 
01515 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01516"></a><a class="code" href="print-weave_8c.html#a46">01516</a> <a class="code" href="print-weave_8c.html#a46">finalize_row</a>(<a class="code" href="structstp__vars.html">stp_vars_t</a> *v, <span class="keywordtype">int</span> row)
01517 {
01518   <a class="code" href="structstpi__softweave.html">stpi_softweave_t</a> *sw =
01519     (<a class="code" href="structstpi__softweave.html">stpi_softweave_t</a> *) <a class="code" href="group__vars.html#ga20">stp_get_component_data</a>(v, <span class="stringliteral">"Weave"</span>);
01520   <span class="keywordtype">int</span> i,j;
01521   <a class="code" href="print-util_8c.html#a23">stp_dprintf</a>(<a class="code" href="group__util.html#ga40">STP_DBG_ROWS</a>, v, <span class="stringliteral">"Finalizing row %d...\n"</span>, row);
01522   <span class="keywordflow">for</span> (i = 0; i &lt; sw-&gt;<a class="code" href="structstpi__softweave.html#o15">oversample</a>; i++)
01523     {
01524       <a class="code" href="structstp__weave__t.html">stp_weave_t</a> w;
01525       <a class="code" href="structstp__linecount__t.html">stp_linecount_t</a> *lines;
01526 
01527       <span class="keywordflow">for</span>(j=0; j&lt;sw-&gt;<a class="code" href="structstpi__softweave.html#o17">ncolors</a>; j++)
01528         {
01529           lines = <a class="code" href="print-weave_8c.html#a28">stpi_get_linecount</a>(v, sw, row, i, sw-&gt;<a class="code" href="structstpi__softweave.html#o26">head_offset</a>[j]);
01530           lines[0].<a class="code" href="structstp__linecount__t.html#o1">v</a>[j]++;
01531         }
01532 
01533       <a class="code" href="print-weave_8c.html#a24">weave_parameters_by_row</a>(v, sw, row, i, &amp;w);
01534       <span class="keywordflow">if</span> (w.<a class="code" href="structstp__weave__t.html#o6">physpassend</a> == row)
01535         {
01536           <a class="code" href="print-util_8c.html#a23">stp_dprintf</a>(<a class="code" href="group__util.html#ga40">STP_DBG_ROWS</a>, v,
01537                       <span class="stringliteral">"Pass=%d, physpassend=%d, row=%d, lineno=%d, flush..\n"</span>,
01538                       w.<a class="code" href="structstp__weave__t.html#o1">pass</a>, w.<a class="code" href="structstp__weave__t.html#o6">physpassend</a>, row, sw-&gt;<a class="code" href="structstpi__softweave.html#o22">lineno</a>);
01539           <a class="code" href="print-weave_8c.html#a44">stpi_flush_passes</a>(v, 0);
01540         }
01541     }
01542 }
01543 
01544 <span class="keywordtype">void</span>
<a name="l01545"></a><a class="code" href="print-weave_8c.html#a47">01545</a> <a class="code" href="print-weave_8c.html#a47">stp_write_weave</a>(<a class="code" href="structstp__vars.html">stp_vars_t</a> *v, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *<span class="keyword">const</span> cols[])
01546 {
01547   <a class="code" href="structstpi__softweave.html">stpi_softweave_t</a> *sw =
01548     (<a class="code" href="structstpi__softweave.html">stpi_softweave_t</a> *) <a class="code" href="group__vars.html#ga20">stp_get_component_data</a>(v, <span class="stringliteral">"Weave"</span>);
01549   <span class="keywordtype">int</span> length = (sw-&gt;<a class="code" href="structstpi__softweave.html#o18">linewidth</a> + 7) / 8;
01550   <a class="code" href="structstp__lineoff__t.html">stp_lineoff_t</a> *lineoffs[<a class="code" href="weave_8h.html#a0">STP_MAX_WEAVE</a>];
01551   <a class="code" href="structstp__lineactive__t.html">stp_lineactive_t</a> *lineactives[<a class="code" href="weave_8h.html#a0">STP_MAX_WEAVE</a>];
01552   <a class="code" href="structstp__linecount__t.html">stp_linecount_t</a> *linecounts[<a class="code" href="weave_8h.html#a0">STP_MAX_WEAVE</a>];
01553   <a class="code" href="structstp__linebounds__t.html">stp_linebounds_t</a> *linebounds[<a class="code" href="weave_8h.html#a0">STP_MAX_WEAVE</a>];
01554   <span class="keyword">const</span> <a class="code" href="structstp__linebufs__t.html">stp_linebufs_t</a> *bufs[<a class="code" href="weave_8h.html#a0">STP_MAX_WEAVE</a>];
01555   <span class="keywordtype">int</span> xlength = (length + sw-&gt;<a class="code" href="structstpi__softweave.html#o12">horizontal_weave</a> - 1) / sw-&gt;<a class="code" href="structstpi__softweave.html#o12">horizontal_weave</a>;
01556   <span class="keywordtype">int</span> ylength = xlength * sw-&gt;<a class="code" href="structstpi__softweave.html#o12">horizontal_weave</a>;
01557   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *comp_ptr;
01558   <span class="keywordtype">int</span> i, j;
01559   <span class="keywordtype">int</span> setactive;
01560   <span class="keywordtype">int</span> h_passes = sw-&gt;<a class="code" href="structstpi__softweave.html#o12">horizontal_weave</a> * sw-&gt;<a class="code" href="structstpi__softweave.html#o13">vertical_subpasses</a>;
01561   <span class="keywordtype">int</span> cpass = sw-&gt;<a class="code" href="structstpi__softweave.html#o24">current_vertical_subpass</a> * h_passes;
01562 
01563   <span class="keywordflow">if</span> (!sw-&gt;<a class="code" href="structstpi__softweave.html#o28">fold_buf</a>)
01564     sw-&gt;<a class="code" href="structstpi__softweave.html#o28">fold_buf</a> = <a class="code" href="group__util.html#ga29">stp_zalloc</a>(sw-&gt;<a class="code" href="structstpi__softweave.html#o21">bitwidth</a> * ylength);
01565   <span class="keywordflow">if</span> (!sw-&gt;<a class="code" href="structstpi__softweave.html#o29">comp_buf</a>)
01566     sw-&gt;<a class="code" href="structstpi__softweave.html#o29">comp_buf</a> = <a class="code" href="group__util.html#ga29">stp_zalloc</a>(sw-&gt;<a class="code" href="structstpi__softweave.html#o21">bitwidth</a> *
01567                                (sw-&gt;<a class="code" href="structstpi__softweave.html#o36">compute_linewidth</a>)(v,ylength));
01568   <span class="keywordflow">if</span> (sw-&gt;<a class="code" href="structstpi__softweave.html#o24">current_vertical_subpass</a> == 0)
01569     <a class="code" href="print-weave_8c.html#a42">initialize_row</a>(v, sw, sw-&gt;<a class="code" href="structstpi__softweave.html#o22">lineno</a>, xlength, cols);
01570 
01571   <span class="keywordflow">for</span> (j = 0; j &lt; sw-&gt;<a class="code" href="structstpi__softweave.html#o17">ncolors</a>; j++)
01572     {
01573       <span class="keywordflow">if</span> (cols[j])
01574         {
01575           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *in;
01576           <span class="keywordtype">int</span> idx;
01577 
01578           <span class="keywordflow">for</span> (i = 0; i &lt; h_passes; i++)
01579             {
01580               <span class="keywordtype">int</span> offset = sw-&gt;<a class="code" href="structstpi__softweave.html#o26">head_offset</a>[j];
01581               <span class="keywordtype">int</span> pass = cpass + i;
01582               <span class="keywordflow">if</span> (!sw-&gt;<a class="code" href="structstpi__softweave.html#o27">s</a>[i])
01583                 sw-&gt;<a class="code" href="structstpi__softweave.html#o27">s</a>[i] = <a class="code" href="group__util.html#ga29">stp_zalloc</a>(sw-&gt;<a class="code" href="structstpi__softweave.html#o21">bitwidth</a> *
01584                                       (sw-&gt;<a class="code" href="structstpi__softweave.html#o36">compute_linewidth</a>)(v, ylength));
01585               lineoffs[i] =
01586                 <a class="code" href="print-weave_8c.html#a26">stpi_get_lineoffsets</a>(v, sw, sw-&gt;<a class="code" href="structstpi__softweave.html#o22">lineno</a>, pass, offset);
01587               linecounts[i] =
01588                 <a class="code" href="print-weave_8c.html#a28">stpi_get_linecount</a>(v, sw, sw-&gt;<a class="code" href="structstpi__softweave.html#o22">lineno</a>, pass, offset);
01589               lineactives[i] =
01590                 <a class="code" href="print-weave_8c.html#a27">stpi_get_lineactive</a>(v, sw, sw-&gt;<a class="code" href="structstpi__softweave.html#o22">lineno</a>, pass,offset);
01591               linebounds[i] =
01592                 <a class="code" href="print-weave_8c.html#a30">stpi_get_linebounds</a>(v, sw, sw-&gt;<a class="code" href="structstpi__softweave.html#o22">lineno</a>, pass, offset);
01593               bufs[i] =
01594                 <a class="code" href="print-weave_8c.html#a29">stpi_get_linebases</a>(v, sw, sw-&gt;<a class="code" href="structstpi__softweave.html#o22">lineno</a>, pass, offset);
01595             }
01596 
01597           <span class="keywordflow">if</span> (sw-&gt;<a class="code" href="structstpi__softweave.html#o21">bitwidth</a> == 2)
01598             {
01599               <a class="code" href="bit-ops_8c.html#a6">stp_fold</a>(cols[j], length, sw-&gt;<a class="code" href="structstpi__softweave.html#o28">fold_buf</a>);
01600               in = sw-&gt;<a class="code" href="structstpi__softweave.html#o28">fold_buf</a>;
01601             }
01602           <span class="keywordflow">else</span>
01603             in = cols[j];
01604           <span class="keywordflow">switch</span> (sw-&gt;<a class="code" href="structstpi__softweave.html#o12">horizontal_weave</a>)
01605             {
01606             <span class="keywordflow">case</span> 1:
01607               memcpy(sw-&gt;<a class="code" href="structstpi__softweave.html#o27">s</a>[0], in, length * sw-&gt;<a class="code" href="structstpi__softweave.html#o21">bitwidth</a>);
01608               <span class="keywordflow">break</span>;
01609             <span class="keywordflow">case</span> 2:
01610               <a class="code" href="bit-ops_8c.html#a15">stp_unpack_2</a>(length, sw-&gt;<a class="code" href="structstpi__softweave.html#o21">bitwidth</a>, in, sw-&gt;<a class="code" href="structstpi__softweave.html#o27">s</a>[0], sw-&gt;<a class="code" href="structstpi__softweave.html#o27">s</a>[1]);
01611               <span class="keywordflow">break</span>;
01612             <span class="keywordflow">case</span> 4:
01613               <a class="code" href="bit-ops_8c.html#a18">stp_unpack_4</a>(length, sw-&gt;<a class="code" href="structstpi__softweave.html#o21">bitwidth</a>, in,
01614                            sw-&gt;<a class="code" href="structstpi__softweave.html#o27">s</a>[0], sw-&gt;<a class="code" href="structstpi__softweave.html#o27">s</a>[1], sw-&gt;<a class="code" href="structstpi__softweave.html#o27">s</a>[2], sw-&gt;<a class="code" href="structstpi__softweave.html#o27">s</a>[3]);
01615               <span class="keywordflow">break</span>;
01616             <span class="keywordflow">case</span> 8:
01617               <a class="code" href="bit-ops_8c.html#a21">stp_unpack_8</a>(length, sw-&gt;<a class="code" href="structstpi__softweave.html#o21">bitwidth</a>, in,
01618                            sw-&gt;<a class="code" href="structstpi__softweave.html#o27">s</a>[0], sw-&gt;<a class="code" href="structstpi__softweave.html#o27">s</a>[1], sw-&gt;<a class="code" href="structstpi__softweave.html#o27">s</a>[2], sw-&gt;<a class="code" href="structstpi__softweave.html#o27">s</a>[3],
01619                            sw-&gt;<a class="code" href="structstpi__softweave.html#o27">s</a>[4], sw-&gt;<a class="code" href="structstpi__softweave.html#o27">s</a>[5], sw-&gt;<a class="code" href="structstpi__softweave.html#o27">s</a>[6], sw-&gt;<a class="code" href="structstpi__softweave.html#o27">s</a>[7]);
01620               <span class="keywordflow">break</span>;
01621             }
01622           <span class="keywordflow">switch</span> (sw-&gt;<a class="code" href="structstpi__softweave.html#o13">vertical_subpasses</a>)
01623             {
01624             <span class="keywordflow">case</span> 4:
01625               <span class="keywordflow">for</span> (idx = 0; idx &lt; sw-&gt;<a class="code" href="structstpi__softweave.html#o12">horizontal_weave</a>; idx++)
01626                 <a class="code" href="bit-ops_8c.html#a12">stp_split_4</a>(length, sw-&gt;<a class="code" href="structstpi__softweave.html#o21">bitwidth</a>, sw-&gt;<a class="code" href="structstpi__softweave.html#o27">s</a>[idx], sw-&gt;<a class="code" href="structstpi__softweave.html#o27">s</a>[idx],
01627                             sw-&gt;<a class="code" href="structstpi__softweave.html#o27">s</a>[idx + sw-&gt;<a class="code" href="structstpi__softweave.html#o12">horizontal_weave</a>],
01628                             sw-&gt;<a class="code" href="structstpi__softweave.html#o27">s</a>[idx + sw-&gt;<a class="code" href="structstpi__softweave.html#o12">horizontal_weave</a> * 2],
01629                             sw-&gt;<a class="code" href="structstpi__softweave.html#o27">s</a>[idx + sw-&gt;<a class="code" href="structstpi__softweave.html#o12">horizontal_weave</a> * 3]);
01630               <span class="keywordflow">break</span>;
01631             <span class="keywordflow">case</span> 2:
01632               <span class="keywordflow">for</span> (idx = 0; idx &lt; sw-&gt;<a class="code" href="structstpi__softweave.html#o12">horizontal_weave</a>; idx++)
01633                 <a class="code" href="bit-ops_8c.html#a9">stp_split_2</a>(length, sw-&gt;<a class="code" href="structstpi__softweave.html#o21">bitwidth</a>, sw-&gt;<a class="code" href="structstpi__softweave.html#o27">s</a>[idx], sw-&gt;<a class="code" href="structstpi__softweave.html#o27">s</a>[idx],
01634                             sw-&gt;<a class="code" href="structstpi__softweave.html#o27">s</a>[idx + sw-&gt;<a class="code" href="structstpi__softweave.html#o12">horizontal_weave</a>]);
01635               <span class="keywordflow">break</span>;
01636               <span class="comment">/* case 1 is taken care of because the various unpack */</span>
01637               <span class="comment">/* functions will do the trick themselves */</span>
01638             }
01639           <span class="keywordflow">for</span> (i = 0; i &lt; h_passes; i++)
01640             {
01641               <span class="keywordtype">int</span> first, last;
01642               setactive = (sw-&gt;<a class="code" href="structstpi__softweave.html#o35">pack</a>)(v, sw-&gt;<a class="code" href="structstpi__softweave.html#o27">s</a>[i], sw-&gt;<a class="code" href="structstpi__softweave.html#o21">bitwidth</a> * xlength,
01643                                      sw-&gt;<a class="code" href="structstpi__softweave.html#o29">comp_buf</a>, &amp;comp_ptr, &amp;first, &amp;last);
01644               <span class="keywordflow">if</span> (first &lt; linebounds[i]-&gt;<a class="code" href="structstp__linebounds__t.html#o1">start_pos</a>[j])
01645                 linebounds[i]-&gt;start_pos[j] = first;
01646               <span class="keywordflow">if</span> (last &gt; linebounds[i]-&gt;end_pos[j])
01647                 linebounds[i]-&gt;end_pos[j] = last;
01648               <a class="code" href="print-weave_8c.html#a43">add_to_row</a>(v, sw, sw-&gt;<a class="code" href="structstpi__softweave.html#o22">lineno</a>, sw-&gt;<a class="code" href="structstpi__softweave.html#o29">comp_buf</a>,
01649                          comp_ptr - sw-&gt;<a class="code" href="structstpi__softweave.html#o29">comp_buf</a>, j, setactive, cpass + i);
01650             }
01651         }
01652     }
01653   sw-&gt;<a class="code" href="structstpi__softweave.html#o24">current_vertical_subpass</a>++;
01654   <span class="keywordflow">if</span> (sw-&gt;<a class="code" href="structstpi__softweave.html#o24">current_vertical_subpass</a> &gt;= sw-&gt;<a class="code" href="structstpi__softweave.html#o23">vertical_oversample</a>)
01655     {
01656       <a class="code" href="print-weave_8c.html#a46">finalize_row</a>(v, sw-&gt;<a class="code" href="structstpi__softweave.html#o22">lineno</a>);
01657       sw-&gt;<a class="code" href="structstpi__softweave.html#o22">lineno</a>++;
01658       sw-&gt;<a class="code" href="structstpi__softweave.html#o24">current_vertical_subpass</a> = 0;
01659     }
01660 }
01661 
01662 <span class="preprocessor">#if 0</span>
01663 <span class="preprocessor"></span><span class="preprocessor">#define TEST_RAW</span>
01664 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
01665 <span class="preprocessor"></span><span class="preprocessor">#if 0</span>
01666 <span class="preprocessor"></span><span class="preprocessor">#define TEST_COOKED</span>
01667 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
01668 <span class="preprocessor"></span><span class="preprocessor">#if 0</span>
01669 <span class="preprocessor"></span><span class="preprocessor">#define ACCUMULATE</span>
01670 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
01671 <span class="preprocessor"></span>
01672 <span class="preprocessor">#if defined(TEST_RAW) || defined(TEST_COOKED)</span>
01673 <span class="preprocessor"></span><span class="preprocessor">#define TEST</span>
01674 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
01675 <span class="preprocessor"></span>
01676 <span class="preprocessor">#ifdef TEST</span>
01677 <span class="preprocessor"></span><span class="preprocessor">#define MAXCOLLECT (1000)</span>
01678 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
01679 <span class="preprocessor"></span>
01680 <span class="preprocessor">#ifdef TEST_COOKED</span>
01681 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span>
01682 calculate_pass_parameters(<a class="code" href="structcooked.html">cooked_t</a> *w,          <span class="comment">/* I - weave parameters */</span>
01683                           <span class="keywordtype">int</span> pass,             <span class="comment">/* I - pass number ( &gt;= 0) */</span>
01684                           <span class="keywordtype">int</span> *startrow,        <span class="comment">/* O - print head position */</span>
01685                           <span class="keywordtype">int</span> *subpass,         <span class="comment">/* O - subpass number */</span>
01686                           <span class="keywordtype">int</span> *phantomrows,     <span class="comment">/* O - missing rows */</span>
01687                           <span class="keywordtype">int</span> *jetsused)        <span class="comment">/* O - jets used to print */</span>
01688 {
01689         <span class="keywordtype">int</span> raw_pass = pass + w-&gt;<a class="code" href="structcooked.html#o3">first_premapped_pass</a>;
01690         <span class="keywordtype">int</span> stagger = 0;
01691         <span class="keywordtype">int</span> extra;
01692 
01693         <span class="keywordflow">if</span> (raw_pass &lt; w-&gt;<a class="code" href="structcooked.html#o4">first_normal_pass</a>) {
01694                 <span class="keywordtype">int</span> i = 0;
01695                 <span class="keywordflow">while</span> (i + w-&gt;<a class="code" href="structcooked.html#o3">first_premapped_pass</a> &lt; w-&gt;<a class="code" href="structcooked.html#o4">first_normal_pass</a>) {
01696                         <span class="keywordflow">if</span> (w-&gt;<a class="code" href="structcooked.html#o7">pass_premap</a>[i] == pass) {
01697                                 raw_pass = i + w-&gt;<a class="code" href="structcooked.html#o3">first_premapped_pass</a>;
01698                                 stagger = w-&gt;<a class="code" href="structcooked.html#o8">stagger_premap</a>[i];
01699                                 <span class="keywordflow">break</span>;
01700                         }
01701                         i++;
01702                 }
01703         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (raw_pass &gt;= w-&gt;<a class="code" href="structcooked.html#o5">first_postmapped_pass</a>) {
01704                 <span class="keywordtype">int</span> i = 0;
01705                 <span class="keywordflow">while</span> (i + w-&gt;<a class="code" href="structcooked.html#o5">first_postmapped_pass</a> &lt; w-&gt;<a class="code" href="structcooked.html#o6">first_unused_pass</a>) {
01706                         <span class="keywordflow">if</span> (w-&gt;<a class="code" href="structcooked.html#o9">pass_postmap</a>[i] == pass) {
01707                                 raw_pass = i + w-&gt;<a class="code" href="structcooked.html#o5">first_postmapped_pass</a>;
01708                                 stagger = w-&gt;<a class="code" href="structcooked.html#o10">stagger_postmap</a>[i];
01709                                 <span class="keywordflow">break</span>;
01710                         }
01711                         i++;
01712                 }
01713         }
01714 
01715         <a class="code" href="print-weave_8c.html#a7">calculate_raw_pass_parameters</a>(&amp;w-&gt;<a class="code" href="structcooked.html#o0">rw</a>, raw_pass, startrow, subpass);
01716         *startrow -= w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o0">separation</a> * w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o1">jets</a>;
01717         *jetsused = w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o1">jets</a>;
01718         *phantomrows = 0;
01719 
01720         *startrow += stagger * w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o0">separation</a>;
01721         <span class="keywordflow">if</span> (stagger &lt; 0) {
01722                 stagger = -stagger;
01723                 *phantomrows += stagger;
01724         }
01725         *jetsused -= stagger;
01726 
01727         extra = w-&gt;<a class="code" href="structcooked.html#o1">first_row_printed</a> - (*startrow + w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o0">separation</a> * *phantomrows);
01728         extra = (extra + w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o0">separation</a> - 1) / w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o0">separation</a>;
01729         <span class="keywordflow">if</span> (extra &gt; 0) {
01730                 *jetsused -= extra;
01731                 *phantomrows += extra;
01732         }
01733 
01734         extra = *startrow + w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o0">separation</a> * (*phantomrows + *jetsused - 1)
01735                   - w-&gt;<a class="code" href="structcooked.html#o2">last_row_printed</a>;
01736         extra = (extra + w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o0">separation</a> - 1) / w-&gt;<a class="code" href="structcooked.html#o0">rw</a>.<a class="code" href="structraw.html#o0">separation</a>;
01737         <span class="keywordflow">if</span> (extra &gt; 0) {
01738                 *jetsused -= extra;
01739         }
01740 }
01741 <span class="preprocessor">#endif </span><span class="comment">/* TEST_COOKED */</span>
01742 
01743 <span class="preprocessor">#ifdef TEST</span>
01744 <span class="preprocessor"></span>
01745 <span class="preprocessor">#ifdef ACCUMULATE</span>
01746 <span class="preprocessor"></span><span class="preprocessor">#define PUTCHAR(x) </span><span class="comment">/* nothing */</span>
01747 <span class="preprocessor">#else</span>
01748 <span class="preprocessor"></span><span class="preprocessor">#define PUTCHAR(x) putchar(x)</span>
01749 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
01750 <span class="preprocessor"></span>
01751 <span class="keyword">static</span> <span class="keywordtype">void</span>
01752 plotpass(<span class="keywordtype">int</span> startrow, <span class="keywordtype">int</span> phantomjets, <span class="keywordtype">int</span> jetsused, <span class="keywordtype">int</span> totaljets,
01753          <span class="keywordtype">int</span> separation, <span class="keywordtype">int</span> subpass, <span class="keywordtype">int</span> *collect, <span class="keywordtype">int</span> *prints)
01754 {
01755         <span class="keywordtype">int</span> hpos, i;
01756 
01757         <span class="keywordflow">for</span> (hpos = 0; hpos &lt; startrow; hpos++)
01758                 PUTCHAR(<span class="charliteral">' '</span>);
01759 
01760         <span class="keywordflow">for</span> (i = 0; i &lt; phantomjets; i++) {
01761                 <span class="keywordtype">int</span> j;
01762                 PUTCHAR(<span class="charliteral">'X'</span>);
01763                 hpos++;
01764                 <span class="keywordflow">for</span> (j = 1; j &lt; separation; j++) {
01765                         PUTCHAR(<span class="charliteral">' '</span>);
01766                         hpos++;
01767                 }
01768         }
01769 
01770         <span class="keywordflow">for</span> (; i &lt; phantomjets + jetsused; i++) {
01771                 <span class="keywordflow">if</span> (i &gt; phantomjets) {
01772                         <span class="keywordtype">int</span> j;
01773                         <span class="keywordflow">for</span> (j = 1; j &lt; separation; j++) {
01774                                 PUTCHAR(<span class="charliteral">'-'</span>);
01775                                 hpos++;
01776                         }
01777                 }
01778                 <span class="keywordflow">if</span> (hpos &lt; MAXCOLLECT) {
01779                         <span class="keywordflow">if</span> (collect[hpos] &amp; 1 &lt;&lt; subpass)
01780                                 PUTCHAR(<span class="charliteral">'^'</span>);
01781                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (subpass &lt; 10)
01782                                 PUTCHAR(<span class="charliteral">'0'</span> + subpass);
01783                         <span class="keywordflow">else</span>
01784                                 PUTCHAR(<span class="charliteral">'A'</span> + subpass - 10);
01785                         collect[hpos] |= 1 &lt;&lt; subpass;
01786                         prints[hpos]++;
01787                 } <span class="keywordflow">else</span> {
01788                         PUTCHAR(<span class="charliteral">'0'</span> + subpass);
01789                 }
01790                 hpos++;
01791         }
01792 
01793         <span class="keywordflow">while</span> (i++ &lt; totaljets) {
01794                 <span class="keywordtype">int</span> j;
01795                 <span class="keywordflow">for</span> (j = 1; j &lt; separation; j++) {
01796                         PUTCHAR(<span class="charliteral">' '</span>);
01797                         hpos++;
01798                 }
01799                 PUTCHAR(<span class="charliteral">'X'</span>);
01800         }
01801 <span class="preprocessor">#ifdef ACCUMULATE</span>
01802 <span class="preprocessor"></span>        <span class="keywordflow">for</span> (i=0; i&lt;=MAXCOLLECT; i++) {
01803                 <span class="keywordflow">if</span> (collect[i] == 0)
01804                         putchar(<span class="charliteral">' '</span>);
01805                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (collect[i] &lt; 10)
01806                         putchar(<span class="charliteral">'0'</span>+collect[i]);
01807                 <span class="keywordflow">else</span>
01808                         putchar(<span class="charliteral">'A'</span>+collect[i]-10);
01809         }
01810 <span class="preprocessor">#endif</span>
01811 <span class="preprocessor"></span>        putchar(<span class="charliteral">'\n'</span>);
01812 }
01813 <span class="preprocessor">#endif </span><span class="comment">/* TEST */</span>
01814 
01815 <span class="preprocessor">#ifdef TEST_COOKED</span>
01816 <span class="preprocessor"></span><span class="keywordtype">int</span>
01817 main(<span class="keywordtype">int</span> ac, <span class="keywordtype">char</span> *av[])
01818 {
01819         <span class="keywordtype">int</span> S         =ac&gt;1 ? atoi(av[1]) : 4;
01820         <span class="keywordtype">int</span> J         =ac&gt;2 ? atoi(av[2]) : 12;
01821         <span class="keywordtype">int</span> H         =ac&gt;3 ? atoi(av[3]) : 1;
01822         <span class="keywordtype">int</span> firstrow  =ac&gt;4 ? atoi(av[4]) : 1;
01823         <span class="keywordtype">int</span> lastrow   =ac&gt;5 ? atoi(av[5]) : 100;
01824         <span class="keywordtype">int</span> pageheight=ac&gt;6 ? atoi(av[6]) : 1000;
01825         <a class="code" href="weave_8h.html#a26">stp_weave_strategy_t</a> strategy  =ac&gt;7 ? atoi(av[7]) : 1;
01826         <a class="code" href="structcooked.html">cooked_t</a> *weave;
01827         <span class="keywordtype">int</span> passes;
01828 
01829         <span class="keywordtype">int</span> pass, x;
01830         <span class="keywordtype">int</span> collect[MAXCOLLECT];
01831         <span class="keywordtype">int</span> prints[MAXCOLLECT];
01832 
01833         memset(collect, 0, MAXCOLLECT*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
01834         memset(prints, 0, MAXCOLLECT*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
01835         printf(<span class="stringliteral">"S=%d  J=%d  H=%d  firstrow=%d  lastrow=%d  "</span>
01836                <span class="stringliteral">"pageheight=%d  strategy=%d\n"</span>,
01837                S, J, H, firstrow, lastrow, pageheight, strategy);
01838 
01839         weave = <a class="code" href="print-weave_8c.html#a14">initialize_weave_params</a>(S, J, H, firstrow, lastrow,
01840                                         pageheight, strategy);
01841         passes = weave-&gt;<a class="code" href="structcooked.html#o6">first_unused_pass</a> - weave-&gt;<a class="code" href="structcooked.html#o3">first_premapped_pass</a>;
01842 
01843         <span class="keywordflow">for</span> (pass = 0; pass &lt; passes; pass++) {
01844                 <span class="keywordtype">int</span> startrow, subpass, phantomjets, jetsused;
01845 
01846                 calculate_pass_parameters(weave, pass, &amp;startrow, &amp;subpass,
01847                                           &amp;phantomjets, &amp;jetsused);
01848 
01849                 plotpass(startrow, phantomjets, jetsused, J, S, subpass,
01850                          collect, prints);
01851         }
01852 
01853         <span class="keywordflow">for</span> (pass=MAXCOLLECT - 1; prints[pass] == 0; pass--)
01854                 ;
01855 
01856         <span class="keywordflow">for</span> (x=0; x&lt;=pass; x++) {
01857                 <span class="keywordflow">if</span> (collect[x] &lt; 10)
01858                         putchar(<span class="charliteral">'0'</span>+collect[x]);
01859                 <span class="keywordflow">else</span>
01860                         putchar(<span class="charliteral">'A'</span>+collect[x]-10);
01861         }
01862         putchar(<span class="charliteral">'\n'</span>);
01863 
01864         <span class="keywordflow">for</span> (x=0; x&lt;=pass; x++) {
01865                 <span class="keywordflow">if</span> (prints[x] &lt; 10)
01866                         putchar(<span class="charliteral">'0'</span>+prints[x]);
01867                 <span class="keywordflow">else</span>
01868                         putchar(<span class="charliteral">'A'</span>+prints[x]-10);
01869         }
01870         putchar(<span class="charliteral">'\n'</span>);
01871 
01872         <span class="keywordflow">return</span> 0;
01873 }
01874 <span class="preprocessor">#endif </span><span class="comment">/* TEST_COOKED */</span>
01875 
01876 <span class="preprocessor">#ifdef TEST_RAW</span>
01877 <span class="preprocessor"></span><span class="keywordtype">int</span>
01878 main(<span class="keywordtype">int</span> ac, <span class="keywordtype">char</span> *av[])
01879 {
01880         <span class="keywordtype">int</span> S     =ac&gt;1 ? atoi(av[1]) : 4;
01881         <span class="keywordtype">int</span> J     =ac&gt;2 ? atoi(av[2]) : 12;
01882         <span class="keywordtype">int</span> h_pos =ac&gt;3 ? atoi(av[3]) : 1;
01883         <span class="keywordtype">int</span> h_over=ac&gt;4 ? atoi(av[4]) : 1;
01884         <span class="keywordtype">int</span> v_over=ac&gt;5 ? atoi(av[5]) : 1;
01885         <span class="keywordtype">int</span> H = h_pos * h_over * v_over;
01886 
01887         <span class="keywordtype">int</span> pass, passes, x;
01888         <span class="keywordtype">int</span> collect[MAXCOLLECT];
01889         <span class="keywordtype">int</span> prints[MAXCOLLECT];
01890         <a class="code" href="structraw.html">raw_t</a> <a class="code" href="structraw.html">raw</a>;
01891 
01892         memset(collect, 0, MAXCOLLECT*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
01893         memset(prints, 0, MAXCOLLECT*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
01894         printf(<span class="stringliteral">"S=%d  J=%d  H=%d\n"</span>, S, J, H);
01895 
01896         <span class="keywordflow">if</span> (H &gt; J) {
01897                 printf(<span class="stringliteral">"H &gt; J, so this weave will not work!\n"</span>);
01898         }
01899         passes = S * H * 3;
01900 
01901         <a class="code" href="print-weave_8c.html#a6">initialize_raw_weave</a>(&amp;raw, S, J, H);
01902 
01903         <span class="keywordflow">for</span> (pass=0; pass&lt;passes + S * H; pass++) {
01904                 <span class="keywordtype">int</span> startrow, subpass, phantomjets, jetsused;
01905 
01906                 <a class="code" href="print-weave_8c.html#a7">calculate_raw_pass_parameters</a>(&amp;raw, pass, &amp;startrow, &amp;subpass);
01907                 phantomjets = 0;
01908                 jetsused = J;
01909 
01910                 plotpass(startrow, phantomjets, jetsused, J, S, subpass,
01911                          collect, prints);
01912         }
01913         <span class="keywordflow">for</span> (pass=MAXCOLLECT - 1; prints[pass] == 0; pass--)
01914                 ;
01915 
01916         <span class="keywordflow">for</span> (x=0; x&lt;=pass; x++) {
01917                 <span class="keywordflow">if</span> (collect[x] &lt; 10)
01918                         putchar(<span class="charliteral">'0'</span>+collect[x]);
01919                 <span class="keywordflow">else</span>
01920                         putchar(<span class="charliteral">'A'</span>+collect[x]-10);
01921         }
01922         putchar(<span class="charliteral">'\n'</span>);
01923 
01924         <span class="keywordflow">for</span> (x=0; x&lt;=pass; x++) {
01925                 <span class="keywordflow">if</span> (prints[x] &lt; 10)
01926                         putchar(<span class="charliteral">'0'</span>+prints[x]);
01927                 <span class="keywordflow">else</span>
01928                         putchar(<span class="charliteral">'A'</span>+prints[x]-10);
01929         }
01930         putchar(<span class="charliteral">'\n'</span>);
01931 
01932         printf(<span class="stringliteral">"  A  first row given by pass lookup doesn't match row lookup\n"</span>
01933                <span class="stringliteral">"  B  jet out of range\n"</span>
01934                <span class="stringliteral">"  C  given jet number of pass doesn't print this row\n"</span>
01935                <span class="stringliteral">"  D  subpass given by reverse lookup doesn't match requested subpass\n"</span>);
01936 
01937         <span class="keywordflow">for</span> (x = S * J; x &lt; S * J * 20; x++) {
01938                 <span class="keywordtype">int</span> h;
01939                 <span class="keywordflow">for</span> (h = 0; h &lt; H; h++) {
01940                         <span class="keywordtype">int</span> pass, jet, start, first, subpass, z;
01941                         <span class="keywordtype">int</span> a=0, b=0, c=0, d=0;
01942                         <a class="code" href="print-weave_8c.html#a8">calculate_raw_row_parameters</a>(&amp;raw, x, h, &amp;pass, &amp;jet, &amp;start);
01943                         <span class="keywordflow">for</span> (z=0; z &lt; pass; z++) {
01944                                 putchar(<span class="charliteral">' '</span>);
01945                         }
01946                         printf(<span class="stringliteral">"%d"</span>, jet);
01947                         <a class="code" href="print-weave_8c.html#a7">calculate_raw_pass_parameters</a>(&amp;raw, pass, &amp;first, &amp;subpass);
01948                         <span class="keywordflow">if</span> (first != start)
01949                                 a=1;
01950                         <span class="keywordflow">if</span> (jet &lt; 0 || jet &gt;= J)
01951                                 b=1;
01952                         <span class="keywordflow">if</span> (x != first + jet * S)
01953                                 c=1;
01954                         <span class="keywordflow">if</span> (subpass != h)
01955                                 d=1;
01956                         <span class="keywordflow">if</span> (a || b || c || d) {
01957                                 printf(<span class="stringliteral">"    ("</span>);
01958                                 <span class="keywordflow">if</span> (a) putchar(<span class="charliteral">'A'</span>);
01959                                 <span class="keywordflow">if</span> (b) putchar(<span class="charliteral">'B'</span>);
01960                                 <span class="keywordflow">if</span> (c) putchar(<span class="charliteral">'C'</span>);
01961                                 <span class="keywordflow">if</span> (d) putchar(<span class="charliteral">'D'</span>);
01962                                 putchar(<span class="charliteral">')'</span>);
01963                                 printf(<span class="stringliteral">"\npass=%d first=%d start=%d jet=%d subpass=%d"</span>, pass, first, start, jet, subpass);
01964                         }
01965                         putchar(<span class="charliteral">'\n'</span>);
01966                 }
01967                 <span class="comment">/* putchar('\n'); */</span>
01968         }
01969 
01970         <span class="keywordflow">return</span> 0;
01971 }
01972 
01973 <span class="preprocessor">#endif </span><span class="comment">/* TEST_RAW */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Aug 25 07:56:14 2004 for libgimpprint API Reference by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > </a>1.3.6 </small></address>
</body>
</html>
