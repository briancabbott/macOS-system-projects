<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libgimpprint API Reference: src/main/path.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>src/main/path.c</h1><a href="path_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * "$Id: path_8c-source.html,v 1.1.1.2 2004/12/22 23:49:05 jlovell Exp $"</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> *   libgimpprint path functions - split and search paths.</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> *   Copyright 2002 Roger Leigh (rleigh@debian.org)</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> *   This program is free software; you can redistribute it and/or modify it</span>
00009 <span class="comment"> *   under the terms of the GNU General Public License as published by the Free</span>
00010 <span class="comment"> *   Software Foundation; either version 2 of the License, or (at your option)</span>
00011 <span class="comment"> *   any later version.</span>
00012 <span class="comment"> *</span>
00013 <span class="comment"> *   This program is distributed in the hope that it will be useful, but</span>
00014 <span class="comment"> *   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY</span>
00015 <span class="comment"> *   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</span>
00016 <span class="comment"> *   for more details.</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> *   You should have received a copy of the GNU General Public License</span>
00019 <span class="comment"> *   along with this program; if not, write to the Free Software</span>
00020 <span class="comment"> *   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
00021 <span class="comment"> */</span>
00022 
00023 <span class="preprocessor">#include &lt;<a class="code" href="gimp-print_8h.html">gimp-print/gimp-print.h</a>&gt;</span>
00024 <span class="preprocessor">#include "<a class="code" href="gimp-print-internal_8h.html">gimp-print-internal.h</a>"</span>
00025 <span class="preprocessor">#include &lt;<a class="code" href="gimp-print-intl-internal_8h.html">gimp-print/gimp-print-intl-internal.h</a>&gt;</span>
00026 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00027 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00028 <span class="preprocessor">#include &lt;string.h&gt;</span>
00029 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00030 <span class="preprocessor">#include &lt;dirent.h&gt;</span>
00031 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00032 <span class="preprocessor">#include &lt;sys/stat.h&gt;</span>
00033 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00034 
00035 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="path_8c.html#a4">stpi_path_check</a>(<span class="keyword">const</span> <span class="keyword">struct</span> dirent *module);
00036 <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="path_8c.html#a5">stpi_path_merge</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *path,
00037                              <span class="keyword">const</span> <span class="keywordtype">char</span> *file);
00038 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="path_8c.html#a6">stpi_scandir</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *dir,
00039                          <span class="keyword">struct</span> dirent ***namelist,
00040                          <span class="keywordtype">int</span> (*sel) (<span class="keyword">const</span> <span class="keyword">struct</span> dirent *),
00041                          <span class="keywordtype">int</span> (*cmp) (<span class="keyword">const</span> <span class="keywordtype">void</span> *, <span class="keyword">const</span> <span class="keywordtype">void</span> *));
00042 
00043 <span class="comment">/* WARNING: This is not thread safe! -- rlk 20030721 */</span>
<a name="l00044"></a><a class="code" href="path_8c.html#a2">00044</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="path_8c.html#a2">path_check_path</a>;   <span class="comment">/* Path for stpi_scandir() callback */</span>
<a name="l00045"></a><a class="code" href="path_8c.html#a3">00045</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="path_8c.html#a3">path_check_suffix</a>; <span class="comment">/* Suffix for stpi_scandir() callback */</span>
00046 
00047 
00048 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00049"></a><a class="code" href="path_8c.html#a7">00049</a> <a class="code" href="path_8c.html#a7">dirent_sort</a>(<span class="keyword">const</span> <span class="keywordtype">void</span> *a,
00050             <span class="keyword">const</span> <span class="keywordtype">void</span> *b)
00051 {
00052   <span class="keywordflow">return</span> strcoll ((*(<span class="keyword">const</span> <span class="keyword">struct</span> dirent **) a)-&gt;d_name,
00053                   (*(<span class="keyword">const</span> <span class="keyword">struct</span> dirent **) b)-&gt;d_name);
00054 }
00055 
00056 
00057 <span class="comment">/*</span>
00058 <span class="comment"> * Make a list of all modules in the search path.</span>
00059 <span class="comment"> */</span>
00060 <a class="code" href="structstp__list.html">stp_list_t</a> *
<a name="l00061"></a><a class="code" href="path_8c.html#a8">00061</a> <a class="code" href="path_8c.html#a8">stp_path_search</a>(<a class="code" href="structstp__list.html">stp_list_t</a> *dirlist, <span class="comment">/* List of directories to search */</span>
00062                 <span class="keyword">const</span> <span class="keywordtype">char</span> *suffix)  <span class="comment">/* Required filename suffix */</span>
00063 {
00064   <a class="code" href="structstp__list.html">stp_list_t</a> *findlist;              <span class="comment">/* List of files to return */</span>
00065   <a class="code" href="structstp__list__item.html">stp_list_item_t</a> *diritem;          <span class="comment">/* Current directory */</span>
00066   <span class="keyword">struct </span>dirent** module_dir;        <span class="comment">/* Current directory contents */</span>
00067   <span class="keywordtype">char</span> *module_name;                 <span class="comment">/* File name to check */</span>
00068   <span class="keywordtype">int</span> n;                             <span class="comment">/* Number of directory entries */</span>
00069 
00070   <span class="keywordflow">if</span> (!dirlist)
00071     <span class="keywordflow">return</span> NULL;
00072 
00073   <a class="code" href="path_8c.html#a3">path_check_suffix</a> = suffix;
00074 
00075   findlist = <a class="code" href="list_8h.html#a7">stp_list_create</a>();
00076   <span class="keywordflow">if</span> (!findlist)
00077     <span class="keywordflow">return</span> NULL;
00078   <a class="code" href="print-list_8c.html#a19">stp_list_set_freefunc</a>(findlist, <a class="code" href="list_8h.html#a6">stp_list_node_free_data</a>);
00079 
00080   diritem = <a class="code" href="print-list_8c.html#a12">stp_list_get_start</a>(dirlist);
00081   <span class="keywordflow">while</span> (diritem)
00082     {
00083       <a class="code" href="path_8c.html#a2">path_check_path</a> = (<span class="keyword">const</span> <span class="keywordtype">char</span> *) <a class="code" href="print-list_8c.html#a33">stp_list_item_get_data</a>(diritem);
00084       <a class="code" href="print-util_8c.html#a24">stp_deprintf</a>(<a class="code" href="group__util.html#ga44">STP_DBG_PATH</a>, <span class="stringliteral">"stp-path: directory: %s\n"</span>,
00085                    (<span class="keyword">const</span> <span class="keywordtype">char</span> *) <a class="code" href="print-list_8c.html#a33">stp_list_item_get_data</a>(diritem));
00086       n = <a class="code" href="path_8c.html#a6">stpi_scandir</a> ((<span class="keyword">const</span> <span class="keywordtype">char</span> *) <a class="code" href="print-list_8c.html#a33">stp_list_item_get_data</a>(diritem),
00087                         &amp;module_dir, <a class="code" href="path_8c.html#a4">stpi_path_check</a>, <a class="code" href="path_8c.html#a7">dirent_sort</a>);
00088       <span class="keywordflow">if</span> (n &gt;= 0)
00089         {
00090           <span class="keywordtype">int</span> idx;
00091           <span class="keywordflow">for</span> (idx = 0; idx &lt; n; ++idx)
00092             {
00093               module_name = <a class="code" href="path_8c.html#a5">stpi_path_merge</a>((<span class="keyword">const</span> <span class="keywordtype">char</span> *) <a class="code" href="print-list_8c.html#a33">stp_list_item_get_data</a>(diritem),
00094                                            module_dir[idx]-&gt;d_name);
00095               <a class="code" href="print-list_8c.html#a29">stp_list_item_create</a>(findlist, NULL, module_name);
00096               free (module_dir[idx]); <span class="comment">/* Must use plain free() */</span>
00097             }
00098           free (module_dir); <span class="comment">/* Must use plain free() */</span>
00099         }
00100       diritem = <a class="code" href="print-list_8c.html#a32">stp_list_item_next</a>(diritem);
00101     }
00102   <span class="keywordflow">return</span> findlist;
00103 }
00104 
00105 
00106 <span class="comment">/*</span>
00107 <span class="comment"> * stpi_scandir() callback.  Check the filename is sane, has the</span>
00108 <span class="comment"> * correct mode bits and suffix.</span>
00109 <span class="comment"> */</span>
00110 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00111"></a><a class="code" href="path_8c.html#a4">00111</a> <a class="code" href="path_8c.html#a4">stpi_path_check</a>(<span class="keyword">const</span> <span class="keyword">struct</span> dirent *module) <span class="comment">/* File to check */</span>
00112 {
00113   <span class="keywordtype">int</span> namelen;                              <span class="comment">/* Filename length */</span>
00114   <span class="keywordtype">int</span> status = 0;                           <span class="comment">/* Error status */</span>
00115   <span class="keywordtype">int</span> savederr;                             <span class="comment">/* Saved errno */</span>
00116   <span class="keywordtype">char</span> *filename;                           <span class="comment">/* Filename */</span>
00117   <span class="keyword">struct </span>stat modstat;                      <span class="comment">/* stat() output */</span>
00118 
00119   savederr = errno; <span class="comment">/* since we are a callback, preserve</span>
00120 <span class="comment">                       stpi_scandir() state */</span>
00121 
00122   filename = <a class="code" href="path_8c.html#a5">stpi_path_merge</a>(<a class="code" href="path_8c.html#a2">path_check_path</a>, module-&gt;d_name);
00123 
00124   namelen = strlen(filename);
00125   <span class="comment">/* make sure we can take off suffix (e.g. .la)</span>
00126 <span class="comment">     and still have a sane filename */</span>
00127   <span class="keywordflow">if</span> (namelen &gt;= strlen(<a class="code" href="path_8c.html#a3">path_check_suffix</a>) + 1) 
00128     {
00129       <span class="keywordflow">if</span> (!stat (filename, &amp;modstat))
00130         {
00131           <span class="comment">/* check file exists, and is a regular file */</span>
00132           <span class="keywordflow">if</span> (S_ISREG(modstat.st_mode))
00133             status = 1;
00134           <span class="keywordflow">if</span> (strncmp(filename + (namelen - strlen(<a class="code" href="path_8c.html#a3">path_check_suffix</a>)),
00135                       <a class="code" href="path_8c.html#a3">path_check_suffix</a>,
00136                       strlen(<a class="code" href="path_8c.html#a3">path_check_suffix</a>)))
00137             {
00138               status = 0;
00139             }
00140         }
00141     }
00142 
00143   <span class="keywordflow">if</span> (status)
00144     <a class="code" href="print-util_8c.html#a24">stp_deprintf</a>(<a class="code" href="group__util.html#ga44">STP_DBG_PATH</a>, <span class="stringliteral">"stp-path: file: `%s'\n"</span>, filename);
00145 
00146   <a class="code" href="group__util.html#ga31">stp_free</a>(filename);
00147   filename = NULL;
00148 
00149   errno = savederr;
00150   <span class="keywordflow">return</span> status;
00151 }
00152 
00153 
00154 <span class="comment">/*</span>
00155 <span class="comment"> * Join a path and filename together.</span>
00156 <span class="comment"> */</span>
00157 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l00158"></a><a class="code" href="path_8c.html#a5">00158</a> <a class="code" href="path_8c.html#a5">stpi_path_merge</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *path, <span class="comment">/* Path */</span>
00159                <span class="keyword">const</span> <span class="keywordtype">char</span> *file) <span class="comment">/* Filename */</span>
00160 {
00161   <span class="keywordtype">char</span> *filename;                <span class="comment">/* Filename to return */</span>
00162   <span class="keywordtype">int</span> namelen = strlen(path) + strlen(file) + 2;
00163   filename = (<span class="keywordtype">char</span> *) <a class="code" href="group__util.html#ga28">stp_malloc</a>(namelen * <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
00164   strcpy (filename, path);
00165   strcat (filename, <span class="stringliteral">"/"</span>);
00166   strcat (filename, file);
00167   filename[namelen - 1] = <span class="charliteral">'\0'</span>;
00168   <span class="keywordflow">return</span> filename;
00169 }
00170 
00171 
00172 <span class="comment">/*</span>
00173 <span class="comment"> * Split a PATH-type string (colon-delimited) into separate</span>
00174 <span class="comment"> * directories.</span>
00175 <span class="comment"> */</span>
00176 <span class="keywordtype">void</span>
<a name="l00177"></a><a class="code" href="path_8c.html#a9">00177</a> <a class="code" href="path_8c.html#a9">stp_path_split</a>(<a class="code" href="structstp__list.html">stp_list_t</a> *list, <span class="comment">/* List to add directories to */</span>
00178                <span class="keyword">const</span> <span class="keywordtype">char</span> *path) <span class="comment">/* Path to split */</span>
00179 {
00180   <span class="keyword">const</span> <span class="keywordtype">char</span> *start = path;      <span class="comment">/* Start of path name */</span>
00181   <span class="keyword">const</span> <span class="keywordtype">char</span> *end = NULL;        <span class="comment">/* End of path name */</span>
00182   <span class="keywordtype">char</span> *dir = NULL;              <span class="comment">/* Path name */</span>
00183   <span class="keywordtype">int</span> len;                       <span class="comment">/* Length of path name */</span>
00184 
00185   <span class="keywordflow">while</span> (start)
00186     {
00187       end = (<span class="keyword">const</span> <span class="keywordtype">char</span> *) strchr(start, <span class="charliteral">':'</span>);
00188       <span class="keywordflow">if</span> (!end)
00189         len = strlen(start) + 1;
00190       <span class="keywordflow">else</span>
00191         len = (end - start);
00192 
00193       <span class="keywordflow">if</span> (len &amp;&amp; !(len == 1 &amp;&amp; !end))
00194         {
00195           dir = (<span class="keywordtype">char</span> *) <a class="code" href="group__util.html#ga28">stp_malloc</a>(len + 1);
00196           strncpy(dir, start, len);
00197           dir[len] = <span class="charliteral">'\0'</span>;
00198           <a class="code" href="print-list_8c.html#a29">stp_list_item_create</a>(list, NULL, dir);
00199         }
00200       <span class="keywordflow">if</span> (!end)
00201         {
00202           start = NULL;
00203           <span class="keywordflow">break</span>;
00204         }
00205       start = end + 1;
00206     }
00207 }
00208 
00209 <span class="comment">/* Adapted from GNU libc &lt;dirent.h&gt;</span>
00210 <span class="comment">   These macros extract size information from a `struct dirent *'.</span>
00211 <span class="comment">   They may evaluate their argument multiple times, so it must not</span>
00212 <span class="comment">   have side effects.  Each of these may involve a relatively costly</span>
00213 <span class="comment">   call to `strlen' on some systems, so these values should be cached.</span>
00214 <span class="comment"></span>
00215 <span class="comment">   _D_EXACT_NAMLEN (DP) returns the length of DP-&gt;d_name, not including</span>
00216 <span class="comment">   its terminating null character.</span>
00217 <span class="comment"></span>
00218 <span class="comment">   _D_ALLOC_NAMLEN (DP) returns a size at least (_D_EXACT_NAMLEN (DP) + 1);</span>
00219 <span class="comment">   that is, the allocation size needed to hold the DP-&gt;d_name string.</span>
00220 <span class="comment">   Use this macro when you don't need the exact length, just an upper bound.</span>
00221 <span class="comment">   This macro is less likely to require calling `strlen' than _D_EXACT_NAMLEN.</span>
00222 <span class="comment">   */</span>
00223 
00224 <span class="preprocessor">#ifdef _DIRENT_HAVE_D_NAMLEN</span>
00225 <span class="preprocessor"></span><span class="preprocessor"># ifndef _D_EXACT_NAMLEN</span>
00226 <span class="preprocessor"></span><span class="preprocessor">#  define _D_EXACT_NAMLEN(d) ((d)-&gt;d_namlen)</span>
00227 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
00228 <span class="preprocessor"></span><span class="preprocessor"># ifndef _D_ALLOC_NAMLEN</span>
00229 <span class="preprocessor"></span><span class="preprocessor">#  define _D_ALLOC_NAMLEN(d) (_D_EXACT_NAMLEN (d) + 1)</span>
00230 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
00231 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00232 <span class="preprocessor"></span><span class="preprocessor"># ifndef _D_EXACT_NAMLEN</span>
<a name="l00233"></a><a class="code" href="path_8c.html#a0">00233</a> <span class="preprocessor"></span><span class="preprocessor">#  define _D_EXACT_NAMLEN(d) (strlen ((d)-&gt;d_name))</span>
00234 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
00235 <span class="preprocessor"></span><span class="preprocessor"># ifndef _D_ALLOC_NAMLEN</span>
00236 <span class="preprocessor"></span><span class="preprocessor">#  ifdef _DIRENT_HAVE_D_RECLEN</span>
00237 <span class="preprocessor"></span><span class="preprocessor">#   define _D_ALLOC_NAMLEN(d) (((char *) (d) + (d)-&gt;d_reclen) - &amp;(d)-&gt;d_name[0])</span>
00238 <span class="preprocessor"></span><span class="preprocessor">#  else</span>
<a name="l00239"></a><a class="code" href="path_8c.html#a1">00239</a> <span class="preprocessor"></span><span class="preprocessor">#   define _D_ALLOC_NAMLEN(d) (sizeof (d)-&gt;d_name &gt; 1 ? sizeof (d)-&gt;d_name : \</span>
00240 <span class="preprocessor">                               _D_EXACT_NAMLEN (d) + 1)</span>
00241 <span class="preprocessor"></span><span class="preprocessor">#  endif</span>
00242 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
00243 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00244 <span class="preprocessor"></span>
00245 <span class="comment">/*</span>
00246 <span class="comment"> * BSD scandir() replacement, from glibc</span>
00247 <span class="comment"> */</span>
00248 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00249"></a><a class="code" href="path_8c.html#a6">00249</a> <a class="code" href="path_8c.html#a6">stpi_scandir</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *dir,
00250               <span class="keyword">struct</span> dirent ***namelist,
00251               <span class="keywordtype">int</span> (*sel) (<span class="keyword">const</span> <span class="keyword">struct</span> dirent *),
00252               <span class="keywordtype">int</span> (*cmp) (<span class="keyword">const</span> <span class="keywordtype">void</span> *, <span class="keyword">const</span> <span class="keywordtype">void</span> *))
00253 {
00254   DIR *dp = opendir (dir);
00255   <span class="keyword">struct </span>dirent **v = NULL;
00256   size_t vsize = 0, i;
00257   <span class="keyword">struct </span>dirent *d;
00258   <span class="keywordtype">int</span> save;
00259 
00260   <span class="keywordflow">if</span> (dp == NULL)
00261     <span class="keywordflow">return</span> -1;
00262 
00263   save = errno;
00264   errno = 0;
00265 
00266   i = 0;
00267   <span class="keywordflow">while</span> ((d = readdir (dp)) != NULL)
00268     <span class="keywordflow">if</span> (sel == NULL || (*sel) (d))
00269       {
00270         <span class="keyword">struct </span>dirent *vnew;
00271         size_t dsize;
00272 
00273         <span class="comment">/* Ignore errors from sel or readdir */</span>
00274         errno = 0;
00275 
00276         <span class="keywordflow">if</span> (i == vsize)
00277           {
00278             <span class="keyword">struct </span>dirent **<span class="keyword">new</span>;
00279             <span class="keywordflow">if</span> (vsize == 0)
00280               vsize = 10;
00281             <span class="keywordflow">else</span>
00282               vsize *= 2;
00283             <span class="keyword">new</span> = (<span class="keyword">struct </span>dirent **) realloc (v, vsize * <span class="keyword">sizeof</span> (*v));
00284             <span class="keywordflow">if</span> (<span class="keyword">new</span> == NULL)
00285               <span class="keywordflow">break</span>;
00286             v = <span class="keyword">new</span>;
00287           }
00288 
00289         dsize = &amp;d-&gt;d_name[<a class="code" href="path_8c.html#a1">_D_ALLOC_NAMLEN</a> (d)] - (<span class="keywordtype">char</span> *) d;
00290         vnew = (<span class="keyword">struct </span>dirent *) malloc (dsize);
00291         <span class="keywordflow">if</span> (vnew == NULL)
00292           <span class="keywordflow">break</span>;
00293 
00294         v[i++] = (<span class="keyword">struct </span>dirent *) memcpy (vnew, d, dsize);
00295       }
00296 
00297   <span class="keywordflow">if</span> (errno != 0)
00298     {
00299       save = errno;
00300 
00301       <span class="keywordflow">while</span> (i &gt; 0)
00302         free (v[--i]);
00303       free (v);
00304 
00305       i = -1;
00306     }
00307   <span class="keywordflow">else</span>
00308     {
00309       <span class="comment">/* Sort the list if we have a comparison function to sort with.  */</span>
00310       <span class="keywordflow">if</span> (cmp != NULL)
00311         qsort (v, i, <span class="keyword">sizeof</span> (*v), cmp);
00312 
00313       *namelist = v;
00314     }
00315 
00316   (<span class="keywordtype">void</span>) closedir (dp);
00317   errno = save;
00318 
00319   <span class="keywordflow">return</span> i;
00320 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Aug 25 07:56:14 2004 for libgimpprint API Reference by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > </a>1.3.6 </small></address>
</body>
</html>
