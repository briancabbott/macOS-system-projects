<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libgimpprint API Reference: src/main/mxml-node.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>src/main/mxml-node.c</h1><a href="mxml-node_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * "$Id: mxml-node_8c-source.html,v 1.1.1.2 2004/12/22 23:49:05 jlovell Exp $"</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * Node support code for mini-XML, a small XML-like file parsing library.</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> * Copyright 2003 by Michael Sweet.</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> * This program is free software; you can redistribute it and/or</span>
00009 <span class="comment"> * modify it under the terms of the GNU Library General Public</span>
00010 <span class="comment"> * License as published by the Free Software Foundation; either</span>
00011 <span class="comment"> * version 2, or (at your option) any later version.</span>
00012 <span class="comment"> *</span>
00013 <span class="comment"> * This program is distributed in the hope that it will be useful,</span>
00014 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00015 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00016 <span class="comment"> * GNU General Public License for more details.</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> * Contents:</span>
00019 <span class="comment"> *</span>
00020 <span class="comment"> *   stp_mxmlAdd()        - Add a node to a tree.</span>
00021 <span class="comment"> *   stp_mxmlDelete()     - Delete a node and all of its children.</span>
00022 <span class="comment"> *   stp_mxmlNewElement() - Create a new element node.</span>
00023 <span class="comment"> *   stp_mxmlNewInteger() - Create a new integer node.</span>
00024 <span class="comment"> *   stp_mxmlNewOpaque()  - Create a new opaque string.</span>
00025 <span class="comment"> *   stp_mxmlNewReal()    - Create a new real number node.</span>
00026 <span class="comment"> *   stp_mxmlNewText()    - Create a new text fragment node.</span>
00027 <span class="comment"> *   stp_mxmlRemove()     - Remove a node from its parent.</span>
00028 <span class="comment"> *   mxml_new()       - Create a new node.</span>
00029 <span class="comment"> */</span>
00030 
00031 <span class="comment">/*</span>
00032 <span class="comment"> * Include necessary headers...</span>
00033 <span class="comment"> */</span>
00034 
00035 <span class="preprocessor">#include &lt;<a class="code" href="mxml_8h.html">gimp-print/mxml.h</a>&gt;</span>
00036 <span class="preprocessor">#include "config.h"</span>
00037 
00038 
00039 <span class="comment">/*</span>
00040 <span class="comment"> * Local functions...</span>
00041 <span class="comment"> */</span>
00042 
00043 <span class="keyword">static</span> <a class="code" href="structstp__mxml__node__s.html">stp_mxml_node_t</a>  *<a class="code" href="mxml-node_8c.html#a0">mxml_new</a>(<a class="code" href="structstp__mxml__node__s.html">stp_mxml_node_t</a> *parent, <a class="code" href="mxml_8h.html#a14">stp_mxml_type_t</a> type);
00044 
00045 
00046 <span class="comment">/*</span>
00047 <span class="comment"> * 'stp_mxmlAdd()' - Add a node to a tree.</span>
00048 <span class="comment"> *</span>
00049 <span class="comment"> * Adds the specified node to the parent. If the child argument is not</span>
00050 <span class="comment"> * NULL, puts the new node before or after the specified child depending</span>
00051 <span class="comment"> * on the value of the where argument. If the child argument is NULL,</span>
00052 <span class="comment"> * puts the new node at the beginning of the child list (STP_MXML_ADD_BEFORE)</span>
00053 <span class="comment"> * or at the end of the child list (STP_MXML_ADD_AFTER). The constant</span>
00054 <span class="comment"> * STP_MXML_ADD_TO_PARENT can be used to specify a NULL child pointer.</span>
00055 <span class="comment"> */</span>
00056 
00057 <span class="keywordtype">void</span>
<a name="l00058"></a><a class="code" href="mxml-node_8c.html#a1">00058</a> <a class="code" href="mxml-node_8c.html#a1">stp_mxmlAdd</a>(<a class="code" href="structstp__mxml__node__s.html">stp_mxml_node_t</a> *parent,            <span class="comment">/* I - Parent node */</span>
00059         <span class="keywordtype">int</span>         where,              <span class="comment">/* I - Where to add, STP_MXML_ADD_BEFORE or STP_MXML_ADD_AFTER */</span>
00060         <a class="code" href="structstp__mxml__node__s.html">stp_mxml_node_t</a> *child,         <span class="comment">/* I - Child node for where or STP_MXML_ADD_TO_PARENT */</span>
00061         <a class="code" href="structstp__mxml__node__s.html">stp_mxml_node_t</a> *node)          <span class="comment">/* I - Node to add */</span>
00062 {
00063 <span class="comment">/*  fprintf(stderr, "stp_mxmlAdd(parent=%p, where=%d, child=%p, node=%p)\n", parent,</span>
00064 <span class="comment">         where, child, node);*/</span>
00065 
00066  <span class="comment">/*</span>
00067 <span class="comment">  * Range check input...</span>
00068 <span class="comment">  */</span>
00069 
00070   <span class="keywordflow">if</span> (!parent || !node)
00071     <span class="keywordflow">return</span>;
00072 
00073  <span class="comment">/*</span>
00074 <span class="comment">  * Remove the node from any existing parent...</span>
00075 <span class="comment">  */</span>
00076 
00077   <span class="keywordflow">if</span> (node-&gt;<a class="code" href="structstp__mxml__node__s.html#o3">parent</a>)
00078     <a class="code" href="mxml-node_8c.html#a8">stp_mxmlRemove</a>(node);
00079 
00080  <span class="comment">/*</span>
00081 <span class="comment">  * Reset pointers...</span>
00082 <span class="comment">  */</span>
00083 
00084   node-&gt;<a class="code" href="structstp__mxml__node__s.html#o3">parent</a> = parent;
00085 
00086   <span class="keywordflow">switch</span> (where)
00087   {
00088     <span class="keywordflow">case</span> <a class="code" href="mxml_8h.html#a11">STP_MXML_ADD_BEFORE</a> :
00089         <span class="keywordflow">if</span> (!child || child == parent-&gt;<a class="code" href="structstp__mxml__node__s.html#o4">child</a> || child-&gt;<a class="code" href="structstp__mxml__node__s.html#o3">parent</a> != parent)
00090         {
00091          <span class="comment">/*</span>
00092 <span class="comment">          * Insert as first node under parent...</span>
00093 <span class="comment">          */</span>
00094 
00095           node-&gt;<a class="code" href="structstp__mxml__node__s.html#o1">next</a> = parent-&gt;<a class="code" href="structstp__mxml__node__s.html#o4">child</a>;
00096 
00097           <span class="keywordflow">if</span> (parent-&gt;<a class="code" href="structstp__mxml__node__s.html#o4">child</a>)
00098             parent-&gt;<a class="code" href="structstp__mxml__node__s.html#o4">child</a>-&gt;<a class="code" href="structstp__mxml__node__s.html#o2">prev</a> = node;
00099           <span class="keywordflow">else</span>
00100             parent-&gt;<a class="code" href="structstp__mxml__node__s.html#o5">last_child</a> = node;
00101 
00102           parent-&gt;<a class="code" href="structstp__mxml__node__s.html#o4">child</a> = node;
00103         }
00104         <span class="keywordflow">else</span>
00105         {
00106          <span class="comment">/*</span>
00107 <span class="comment">          * Insert node before this child...</span>
00108 <span class="comment">          */</span>
00109 
00110           node-&gt;<a class="code" href="structstp__mxml__node__s.html#o1">next</a> = child;
00111           node-&gt;<a class="code" href="structstp__mxml__node__s.html#o2">prev</a> = child-&gt;<a class="code" href="structstp__mxml__node__s.html#o2">prev</a>;
00112 
00113           <span class="keywordflow">if</span> (child-&gt;<a class="code" href="structstp__mxml__node__s.html#o2">prev</a>)
00114             child-&gt;<a class="code" href="structstp__mxml__node__s.html#o2">prev</a>-&gt;<a class="code" href="structstp__mxml__node__s.html#o1">next</a> = node;
00115           <span class="keywordflow">else</span>
00116             parent-&gt;<a class="code" href="structstp__mxml__node__s.html#o4">child</a> = node;
00117 
00118           child-&gt;<a class="code" href="structstp__mxml__node__s.html#o2">prev</a> = node;
00119         }
00120         <span class="keywordflow">break</span>;
00121 
00122     <span class="keywordflow">case</span> <a class="code" href="mxml_8h.html#a12">STP_MXML_ADD_AFTER</a> :
00123         <span class="keywordflow">if</span> (!child || child == parent-&gt;<a class="code" href="structstp__mxml__node__s.html#o5">last_child</a> || child-&gt;<a class="code" href="structstp__mxml__node__s.html#o3">parent</a> != parent)
00124         {
00125          <span class="comment">/*</span>
00126 <span class="comment">          * Insert as last node under parent...</span>
00127 <span class="comment">          */</span>
00128 
00129           node-&gt;<a class="code" href="structstp__mxml__node__s.html#o3">parent</a> = parent;
00130           node-&gt;<a class="code" href="structstp__mxml__node__s.html#o2">prev</a>   = parent-&gt;<a class="code" href="structstp__mxml__node__s.html#o5">last_child</a>;
00131 
00132           <span class="keywordflow">if</span> (parent-&gt;<a class="code" href="structstp__mxml__node__s.html#o5">last_child</a>)
00133             parent-&gt;<a class="code" href="structstp__mxml__node__s.html#o5">last_child</a>-&gt;<a class="code" href="structstp__mxml__node__s.html#o1">next</a> = node;
00134           <span class="keywordflow">else</span>
00135             parent-&gt;<a class="code" href="structstp__mxml__node__s.html#o4">child</a> = node;
00136 
00137           parent-&gt;<a class="code" href="structstp__mxml__node__s.html#o5">last_child</a> = node;
00138         }
00139         <span class="keywordflow">else</span>
00140         {
00141          <span class="comment">/*</span>
00142 <span class="comment">          * Insert node after this child...</span>
00143 <span class="comment">          */</span>
00144 
00145           node-&gt;<a class="code" href="structstp__mxml__node__s.html#o2">prev</a> = child;
00146           node-&gt;<a class="code" href="structstp__mxml__node__s.html#o1">next</a> = child-&gt;<a class="code" href="structstp__mxml__node__s.html#o1">next</a>;
00147 
00148           <span class="keywordflow">if</span> (child-&gt;<a class="code" href="structstp__mxml__node__s.html#o1">next</a>)
00149             child-&gt;<a class="code" href="structstp__mxml__node__s.html#o1">next</a>-&gt;<a class="code" href="structstp__mxml__node__s.html#o2">prev</a> = node;
00150           <span class="keywordflow">else</span>
00151             parent-&gt;<a class="code" href="structstp__mxml__node__s.html#o5">last_child</a> = node;
00152 
00153           child-&gt;<a class="code" href="structstp__mxml__node__s.html#o1">next</a> = node;
00154         }
00155         <span class="keywordflow">break</span>;
00156   }
00157 }
00158 
00159 
00160 <span class="comment">/*</span>
00161 <span class="comment"> * 'stp_mxmlDelete()' - Delete a node and all of its children.</span>
00162 <span class="comment"> *</span>
00163 <span class="comment"> * If the specified node has a parent, this function first removes the</span>
00164 <span class="comment"> * node from its parent using the stp_mxmlRemove() function.</span>
00165 <span class="comment"> */</span>
00166 
00167 <span class="keywordtype">void</span>
<a name="l00168"></a><a class="code" href="mxml-node_8c.html#a2">00168</a> <a class="code" href="mxml-node_8c.html#a2">stp_mxmlDelete</a>(<a class="code" href="structstp__mxml__node__s.html">stp_mxml_node_t</a> *node)           <span class="comment">/* I - Node to delete */</span>
00169 {
00170   <span class="keywordtype">int</span>   i;                              <span class="comment">/* Looping var */</span>
00171 
00172 
00173 <span class="comment">/*  fprintf(stderr, "stp_mxmlDelete(node=%p)\n", node);*/</span>
00174 
00175  <span class="comment">/*</span>
00176 <span class="comment">  * Range check input...</span>
00177 <span class="comment">  */</span>
00178 
00179   <span class="keywordflow">if</span> (!node)
00180     <span class="keywordflow">return</span>;
00181 
00182  <span class="comment">/*</span>
00183 <span class="comment">  * Remove the node from its parent, if any...</span>
00184 <span class="comment">  */</span>
00185 
00186   <a class="code" href="mxml-node_8c.html#a8">stp_mxmlRemove</a>(node);
00187 
00188  <span class="comment">/*</span>
00189 <span class="comment">  * Delete children...</span>
00190 <span class="comment">  */</span>
00191 
00192   <span class="keywordflow">while</span> (node-&gt;<a class="code" href="structstp__mxml__node__s.html#o4">child</a>)
00193     <a class="code" href="mxml-node_8c.html#a2">stp_mxmlDelete</a>(node-&gt;<a class="code" href="structstp__mxml__node__s.html#o4">child</a>);
00194 
00195  <span class="comment">/*</span>
00196 <span class="comment">  * Now delete any node data...</span>
00197 <span class="comment">  */</span>
00198 
00199   <span class="keywordflow">switch</span> (node-&gt;<a class="code" href="structstp__mxml__node__s.html#o0">type</a>)
00200   {
00201     <span class="keywordflow">case</span> <a class="code" href="mxml_8h.html#a43a20">STP_MXML_ELEMENT</a> :
00202         <span class="keywordflow">if</span> (node-&gt;<a class="code" href="structstp__mxml__node__s.html#o6">value</a>.<a class="code" href="unionstp__mxml__value__u.html#o0">element</a>.<a class="code" href="structstp__mxml__value__s.html#o0">name</a>)
00203           free(node-&gt;<a class="code" href="structstp__mxml__node__s.html#o6">value</a>.<a class="code" href="unionstp__mxml__value__u.html#o0">element</a>.<a class="code" href="structstp__mxml__value__s.html#o0">name</a>);
00204 
00205         <span class="keywordflow">if</span> (node-&gt;<a class="code" href="structstp__mxml__node__s.html#o6">value</a>.<a class="code" href="unionstp__mxml__value__u.html#o0">element</a>.<a class="code" href="structstp__mxml__value__s.html#o1">num_attrs</a>)
00206         {
00207           <span class="keywordflow">for</span> (i = 0; i &lt; node-&gt;<a class="code" href="structstp__mxml__node__s.html#o6">value</a>.<a class="code" href="unionstp__mxml__value__u.html#o0">element</a>.<a class="code" href="structstp__mxml__value__s.html#o1">num_attrs</a>; i ++)
00208           {
00209             <span class="keywordflow">if</span> (node-&gt;<a class="code" href="structstp__mxml__node__s.html#o6">value</a>.<a class="code" href="unionstp__mxml__value__u.html#o0">element</a>.<a class="code" href="structstp__mxml__value__s.html#o2">attrs</a>[i].<a class="code" href="structstp__mxml__attr__s.html#o0">name</a>)
00210               free(node-&gt;<a class="code" href="structstp__mxml__node__s.html#o6">value</a>.<a class="code" href="unionstp__mxml__value__u.html#o0">element</a>.<a class="code" href="structstp__mxml__value__s.html#o2">attrs</a>[i].<a class="code" href="structstp__mxml__attr__s.html#o0">name</a>);
00211             <span class="keywordflow">if</span> (node-&gt;<a class="code" href="structstp__mxml__node__s.html#o6">value</a>.<a class="code" href="unionstp__mxml__value__u.html#o0">element</a>.<a class="code" href="structstp__mxml__value__s.html#o2">attrs</a>[i].<a class="code" href="structstp__mxml__attr__s.html#o1">value</a>)
00212               free(node-&gt;<a class="code" href="structstp__mxml__node__s.html#o6">value</a>.<a class="code" href="unionstp__mxml__value__u.html#o0">element</a>.<a class="code" href="structstp__mxml__value__s.html#o2">attrs</a>[i].<a class="code" href="structstp__mxml__attr__s.html#o1">value</a>);
00213           }
00214 
00215           free(node-&gt;<a class="code" href="structstp__mxml__node__s.html#o6">value</a>.<a class="code" href="unionstp__mxml__value__u.html#o0">element</a>.<a class="code" href="structstp__mxml__value__s.html#o2">attrs</a>);
00216         }
00217         <span class="keywordflow">break</span>;
00218     <span class="keywordflow">case</span> <a class="code" href="mxml_8h.html#a43a21">STP_MXML_INTEGER</a> :
00219        <span class="comment">/* Nothing to do */</span>
00220         <span class="keywordflow">break</span>;
00221     <span class="keywordflow">case</span> <a class="code" href="mxml_8h.html#a43a22">STP_MXML_OPAQUE</a> :
00222         <span class="keywordflow">if</span> (node-&gt;<a class="code" href="structstp__mxml__node__s.html#o6">value</a>.<a class="code" href="unionstp__mxml__value__u.html#o2">opaque</a>)
00223           free(node-&gt;<a class="code" href="structstp__mxml__node__s.html#o6">value</a>.<a class="code" href="unionstp__mxml__value__u.html#o2">opaque</a>);
00224         <span class="keywordflow">break</span>;
00225     <span class="keywordflow">case</span> <a class="code" href="mxml_8h.html#a43a23">STP_MXML_REAL</a> :
00226        <span class="comment">/* Nothing to do */</span>
00227         <span class="keywordflow">break</span>;
00228     <span class="keywordflow">case</span> <a class="code" href="mxml_8h.html#a43a24">STP_MXML_TEXT</a> :
00229         <span class="keywordflow">if</span> (node-&gt;<a class="code" href="structstp__mxml__node__s.html#o6">value</a>.<a class="code" href="unionstp__mxml__value__u.html#o4">text</a>.<a class="code" href="structstp__mxml__text__s.html#o1">string</a>)
00230           free(node-&gt;<a class="code" href="structstp__mxml__node__s.html#o6">value</a>.<a class="code" href="unionstp__mxml__value__u.html#o4">text</a>.<a class="code" href="structstp__mxml__text__s.html#o1">string</a>);
00231         <span class="keywordflow">break</span>;
00232   }
00233 
00234  <span class="comment">/*</span>
00235 <span class="comment">  * Free this node...</span>
00236 <span class="comment">  */</span>
00237 
00238   free(node);
00239 }
00240 
00241 
00242 <span class="comment">/*</span>
00243 <span class="comment"> * 'stp_mxmlNewElement()' - Create a new element node.</span>
00244 <span class="comment"> *</span>
00245 <span class="comment"> * The new element node is added to the end of the specified parent's child</span>
00246 <span class="comment"> * list. The constant STP_MXML_NO_PARENT can be used to specify that the new</span>
00247 <span class="comment"> * element node has no parent.</span>
00248 <span class="comment"> */</span>
00249 
00250 <a class="code" href="structstp__mxml__node__s.html">stp_mxml_node_t</a> *                               <span class="comment">/* O - New node */</span>
<a name="l00251"></a><a class="code" href="mxml-node_8c.html#a3">00251</a> <a class="code" href="mxml-node_8c.html#a3">stp_mxmlNewElement</a>(<a class="code" href="structstp__mxml__node__s.html">stp_mxml_node_t</a> *parent,     <span class="comment">/* I - Parent node or STP_MXML_NO_PARENT */</span>
00252                <span class="keyword">const</span> <span class="keywordtype">char</span>  *name)       <span class="comment">/* I - Name of element */</span>
00253 {
00254   <a class="code" href="structstp__mxml__node__s.html">stp_mxml_node_t</a>       *node;                  <span class="comment">/* New node */</span>
00255 
00256 
00257  <span class="comment">/*</span>
00258 <span class="comment">  * Range check input...</span>
00259 <span class="comment">  */</span>
00260 
00261   <span class="keywordflow">if</span> (!name)
00262     <span class="keywordflow">return</span> (NULL);
00263 
00264  <span class="comment">/*</span>
00265 <span class="comment">  * Create the node and set the element name...</span>
00266 <span class="comment">  */</span>
00267 
00268   <span class="keywordflow">if</span> ((node = <a class="code" href="mxml-node_8c.html#a0">mxml_new</a>(parent, <a class="code" href="mxml_8h.html#a43a20">STP_MXML_ELEMENT</a>)) != NULL)
00269     node-&gt;<a class="code" href="structstp__mxml__node__s.html#o6">value</a>.<a class="code" href="unionstp__mxml__value__u.html#o0">element</a>.<a class="code" href="structstp__mxml__value__s.html#o0">name</a> = strdup(name);
00270 
00271   <span class="keywordflow">return</span> (node);
00272 }
00273 
00274 
00275 <span class="comment">/*</span>
00276 <span class="comment"> * 'stp_mxmlNewInteger()' - Create a new integer node.</span>
00277 <span class="comment"> *</span>
00278 <span class="comment"> * The new integer node is added to the end of the specified parent's child</span>
00279 <span class="comment"> * list. The constant STP_MXML_NO_PARENT can be used to specify that the new</span>
00280 <span class="comment"> * integer node has no parent.</span>
00281 <span class="comment"> */</span>
00282 
00283 <a class="code" href="structstp__mxml__node__s.html">stp_mxml_node_t</a> *                               <span class="comment">/* O - New node */</span>
<a name="l00284"></a><a class="code" href="mxml-node_8c.html#a4">00284</a> <a class="code" href="mxml-node_8c.html#a4">stp_mxmlNewInteger</a>(<a class="code" href="structstp__mxml__node__s.html">stp_mxml_node_t</a> *parent,     <span class="comment">/* I - Parent node or STP_MXML_NO_PARENT */</span>
00285                <span class="keywordtype">int</span>         integer)     <span class="comment">/* I - Integer value */</span>
00286 {
00287   <a class="code" href="structstp__mxml__node__s.html">stp_mxml_node_t</a>       *node;                  <span class="comment">/* New node */</span>
00288 
00289 
00290  <span class="comment">/*</span>
00291 <span class="comment">  * Range check input...</span>
00292 <span class="comment">  */</span>
00293 
00294   <span class="keywordflow">if</span> (!parent)
00295     <span class="keywordflow">return</span> (NULL);
00296 
00297  <span class="comment">/*</span>
00298 <span class="comment">  * Create the node and set the element name...</span>
00299 <span class="comment">  */</span>
00300 
00301   <span class="keywordflow">if</span> ((node = <a class="code" href="mxml-node_8c.html#a0">mxml_new</a>(parent, <a class="code" href="mxml_8h.html#a43a21">STP_MXML_INTEGER</a>)) != NULL)
00302     node-&gt;<a class="code" href="structstp__mxml__node__s.html#o6">value</a>.<a class="code" href="unionstp__mxml__value__u.html#o1">integer</a> = integer;
00303 
00304   <span class="keywordflow">return</span> (node);
00305 }
00306 
00307 
00308 <span class="comment">/*</span>
00309 <span class="comment"> * 'stp_mxmlNewOpaque()' - Create a new opaque string.</span>
00310 <span class="comment"> *</span>
00311 <span class="comment"> * The new opaque node is added to the end of the specified parent's child</span>
00312 <span class="comment"> * list. The constant STP_MXML_NO_PARENT can be used to specify that the new</span>
00313 <span class="comment"> * opaque node has no parent. The opaque string must be nul-terminated and</span>
00314 <span class="comment"> * is copied into the new node.</span>
00315 <span class="comment"> */</span>
00316 
00317 <a class="code" href="structstp__mxml__node__s.html">stp_mxml_node_t</a> *                               <span class="comment">/* O - New node */</span>
<a name="l00318"></a><a class="code" href="mxml-node_8c.html#a5">00318</a> <a class="code" href="mxml-node_8c.html#a5">stp_mxmlNewOpaque</a>(<a class="code" href="structstp__mxml__node__s.html">stp_mxml_node_t</a> *parent,      <span class="comment">/* I - Parent node or STP_MXML_NO_PARENT */</span>
00319               <span class="keyword">const</span> <span class="keywordtype">char</span>  *opaque)      <span class="comment">/* I - Opaque string */</span>
00320 {
00321   <a class="code" href="structstp__mxml__node__s.html">stp_mxml_node_t</a>       *node;                  <span class="comment">/* New node */</span>
00322 
00323 
00324  <span class="comment">/*</span>
00325 <span class="comment">  * Range check input...</span>
00326 <span class="comment">  */</span>
00327 
00328   <span class="keywordflow">if</span> (!parent || !opaque)
00329     <span class="keywordflow">return</span> (NULL);
00330 
00331  <span class="comment">/*</span>
00332 <span class="comment">  * Create the node and set the element name...</span>
00333 <span class="comment">  */</span>
00334 
00335   <span class="keywordflow">if</span> ((node = <a class="code" href="mxml-node_8c.html#a0">mxml_new</a>(parent, <a class="code" href="mxml_8h.html#a43a22">STP_MXML_OPAQUE</a>)) != NULL)
00336     node-&gt;<a class="code" href="structstp__mxml__node__s.html#o6">value</a>.<a class="code" href="unionstp__mxml__value__u.html#o2">opaque</a> = strdup(opaque);
00337 
00338   <span class="keywordflow">return</span> (node);
00339 }
00340 
00341 
00342 <span class="comment">/*</span>
00343 <span class="comment"> * 'stp_mxmlNewReal()' - Create a new real number node.</span>
00344 <span class="comment"> *</span>
00345 <span class="comment"> * The new real number node is added to the end of the specified parent's</span>
00346 <span class="comment"> * child list. The constant STP_MXML_NO_PARENT can be used to specify that</span>
00347 <span class="comment"> * the new real number node has no parent.</span>
00348 <span class="comment"> */</span>
00349 
00350 <a class="code" href="structstp__mxml__node__s.html">stp_mxml_node_t</a> *                               <span class="comment">/* O - New node */</span>
<a name="l00351"></a><a class="code" href="mxml-node_8c.html#a6">00351</a> <a class="code" href="mxml-node_8c.html#a6">stp_mxmlNewReal</a>(<a class="code" href="structstp__mxml__node__s.html">stp_mxml_node_t</a> *parent,        <span class="comment">/* I - Parent node or STP_MXML_NO_PARENT */</span>
00352             <span class="keywordtype">double</span>      real)           <span class="comment">/* I - Real number value */</span>
00353 {
00354   <a class="code" href="structstp__mxml__node__s.html">stp_mxml_node_t</a>       *node;                  <span class="comment">/* New node */</span>
00355 
00356 
00357  <span class="comment">/*</span>
00358 <span class="comment">  * Range check input...</span>
00359 <span class="comment">  */</span>
00360 
00361   <span class="keywordflow">if</span> (!parent)
00362     <span class="keywordflow">return</span> (NULL);
00363 
00364  <span class="comment">/*</span>
00365 <span class="comment">  * Create the node and set the element name...</span>
00366 <span class="comment">  */</span>
00367 
00368   <span class="keywordflow">if</span> ((node = <a class="code" href="mxml-node_8c.html#a0">mxml_new</a>(parent, <a class="code" href="mxml_8h.html#a43a23">STP_MXML_REAL</a>)) != NULL)
00369     node-&gt;<a class="code" href="structstp__mxml__node__s.html#o6">value</a>.<a class="code" href="unionstp__mxml__value__u.html#o3">real</a> = real;
00370 
00371   <span class="keywordflow">return</span> (node);
00372 }
00373 
00374 
00375 <span class="comment">/*</span>
00376 <span class="comment"> * 'stp_mxmlNewText()' - Create a new text fragment node.</span>
00377 <span class="comment"> *</span>
00378 <span class="comment"> * The new text node is added to the end of the specified parent's child</span>
00379 <span class="comment"> * list. The constant STP_MXML_NO_PARENT can be used to specify that the new</span>
00380 <span class="comment"> * text node has no parent. The whitespace parameter is used to specify</span>
00381 <span class="comment"> * whether leading whitespace is present before the node. The text</span>
00382 <span class="comment"> * string must be nul-terminated and is copied into the new node.  </span>
00383 <span class="comment"> */</span>
00384 
00385 <a class="code" href="structstp__mxml__node__s.html">stp_mxml_node_t</a> *                               <span class="comment">/* O - New node */</span>
<a name="l00386"></a><a class="code" href="mxml-node_8c.html#a7">00386</a> <a class="code" href="mxml-node_8c.html#a7">stp_mxmlNewText</a>(<a class="code" href="structstp__mxml__node__s.html">stp_mxml_node_t</a> *parent,        <span class="comment">/* I - Parent node or STP_MXML_NO_PARENT */</span>
00387             <span class="keywordtype">int</span>         whitespace,     <span class="comment">/* I - 1 = leading whitespace, 0 = no whitespace */</span>
00388             <span class="keyword">const</span> <span class="keywordtype">char</span>  *string)        <span class="comment">/* I - String */</span>
00389 {
00390   <a class="code" href="structstp__mxml__node__s.html">stp_mxml_node_t</a>       *node;                  <span class="comment">/* New node */</span>
00391 
00392 
00393  <span class="comment">/*</span>
00394 <span class="comment">  * Range check input...</span>
00395 <span class="comment">  */</span>
00396 
00397   <span class="keywordflow">if</span> (!parent || !string)
00398     <span class="keywordflow">return</span> (NULL);
00399 
00400  <span class="comment">/*</span>
00401 <span class="comment">  * Create the node and set the text value...</span>
00402 <span class="comment">  */</span>
00403 
00404   <span class="keywordflow">if</span> ((node = <a class="code" href="mxml-node_8c.html#a0">mxml_new</a>(parent, <a class="code" href="mxml_8h.html#a43a24">STP_MXML_TEXT</a>)) != NULL)
00405   {
00406     node-&gt;<a class="code" href="structstp__mxml__node__s.html#o6">value</a>.<a class="code" href="unionstp__mxml__value__u.html#o4">text</a>.<a class="code" href="structstp__mxml__text__s.html#o0">whitespace</a> = whitespace;
00407     node-&gt;<a class="code" href="structstp__mxml__node__s.html#o6">value</a>.<a class="code" href="unionstp__mxml__value__u.html#o4">text</a>.<a class="code" href="structstp__mxml__text__s.html#o1">string</a>     = strdup(string);
00408   }
00409 
00410   <span class="keywordflow">return</span> (node);
00411 }
00412 
00413 
00414 <span class="comment">/*</span>
00415 <span class="comment"> * 'stp_mxmlRemove()' - Remove a node from its parent.</span>
00416 <span class="comment"> *</span>
00417 <span class="comment"> * Does not free memory used by the node - use stp_mxmlDelete() for that.</span>
00418 <span class="comment"> * This function does nothing if the node has no parent.</span>
00419 <span class="comment"> */</span>
00420 
00421 <span class="keywordtype">void</span>
<a name="l00422"></a><a class="code" href="mxml-node_8c.html#a8">00422</a> <a class="code" href="mxml-node_8c.html#a8">stp_mxmlRemove</a>(<a class="code" href="structstp__mxml__node__s.html">stp_mxml_node_t</a> *node)           <span class="comment">/* I - Node to remove */</span>
00423 {
00424  <span class="comment">/*</span>
00425 <span class="comment">  * Range check input...</span>
00426 <span class="comment">  */</span>
00427 
00428 <span class="comment">/*  fprintf(stderr, "stp_mxmlRemove(node=%p)\n", node);*/</span>
00429 
00430   <span class="keywordflow">if</span> (!node || !node-&gt;<a class="code" href="structstp__mxml__node__s.html#o3">parent</a>)
00431     <span class="keywordflow">return</span>;
00432 
00433  <span class="comment">/*</span>
00434 <span class="comment">  * Remove from parent...</span>
00435 <span class="comment">  */</span>
00436 
00437   <span class="keywordflow">if</span> (node-&gt;<a class="code" href="structstp__mxml__node__s.html#o2">prev</a>)
00438     node-&gt;<a class="code" href="structstp__mxml__node__s.html#o2">prev</a>-&gt;<a class="code" href="structstp__mxml__node__s.html#o1">next</a> = node-&gt;<a class="code" href="structstp__mxml__node__s.html#o1">next</a>;
00439   <span class="keywordflow">else</span>
00440     node-&gt;<a class="code" href="structstp__mxml__node__s.html#o3">parent</a>-&gt;<a class="code" href="structstp__mxml__node__s.html#o4">child</a> = node-&gt;<a class="code" href="structstp__mxml__node__s.html#o1">next</a>;
00441 
00442   <span class="keywordflow">if</span> (node-&gt;<a class="code" href="structstp__mxml__node__s.html#o1">next</a>)
00443     node-&gt;<a class="code" href="structstp__mxml__node__s.html#o1">next</a>-&gt;<a class="code" href="structstp__mxml__node__s.html#o2">prev</a> = node-&gt;<a class="code" href="structstp__mxml__node__s.html#o2">prev</a>;
00444   <span class="keywordflow">else</span>
00445     node-&gt;<a class="code" href="structstp__mxml__node__s.html#o3">parent</a>-&gt;<a class="code" href="structstp__mxml__node__s.html#o5">last_child</a> = node-&gt;<a class="code" href="structstp__mxml__node__s.html#o2">prev</a>;
00446 
00447   node-&gt;<a class="code" href="structstp__mxml__node__s.html#o3">parent</a> = NULL;
00448   node-&gt;<a class="code" href="structstp__mxml__node__s.html#o2">prev</a>   = NULL;
00449   node-&gt;<a class="code" href="structstp__mxml__node__s.html#o1">next</a>   = NULL;
00450 }
00451 
00452 
00453 <span class="comment">/*</span>
00454 <span class="comment"> * 'mxml_new()' - Create a new node.</span>
00455 <span class="comment"> */</span>
00456 
00457 <span class="keyword">static</span> <a class="code" href="structstp__mxml__node__s.html">stp_mxml_node_t</a> *                        <span class="comment">/* O - New node */</span>
<a name="l00458"></a><a class="code" href="mxml-node_8c.html#a0">00458</a> <a class="code" href="mxml-node_8c.html#a0">mxml_new</a>(<a class="code" href="structstp__mxml__node__s.html">stp_mxml_node_t</a> *parent,               <span class="comment">/* I - Parent node */</span>
00459          <a class="code" href="mxml_8h.html#a14">stp_mxml_type_t</a> type)          <span class="comment">/* I - Node type */</span>
00460 {
00461   <a class="code" href="structstp__mxml__node__s.html">stp_mxml_node_t</a>       *node;                  <span class="comment">/* New node */</span>
00462 
00463 
00464  <span class="comment">/*</span>
00465 <span class="comment">  * Allocate memory for the node...</span>
00466 <span class="comment">  */</span>
00467 
00468   <span class="keywordflow">if</span> ((node = calloc(1, <span class="keyword">sizeof</span>(<a class="code" href="structstp__mxml__node__s.html">stp_mxml_node_t</a>))) == NULL)
00469     <span class="keywordflow">return</span> (NULL);
00470 
00471  <span class="comment">/*</span>
00472 <span class="comment">  * Set the node type...</span>
00473 <span class="comment">  */</span>
00474 
00475   node-&gt;<a class="code" href="structstp__mxml__node__s.html#o0">type</a> = type;
00476 
00477  <span class="comment">/*</span>
00478 <span class="comment">  * Add to the parent if present...</span>
00479 <span class="comment">  */</span>
00480 
00481   <span class="keywordflow">if</span> (parent)
00482     <a class="code" href="mxml-node_8c.html#a1">stp_mxmlAdd</a>(parent, <a class="code" href="mxml_8h.html#a12">STP_MXML_ADD_AFTER</a>, <a class="code" href="mxml_8h.html#a13">STP_MXML_ADD_TO_PARENT</a>, node);
00483 
00484  <span class="comment">/*</span>
00485 <span class="comment">  * Return the new node...</span>
00486 <span class="comment">  */</span>
00487 
00488   <span class="keywordflow">return</span> (node);
00489 }
00490 
00491 
00492 <span class="comment">/*</span>
00493 <span class="comment"> * End of "$Id: mxml-node_8c-source.html,v 1.1.1.2 2004/12/22 23:49:05 jlovell Exp $".</span>
00494 <span class="comment"> */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Aug 25 07:56:14 2004 for libgimpprint API Reference by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > </a>1.3.6 </small></address>
</body>
</html>
