<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libgimpprint API Reference: src/main/bit-ops.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>src/main/bit-ops.c</h1><a href="bit-ops_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * "$Id: bit-ops_8c-source.html,v 1.1.1.2 2004/12/22 23:48:56 jlovell Exp $"</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> *   Softweave calculator for gimp-print.</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> *   Copyright 2000 Charles Briscoe-Smith &lt;cpbs@debian.org&gt;</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> *   This program is free software; you can redistribute it and/or modify it</span>
00009 <span class="comment"> *   under the terms of the GNU General Public License as published by the Free</span>
00010 <span class="comment"> *   Software Foundation; either version 2 of the License, or (at your option)</span>
00011 <span class="comment"> *   any later version.</span>
00012 <span class="comment"> *</span>
00013 <span class="comment"> *   This program is distributed in the hope that it will be useful, but</span>
00014 <span class="comment"> *   WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY</span>
00015 <span class="comment"> *   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</span>
00016 <span class="comment"> *   for more details.</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> *   You should have received a copy of the GNU General Public License</span>
00019 <span class="comment"> *   along with this program; if not, write to the Free Software</span>
00020 <span class="comment"> *   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
00021 <span class="comment"> */</span>
00022 
00023 <span class="comment">/*</span>
00024 <span class="comment"> * This file must include only standard C header files.  The core code must</span>
00025 <span class="comment"> * compile on generic platforms that don't support glib, gimp, gtk, etc.</span>
00026 <span class="comment"> */</span>
00027 
00028 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
00029 <span class="preprocessor"></span><span class="preprocessor">#include &lt;config.h&gt;</span>
00030 <span class="preprocessor">#endif</span>
00031 <span class="preprocessor"></span><span class="preprocessor">#include &lt;string.h&gt;</span>
00032 <span class="preprocessor">#include &lt;<a class="code" href="gimp-print_8h.html">gimp-print/gimp-print.h</a>&gt;</span>
00033 <span class="preprocessor">#include "<a class="code" href="gimp-print-internal_8h.html">gimp-print-internal.h</a>"</span>
00034 <span class="preprocessor">#include &lt;<a class="code" href="gimp-print-intl-internal_8h.html">gimp-print/gimp-print-intl-internal.h</a>&gt;</span>
00035 <span class="preprocessor">#ifdef HAVE_LIMITS_H</span>
00036 <span class="preprocessor"></span><span class="preprocessor">#include &lt;limits.h&gt;</span>
00037 <span class="preprocessor">#endif</span>
00038 <span class="preprocessor"></span>
00039 <span class="keywordtype">void</span>
<a name="l00040"></a><a class="code" href="bit-ops_8c.html#a6">00040</a> <a class="code" href="bit-ops_8c.html#a6">stp_fold</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *line,
00041          <span class="keywordtype">int</span> single_length,
00042          <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *outbuf)
00043 {
00044   <span class="keywordtype">int</span> i;
00045   memset(outbuf, 0, single_length * 2);
00046   <span class="keywordflow">for</span> (i = 0; i &lt; single_length; i++)
00047     {
00048       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> l0 = line[0];
00049       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> l1 = line[single_length];
00050       <span class="keywordflow">if</span> (l0 || l1)
00051         {
00052           outbuf[0] =
00053             ((l0 &amp; (1 &lt;&lt; 7)) &gt;&gt; 1) +
00054             ((l0 &amp; (1 &lt;&lt; 6)) &gt;&gt; 2) +
00055             ((l0 &amp; (1 &lt;&lt; 5)) &gt;&gt; 3) +
00056             ((l0 &amp; (1 &lt;&lt; 4)) &gt;&gt; 4) +
00057             ((l1 &amp; (1 &lt;&lt; 7)) &gt;&gt; 0) +
00058             ((l1 &amp; (1 &lt;&lt; 6)) &gt;&gt; 1) +
00059             ((l1 &amp; (1 &lt;&lt; 5)) &gt;&gt; 2) +
00060             ((l1 &amp; (1 &lt;&lt; 4)) &gt;&gt; 3);
00061           outbuf[1] =
00062             ((l0 &amp; (1 &lt;&lt; 3)) &lt;&lt; 3) +
00063             ((l0 &amp; (1 &lt;&lt; 2)) &lt;&lt; 2) +
00064             ((l0 &amp; (1 &lt;&lt; 1)) &lt;&lt; 1) +
00065             ((l0 &amp; (1 &lt;&lt; 0)) &lt;&lt; 0) +
00066             ((l1 &amp; (1 &lt;&lt; 3)) &lt;&lt; 4) +
00067             ((l1 &amp; (1 &lt;&lt; 2)) &lt;&lt; 3) +
00068             ((l1 &amp; (1 &lt;&lt; 1)) &lt;&lt; 2) +
00069             ((l1 &amp; (1 &lt;&lt; 0)) &lt;&lt; 1);
00070         }
00071       line++;
00072       outbuf += 2;
00073     }
00074 }
00075 
00076 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00077"></a><a class="code" href="bit-ops_8c.html#a7">00077</a> <a class="code" href="bit-ops_8c.html#a7">stpi_split_2_1</a>(<span class="keywordtype">int</span> length,
00078                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *in,
00079                <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *outhi,
00080                <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *outlo)
00081 {
00082   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *outs[2];
00083   <span class="keywordtype">int</span> i;
00084   <span class="keywordtype">int</span> row = 0;
00085   <span class="keywordtype">int</span> limit = length;
00086   outs[0] = outhi;
00087   outs[1] = outlo;
00088   memset(outs[1], 0, limit);
00089   <span class="keywordflow">for</span> (i = 0; i &lt; limit; i++)
00090     {
00091       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> inbyte = in[i];
00092       outs[0][i] = 0;
00093       <span class="keywordflow">if</span> (inbyte == 0)
00094         <span class="keywordflow">continue</span>;
00095       <span class="comment">/* For some reason gcc isn't unrolling this, even with -funroll-loops */</span>
00096       <span class="keywordflow">if</span> (inbyte &amp; 1)
00097         {
00098           outs[row][i] |= 1 &amp; inbyte;
00099           row = row ^ 1;
00100         }
00101       <span class="keywordflow">if</span> (inbyte &amp; (1 &lt;&lt; 1))
00102         {
00103           outs[row][i] |= (1 &lt;&lt; 1) &amp; inbyte;
00104           row = row ^ 1;
00105         }
00106       <span class="keywordflow">if</span> (inbyte &amp; (1 &lt;&lt; 2))
00107         {
00108           outs[row][i] |= (1 &lt;&lt; 2) &amp; inbyte;
00109           row = row ^ 1;
00110         }
00111       <span class="keywordflow">if</span> (inbyte &amp; (1 &lt;&lt; 3))
00112         {
00113           outs[row][i] |= (1 &lt;&lt; 3) &amp; inbyte;
00114           row = row ^ 1;
00115         }
00116       <span class="keywordflow">if</span> (inbyte &amp; (1 &lt;&lt; 4))
00117         {
00118           outs[row][i] |= (1 &lt;&lt; 4) &amp; inbyte;
00119           row = row ^ 1;
00120         }
00121       <span class="keywordflow">if</span> (inbyte &amp; (1 &lt;&lt; 5))
00122         {
00123           outs[row][i] |= (1 &lt;&lt; 5) &amp; inbyte;
00124           row = row ^ 1;
00125         }
00126       <span class="keywordflow">if</span> (inbyte &amp; (1 &lt;&lt; 6))
00127         {
00128           outs[row][i] |= (1 &lt;&lt; 6) &amp; inbyte;
00129           row = row ^ 1;
00130         }
00131       <span class="keywordflow">if</span> (inbyte &amp; (1 &lt;&lt; 7))
00132         {
00133           outs[row][i] |= (1 &lt;&lt; 7) &amp; inbyte;
00134           row = row ^ 1;
00135         }
00136     }
00137 }
00138 
00139 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00140"></a><a class="code" href="bit-ops_8c.html#a8">00140</a> <a class="code" href="bit-ops_8c.html#a8">stp_split_2_2</a>(<span class="keywordtype">int</span> length,
00141               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *in,
00142               <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *outhi,
00143               <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *outlo)
00144 {
00145   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *outs[2];
00146   <span class="keywordtype">int</span> i;
00147   <span class="keywordtype">unsigned</span> row = 0;
00148   <span class="keywordtype">int</span> limit = length * 2;
00149   outs[0] = outhi;
00150   outs[1] = outlo;
00151   memset(outs[1], 0, limit);
00152   <span class="keywordflow">for</span> (i = 0; i &lt; limit; i++)
00153     {
00154       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> inbyte = in[i];
00155       outs[0][i] = 0;
00156       <span class="keywordflow">if</span> (inbyte == 0)
00157         <span class="keywordflow">continue</span>;
00158       <span class="comment">/* For some reason gcc isn't unrolling this, even with -funroll-loops */</span>
00159       <span class="keywordflow">if</span> (inbyte &amp; 3)
00160         {
00161           outs[row][i] |= (3 &amp; inbyte);
00162           row = row ^ 1;
00163         }
00164       <span class="keywordflow">if</span> (inbyte &amp; (3 &lt;&lt; 2))
00165         {
00166           outs[row][i] |= ((3 &lt;&lt; 2) &amp; inbyte);
00167           row = row ^ 1;
00168         }
00169       <span class="keywordflow">if</span> (inbyte &amp; (3 &lt;&lt; 4))
00170         {
00171           outs[row][i] |= ((3 &lt;&lt; 4) &amp; inbyte);
00172           row = row ^ 1;
00173         }
00174       <span class="keywordflow">if</span> (inbyte &amp; (3 &lt;&lt; 6))
00175         {
00176           outs[row][i] |= ((3 &lt;&lt; 6) &amp; inbyte);
00177           row = row ^ 1;
00178         }
00179     }
00180 }
00181 
00182 <span class="keywordtype">void</span>
<a name="l00183"></a><a class="code" href="bit-ops_8c.html#a9">00183</a> <a class="code" href="bit-ops_8c.html#a9">stp_split_2</a>(<span class="keywordtype">int</span> length,
00184             <span class="keywordtype">int</span> bits,
00185             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *in,
00186             <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *outhi,
00187             <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *outlo)
00188 {
00189   <span class="keywordflow">if</span> (bits == 2)
00190     <a class="code" href="bit-ops_8c.html#a8">stp_split_2_2</a>(length, in, outhi, outlo);
00191   <span class="keywordflow">else</span>
00192     <a class="code" href="bit-ops_8c.html#a7">stpi_split_2_1</a>(length, in, outhi, outlo);
00193 }
00194 
00195 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00196"></a><a class="code" href="bit-ops_8c.html#a10">00196</a> <a class="code" href="bit-ops_8c.html#a10">stpi_split_4_1</a>(<span class="keywordtype">int</span> length,
00197                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *in,
00198                <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out0,
00199                <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out1,
00200                <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out2,
00201                <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out3)
00202 {
00203   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *outs[4];
00204   <span class="keywordtype">int</span> i;
00205   <span class="keywordtype">int</span> row = 0;
00206   <span class="keywordtype">int</span> limit = length;
00207   outs[0] = out0;
00208   outs[1] = out1;
00209   outs[2] = out2;
00210   outs[3] = out3;
00211   memset(outs[1], 0, limit);
00212   memset(outs[2], 0, limit);
00213   memset(outs[3], 0, limit);
00214   <span class="keywordflow">for</span> (i = 0; i &lt; limit; i++)
00215     {
00216       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> inbyte = in[i];
00217       outs[0][i] = 0;
00218       <span class="keywordflow">if</span> (inbyte == 0)
00219         <span class="keywordflow">continue</span>;
00220       <span class="comment">/* For some reason gcc isn't unrolling this, even with -funroll-loops */</span>
00221       <span class="keywordflow">if</span> (inbyte &amp; 1)
00222         {
00223           outs[row][i] |= 1 &amp; inbyte;
00224           row = (row + 1) &amp; 3;
00225         }
00226       <span class="keywordflow">if</span> (inbyte &amp; (1 &lt;&lt; 1))
00227         {
00228           outs[row][i] |= (1 &lt;&lt; 1) &amp; inbyte;
00229           row = (row + 1) &amp; 3;
00230         }
00231       <span class="keywordflow">if</span> (inbyte &amp; (1 &lt;&lt; 2))
00232         {
00233           outs[row][i] |= (1 &lt;&lt; 2) &amp; inbyte;
00234           row = (row + 1) &amp; 3;
00235         }
00236       <span class="keywordflow">if</span> (inbyte &amp; (1 &lt;&lt; 3))
00237         {
00238           outs[row][i] |= (1 &lt;&lt; 3) &amp; inbyte;
00239           row = (row + 1) &amp; 3;
00240         }
00241       <span class="keywordflow">if</span> (inbyte &amp; (1 &lt;&lt; 4))
00242         {
00243           outs[row][i] |= (1 &lt;&lt; 4) &amp; inbyte;
00244           row = (row + 1) &amp; 3;
00245         }
00246       <span class="keywordflow">if</span> (inbyte &amp; (1 &lt;&lt; 5))
00247         {
00248           outs[row][i] |= (1 &lt;&lt; 5) &amp; inbyte;
00249           row = (row + 1) &amp; 3;
00250         }
00251       <span class="keywordflow">if</span> (inbyte &amp; (1 &lt;&lt; 6))
00252         {
00253           outs[row][i] |= (1 &lt;&lt; 6) &amp; inbyte;
00254           row = (row + 1) &amp; 3;
00255         }
00256       <span class="keywordflow">if</span> (inbyte &amp; (1 &lt;&lt; 7))
00257         {
00258           outs[row][i] |= (1 &lt;&lt; 7) &amp; inbyte;
00259           row = (row + 1) &amp; 3;
00260         }
00261     }
00262 }
00263 
00264 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00265"></a><a class="code" href="bit-ops_8c.html#a11">00265</a> <a class="code" href="bit-ops_8c.html#a11">stpi_split_4_2</a>(<span class="keywordtype">int</span> length,
00266                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *in,
00267                <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out0,
00268                <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out1,
00269                <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out2,
00270                <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out3)
00271 {
00272   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *outs[4];
00273   <span class="keywordtype">int</span> i;
00274   <span class="keywordtype">int</span> row = 0;
00275   <span class="keywordtype">int</span> limit = length * 2;
00276   outs[0] = out0;
00277   outs[1] = out1;
00278   outs[2] = out2;
00279   outs[3] = out3;
00280   memset(outs[1], 0, limit);
00281   memset(outs[2], 0, limit);
00282   memset(outs[3], 0, limit);
00283   <span class="keywordflow">for</span> (i = 0; i &lt; limit; i++)
00284     {
00285       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> inbyte = in[i];
00286       outs[0][i] = 0;
00287       <span class="keywordflow">if</span> (inbyte == 0)
00288         <span class="keywordflow">continue</span>;
00289       <span class="comment">/* For some reason gcc isn't unrolling this, even with -funroll-loops */</span>
00290       <span class="keywordflow">if</span> (inbyte &amp; 3)
00291         {
00292           outs[row][i] |= 3 &amp; inbyte;
00293           row = (row + 1) &amp; 3;
00294         }
00295       <span class="keywordflow">if</span> (inbyte &amp; (3 &lt;&lt; 2))
00296         {
00297           outs[row][i] |= (3 &lt;&lt; 2) &amp; inbyte;
00298           row = (row + 1) &amp; 3;
00299         }
00300       <span class="keywordflow">if</span> (inbyte &amp; (3 &lt;&lt; 4))
00301         {
00302           outs[row][i] |= (3 &lt;&lt; 4) &amp; inbyte;
00303           row = (row + 1) &amp; 3;
00304         }
00305       <span class="keywordflow">if</span> (inbyte &amp; (3 &lt;&lt; 6))
00306         {
00307           outs[row][i] |= (3 &lt;&lt; 6) &amp; inbyte;
00308           row = (row + 1) &amp; 3;
00309         }
00310     }
00311 }
00312 
00313 <span class="keywordtype">void</span>
<a name="l00314"></a><a class="code" href="bit-ops_8c.html#a12">00314</a> <a class="code" href="bit-ops_8c.html#a12">stp_split_4</a>(<span class="keywordtype">int</span> length,
00315             <span class="keywordtype">int</span> bits,
00316             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *in,
00317             <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out0,
00318             <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out1,
00319             <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out2,
00320             <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out3)
00321 {
00322   <span class="keywordflow">if</span> (bits == 2)
00323     <a class="code" href="bit-ops_8c.html#a11">stpi_split_4_2</a>(length, in, out0, out1, out2, out3);
00324   <span class="keywordflow">else</span>
00325     <a class="code" href="bit-ops_8c.html#a10">stpi_split_4_1</a>(length, in, out0, out1, out2, out3);
00326 }
00327 
00328 
00329 <span class="preprocessor">#if __BYTE_ORDER == __LITTLE_ENDIAN</span>
<a name="l00330"></a><a class="code" href="bit-ops_8c.html#a0">00330</a> <span class="preprocessor"></span><span class="preprocessor">#define SH20 0</span>
<a name="l00331"></a><a class="code" href="bit-ops_8c.html#a1">00331</a> <span class="preprocessor"></span><span class="preprocessor">#define SH21 8</span>
00332 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00333 <span class="preprocessor"></span><span class="preprocessor">#define SH20 8</span>
00334 <span class="preprocessor"></span><span class="preprocessor">#define SH21 0</span>
00335 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00336 <span class="preprocessor"></span>
00337 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00338"></a><a class="code" href="bit-ops_8c.html#a13">00338</a> <a class="code" href="bit-ops_8c.html#a13">stpi_unpack_2_1</a>(<span class="keywordtype">int</span> length,
00339                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *in,
00340                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out0,
00341                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out1)
00342 {
00343   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> tempin, bit, temp0, temp1;
00344 
00345   <span class="keywordflow">if</span> (length &lt;= 0)
00346     <span class="keywordflow">return</span>;
00347   <span class="keywordflow">for</span> (bit = 128, temp0 = 0, temp1 = 0;
00348        length &gt; 0;
00349        length --)
00350     {
00351       tempin = *in++;
00352 
00353       <span class="keywordflow">if</span> (tempin &amp; 128)
00354         temp0 |= bit;
00355       <span class="keywordflow">if</span> (tempin &amp; 64)
00356         temp1 |= bit;
00357       bit &gt;&gt;= 1;
00358       <span class="keywordflow">if</span> (tempin &amp; 32)
00359         temp0 |= bit;
00360       <span class="keywordflow">if</span> (tempin &amp; 16)
00361         temp1 |= bit;
00362       bit &gt;&gt;= 1;
00363       <span class="keywordflow">if</span> (tempin &amp; 8)
00364         temp0 |= bit;
00365       <span class="keywordflow">if</span> (tempin &amp; 4)
00366         temp1 |= bit;
00367       bit &gt;&gt;= 1;
00368       <span class="keywordflow">if</span> (tempin &amp; 2)
00369         temp0 |= bit;
00370       <span class="keywordflow">if</span> (tempin &amp; 1)
00371         temp1 |= bit;
00372 
00373       <span class="keywordflow">if</span> (bit &gt; 1)
00374         bit &gt;&gt;= 1;
00375       <span class="keywordflow">else</span>
00376       {
00377         bit     = 128;
00378         *out0++ = temp0;
00379         *out1++ = temp1;
00380 
00381         temp0   = 0;
00382         temp1   = 0;
00383       }
00384     }
00385 
00386   <span class="keywordflow">if</span> (bit &lt; 128)
00387     {
00388       *out0++ = temp0;
00389       *out1++ = temp1;
00390     }
00391 }
00392 
00393 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00394"></a><a class="code" href="bit-ops_8c.html#a14">00394</a> <a class="code" href="bit-ops_8c.html#a14">stpi_unpack_2_2</a>(<span class="keywordtype">int</span> length,
00395                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *in,
00396                <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out0,
00397                <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out1)
00398 {
00399   <span class="keywordflow">if</span> (length &lt;= 0)
00400     <span class="keywordflow">return</span>;
00401 
00402   <span class="keywordflow">for</span> (;length;length --)
00403     {
00404       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ti0, ti1;
00405       ti0 = in[0];
00406       ti1 = in[1];
00407 
00408       *out0++  = (ti0 &amp; 0xc0) &lt;&lt; 0
00409         | (ti0 &amp; 0x0c) &lt;&lt; 2
00410         | (ti1 &amp; 0xc0) &gt;&gt; 4
00411         | (ti1 &amp; 0x0c) &gt;&gt; 2;
00412       *out1++  = (ti0 &amp; 0x30) &lt;&lt; 2
00413         | (ti0 &amp; 0x03) &lt;&lt; 4
00414         | (ti1 &amp; 0x30) &gt;&gt; 2
00415         | (ti1 &amp; 0x03) &gt;&gt; 0;
00416       in += 2;
00417     }
00418 }
00419 
00420 <span class="keywordtype">void</span>
<a name="l00421"></a><a class="code" href="bit-ops_8c.html#a15">00421</a> <a class="code" href="bit-ops_8c.html#a15">stp_unpack_2</a>(<span class="keywordtype">int</span> length,
00422              <span class="keywordtype">int</span> bits,
00423              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *in,
00424              <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *outlo,
00425              <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *outhi)
00426 {
00427   <span class="keywordflow">if</span> (bits == 1)
00428     <a class="code" href="bit-ops_8c.html#a13">stpi_unpack_2_1</a>(length, in, outlo, outhi);
00429   <span class="keywordflow">else</span>
00430     <a class="code" href="bit-ops_8c.html#a14">stpi_unpack_2_2</a>(length, in, outlo, outhi);
00431 }
00432 
00433 <span class="preprocessor">#if __BYTE_ORDER == __LITTLE_ENDIAN</span>
<a name="l00434"></a><a class="code" href="bit-ops_8c.html#a2">00434</a> <span class="preprocessor"></span><span class="preprocessor">#define SH40 0</span>
<a name="l00435"></a><a class="code" href="bit-ops_8c.html#a3">00435</a> <span class="preprocessor"></span><span class="preprocessor">#define SH41 8</span>
<a name="l00436"></a><a class="code" href="bit-ops_8c.html#a4">00436</a> <span class="preprocessor"></span><span class="preprocessor">#define SH42 16</span>
<a name="l00437"></a><a class="code" href="bit-ops_8c.html#a5">00437</a> <span class="preprocessor"></span><span class="preprocessor">#define SH43 24</span>
00438 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00439 <span class="preprocessor"></span><span class="preprocessor">#define SH40 24</span>
00440 <span class="preprocessor"></span><span class="preprocessor">#define SH41 16</span>
00441 <span class="preprocessor"></span><span class="preprocessor">#define SH42 8</span>
00442 <span class="preprocessor"></span><span class="preprocessor">#define SH43 0</span>
00443 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00444 <span class="preprocessor"></span>
00445 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00446"></a><a class="code" href="bit-ops_8c.html#a16">00446</a> <a class="code" href="bit-ops_8c.html#a16">stpi_unpack_4_1</a>(<span class="keywordtype">int</span> length,
00447                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *in,
00448                  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out0,
00449                  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out1,
00450                  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out2,
00451                  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out3)
00452 {
00453   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> tempin, bit, temp0, temp1, temp2, temp3;
00454 
00455   <span class="keywordflow">if</span> (length &lt;= 0)
00456     <span class="keywordflow">return</span>;
00457   <span class="keywordflow">for</span> (bit = 128, temp0 = 0, temp1 = 0, temp2 = 0, temp3 = 0;
00458        length &gt; 0;
00459        length --)
00460     {
00461       tempin = *in++;
00462 
00463       <span class="keywordflow">if</span> (tempin &amp; 128)
00464         temp0 |= bit;
00465       <span class="keywordflow">if</span> (tempin &amp; 64)
00466         temp1 |= bit;
00467       <span class="keywordflow">if</span> (tempin &amp; 32)
00468         temp2 |= bit;
00469       <span class="keywordflow">if</span> (tempin &amp; 16)
00470         temp3 |= bit;
00471       bit &gt;&gt;= 1;
00472       <span class="keywordflow">if</span> (tempin &amp; 8)
00473         temp0 |= bit;
00474       <span class="keywordflow">if</span> (tempin &amp; 4)
00475         temp1 |= bit;
00476       <span class="keywordflow">if</span> (tempin &amp; 2)
00477         temp2 |= bit;
00478       <span class="keywordflow">if</span> (tempin &amp; 1)
00479         temp3 |= bit;
00480 
00481       <span class="keywordflow">if</span> (bit &gt; 1)
00482         bit &gt;&gt;= 1;
00483       <span class="keywordflow">else</span>
00484       {
00485         bit     = 128;
00486         *out0++ = temp0;
00487         *out1++ = temp1;
00488         *out2++ = temp2;
00489         *out3++ = temp3;
00490 
00491         temp0   = 0;
00492         temp1   = 0;
00493         temp2   = 0;
00494         temp3   = 0;
00495       }
00496     }
00497 
00498   <span class="keywordflow">if</span> (bit &lt; 128)
00499     {
00500       *out0++ = temp0;
00501       *out1++ = temp1;
00502       *out2++ = temp2;
00503       *out3++ = temp3;
00504     }
00505 }
00506 
00507 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00508"></a><a class="code" href="bit-ops_8c.html#a17">00508</a> <a class="code" href="bit-ops_8c.html#a17">stpi_unpack_4_2</a>(<span class="keywordtype">int</span> length,
00509                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *in,
00510                  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out0,
00511                  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out1,
00512                  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out2,
00513                  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out3)
00514 {
00515   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> tempin,
00516                 shift,
00517                 temp0,
00518                 temp1,
00519                 temp2,
00520                 temp3;
00521 
00522   length *= 2;
00523 
00524   <span class="keywordflow">for</span> (shift = 0, temp0 = 0, temp1 = 0, temp2 = 0, temp3 = 0;
00525        length &gt; 0;
00526        length --)
00527     {
00528      <span class="comment">/*</span>
00529 <span class="comment">      * Note - we can't use (tempin &amp; N) &gt;&gt; (shift - M) since negative</span>
00530 <span class="comment">      * right-shifts are not always implemented.</span>
00531 <span class="comment">      */</span>
00532 
00533       tempin = *in++;
00534 
00535       <span class="keywordflow">if</span> (tempin &amp; 192)
00536         temp0 |= (tempin &amp; 192) &gt;&gt; shift;
00537       <span class="keywordflow">if</span> (tempin &amp; 48)
00538         temp1 |= ((tempin &amp; 48) &lt;&lt; 2) &gt;&gt; shift;
00539       <span class="keywordflow">if</span> (tempin &amp; 12)
00540         temp2 |= ((tempin &amp; 12) &lt;&lt; 4) &gt;&gt; shift;
00541       <span class="keywordflow">if</span> (tempin &amp; 3)
00542         temp3 |= ((tempin &amp; 3) &lt;&lt; 6) &gt;&gt; shift;
00543 
00544       <span class="keywordflow">if</span> (shift &lt; 6)
00545         shift += 2;
00546       <span class="keywordflow">else</span>
00547       {
00548         shift   = 0;
00549         *out0++ = temp0;
00550         *out1++ = temp1;
00551         *out2++ = temp2;
00552         *out3++ = temp3;
00553 
00554         temp0   = 0;
00555         temp1   = 0;
00556         temp2   = 0;
00557         temp3   = 0;
00558       }
00559     }
00560 
00561   <span class="keywordflow">if</span> (shift)
00562     {
00563       *out0++ = temp0;
00564       *out1++ = temp1;
00565       *out2++ = temp2;
00566       *out3++ = temp3;
00567     }
00568 }
00569 
00570 <span class="keywordtype">void</span>
<a name="l00571"></a><a class="code" href="bit-ops_8c.html#a18">00571</a> <a class="code" href="bit-ops_8c.html#a18">stp_unpack_4</a>(<span class="keywordtype">int</span> length,
00572              <span class="keywordtype">int</span> bits,
00573              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *in,
00574              <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out0,
00575              <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out1,
00576              <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out2,
00577              <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out3)
00578 {
00579   <span class="keywordflow">if</span> (bits == 1)
00580     <a class="code" href="bit-ops_8c.html#a16">stpi_unpack_4_1</a>(length, in, out0, out1, out2, out3);
00581   <span class="keywordflow">else</span>
00582     <a class="code" href="bit-ops_8c.html#a17">stpi_unpack_4_2</a>(length, in, out0, out1, out2, out3);
00583 }
00584 
00585 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00586"></a><a class="code" href="bit-ops_8c.html#a19">00586</a> <a class="code" href="bit-ops_8c.html#a19">stpi_unpack_8_1</a>(<span class="keywordtype">int</span> length,
00587                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *in,
00588                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out0,
00589                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out1,
00590                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out2,
00591                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out3,
00592                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out4,
00593                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out5,
00594                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out6,
00595                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out7)
00596 {
00597   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> tempin, bit, temp0, temp1, temp2, temp3, temp4, temp5, temp6,
00598     temp7;
00599 
00600   <span class="keywordflow">if</span> (length &lt;= 0)
00601     <span class="keywordflow">return</span>;
00602 
00603   <span class="keywordflow">for</span> (bit = 128, temp0 = 0, temp1 = 0, temp2 = 0,
00604        temp3 = 0, temp4 = 0, temp5 = 0, temp6 = 0, temp7 = 0;
00605        length &gt; 0;
00606        length --)
00607     {
00608       tempin = *in++;
00609 
00610       <span class="keywordflow">if</span> (tempin &amp; 128)
00611         temp0 |= bit;
00612       <span class="keywordflow">if</span> (tempin &amp; 64)
00613         temp1 |= bit;
00614       <span class="keywordflow">if</span> (tempin &amp; 32)
00615         temp2 |= bit;
00616       <span class="keywordflow">if</span> (tempin &amp; 16)
00617         temp3 |= bit;
00618       <span class="keywordflow">if</span> (tempin &amp; 8)
00619         temp4 |= bit;
00620       <span class="keywordflow">if</span> (tempin &amp; 4)
00621         temp5 |= bit;
00622       <span class="keywordflow">if</span> (tempin &amp; 2)
00623         temp6 |= bit;
00624       <span class="keywordflow">if</span> (tempin &amp; 1)
00625         temp7 |= bit;
00626 
00627       <span class="keywordflow">if</span> (bit &gt; 1)
00628         bit &gt;&gt;= 1;
00629       <span class="keywordflow">else</span>
00630       {
00631         bit     = 128;
00632         *out0++ = temp0;
00633         *out1++ = temp1;
00634         *out2++ = temp2;
00635         *out3++ = temp3;
00636         *out4++ = temp4;
00637         *out5++ = temp5;
00638         *out6++ = temp6;
00639         *out7++ = temp7;
00640 
00641         temp0   = 0;
00642         temp1   = 0;
00643         temp2   = 0;
00644         temp3   = 0;
00645         temp4   = 0;
00646         temp5   = 0;
00647         temp6   = 0;
00648         temp7   = 0;
00649       }
00650     }
00651 
00652   <span class="keywordflow">if</span> (bit &lt; 128)
00653     {
00654       *out0++ = temp0;
00655       *out1++ = temp1;
00656       *out2++ = temp2;
00657       *out3++ = temp3;
00658       *out4++ = temp4;
00659       *out5++ = temp5;
00660       *out6++ = temp6;
00661       *out7++ = temp7;
00662     }
00663 }
00664 
00665 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00666"></a><a class="code" href="bit-ops_8c.html#a20">00666</a> <a class="code" href="bit-ops_8c.html#a20">stpi_unpack_8_2</a>(<span class="keywordtype">int</span> length,
00667                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *in,
00668                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out0,
00669                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out1,
00670                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out2,
00671                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out3,
00672                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out4,
00673                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out5,
00674                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out6,
00675                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out7)
00676 {
00677   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> tempin,
00678                 shift,
00679                 temp0,
00680                 temp1,
00681                 temp2,
00682                 temp3,
00683                 temp4,
00684                 temp5,
00685                 temp6,
00686                 temp7;
00687 
00688 
00689   <span class="keywordflow">for</span> (shift = 0, temp0 = 0, temp1 = 0,
00690        temp2 = 0, temp3 = 0, temp4 = 0, temp5 = 0, temp6 = 0, temp7 = 0;
00691        length &gt; 0;
00692        length --)
00693     {
00694      <span class="comment">/*</span>
00695 <span class="comment">      * Note - we can't use (tempin &amp; N) &gt;&gt; (shift - M) since negative</span>
00696 <span class="comment">      * right-shifts are not always implemented.</span>
00697 <span class="comment">      */</span>
00698 
00699       tempin = *in++;
00700 
00701       <span class="keywordflow">if</span> (tempin &amp; 192)
00702         temp0 |= (tempin &amp; 192) &gt;&gt; shift;
00703       <span class="keywordflow">if</span> (tempin &amp; 48)
00704         temp1 |= ((tempin &amp; 48) &lt;&lt; 2) &gt;&gt; shift;
00705       <span class="keywordflow">if</span> (tempin &amp; 12)
00706         temp2 |= ((tempin &amp; 12) &lt;&lt; 4) &gt;&gt; shift;
00707       <span class="keywordflow">if</span> (tempin &amp; 3)
00708         temp3 |= ((tempin &amp; 3) &lt;&lt; 6) &gt;&gt; shift;
00709 
00710       tempin = *in++;
00711 
00712       <span class="keywordflow">if</span> (tempin &amp; 192)
00713         temp4 |= (tempin &amp; 192) &gt;&gt; shift;
00714       <span class="keywordflow">if</span> (tempin &amp; 48)
00715         temp5 |= ((tempin &amp; 48) &lt;&lt; 2) &gt;&gt; shift;
00716       <span class="keywordflow">if</span> (tempin &amp; 12)
00717         temp6 |= ((tempin &amp; 12) &lt;&lt; 4) &gt;&gt; shift;
00718       <span class="keywordflow">if</span> (tempin &amp; 3)
00719         temp7 |= ((tempin &amp; 3) &lt;&lt; 6) &gt;&gt; shift;
00720 
00721       <span class="keywordflow">if</span> (shift &lt; 6)
00722         shift += 2;
00723       <span class="keywordflow">else</span>
00724       {
00725         shift   = 0;
00726         *out0++ = temp0;
00727         *out1++ = temp1;
00728         *out2++ = temp2;
00729         *out3++ = temp3;
00730         *out4++ = temp4;
00731         *out5++ = temp5;
00732         *out6++ = temp6;
00733         *out7++ = temp7;
00734 
00735         temp0   = 0;
00736         temp1   = 0;
00737         temp2   = 0;
00738         temp3   = 0;
00739         temp4   = 0;
00740         temp5   = 0;
00741         temp6   = 0;
00742         temp7   = 0;
00743       }
00744     }
00745 
00746   <span class="keywordflow">if</span> (shift)
00747     {
00748       *out0++ = temp0;
00749       *out1++ = temp1;
00750       *out2++ = temp2;
00751       *out3++ = temp3;
00752       *out4++ = temp4;
00753       *out5++ = temp5;
00754       *out6++ = temp6;
00755       *out7++ = temp7;
00756     }
00757 }
00758 
00759 <span class="keywordtype">void</span>
<a name="l00760"></a><a class="code" href="bit-ops_8c.html#a21">00760</a> <a class="code" href="bit-ops_8c.html#a21">stp_unpack_8</a>(<span class="keywordtype">int</span> length,
00761              <span class="keywordtype">int</span> bits,
00762              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *in,
00763              <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out0,
00764              <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out1,
00765              <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out2,
00766              <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out3,
00767              <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out4,
00768              <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out5,
00769              <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out6,
00770              <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out7)
00771 {
00772   <span class="keywordflow">if</span> (bits == 1)
00773     <a class="code" href="bit-ops_8c.html#a19">stpi_unpack_8_1</a>(length, in, out0, out1, out2, out3,
00774                      out4, out5, out6, out7);
00775   <span class="keywordflow">else</span>
00776     <a class="code" href="bit-ops_8c.html#a20">stpi_unpack_8_2</a>(length, in, out0, out1, out2, out3,
00777                      out4, out5, out6, out7);
00778 }
00779 
00780 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00781"></a><a class="code" href="bit-ops_8c.html#a22">00781</a> <a class="code" href="bit-ops_8c.html#a22">find_first_and_last</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *line, <span class="keywordtype">int</span> length,
00782                     <span class="keywordtype">int</span> *first, <span class="keywordtype">int</span> *last)
00783 {
00784   <span class="keywordtype">int</span> i;
00785   <span class="keywordtype">int</span> found_first = 0;
00786   <span class="keywordflow">if</span> (!first || !last)
00787     <span class="keywordflow">return</span>;
00788   *first = 0;
00789   *last = 0;
00790   <span class="keywordflow">for</span> (i = 0; i &lt; length; i++)
00791     {
00792       <span class="keywordflow">if</span> (line[i] == 0)
00793         {
00794           <span class="keywordflow">if</span> (!found_first)
00795             (*first)++;
00796         }
00797       <span class="keywordflow">else</span>
00798         {
00799           *last = i;
00800           found_first = 1;
00801         }
00802     }
00803 }
00804 
00805 <span class="keywordtype">int</span>
<a name="l00806"></a><a class="code" href="bit-ops_8c.html#a23">00806</a> <a class="code" href="bit-ops_8c.html#a23">stp_pack_uncompressed</a>(<a class="code" href="structstp__vars.html">stp_vars_t</a> *v,
00807                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *line,
00808                       <span class="keywordtype">int</span> length,
00809                       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *comp_buf,
00810                       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> **comp_ptr,
00811                       <span class="keywordtype">int</span> *first,
00812                       <span class="keywordtype">int</span> *last)
00813 {
00814   <a class="code" href="bit-ops_8c.html#a22">find_first_and_last</a>(line, length, first, last);
00815   memcpy(comp_buf, line, length);
00816   *comp_ptr = comp_buf + length;
00817   <span class="keywordflow">if</span> (first &gt; last)
00818     <span class="keywordflow">return</span> 0;
00819   <span class="keywordflow">else</span>
00820     <span class="keywordflow">return</span> 1;
00821 }
00822 
00823 <span class="keywordtype">int</span>
<a name="l00824"></a><a class="code" href="bit-ops_8c.html#a24">00824</a> <a class="code" href="bit-ops_8c.html#a24">stp_pack_tiff</a>(<a class="code" href="structstp__vars.html">stp_vars_t</a> *v,
00825               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *line,
00826               <span class="keywordtype">int</span> length,
00827               <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *comp_buf,
00828               <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> **comp_ptr,
00829               <span class="keywordtype">int</span> *first,
00830               <span class="keywordtype">int</span> *last)
00831 {
00832   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *start;           <span class="comment">/* Start of compressed data */</span>
00833   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> repeat;                 <span class="comment">/* Repeating char */</span>
00834   <span class="keywordtype">int</span> count;                    <span class="comment">/* Count of compressed bytes */</span>
00835   <span class="keywordtype">int</span> tcount;                   <span class="comment">/* Temporary count &lt; 128 */</span>
00836   <span class="keyword">register</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *xline = line;
00837   <span class="keyword">register</span> <span class="keywordtype">int</span> xlength = length;
00838   <a class="code" href="bit-ops_8c.html#a22">find_first_and_last</a>(line, length, first, last);
00839 
00840   <span class="comment">/*</span>
00841 <span class="comment">   * Compress using TIFF "packbits" run-length encoding...</span>
00842 <span class="comment">   */</span>
00843 
00844   (*comp_ptr) = comp_buf;
00845 
00846   <span class="keywordflow">while</span> (xlength &gt; 0)
00847     {
00848       <span class="comment">/*</span>
00849 <span class="comment">       * Get a run of non-repeated chars...</span>
00850 <span class="comment">       */</span>
00851 
00852       start  = xline;
00853       xline   += 2;
00854       xlength -= 2;
00855 
00856       <span class="keywordflow">while</span> (xlength &gt; 0 &amp;&amp; (xline[-2] != xline[-1] || xline[-1] != xline[0]))
00857         {
00858           xline ++;
00859           xlength --;
00860         }
00861 
00862       xline   -= 2;
00863       xlength += 2;
00864 
00865       <span class="comment">/*</span>
00866 <span class="comment">       * Output the non-repeated sequences (max 128 at a time).</span>
00867 <span class="comment">       */</span>
00868 
00869       count = xline - start;
00870       <span class="keywordflow">while</span> (count &gt; 0)
00871         {
00872           tcount = count &gt; 128 ? 128 : count;
00873 
00874           (*comp_ptr)[0] = tcount - 1;
00875           memcpy((*comp_ptr) + 1, start, tcount);
00876 
00877           (*comp_ptr) += tcount + 1;
00878           start    += tcount;
00879           count    -= tcount;
00880         }
00881 
00882       <span class="keywordflow">if</span> (xlength &lt;= 0)
00883         <span class="keywordflow">break</span>;
00884 
00885       <span class="comment">/*</span>
00886 <span class="comment">       * Find the repeated sequences...</span>
00887 <span class="comment">       */</span>
00888 
00889       start  = xline;
00890       repeat = xline[0];
00891 
00892       xline ++;
00893       xlength --;
00894 
00895       <span class="keywordflow">if</span> (xlength &gt; 0)
00896         {
00897           <span class="keywordtype">int</span> ylength = xlength;
00898           <span class="keywordflow">while</span> (ylength &amp;&amp; *xline == repeat)
00899             {
00900               xline ++;
00901               ylength --;
00902             }
00903           xlength = ylength;
00904         }
00905 
00906       <span class="comment">/*</span>
00907 <span class="comment">       * Output the repeated sequences (max 128 at a time).</span>
00908 <span class="comment">       */</span>
00909 
00910       count = xline - start;
00911       <span class="keywordflow">while</span> (count &gt; 0)
00912         {
00913           tcount = count &gt; 128 ? 128 : count;
00914 
00915           (*comp_ptr)[0] = 1 - tcount;
00916           (*comp_ptr)[1] = repeat;
00917 
00918           (*comp_ptr) += 2;
00919           count    -= tcount;
00920         }
00921     }
00922   <span class="keywordflow">if</span> (first &amp;&amp; last &amp;&amp; *first &gt; *last)
00923     <span class="keywordflow">return</span> 0;
00924   <span class="keywordflow">else</span>
00925     <span class="keywordflow">return</span> 1;
00926 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Aug 25 07:56:13 2004 for libgimpprint API Reference by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > </a>1.3.6 </small></address>
</body>
</html>
