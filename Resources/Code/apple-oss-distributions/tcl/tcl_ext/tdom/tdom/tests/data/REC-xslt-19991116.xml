<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Id: REC-xslt-19991116.xml,v 1.1 2002/03/03 01:03:02 rolf Exp $ -->
<!DOCTYPE spec PUBLIC "-//W3C//DTD Specification V2.0//EN"
                      "/XML/1998/06/xmlspec-v20.dtd" [
<!ENTITY XML "http://www.w3.org/TR/REC-xml">
<!ENTITY XMLNames "http://www.w3.org/TR/REC-xml-names">
<!ENTITY XSLT.ns "http://www.w3.org/1999/XSL/Transform">
<!ENTITY XSLTA.ns "http://www.w3.org/1999/XSL/TransformAlias">
<!ENTITY XSLFO.ns "http://www.w3.org/1999/XSL/Format">
<!ENTITY XHTML.ns "http://www.w3.org/TR/xhtml1/strict">
<!ENTITY year "1999">
<!ENTITY month "November">
<!ENTITY MM "11">
<!ENTITY day "16">
<!ENTITY DD "16">
<!ENTITY YYYYMMDD "&year;&MM;&DD;">
<!ENTITY LEV "REC">
<!ENTITY XPath "http://www.w3.org/TR/xpath">
<!ATTLIST xfunction href CDATA "&XPath;">
<!-- DTD customizations -->
<!ELEMENT proto (arg*)>
<!ATTLIST proto
  name NMTOKEN #REQUIRED
  return-type (number|string|boolean|node-set|object) #REQUIRED
>
<!ELEMENT arg EMPTY>
<!ATTLIST arg
  type (number|string|boolean|node-set|object) #REQUIRED
  occur (opt|rep) #IMPLIED
>
<!ELEMENT function (#PCDATA)>
<!ELEMENT xfunction (#PCDATA)>
<!ATTLIST xfunction href CDATA #REQUIRED>
<!ELEMENT e:element-syntax
  (e:in-category*, e:attribute*, (e:empty|e:text|e:element|e:model|e:sequence|e:choice))
>
<!ATTLIST e:element-syntax
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
  name NMTOKEN #REQUIRED
>
<!ELEMENT e:in-category EMPTY>
<!ATTLIST
  e:in-category name NMTOKEN #REQUIRED
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
>
<!ELEMENT e:attribute (e:attribute-value-template|(e:constant|e:data-type)+)>
<!ATTLIST e:attribute
  name NMTOKEN #REQUIRED
  required (yes) #IMPLIED
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
>
<!ELEMENT e:attribute-value-template (e:constant|e:data-type)+>
<!ATTLIST e:attribute-value-template
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
>
<!ELEMENT e:constant EMPTY>
<!ATTLIST
  e:constant value CDATA #REQUIRED
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
>
<!ELEMENT e:data-type EMPTY>
<!ATTLIST e:data-type
  name NMTOKEN #REQUIRED
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
>
<!ELEMENT e:empty EMPTY>
<!ATTLIST e:empty
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
>
<!ELEMENT e:text EMPTY>
<!ATTLIST e:text
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
>
<!ELEMENT e:element EMPTY>
<!ATTLIST e:element
  name NMTOKEN #REQUIRED
  repeat (zero-or-one|zero-or-more|one-or-more) #IMPLIED
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
>
<!ELEMENT e:model EMPTY>
<!ATTLIST e:model
  name NMTOKEN #REQUIRED
  repeat (zero-or-one|zero-or-more|one-or-more) #IMPLIED
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
>
<!ELEMENT e:sequence (e:element|e:model|e:choice)+>
<!ATTLIST e:sequence
  repeat (zero-or-one|zero-or-more|one-or-more) #IMPLIED
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
>
<!ELEMENT e:choice (e:element|e:model|e:sequence)+>
<!ATTLIST e:choice
  repeat (zero-or-one|zero-or-more|one-or-more) #IMPLIED
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
>
<!ELEMENT e:element-syntax-summary EMPTY>
<!ATTLIST e:element-syntax-summary 
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
>
<!ENTITY % local.illus.class "|proto|e:element-syntax|e:element-syntax-summary">
<!ENTITY % local.tech.class "|function|xfunction">
<!ENTITY % local.loc.class "|var">
<!ELEMENT var (#PCDATA)>
<!ATTLIST spec
  xmlns:e CDATA #FIXED "http://www.w3.org/1999/XSL/Spec/ElementSyntax"
>
]>
<spec xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax">
<header>
<title>XSL Transformations (XSLT)</title>
<version>Version 1.0</version>
<w3c-designation>&LEV;-xslt-&YYYYMMDD;</w3c-designation>
<w3c-doctype>W3C Recommendation</w3c-doctype>
<pubdate><day>&day;</day><month>&month;</month><year>&year;</year></pubdate>
<publoc>
<loc href="http://www.w3.org/TR/&year;/&LEV;-xslt-&YYYYMMDD;"
          >http://www.w3.org/TR/&year;/&LEV;-xslt-&YYYYMMDD;</loc>
<loc role="available-format"
href="http://www.w3.org/TR/&year;/&LEV;-xslt-&YYYYMMDD;.xml">XML</loc>
<loc role="available-format"
href="http://www.w3.org/TR/&year;/&LEV;-xslt-&YYYYMMDD;.html">HTML</loc>
<!--
<loc href="http://www.w3.org/TR/&year;/&LEV;-xslt-&YYYYMMDD;.pdf"
          >http://www.w3.org/TR/&year;/&LEV;-xslt-&YYYYMMDD;.pdf</loc>
-->
</publoc>
<latestloc>
<loc href="http://www.w3.org/TR/xslt"
          >http://www.w3.org/TR/xslt</loc>
</latestloc>
<prevlocs>
<loc href="http://www.w3.org/TR/1999/PR-xslt-19991008"
          >http://www.w3.org/TR/1999/PR-xslt-19991008</loc>
<loc href="http://www.w3.org/1999/08/WD-xslt-19990813"
          >http://www.w3.org/1999/08/WD-xslt-19990813</loc>
<loc href="http://www.w3.org/1999/07/WD-xslt-19990709"
          >http://www.w3.org/1999/07/WD-xslt-19990709</loc>
<loc href="http://www.w3.org/TR/1999/WD-xslt-19990421"
          >http://www.w3.org/TR/1999/WD-xslt-19990421</loc>
<loc href="http://www.w3.org/TR/1998/WD-xsl-19981216"
          >http://www.w3.org/TR/1998/WD-xsl-19981216</loc>
<loc href="http://www.w3.org/TR/1998/WD-xsl-19980818"
          >http://www.w3.org/TR/1998/WD-xsl-19980818</loc>
</prevlocs>
<authlist>
<author>
<name>James Clark</name>
<email href="mailto:jjc@jclark.com">jjc@jclark.com</email>
</author>
</authlist>

<status>

<p>This document has been reviewed by W3C Members and other interested
parties and has been endorsed by the Director as a W3C <loc
href="http://www.w3.org/Consortium/Process/#RecsW3C">Recommendation</loc>. It
is a stable document and may be used as reference material or cited as
a normative reference from other documents. W3C's role in making the
Recommendation is to draw attention to the specification and to
promote its widespread deployment. This enhances the functionality and
interoperability of the Web.</p>

<p>The list of known errors in this specification is available at
<loc href="http://www.w3.org/&year;/&MM;/&LEV;-xslt-&YYYYMMDD;-errata"
>http://www.w3.org/&year;/&MM;/&LEV;-xslt-&YYYYMMDD;-errata</loc>.</p>

<p>Comments on this specification may be sent to <loc
href="mailto:xsl-editors@w3.org">xsl-editors@w3.org</loc>; <loc
href="http://lists.w3.org/Archives/Public/xsl-editors">archives</loc>
of the comments are available.  Public discussion of XSL, including
XSL Transformations, takes place on the <loc
href="http://www.mulberrytech.com/xsl/xsl-list/index.html">XSL-List</loc>
mailing list.</p>

<p>The English version of this specification is the only normative
version. However, for translations of this document, see <loc
href="http://www.w3.org/Style/XSL/translations.html"
>http://www.w3.org/Style/XSL/translations.html</loc>.</p>

<p>A list of current W3C Recommendations and other technical documents
can be found at <loc
href="http://www.w3.org/TR">http://www.w3.org/TR</loc>.</p>

<p>This specification has been produced as part of the <loc
href="http://www.w3.org/Style/Activity">W3C Style activity</loc>.</p>

</status>

<abstract>

<p>This specification defines the syntax and semantics of XSLT, which
is a language for transforming XML documents into other XML
documents.</p>

<p>XSLT is designed for use as part of XSL, which is a stylesheet
language for XML. In addition to XSLT, XSL includes an XML vocabulary
for specifying formatting.  XSL specifies the styling of an XML
document by using XSLT to describe how the document is transformed
into another XML document that uses the formatting vocabulary.</p>

<p>XSLT is also designed to be used independently of XSL.  However,
XSLT is not intended as a completely general-purpose XML
transformation language.  Rather it is designed primarily for the
kinds of transformations that are needed when XSLT is used as part of
XSL.</p>

</abstract>

<langusage>
<language id="EN">English</language>
<language id="ebnf">EBNF</language>
</langusage>
<revisiondesc>
<slist>
<sitem>See RCS log for revision history.</sitem>
</slist>
</revisiondesc>
</header>
<body>
<div1>
<head>Introduction</head>

<p>This specification defines the syntax and semantics of the XSLT
language.  A transformation in the XSLT language is expressed as a
well-formed XML document <bibref ref="XML"/> conforming to the
Namespaces in XML Recommendation <bibref ref="XMLNAMES"/>, which may
include both elements that are defined by XSLT and elements that are
not defined by XSLT.  <termdef id="dt-xslt-namespace" term="XSLT
Namespace">XSLT-defined elements are distinguished by belonging to a
specific XML namespace (see <specref ref="xslt-namespace"/>), which is
referred to in this specification as the <term>XSLT
namespace</term>.</termdef> Thus this specification is a definition of
the syntax and semantics of the XSLT namespace.</p>

<p>A transformation expressed in XSLT describes rules for transforming
a source tree into a result tree.  The transformation is achieved by
associating patterns with templates.  A pattern is matched against
elements in the source tree.  A template is instantiated to create
part of the result tree.  The result tree is separate from the source
tree.  The structure of the result tree can be completely different
from the structure of the source tree. In constructing the result
tree, elements from the source tree can be filtered and reordered, and
arbitrary structure can be added.</p>

<p>A transformation expressed in XSLT is called a stylesheet.  This is
because, in the case when XSLT is transforming into the XSL formatting
vocabulary, the transformation functions as a stylesheet.</p>

<p>This document does not specify how an XSLT stylesheet is associated
with an XML document.  It is recommended that XSL processors support
the mechanism described in <bibref ref="XMLSTYLE"/>.  When this or any
other mechanism yields a sequence of more than one XSLT stylesheet to
be applied simultaneously to a XML document, then the effect
should be the same as applying a single stylesheet that imports each
member of the sequence in order (see <specref ref="import"/>).</p>

<p>A stylesheet contains a set of template rules.  A template rule has
two parts: a pattern which is matched against nodes in the source tree
and a template which can be instantiated to form part of the result
tree.  This allows a stylesheet to be applicable to a wide class of
documents that have similar source tree structures.</p>

<p>A template is instantiated for a particular source element
to create part of the result tree. A template can contain elements
that specify literal result element structure.  A template can also
contain elements from the XSLT namespace
that are instructions for creating result tree
fragments.  When a template is instantiated, each instruction is
executed and replaced by the result tree fragment that it creates.
Instructions can select and process descendant source elements.  Processing a
descendant element creates a result tree fragment by finding the
applicable template rule and instantiating its template. Note
that elements are only processed when they have been selected by the
execution of an instruction.  The result tree is constructed by
finding the template rule for the root node and instantiating
its template.</p>

<p>In the process of finding the applicable template rule, more
than one template rule may have a pattern that matches a given
element. However, only one template rule will be applied. The
method for deciding which template rule to apply is described
in <specref ref="conflict"/>.</p>

<p>A single template by itself has considerable power: it can create
structures of arbitrary complexity; it can pull string values out of
arbitrary locations in the source tree; it can generate structures
that are repeated according to the occurrence of elements in the
source tree.  For simple transformations where the structure of the
result tree is independent of the structure of the source tree, a
stylesheet can often consist of only a single template, which
functions as a template for the complete result tree.  Transformations
on XML documents that represent data are often of this kind (see
<specref ref="data-example"/>). XSLT allows a simplified syntax for
such stylesheets (see <specref ref="result-element-stylesheet"/>).</p>

<p>When a template is instantiated, it is always instantiated with
respect to a <termdef id="dt-current-node" term="Current
Node"><term>current node</term></termdef> and a <termdef
id="dt-current-node-list" term="Current Node List"><term>current node
list</term></termdef>. The current node is always a member of the
current node list.  Many operations in XSLT are relative to the
current node. Only a few instructions change the current node list or
the current node (see <specref ref="rules"/> and <specref
ref="for-each"/>); during the instantiation of one of these
instructions, the current node list changes to a new list of nodes and
each member of this new list becomes the current node in turn; after
the instantiation of the instruction is complete, the current node and
current node list revert to what they were before the instruction was
instantiated.</p>

<p>XSLT makes use of the expression language defined by <bibref
ref="XPATH"/> for selecting elements for processing, for conditional
processing and for generating text.</p>

<p>XSLT provides two <quote>hooks</quote> for extending the language,
one hook for extending the set of instruction elements used in
templates and one hook for extending the set of functions used in
XPath expressions.  These hooks are both based on XML namespaces.
This version of XSLT does not define a mechanism for implementing the
hooks. See <specref ref="extension"/>.</p>

<note><p>The XSL WG intends to define such a mechanism in a future
version of this specification or in a separate
specification.</p></note>

<p>The element syntax summary notation used to describe the syntax of
XSLT-defined elements is described in <specref ref="notation"/>.</p>

<p>The MIME media types <code>text/xml</code> and
<code>application/xml</code> <bibref ref="RFC2376"/> should be used
for XSLT stylesheets.  It is possible that a media type will be
registered specifically for XSLT stylesheets; if and when it is, that
media type may also be used.</p>

</div1>

<div1>
<head>Stylesheet Structure</head>

<div2 id="xslt-namespace">
<head>XSLT Namespace</head>

<p>The XSLT namespace has the URI <code>&XSLT.ns;</code>.</p>

<note><p>The <code>1999</code> in the URI indicates the year in which
the URI was allocated by the W3C.  It does not indicate the version of
XSLT being used, which is specified by attributes (see <specref
ref="stylesheet-element"/> and <specref
ref="result-element-stylesheet"/>).</p></note>

<p>XSLT processors must use the XML namespaces mechanism <bibref
ref="XMLNAMES"/> to recognize elements and attributes from this
namespace. Elements from the XSLT namespace are recognized only in the
stylesheet not in the source document. The complete list of
XSLT-defined elements is specified in <specref
ref="element-syntax-summary"/>.  Vendors must not extend the XSLT
namespace with additional elements or attributes. Instead, any
extension must be in a separate namespace.  Any namespace that is used
for additional instruction elements must be identified by means of the
extension element mechanism specified in <specref
ref="extension-element"/>.</p>

<p>This specification uses a prefix of <code>xsl:</code> for referring
to elements in the XSLT namespace. However, XSLT stylesheets are free
to use any prefix, provided that there is a namespace declaration that
binds the prefix to the URI of the XSLT namespace.</p>

<p>An element from the XSLT namespace may have any attribute not from
the XSLT namespace, provided that the <xtermref
href="&XPath;#dt-expanded-name">expanded-name</xtermref> of the
attribute has a non-null namespace URI.  The presence of such
attributes must not change the behavior of XSLT elements and functions
defined in this document. Thus, an XSLT processor is always free to
ignore such attributes, and must ignore such attributes without giving
an error if it does not recognize the namespace URI. Such attributes
can provide, for example, unique identifiers, optimization hints, or
documentation.</p>

<p>It is an error for an element from the XSLT namespace to have
attributes with expanded-names that have null namespace URIs
(i.e. attributes with unprefixed names) other than attributes defined
for the element in this document.</p>

<note><p>The conventions used for the names of XSLT elements,
attributes and functions are that names are all lower-case, use
hyphens to separate words, and use abbreviations only if they already
appear in the syntax of a related language such as XML or
HTML.</p></note>


</div2>

<div2 id="stylesheet-element">
<head>Stylesheet Element</head>

<e:element-syntax name="stylesheet">
  <e:attribute name="id">
    <e:data-type name="id"/>
  </e:attribute>
  <e:attribute name="extension-element-prefixes">
    <e:data-type name="tokens"/>
  </e:attribute>
  <e:attribute name="exclude-result-prefixes">
    <e:data-type name="tokens"/>
  </e:attribute>
  <e:attribute name="version" required="yes">
    <e:data-type name="number"/>
  </e:attribute>
  <e:sequence>
    <e:element repeat="zero-or-more" name="import"/>
    <e:model name="top-level-elements"/>
  </e:sequence>
</e:element-syntax>

<e:element-syntax name="transform">
  <e:attribute name="id">
    <e:data-type name="id"/>
  </e:attribute>
  <e:attribute name="extension-element-prefixes">
    <e:data-type name="tokens"/>
  </e:attribute>
  <e:attribute name="exclude-result-prefixes">
    <e:data-type name="tokens"/>
  </e:attribute>
  <e:attribute name="version" required="yes">
    <e:data-type name="number"/>
  </e:attribute>
  <e:sequence>
    <e:element repeat="zero-or-more" name="import"/>
    <e:model name="top-level-elements"/>
  </e:sequence>
</e:element-syntax>

<p>A stylesheet is represented by an <code>xsl:stylesheet</code>
element in an XML document.  <code>xsl:transform</code> is allowed as
a synonym for <code>xsl:stylesheet</code>.</p>

<p>An <code>xsl:stylesheet</code> element must have a
<code>version</code> attribute, indicating the version of XSLT that
the stylesheet requires.  For this version of XSLT, the value should
be <code>1.0</code>.  When the value is not equal to <code>1.0</code>,
forwards-compatible processing mode is enabled (see <specref
ref="forwards"/>).</p>

<p>The <code>xsl:stylesheet</code> element may contain the following types
of elements:</p>
<ulist>
<item><p><code>xsl:import</code></p></item>
<item><p><code>xsl:include</code></p></item>
<item><p><code>xsl:strip-space</code></p></item>
<item><p><code>xsl:preserve-space</code></p></item>
<item><p><code>xsl:output</code></p></item>
<item><p><code>xsl:key</code></p></item>
<item><p><code>xsl:decimal-format</code></p></item>
<item><p><code>xsl:namespace-alias</code></p></item>
<item><p><code>xsl:attribute-set</code></p></item>
<item><p><code>xsl:variable</code></p></item>
<item><p><code>xsl:param</code></p></item>
<item><p><code>xsl:template</code></p></item>
</ulist>

<p><termdef id="dt-top-level" term="Top-level">An element occurring as
a child of an <code>xsl:stylesheet</code> element is called a
<term>top-level</term> element.</termdef></p>

<p>This example shows the structure of a stylesheet.  Ellipses
(<code>...</code>) indicate where attribute values or content have
been omitted.  Although this example shows one of each type of allowed
element, stylesheets may contain zero or more of each of these
elements.</p>

<eg>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="&XSLT.ns;"><![CDATA[
  <xsl:import href="..."/>

  <xsl:include href="..."/>

  <xsl:strip-space elements="..."/>
  
  <xsl:preserve-space elements="..."/>

  <xsl:output method="..."/>

  <xsl:key name="..." match="..." use="..."/>

  <xsl:decimal-format name="..."/>

  <xsl:namespace-alias stylesheet-prefix="..." result-prefix="..."/>

  <xsl:attribute-set name="...">
    ...
  </xsl:attribute-set>

  <xsl:variable name="...">...</xsl:variable>

  <xsl:param name="...">...</xsl:param>

  <xsl:template match="...">
    ...
  </xsl:template>

  <xsl:template name="...">
    ...
  </xsl:template>

</xsl:stylesheet>]]></eg>

<p>The order in which the children of the <code>xsl:stylesheet</code>
element occur is not significant except for <code>xsl:import</code>
elements and for error recovery.  Users are free to order the elements
as they prefer, and stylesheet creation tools need not provide control
over the order in which the elements occur.</p>

<p>In addition, the <code>xsl:stylesheet</code> element may contain
any element not from the XSLT namespace, provided that the
expanded-name of the element has a non-null namespace URI.  The presence of
such top-level elements must not change the behavior of XSLT elements
and functions defined in this document; for example, it would not be
permitted for such a top-level element to specify that
<code>xsl:apply-templates</code> was to use different rules to resolve
conflicts. Thus, an XSLT processor is always free to ignore such
top-level elements, and must ignore a top-level element without giving
an error if it does not recognize the namespace URI. Such elements can
provide, for example,</p>

<ulist>

<item><p>information used by extension elements or extension functions
(see <specref ref="extension"/>),</p></item>

<item><p>information about what to do with the result tree,</p></item>

<item><p>information about how to obtain the source tree,</p></item>

<item><p>metadata about the stylesheet,</p></item>

<item><p>structured documentation for the stylesheet.</p></item>

</ulist>

</div2>

<div2 id="result-element-stylesheet">
<head>Literal Result Element as Stylesheet</head>

<p>A simplified syntax is allowed for stylesheets that consist of only
a single template for the root node.  The stylesheet may consist of
just a literal result element (see <specref
ref="literal-result-element"/>).  Such a stylesheet is equivalent to a
stylesheet with an <code>xsl:stylesheet</code> element containing a
template rule containing the literal result element; the template rule
has a match pattern of <code>/</code>. For example</p>

<eg>&lt;html xsl:version="1.0"
      xmlns:xsl="&XSLT.ns;"
      xmlns="&XHTML.ns;"><![CDATA[
  <head>
    <title>Expense Report Summary</title>
  </head>
  <body>
    <p>Total Amount: <xsl:value-of select="expense-report/total"/></p>
  </body>
</html>]]></eg>

<p>has the same meaning as</p>

<eg>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="&XSLT.ns;"
                xmlns="&XHTML.ns;"><![CDATA[
<xsl:template match="/">
<html>
  <head>
    <title>Expense Report Summary</title>
  </head>
  <body>
    <p>Total Amount: <xsl:value-of select="expense-report/total"/></p>
  </body>
</html>
</xsl:template>
</xsl:stylesheet>]]></eg>

<p>A literal result element that is the document element of a
stylesheet must have an <code>xsl:version</code> attribute, which
indicates the version of XSLT that the stylesheet requires.  For this
version of XSLT, the value should be <code>1.0</code>; the value must
be a <xnt href="&XPath;#NT-Number">Number</xnt>.  Other literal result
elements may also have an <code>xsl:version</code> attribute. When the
<code>xsl:version</code> attribute is not equal to <code>1.0</code>,
forwards-compatible processing mode is enabled (see <specref
ref="forwards"/>).</p>

<p>The allowed content of a literal result element when used as a
stylesheet is no different from when it occurs within a
stylesheet. Thus, a literal result element used as a stylesheet cannot
contain <termref def="dt-top-level">top-level</termref> elements.</p>

<p>In some situations, the only way that a system can recognize that an
XML document needs to be processed by an XSLT processor as an XSLT
stylesheet is by examining the XML document itself.  Using the
simplified syntax makes this harder.</p>

<note><p>For example, another XML language (AXL) might also use an
<code>axl:version</code> on the document element to indicate that an
XML document was an AXL document that required processing by an AXL
processor; if a document had both an <code>axl:version</code>
attribute and an <code>xsl:version</code> attribute, it would be
unclear whether the document should be processed by an XSLT processor
or an AXL processor.</p></note>

<p>Therefore, the simplified syntax should not be used for XSLT
stylesheets that may be used in such a situation.  This situation can,
for example, arise when an XSLT stylesheet is transmitted as a message
with a MIME media type of <code>text/xml</code> or
<code>application/xml</code> to a recipient that will use the MIME
media type to determine how the message is processed.</p>

</div2>

<div2 id="qname">
<head>Qualified Names</head>

<p>The name of an internal XSLT object, specifically a named template
(see <specref ref="named-templates"/>), a mode (see <specref
ref="modes"/>), an attribute set (see <specref
ref="attribute-sets"/>), a key (see <specref ref="key"/>), a
decimal-format (see <specref ref="format-number"/>), a variable or a
parameter (see <specref ref="variables"/>) is specified as a <xnt
href="&XMLNames;#NT-QName">QName</xnt>.  If it has a prefix, then the
prefix is expanded into a URI reference using the namespace
declarations in effect on the attribute in which the name occurs.  The
<xtermref href="&XPath;#dt-expanded-name">expanded-name</xtermref>
consisting of the local part of the name and the possibly null URI
reference is used as the name of the object.  The default namespace is
<emph>not</emph> used for unprefixed names.</p>

</div2>

<div2 id="forwards">
<head>Forwards-Compatible Processing</head>

<p>An element enables forwards-compatible mode for itself, its
attributes, its descendants and their attributes if either it is an
<code>xsl:stylesheet</code> element whose <code>version</code>
attribute is not equal to <code>1.0</code>, or it is a literal result
element that has an <code>xsl:version</code> attribute whose value is
not equal to <code>1.0</code>, or it is a literal result element that
does not have an <code>xsl:version</code> attribute and that is the
document element of a stylesheet using the simplified syntax (see
<specref ref="result-element-stylesheet"/>).  A literal result element
that has an <code>xsl:version</code> attribute whose value is equal to
<code>1.0</code> disables forwards-compatible mode for itself, its
attributes, its descendants and their attributes.</p>

<p>If an element is processed in forwards-compatible mode, then:</p>

<ulist>

<item><p>if it is a <termref def="dt-top-level">top-level</termref>
element and XSLT 1.0 does not allow such elements as top-level
elements, then the element must be ignored along with its
content;</p></item>

<item><p>if it is an element in a template and XSLT 1.0 does not allow
such elements to occur in templates, then if the element is not
instantiated, an error must not be signaled, and if the element is
instantiated, the XSLT must perform fallback for the element as
specified in <specref ref="fallback"/>;</p></item>

<item><p>if the element has an attribute that XSLT 1.0 does not allow
the element to have or if the element has an optional attribute with a
value that the XSLT 1.0 does not allow the attribute to have, then the
attribute must be ignored.</p></item>

</ulist>

<p>Thus, any XSLT 1.0 processor must be able to process the following
stylesheet without error, although the stylesheet includes elements
from the XSLT namespace that are not defined in this
specification:</p>

<eg>&lt;xsl:stylesheet version="1.1"
                xmlns:xsl="&XSLT.ns;"><![CDATA[
  <xsl:template match="/">
    <xsl:choose>
      <xsl:when test="system-property('xsl:version') >= 1.1">
        <xsl:exciting-new-1.1-feature/>
      </xsl:when>
      <xsl:otherwise>
        <html>
        <head>
          <title>XSLT 1.1 required</title>
        </head>
        <body>
          <p>Sorry, this stylesheet requires XSLT 1.1.</p>
        </body>
        </html>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
</xsl:stylesheet>]]></eg>

<note><p>If a stylesheet depends crucially on a top-level element
introduced by a version of XSL after 1.0, then the stylesheet can use
an <code>xsl:message</code> element with <code>terminate="yes"</code>
(see <specref ref="message"/>) to ensure that XSLT processors
implementing earlier versions of XSL will not silently ignore the
top-level element. For example,</p>

<eg>&lt;xsl:stylesheet version="1.5"
                xmlns:xsl="&XSLT.ns;"><![CDATA[

  <xsl:important-new-1.1-declaration/>

  <xsl:template match="/">
    <xsl:choose>
      <xsl:when test="system-property('xsl:version') &lt; 1.1">
        <xsl:message terminate="yes">
          <xsl:text>Sorry, this stylesheet requires XSLT 1.1.</xsl:text>
        </xsl:message>
      </xsl:when>
      <xsl:otherwise>
        ...
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  ...
</xsl:stylesheet>]]></eg>
</note>

<p>If an <termref def="dt-expression">expression</termref> occurs in
an attribute that is processed in forwards-compatible mode, then an
XSLT processor must recover from errors in the expression as
follows:</p>

<ulist>

<item><p>if the expression does not match the syntax allowed by the
XPath grammar, then an error must not be signaled unless the
expression is actually evaluated;</p></item>

<item><p>if the expression calls a function with an unprefixed name
that is not part of the XSLT library, then an error must not be
signaled unless the function is actually called;</p></item>

<item><p>if the expression calls a function with a number of arguments
that XSLT does not allow or with arguments of types that XSLT does not
allow, then an error must not be signaled unless the function is
actually called.</p></item>

</ulist>


</div2>

<div2>
<head>Combining Stylesheets</head>

<p>XSLT provides two mechanisms to combine stylesheets:</p>

<slist>

<sitem>an inclusion mechanism that allows stylesheets to be combined
without changing the semantics of the stylesheets being combined,
and</sitem>

<sitem>an import mechanism that allows stylesheets to override each
other.</sitem>

</slist>

<div3 id="include">
<head>Stylesheet Inclusion</head>

<e:element-syntax name="include">
  <e:in-category name="top-level-element"/>
  <e:attribute name="href" required="yes">
    <e:data-type name="uri-reference"/>
  </e:attribute>
  <e:empty/>
</e:element-syntax>

<p>An XSLT stylesheet may include another XSLT stylesheet using an
<code>xsl:include</code> element. The <code>xsl:include</code> element
has an <code>href</code> attribute whose value is a URI reference
identifying the stylesheet to be included.  A relative URI is resolved
relative to the base URI of the <code>xsl:include</code> element (see
<specref ref="base-uri"/>).</p>

<p>The <code>xsl:include</code> element is only allowed as a <termref
def="dt-top-level">top-level</termref> element.</p>

<p>The inclusion works at the XML tree level.  The resource located by
the <code>href</code> attribute value is parsed as an XML document,
and the children of the <code>xsl:stylesheet</code> element in this
document replace the <code>xsl:include</code> element in the including
document.  The fact that template rules or definitions are included
does not affect the way they are processed.</p>

<p>The included stylesheet may use the simplified syntax described in
<specref ref="result-element-stylesheet"/>.  The included stylesheet
is treated the same as the equivalent <code>xsl:stylesheet</code>
element.</p>

<p>It is an error if a stylesheet directly or indirectly includes
itself.</p>

<note><p>Including a stylesheet multiple times can cause errors
because of duplicate definitions.  Such multiple inclusions are less
obvious when they are indirect. For example, if stylesheet
<var>B</var> includes stylesheet <var>A</var>, stylesheet <var>C</var>
includes stylesheet <var>A</var>, and stylesheet <var>D</var> includes
both stylesheet <var>B</var> and stylesheet <var>C</var>, then
<var>A</var> will be included indirectly by <var>D</var> twice.  If
all of <var>B</var>, <var>C</var> and <var>D</var> are used as
independent stylesheets, then the error can be avoided by separating
everything in <var>B</var> other than the inclusion of <var>A</var>
into a separate stylesheet <var>B'</var> and changing <var>B</var> to
contain just inclusions of <var>B'</var> and <var>A</var>, similarly
for <var>C</var>, and then changing <var>D</var> to include
<var>A</var>, <var>B'</var>, <var>C'</var>.</p></note>

</div3>

<div3 id="import">
<head>Stylesheet Import</head>

<e:element-syntax name="import">
  <e:attribute name="href" required="yes">
    <e:data-type name="uri-reference"/>
  </e:attribute>
  <e:empty/>
</e:element-syntax>

<p>An XSLT stylesheet may import another XSLT stylesheet using an
<code>xsl:import</code> element.  Importing a stylesheet is the same
as including it (see <specref ref="include"/>) except that definitions
and template rules in the importing stylesheet take precedence over
template rules and definitions in the imported stylesheet; this is
described in more detail below.  The <code>xsl:import</code> element
has an <code>href</code> attribute whose value is a URI reference
identifying the stylesheet to be imported.  A relative URI is resolved
relative to the base URI of the <code>xsl:import</code> element (see
<specref ref="base-uri"/>).</p>

<p>The <code>xsl:import</code> element is only allowed as a <termref
def="dt-top-level">top-level</termref> element.  The
<code>xsl:import</code> element children must precede all other
element children of an <code>xsl:stylesheet</code> element, including
any <code>xsl:include</code> element children.  When
<code>xsl:include</code> is used to include a stylesheet, any
<code>xsl:import</code> elements in the included document are moved up
in the including document to after any existing
<code>xsl:import</code> elements in the including document.</p>

<p>For example,</p>

<eg>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="&XSLT.ns;"><![CDATA[
  <xsl:import href="article.xsl"/>
  <xsl:import href="bigfont.xsl"/>
  <xsl:attribute-set name="note-style">
    <xsl:attribute name="font-style">italic</xsl:attribute>
  </xsl:attribute-set>
</xsl:stylesheet>]]></eg>

<p><termdef id="dt-import-tree" term="Import Tree">The
<code>xsl:stylesheet</code> elements encountered during processing of
a stylesheet that contains <code>xsl:import</code> elements are
treated as forming an <term>import tree</term>.  In the import tree,
each <code>xsl:stylesheet</code> element has one import child for each
<code>xsl:import</code> element that it contains. Any
<code>xsl:include</code> elements are resolved before constructing the
import tree.</termdef> <termdef id="dt-import-precedence" term="Import
Precedence">An <code>xsl:stylesheet</code> element in the import tree
is defined to have lower <term>import precedence</term> than another
<code>xsl:stylesheet</code> element in the import tree if it would be
visited before that <code>xsl:stylesheet</code> element in a
post-order traversal of the import tree (i.e. a traversal of the
import tree in which an <code>xsl:stylesheet</code> element is visited
after its import children).</termdef> Each definition and template
rule has import precedence determined by the
<code>xsl:stylesheet</code> element that contains it.</p>

<p>For example, suppose</p>

<ulist>

<item><p>stylesheet <var>A</var> imports stylesheets <var>B</var>
and <var>C</var> in that order;</p></item>

<item><p>stylesheet <var>B</var> imports stylesheet
<var>D</var>;</p></item>

<item><p>stylesheet <var>C</var> imports stylesheet
<var>E</var>.</p></item>

</ulist>

<p>Then the order of import precedence (lowest first) is
<var>D</var>, <var>B</var>, <var>E</var>, <var>C</var>,
<var>A</var>.</p>

<note><p>Since <code>xsl:import</code> elements are required to occur
before any definitions or template rules, an implementation that
processes imported stylesheets at the point at which it encounters the
<code>xsl:import</code> element will encounter definitions and
template rules in increasing order of import precedence.</p></note>

<p>In general, a definition or template rule with higher import
precedence takes precedence over a definition or template rule with
lower import precedence.  This is defined in detail for each kind of
definition and for template rules.</p>

<p>It is an error if a stylesheet directly or indirectly imports
itself. Apart from this, the case where a stylesheet with a particular
URI is imported in multiple places is not treated specially. The
<termref def="dt-import-tree">import tree</termref> will have a
separate <code>xsl:stylesheet</code> for each place that it is
imported.</p>

<note><p>If <code>xsl:apply-imports</code> is used (see <specref
ref="apply-imports"/>), the behavior may be different from the
behavior if the stylesheet had been imported only at the place with
the highest <termref def="dt-import-precedence">import
precedence</termref>.</p></note>

</div3>

</div2>

<div2>
<head>Embedding Stylesheets</head>

<p>Normally an XSLT stylesheet is a complete XML document with the
<code>xsl:stylesheet</code> element as the document element. However,
an XSLT stylesheet may also be embedded in another resource. Two forms
of embedding are possible:</p>

<slist>

<sitem>the XSLT stylesheet may be textually embedded in a non-XML
resource, or</sitem>

<sitem>the <code>xsl:stylesheet</code> element may occur in an XML
document other than as the document element.</sitem>

</slist>

<p>To facilitate the second form of embedding, the
<code>xsl:stylesheet</code> element is allowed to have an ID attribute
that specifies a unique identifier.</p>

<note><p>In order for such an attribute to be used with the XPath
<xfunction>id</xfunction> function, it must actually be declared in
the DTD as being an ID.</p></note>

<p>The following example shows how the <code>xml-stylesheet</code>
processing instruction <bibref ref="XMLSTYLE"/> can be used to allow a
document to contain its own stylesheet.  The URI reference uses a
relative URI with a fragment identifier to locate the
<code>xsl:stylesheet</code> element:</p>

<eg><![CDATA[<?xml-stylesheet type="text/xml" href="#style1"?>
<!DOCTYPE doc SYSTEM "doc.dtd">
<doc>
<head>
<xsl:stylesheet id="style1"
                version="1.0"]]>
                xmlns:xsl="&XSLT.ns;"
                xmlns:fo="&XSLFO.ns;"><![CDATA[
<xsl:import href="doc.xsl"/>
<xsl:template match="id('foo')">
  <fo:block font-weight="bold"><xsl:apply-templates/></fo:block>
</xsl:template>
<xsl:template match="xsl:stylesheet">
  <!-- ignore -->
</xsl:template>
</xsl:stylesheet>
</head>
<body>
<para id="foo">
...
</para>
</body>
</doc>
]]></eg>

<note><p>A stylesheet that is embedded in the document to which it is
to be applied or that may be included or imported into an stylesheet
that is so embedded typically needs to contain a template rule that
specifies that <code>xsl:stylesheet</code> elements are to be
ignored.</p></note>

</div2>

</div1>

<div1 id="data-model">
<head>Data Model</head>

<p>The data model used by XSLT is the same as that used by <xspecref
href="&XPath;#data-model">XPath</xspecref> with the additions
described in this section.  XSLT operates on source, result and
stylesheet documents using the same data model.  Any two XML documents
that have the same tree will be treated the same by XSLT.</p>

<p>Processing instructions and comments in the stylesheet are ignored:
the stylesheet is treated as if neither processing instruction nodes
nor comment nodes were included in the tree that represents the
stylesheet.</p>

<div2 id="root-node-children">
<head>Root Node Children</head>

<p>The normal restrictions on the children of the root node are
relaxed for the result tree.  The result tree may have any sequence of
nodes as children that would be possible for an element node. In
particular, it may have text node children, and any number of element
node children. When written out using the XML output method (see
<specref ref="output"/>), it is possible that a result tree will not
be a well-formed XML document; however, it will always be a
well-formed external general parsed entity.</p>

<p>When the source tree is created by parsing a well-formed XML
document, the root node of the source tree will automatically satisfy
the normal restrictions of having no text node children and exactly
one element child.  When the source tree is created in some other way,
for example by using the DOM, the usual restrictions are relaxed for
the source tree as for the result tree.</p>

</div2>

<div2 id="base-uri">
<head>Base URI</head>

<p>Every node also has an associated URI called its base URI, which is
used for resolving attribute values that represent relative URIs into
absolute URIs.  If an element or processing instruction occurs in an
external entity, the base URI of that element or processing
instruction is the URI of the external entity; otherwise, the base URI
is the base URI of the document.  The base URI of the document node is
the URI of the document entity.  The base URI for a text node, a
comment node, an attribute node or a namespace node is the base URI of
the parent of the node.</p>

</div2>

<div2 id="unparsed-entities">
<head>Unparsed Entities</head>

<p>The root node has a mapping that gives the URI for each unparsed
entity declared in the document's DTD.  The URI is generated from the
system identifier and public identifier specified in the entity
declaration. The XSLT processor may use the public identifier to
generate a URI for the entity instead of the URI specified in the
system identifier.  If the XSLT processor does not use the public
identifier to generate the URI, it must use the system identifier; if
the system identifier is a relative URI, it must be resolved into an
absolute URI using the URI of the resource containing the entity
declaration as the base URI <bibref ref="RFC2396"/>.</p>

</div2>

<div2 id="strip">
<head>Whitespace Stripping</head>

<p>After the tree for a source document or stylesheet document has
been constructed, but before it is otherwise processed by XSLT,
some text nodes are stripped.  A text node is never stripped
unless it contains only whitespace characters.  Stripping the text
node removes the text node from the tree.  The stripping process takes
as input a set of element names for which whitespace must be
preserved.  The stripping process is applied to both stylesheets and
source documents, but the set of whitespace-preserving element names
is determined differently for stylesheets and for source
documents.</p>

<p>A text node is preserved if any of the following apply:</p>

<ulist>

<item><p>The element name of the parent of the text node is in the set
of whitespace-preserving element names.</p></item>

<item><p>The text node contains at least one non-whitespace character.
As in XML, a whitespace character is #x20, #x9, #xD or #xA.</p></item>

<item><p>An ancestor element of the text node has an
<code>xml:space</code> attribute with a value of
<code>preserve</code>, and no closer ancestor element has
<code>xml:space</code> with a value of
<code>default</code>.</p></item>

</ulist>

<p>Otherwise, the text node is stripped.</p>

<p>The <code>xml:space</code> attributes are not stripped from the
tree.</p>

<note><p>This implies that if an <code>xml:space</code> attribute is
specified on a literal result element, it will be included in the
result.</p></note>

<p>For stylesheets, the set of whitespace-preserving element names
consists of just <code>xsl:text</code>.</p>

<e:element-syntax name="strip-space">
  <e:in-category name="top-level-element"/>
  <e:attribute name="elements" required="yes">
    <e:data-type name="tokens"/>
  </e:attribute>
  <e:empty/>
</e:element-syntax>

<e:element-syntax name="preserve-space">
  <e:in-category name="top-level-element"/>
  <e:attribute name="elements" required="yes">
    <e:data-type name="tokens"/>
  </e:attribute>
  <e:empty/>
</e:element-syntax>

<p>For source documents, the set of whitespace-preserving element
names is specified by <code>xsl:strip-space</code> and
<code>xsl:preserve-space</code> <termref
def="dt-top-level">top-level</termref> elements.  These elements each
have an <code>elements</code> attribute whose value is a
whitespace-separated list of <xnt
href="&XPath;#NT-NameTest">NameTest</xnt>s.  Initially, the
set of whitespace-preserving element names contains all element names.
If an element name matches a <xnt
href="&XPath;#NT-NameTest">NameTest</xnt> in an
<code>xsl:strip-space</code> element, then it is removed from the set
of whitespace-preserving element names.  If an element name matches a
<xnt href="&XPath;#NT-NameTest">NameTest</xnt> in an
<code>xsl:preserve-space</code> element, then it is added to the set
of whitespace-preserving element names.  An element matches a <xnt
href="&XPath;#NT-NameTest">NameTest</xnt> if and only if the
<xnt href="&XPath;#NT-NameTest">NameTest</xnt> would be true
for the element as an <xspecref href="&XPath;#node-tests">XPath node
test</xspecref>.  Conflicts between matches to
<code>xsl:strip-space</code> and <code>xsl:preserve-space</code>
elements are resolved the same way as conflicts between template rules
(see <specref ref="conflict"/>).  Thus, the applicable match for a
particular element name is determined as follows:</p>

<ulist>

<item><p>First, any match with lower <termref
def="dt-import-precedence">import precedence</termref> than another
match is ignored.</p></item>

<item><p>Next, any match with a <xnt
href="&XPath;#NT-NameTest">NameTest</xnt> that has a lower
<termref def="dt-default-priority">default priority</termref> than the
<termref def="dt-default-priority">default priority</termref> of the
<xnt href="&XPath;#NT-NameTest">NameTest</xnt> of another
match is ignored.</p></item>

</ulist>

<p>It is an error if this leaves more than one match.  An XSLT
processor may signal the error; if it does not signal the error, it
must recover by choosing, from amongst the matches that are left, the
one that occurs last in the stylesheet.</p>

</div2>

</div1>

<div1>
<head>Expressions</head>

<p>XSLT uses the expression language defined by XPath <bibref
ref="XPATH"/>.  Expressions are used in XSLT for a variety of purposes
including:</p>

<slist>
<sitem>selecting nodes for processing;</sitem>
<sitem>specifying conditions for different ways of processing a node;</sitem>
<sitem>generating text to be inserted in the result tree.</sitem>
</slist>

<p><termdef id="dt-expression" term="Expression">An
<term>expression</term> must match the XPath production <xnt
href="&XPath;#NT-Expr">Expr</xnt>.</termdef></p>

<p>Expressions occur as the value of certain attributes on
XSLT-defined elements and within curly braces in <termref
def="dt-attribute-value-template">attribute value
template</termref>s.</p>

<p>In XSLT, an outermost expression (i.e. an expression that is not
part of another expression) gets its context as follows:</p>

<ulist>

<item><p>the context node comes from the <termref
def="dt-current-node">current node</termref></p></item>

<item><p>the context position comes from the position of the <termref
def="dt-current-node">current node</termref> in the <termref
def="dt-current-node-list">current node list</termref>; the first
position is 1</p></item>

<item><p>the context size comes from the size of the <termref
def="dt-current-node-list">current node list</termref></p></item>

<item><p>the variable bindings are the bindings in scope on the
element which has the attribute in which the expression occurs (see
<specref ref="variables"/>)</p></item>

<item><p>the set of namespace declarations are those in scope on the
element which has the attribute in which the expression occurs;
this includes the implicit declaration of the prefix <code>xml</code>
required by the the XML Namespaces Recommendation <bibref ref="XMLNAMES"/>;
the default
namespace (as declared by <code>xmlns</code>) is not part of this
set</p></item>

<item><p>the function library consists of the core function library
together with the additional functions defined in <specref
ref="add-func"/> and extension functions as described in <specref
ref="extension"/>; it is an error for an expression to include a call
to any other function</p></item>

</ulist>

</div1>

<div1 id="rules">
<head>Template Rules</head>

<div2>
<head>Processing Model</head>

<p>A list of source nodes is processed to create a result tree
fragment.  The result tree is constructed by processing a list
containing just the root node.  A list of source nodes is processed by
appending the result tree structure created by processing each of the
members of the list in order.  A node is processed by finding all the
template rules with patterns that match the node, and choosing the
best amongst them; the chosen rule's template is then instantiated
with the node as the <termref def="dt-current-node">current
node</termref> and with the list of source nodes as the <termref
def="dt-current-node-list">current node list</termref>.  A template
typically contains instructions that select an additional list of
source nodes for processing.  The process of matching, instantiation
and selection is continued recursively until no new source nodes are
selected for processing.</p>

<p>Implementations are free to process the source document in any way
that produces the same result as if it were processed using this
processing model.</p>

</div2>

<div2 id="patterns">
<head>Patterns</head>

<p><termdef id="dt-pattern" term="Pattern">Template rules identify the
nodes to which they apply by using a <term>pattern</term>.  As well as
being used in template rules, patterns are used for numbering (see
<specref ref="number"/>) and for declaring keys (see <specref
ref="key"/>).  A pattern specifies a set of conditions on a node.  A
node that satisfies the conditions matches the pattern; a node that
does not satisfy the conditions does not match the pattern.  The
syntax for patterns is a subset of the syntax for expressions. In
particular, location paths that meet certain restrictions can be used
as patterns.  An expression that is also a pattern always evaluates to
an object of type node-set.  A node matches a pattern if the node is a
member of the result of evaluating the pattern as an expression with
respect to some possible context; the possible contexts are those
whose context node is the node being matched or one of its
ancestors.</termdef></p>

<p>Here are some examples of patterns:</p>

<ulist>

<item><p><code>para</code> matches any <code>para</code> element</p></item>

<item><p><code>*</code> matches any element</p></item>

<item><p><code>chapter|appendix</code> matches any
<code>chapter</code> element and any <code>appendix</code>
element</p></item>

<item><p><code>olist/item</code> matches any <code>item</code> element with
an <code>olist</code> parent</p></item>

<item><p><code>appendix//para</code> matches any <code>para</code> element with
an <code>appendix</code> ancestor element</p></item>

<item><p><code>/</code> matches the root node</p></item>

<item><p><code>text()</code> matches any text node</p></item>

<item><p><code>processing-instruction()</code> matches any processing
instruction</p></item>

<item><p><code>node()</code> matches any node other than an attribute
node and the root node</p></item>

<item><p><code>id("W11")</code> matches the element with unique ID
<code>W11</code></p></item>

<item><p><code>para[1]</code> matches any <code>para</code> element
that is the first <code>para</code> child element of its
parent</p></item>

<item><p><code>*[position()=1 and self::para]</code> matches any
<code>para</code> element that is the first child element of its
parent</p></item>

<item><p><code>para[last()=1]</code> matches any <code>para</code>
element that is the only <code>para</code> child element of its
parent</p></item>

<item><p><code>items/item[position()>1]</code> matches any
<code>item</code> element that has a <code>items</code> parent and
that is not the first <code>item</code> child of its parent</p></item>

<item><p><code>item[position() mod 2 = 1]</code> would be true for any
<code>item</code> element that is an odd-numbered <code>item</code>
child of its parent.</p></item>

<item><p><code>div[@class="appendix"]//p</code> matches any
<code>p</code> element with a <code>div</code> ancestor element that
has a <code>class</code> attribute with value
<code>appendix</code></p></item>

<item><p><code>@class</code> matches any <code>class</code> attribute
(<emph>not</emph> any element that has a <code>class</code>
attribute)</p></item>

<item><p><code>@*</code> matches any attribute</p></item>

</ulist>

<p>A pattern must match the grammar for <nt
def="NT-Pattern">Pattern</nt>.  A <nt def="NT-Pattern">Pattern</nt> is
a set of location path patterns separated by <code>|</code>.  A
location path pattern is a location path whose steps all use only the
<code>child</code> or <code>attribute</code> axes.  Although patterns
must not use the <code>descendant-or-self</code> axis, patterns may
use the <code>//</code> operator as well as the <code>/</code>
operator.  Location path patterns can also start with an
<xfunction>id</xfunction> or <function>key</function> function call
with a literal argument.  Predicates in a pattern can use arbitrary
expressions just like predicates in a location path.</p>

<scrap>
<head>Patterns</head>
<prodgroup pcw5="1" pcw2="10">
<prod id="NT-Pattern">
<lhs>Pattern</lhs>
<rhs><nt def="NT-LocationPathPattern">LocationPathPattern</nt></rhs>
<rhs>| <nt def="NT-Pattern">Pattern</nt> '|' <nt def="NT-LocationPathPattern">LocationPathPattern</nt></rhs>
</prod>
<prod id="NT-LocationPathPattern">
<lhs>LocationPathPattern</lhs>
<rhs>'/' <nt def="NT-RelativePathPattern">RelativePathPattern</nt>?</rhs>
<rhs>| <nt def="NT-IdKeyPattern">IdKeyPattern</nt> (('/' | '//') <nt def="NT-RelativePathPattern">RelativePathPattern</nt>)?</rhs>
<rhs>| '//'? <nt def="NT-RelativePathPattern">RelativePathPattern</nt></rhs>
</prod>
<prod id="NT-IdKeyPattern">
<lhs>IdKeyPattern</lhs>
<rhs>'id' '(' <xnt href="&XPath;#NT-Literal">Literal</xnt> ')'</rhs>
<rhs>| 'key' '(' <xnt href="&XPath;#NT-Literal">Literal</xnt> ',' <xnt href="&XPath;#NT-Literal">Literal</xnt> ')'</rhs>
</prod>
<prod id="NT-RelativePathPattern">
<lhs>RelativePathPattern</lhs>
<rhs><nt def="NT-StepPattern">StepPattern</nt></rhs>
<rhs>| <nt def="NT-RelativePathPattern">RelativePathPattern</nt> '/' <nt def="NT-StepPattern">StepPattern</nt></rhs>
<rhs>| <nt def="NT-RelativePathPattern">RelativePathPattern</nt> '//' <nt def="NT-StepPattern">StepPattern</nt></rhs>
</prod>
<prod id="NT-StepPattern">
<lhs>StepPattern</lhs>
<rhs>
<nt def="NT-ChildOrAttributeAxisSpecifier">ChildOrAttributeAxisSpecifier</nt>
<xnt href="&XPath;#NT-NodeTest">NodeTest</xnt>
<xnt href="&XPath;#NT-Predicate">Predicate</xnt>*
</rhs>
</prod>
<prod id="NT-ChildOrAttributeAxisSpecifier">
<lhs>ChildOrAttributeAxisSpecifier</lhs>
<rhs><xnt href="&XPath;#NT-AbbreviatedAxisSpecifier">AbbreviatedAxisSpecifier</xnt></rhs>
<rhs>| ('child' | 'attribute') '::'</rhs>
</prod>
</prodgroup>
</scrap>

<p>A pattern is defined to match a node if and only if there is
possible context such that when the pattern is evaluated as an
expression with that context, the node is a member of the resulting
node-set.  When a node is being matched, the possible contexts have a
context node that is the node being matched or any ancestor of that
node, and a context node list containing just the context node.</p>

<p>For example, <code>p</code> matches any <code>p</code> element,
because for any <code>p</code> if the expression <code>p</code> is
evaluated with the parent of the <code>p</code> element as context the
resulting node-set will contain that <code>p</code> element as one of
its members.</p>

<note><p>This matches even a <code>p</code> element that is the
document element, since the document root is the parent of the
document element.</p></note>

<p>Although the semantics of patterns are specified indirectly in
terms of expression evaluation, it is easy to understand the meaning
of a pattern directly without thinking in terms of expression
evaluation.  In a pattern, <code>|</code> indicates alternatives; a
pattern with one or more <code>|</code> separated alternatives matches
if any one of the alternative matches.  A pattern that consists of a
sequence of <nt def="NT-StepPattern">StepPattern</nt>s separated by
<code>/</code> or <code>//</code> is matched from right to left.  The
pattern only matches if the rightmost <nt
def="NT-StepPattern">StepPattern</nt> matches and a suitable element
matches the rest of the pattern; if the separator is <code>/</code>
then only the parent is a suitable element; if the separator is
<code>//</code>, then any ancestor is a suitable element.  A <nt
def="NT-StepPattern">StepPattern</nt> that uses the child axis matches
if the <xnt href="&XPath;#NT-NodeTest">NodeTest</xnt> is true for the
node and the node is not an attribute node.  A <nt
def="NT-StepPattern">StepPattern</nt> that uses the attribute axis
matches if the <xnt href="&XPath;#NT-NodeTest">NodeTest</xnt> is true
for the node and the node is an attribute node.  When <code>[]</code>
is present, then the first <xnt
href="&XPath;#NT-PredicateExpr">PredicateExpr</xnt> in a <nt
def="NT-StepPattern">StepPattern</nt> is evaluated with the node being
matched as the context node and the siblings of the context node that
match the <xnt href="&XPath;#NT-NodeTest">NodeTest</xnt> as the
context node list, unless the node being matched is an attribute node,
in which case the context node list is all the attributes that have
the same parent as the attribute being matched and that match the <xnt
href="&XPath;#NT-NameTest">NameTest</xnt>.</p>

<p>For example</p>

<eg>appendix//ulist/item[position()=1]</eg>

<p>matches a node if and only if all of the following are true:</p>

<ulist>

<item><p>the <xnt href="&XPath;#NT-NodeTest">NodeTest</xnt> <code>item</code> is
true for the node and the node is not an attribute; in other words the
node is an <code>item</code> element</p></item>

<item><p>evaluating the <xnt href="&XPath;#NT-PredicateExpr">PredicateExpr</xnt>
<code>position()=1</code> with the node as context node and the
siblings of the node that are <code>item</code> elements as the
context node list yields true</p></item>

<item><p>the node has a parent that matches
<code>appendix//ulist</code>; this will be true if the parent is a
<code>ulist</code> element that has an <code>appendix</code> ancestor
element.</p></item>

</ulist>

</div2>

<div2>
<head>Defining Template Rules</head>

<e:element-syntax name="template">
  <e:in-category name="top-level-element"/>
  <e:attribute name="match">
    <e:data-type name="pattern"/>
  </e:attribute>
  <e:attribute name="name">
    <e:data-type name="qname"/>
  </e:attribute>
  <e:attribute name="priority">
    <e:data-type name="number"/>
  </e:attribute>
  <e:attribute name="mode">
    <e:data-type name="qname"/>
  </e:attribute>
  <e:sequence>
    <e:element repeat="zero-or-more" name="param"/>
    <e:model name="template"/>
  </e:sequence>
</e:element-syntax>

<p>A template rule is specified with the <code>xsl:template</code>
element. The <code>match</code> attribute is a <nt
def="NT-Pattern">Pattern</nt> that identifies the source node or nodes
to which the rule applies.  The <code>match</code> attribute is
required unless the <code>xsl:template</code> element has a
<code>name</code> attribute (see <specref ref="named-templates"/>).
It is an error for the value of the <code>match</code> attribute to
contain a <xnt
href="&XPath;#NT-VariableReference">VariableReference</xnt>. The
content of the <code>xsl:template</code> element is the template that
is instantiated when the template rule is applied.</p>

<p>For example, an XML document might contain:</p>

<eg><![CDATA[This is an <emph>important</emph> point.]]></eg>

<p>The following template rule matches <code>emph</code> elements and
produces a <code>fo:inline-sequence</code> formatting object with a
<code>font-weight</code> property of <code>bold</code>.</p>

<eg><![CDATA[<xsl:template match="emph">
  <fo:inline-sequence font-weight="bold">
    <xsl:apply-templates/>
  </fo:inline-sequence>
</xsl:template>
]]></eg>

<note><p>Examples in this document use the <code>fo:</code> prefix for
the namespace <code>&XSLFO.ns;</code>, which is
the namespace of the formatting objects defined in <bibref
ref="XSL"/>.</p></note>

<p>As described next, the <code>xsl:apply-templates</code> element
recursively processes the children of the source element.</p>

</div2>

<div2>
<head>Applying Template Rules</head>

<e:element-syntax name="apply-templates">
  <e:in-category name="instruction"/>
  <e:attribute name="select">
    <e:data-type name="node-set-expression"/>
  </e:attribute>
  <e:attribute name="mode">
    <e:data-type name="qname"/>
  </e:attribute>
  <e:choice repeat="zero-or-more">
    <e:element name="sort"/>
    <e:element name="with-param"/>
  </e:choice>
</e:element-syntax>

<p>This example creates a block for a <code>chapter</code> element and
then processes its immediate children.</p>

<eg><![CDATA[<xsl:template match="chapter">
  <fo:block>
    <xsl:apply-templates/>
  </fo:block>
</xsl:template>]]></eg>

<p>In the absence of a <code>select</code> attribute, the
<code>xsl:apply-templates</code> instruction processes all of the
children of the current node, including text nodes.  However, text
nodes that have been stripped as specified in <specref ref="strip"/>
will not be processed.  If stripping of whitespace nodes has not been
enabled for an element, then all whitespace in the content of the
element will be processed as text, and thus whitespace
between child elements will count in determining the position of a
child element as returned by the <xfunction>position</xfunction>
function.</p>

<p>A <code>select</code> attribute can be used to process nodes
selected by an expression instead of processing all children.  The
value of the <code>select</code> attribute is an <termref
def="dt-expression">expression</termref>.  The expression must
evaluate to a node-set.  The selected set of nodes is processed in
document order, unless a sorting specification is present (see
<specref ref="sorting"/>).  The following example processes all of the
<code>author</code> children of the <code>author-group</code>:</p>

<eg><![CDATA[<xsl:template match="author-group">
  <fo:inline-sequence>
    <xsl:apply-templates select="author"/>
  </fo:inline-sequence>
</xsl:template>]]></eg>

<p>The following example processes all of the <code>given-name</code>s
of the <code>author</code>s that are children of
<code>author-group</code>:</p>

<eg><![CDATA[<xsl:template match="author-group">
  <fo:inline-sequence>
    <xsl:apply-templates select="author/given-name"/>
  </fo:inline-sequence>
</xsl:template>]]></eg>

<p>This example processes all of the <code>heading</code> descendant
elements of the <code>book</code> element.</p>

<eg><![CDATA[<xsl:template match="book">
  <fo:block>
    <xsl:apply-templates select=".//heading"/>
  </fo:block>
</xsl:template>]]></eg>

<p>It is also possible to process elements that are not descendants of
the current node.  This example assumes that a <code>department</code>
element has <code>group</code> children and <code>employee</code>
descendants. It finds an employee's department and then processes
the <code>group</code> children of the <code>department</code>.</p>

<eg><![CDATA[<xsl:template match="employee">
  <fo:block>
    Employee <xsl:apply-templates select="name"/> belongs to group
    <xsl:apply-templates select="ancestor::department/group"/>
  </fo:block>
</xsl:template>]]></eg>

<p>Multiple <code>xsl:apply-templates</code> elements can be used within a
single template to do simple reordering.  The following example
creates two HTML tables. The first table is filled with domestic sales
while the second table is filled with foreign sales.</p>

<eg><![CDATA[<xsl:template match="product">
  <table>
    <xsl:apply-templates select="sales/domestic"/>
  </table>
  <table>
    <xsl:apply-templates select="sales/foreign"/>
  </table>
</xsl:template>]]></eg>

<note>

<p>It is possible for there to be two matching descendants where one
is a descendant of the other.  This case is not treated specially:
both descendants will be processed as usual. For example, given a
source document</p>

<eg><![CDATA[<doc><div><div></div></div></doc>]]></eg>

<p>the rule</p>

<eg><![CDATA[<xsl:template match="doc">
  <xsl:apply-templates select=".//div"/>
</xsl:template>]]></eg>

<p>will process both the outer <code>div</code> and inner <code>div</code>
elements.</p>

</note>

<note><p>Typically, <code>xsl:apply-templates</code> is used to
process only nodes that are descendants of the current node.  Such use
of <code>xsl:apply-templates</code> cannot result in non-terminating
processing loops.  However, when <code>xsl:apply-templates</code> is
used to process elements that are not descendants of the current node,
the possibility arises of non-terminating loops. For example,</p>

<eg role="error"><![CDATA[<xsl:template match="foo">
  <xsl:apply-templates select="."/>
</xsl:template>]]></eg>

<p>Implementations may be able to detect such loops in some cases, but
the possibility exists that a stylesheet may enter a non-terminating
loop that an implementation is unable to detect. This may present a
denial of service security risk.</p></note>

</div2>

<div2 id="conflict">
<head>Conflict Resolution for Template Rules</head>

<p>It is possible for a source node to match more than one template
rule. The template rule to be used is determined as follows:</p>

<olist>

<item><p>First, all matching template rules that have lower <termref
def="dt-import-precedence">import precedence</termref> than the
matching template rule or rules with the highest import precedence are
eliminated from consideration.</p></item>

<item><p>Next, all matching template rules that have lower priority
than the matching template rule or rules with the highest priority are
eliminated from consideration.  The priority of a template rule is
specified by the <code>priority</code> attribute on the template rule.
The value of this must be a real number (positive or negative),
matching the production <xnt href="&XPath;#NT-Number">Number</xnt>
with an optional leading minus sign (<code>-</code>).  <termdef
id="dt-default-priority" term="Default Priority">The <term>default
priority</term> is computed as follows:</termdef></p>

<ulist>

<item><p>If the pattern contains multiple alternatives separated by
<code>|</code>, then it is treated equivalently to a set of template
rules, one for each alternative.</p></item>

<item><p>If the pattern has the form of a <xnt
href="&XMLNames;#NT-QName">QName</xnt> preceded by a <nt
def="NT-ChildOrAttributeAxisSpecifier">ChildOrAttributeAxisSpecifier</nt>
or has the form
<code>processing-instruction(</code><xnt href="&XPath;#NT-Literal"
>Literal</xnt><code>)</code> preceded by a <nt
def="NT-ChildOrAttributeAxisSpecifier">ChildOrAttributeAxisSpecifier</nt>,
then the priority is 0.</p></item>

<item><p>If the pattern has the form <xnt
href="&XMLNames;#NT-NCName">NCName</xnt><code>:*</code> preceded by a
<nt
def="NT-ChildOrAttributeAxisSpecifier">ChildOrAttributeAxisSpecifier</nt>,
then the priority is -0.25.</p></item>

<item><p>Otherwise, if the pattern consists of just a <xnt
href="&XPath;#NT-NodeTest">NodeTest</xnt> preceded by a <nt
def="NT-ChildOrAttributeAxisSpecifier">ChildOrAttributeAxisSpecifier</nt>,
then the priority is -0.5.</p></item>

<item><p>Otherwise, the priority is 0.5.</p></item>

</ulist>

<p>Thus, the most common kind of pattern (a pattern that tests for a
node with a particular type and a particular expanded-name) has
priority 0. The next less specific kind of pattern (a pattern that
tests for a node with a particular type and an expanded-name with a
particular namespace URI) has priority -0.25.  Patterns less specific
than this (patterns that just tests for nodes with particular types)
have priority -0.5.  Patterns more specific than the most common kind
of pattern have priority 0.5.</p>

</item>

</olist>

<p>It is an error if this leaves more than one matching template
rule.  An XSLT processor may signal the error; if it does not signal
the error, it must recover by choosing, from amongst the matching
template rules that are left, the one that occurs last in the
stylesheet.</p>

</div2>

<div2 id="apply-imports">
<head>Overriding Template Rules</head>

<e:element-syntax name="apply-imports">
  <e:in-category name="instruction"/>
  <e:empty/>
</e:element-syntax>

<p>A template rule that is being used to override a template rule in
an imported stylesheet (see <specref ref="conflict"/>) can use the
<code>xsl:apply-imports</code> element to invoke the overridden
template rule.</p>

<p><termdef id="dt-current-template-rule" term="Current Template
Rule">At any point in the processing of a stylesheet, there is a
<term>current template rule</term>.  Whenever a template rule is
chosen by matching a pattern, the template rule becomes the current
template rule for the instantiation of the rule's template. When an
<code>xsl:for-each</code> element is instantiated, the current
template rule becomes null for the instantiation of the content of the
<code>xsl:for-each</code> element.</termdef></p>

<p><code>xsl:apply-imports</code> processes the current node using
only template rules that were imported into the stylesheet element
containing the current template rule; the node is processed in the
current template rule's mode.  It is an error if
<code>xsl:apply-imports</code> is instantiated when the current
template rule is null.</p>

<p>For example, suppose the stylesheet <code>doc.xsl</code> contains a
template rule for <code>example</code> elements:</p>

<eg><![CDATA[<xsl:template match="example">
  <pre><xsl:apply-templates/></pre>
</xsl:template>]]></eg>

<p>Another stylesheet could import <code>doc.xsl</code> and modify the
treatment of <code>example</code> elements as follows:</p>

<eg><![CDATA[<xsl:import href="doc.xsl"/>

<xsl:template match="example">
  <div style="border: solid red">
     <xsl:apply-imports/>
  </div>
</xsl:template>]]></eg>

<p>The combined effect would be to transform an <code>example</code>
into an element of the form:</p>

<eg><![CDATA[<div style="border: solid red"><pre>...</pre></div>]]></eg>

</div2>

<div2 id="modes">
<head>Modes</head>

<p>Modes allow an element to be processed multiple times, each time
producing a different result.</p>

<p>Both <code>xsl:template</code> and <code>xsl:apply-templates</code>
have an optional <code>mode</code> attribute.  The value of the
<code>mode</code> attribute is a <xnt
href="&XMLNames;#NT-QName">QName</xnt>, which is expanded as described
in <specref ref="qname"/>. If <code>xsl:template</code> does not have
a <code>match</code> attribute, it must not have a <code>mode</code>
attribute.  If an <code>xsl:apply-templates</code> element has a
<code>mode</code> attribute, then it applies only to those template
rules from <code>xsl:template</code> elements that have a
<code>mode</code> attribute with the same value; if an
<code>xsl:apply-templates</code> element does not have a
<code>mode</code> attribute, then it applies only to those template
rules from <code>xsl:template</code> elements that do not have a
<code>mode</code> attribute.</p>

</div2>

<div2 id="built-in-rule">
<head>Built-in Template Rules</head>

<p>There is a built-in template rule to allow recursive processing to
continue in the absence of a successful pattern match by an explicit
template rule in the stylesheet.  This template rule applies to both
element nodes and the root node.  The following shows the equivalent
of the built-in template rule:</p>

<eg><![CDATA[<xsl:template match="*|/">
  <xsl:apply-templates/>
</xsl:template>]]></eg>

<p>There is also a built-in template rule for each mode, which allows
recursive processing to continue in the same mode in the absence of a
successful pattern match by an explicit template rule in the
stylesheet.  This template rule applies to both element nodes and the
root node.  The following shows the equivalent of the built-in
template rule for mode <code><var>m</var></code>.</p>

<eg>&lt;xsl:template match="*|/" mode="<var>m</var>">
  &lt;xsl:apply-templates mode="<var>m</var>"/>
&lt;/xsl:template></eg>

<p>There is also a built-in template rule for text and attribute nodes
that copies text through:</p>

<eg><![CDATA[<xsl:template match="text()|@*">
  <xsl:value-of select="."/>
</xsl:template>]]></eg>

<p>The built-in template rule for processing instructions and comments
is to do nothing.</p>

<eg><![CDATA[<xsl:template match="processing-instruction()|comment()"/>]]></eg>

<p>The built-in template rule for namespace nodes is also to do
nothing. There is no pattern that can match a namespace node; so, the
built-in template rule is the only template rule that is applied for
namespace nodes.</p>

<p>The built-in template rules are treated as if they were imported
implicitly before the stylesheet and so have lower <termref
def="dt-import-precedence">import precedence</termref> than all other
template rules.  Thus, the author can override a built-in template
rule by including an explicit template rule.</p>

</div2>


</div1>

<div1 id="named-templates">
<head>Named Templates</head>

<e:element-syntax name="call-template">
  <e:in-category name="instruction"/>
  <e:attribute name="name" required="yes">
    <e:data-type name="qname"/>
  </e:attribute>
  <e:element repeat="zero-or-more" name="with-param"/>
</e:element-syntax>

<p>Templates can be invoked by name.  An <code>xsl:template</code>
element with a <code>name</code> attribute specifies a named template.
The value of the <code>name</code> attribute is a <xnt
href="&XMLNames;#NT-QName">QName</xnt>, which is expanded as described
in <specref ref="qname"/>. If an <code>xsl:template</code> element has
a <code>name</code> attribute, it may, but need not, also have a
<code>match</code> attribute.  An <code>xsl:call-template</code>
element invokes a template by name; it has a required
<code>name</code> attribute that identifies the template to be
invoked.  Unlike <code>xsl:apply-templates</code>,
<code>xsl:call-template</code> does not change the current node or the
current node list.</p>

<p>The <code>match</code>, <code>mode</code> and <code>priority</code> attributes on an
<code>xsl:template</code> element do not affect whether the template
is invoked by an <code>xsl:call-template</code> element.  Similarly,
the <code>name</code> attribute on an <code>xsl:template</code>
element does not affect whether the template is invoked by an
<code>xsl:apply-templates</code> element.</p>

<p>It is an error if a stylesheet contains more than one template with
the same name and same <termref def="dt-import-precedence">import
precedence</termref>.</p>

</div1>


<div1>
<head>Creating the Result Tree</head>

<p>This section describes instructions that directly create nodes in
the result tree.</p>

<div2>
<head>Creating Elements and Attributes</head>

<div3 id="literal-result-element">
<head>Literal Result Elements</head>

<p>In a template, an element in the stylesheet that does not belong to
the XSLT namespace and that is not an extension element (see <specref
ref="extension-element"/>) is instantiated to create an element node
with the same <xtermref
href="&XPath;#dt-expanded-name">expanded-name</xtermref>.  The content
of the element is a template, which is instantiated to give the
content of the created element node. The created element node will
have the attribute nodes that were present on the element node in the
stylesheet tree, other than attributes with names in the XSLT
namespace.</p>

<p>The created element node will also have a copy of the namespace
nodes that were present on the element node in the stylesheet tree
with the exception of any namespace node whose string-value is the
XSLT namespace URI (<code>&XSLT.ns;</code>), a
namespace URI declared as an extension namespace (see <specref
ref="extension-element"/>), or a namespace URI designated as an
excluded namespace.  A namespace URI is designated as an excluded
namespace by using an <code>exclude-result-prefixes</code> attribute
on an <code>xsl:stylesheet</code> element or an
<code>xsl:exclude-result-prefixes</code> attribute on a literal result
element.  The value of both these attributes is a whitespace-separated
list of namespace prefixes. The namespace bound to each of the
prefixes is designated as an excluded namespace.  It is an error if
there is no namespace bound to the prefix on the element bearing the
<code>exclude-result-prefixes</code> or
<code>xsl:exclude-result-prefixes</code> attribute.  The default
namespace (as declared by <code>xmlns</code>) may be designated as an
excluded namespace by including <code>#default</code> in the list of
namespace prefixes.  The designation of a namespace as an excluded
namespace is effective within the subtree of the stylesheet rooted at
the element bearing the <code>exclude-result-prefixes</code> or
<code>xsl:exclude-result-prefixes</code> attribute;
a subtree rooted at an <code>xsl:stylesheet</code> element
does not include any stylesheets imported or included by children
of that <code>xsl:stylesheet</code> element.</p>

<note><p>When a stylesheet uses a namespace declaration only for the
purposes of addressing the source tree, specifying the prefix in the
<code>exclude-result-prefixes</code> attribute will avoid superfluous
namespace declarations in the result tree.</p></note>

<p>The value of an attribute of a literal result element is
interpreted as an <termref def="dt-attribute-value-template">attribute
value template</termref>: it can contain expressions contained
in curly braces (<code>{}</code>).</p>

<p><termdef id="dt-literal-namespace-uri" term="Literal Namespace
URI">A namespace URI in the stylesheet tree that is being used to
specify a namespace URI in the result tree is called a <term>literal
namespace URI</term>.</termdef> This applies to:</p>

<ulist>

<item><p>the namespace URI in the expanded-name of a literal
result element in the stylesheet</p></item>

<item><p>the namespace URI in the expanded-name of an attribute
specified on a literal result element in the stylesheet</p></item>

<item><p>the string-value of a namespace node on a literal result
element in the stylesheet</p></item>

</ulist>

<e:element-syntax name="namespace-alias">
  <e:in-category name="top-level-element"/>
  <e:attribute name="stylesheet-prefix" required="yes">
    <e:data-type name="prefix"/>
    <e:constant value="#default"/>
  </e:attribute>
  <e:attribute name="result-prefix" required="yes">
    <e:data-type name="prefix"/>
    <e:constant value="#default"/>
  </e:attribute>
  <e:empty/>
</e:element-syntax>

<p><termdef id="dt-alias" term="Alias">A stylesheet can use the
<code>xsl:namespace-alias</code> element to declare that one namespace
URI is an <term>alias</term> for another namespace URI.</termdef> When
a <termref def="dt-literal-namespace-uri">literal namespace
URI</termref> has been declared to be an alias for another namespace
URI, then the namespace URI in the result tree will be the namespace
URI that the literal namespace URI is an alias for, instead of the
literal namespace URI itself.  The <code>xsl:namespace-alias</code>
element declares that the namespace URI bound to the prefix specified
by the <code>stylesheet-prefix</code> attribute is an alias for the
namespace URI bound to the prefix specified by the
<code>result-prefix</code> attribute.  Thus, the
<code>stylesheet-prefix</code> attribute specifies the namespace URI
that will appear in the stylesheet, and the
<code>result-prefix</code> attribute specifies the corresponding
namespace URI that will appear in the result tree.  The default
namespace (as declared by <code>xmlns</code>) may be specified by
using <code>#default</code> instead of a prefix.  If a namespace URI
is declared to be an alias for multiple different namespace URIs, then
the declaration with the highest <termref
def="dt-import-precedence">import precedence</termref> is used. It is
an error if there is more than one such declaration.  An XSLT
processor may signal the error; if it does not signal the error, it
must recover by choosing, from amongst the declarations with the
highest import precedence, the one that occurs last in the
stylesheet.</p>

<p>When literal result elements are being used to create element,
attribute, or namespace nodes that use the XSLT namespace URI, the
stylesheet must use an alias.  For example, the stylesheet</p>

<eg>&lt;xsl:stylesheet
  version="1.0"
  xmlns:xsl="&XSLT.ns;"
  xmlns:fo="&XSLFO.ns;"
  xmlns:axsl="&XSLTA.ns;"><![CDATA[

<xsl:namespace-alias stylesheet-prefix="axsl" result-prefix="xsl"/>

<xsl:template match="/">
  <axsl:stylesheet>
    <xsl:apply-templates/>
  </axsl:stylesheet>
</xsl:template>

<xsl:template match="block">
  <axsl:template match="{.}">
     <fo:block><axsl:apply-templates/></fo:block>
  </axsl:template>
</xsl:template>

</xsl:stylesheet>]]></eg>

<p>will generate an XSLT stylesheet from a document of the form:</p>

<eg><![CDATA[<elements>
<block>p</block>
<block>h1</block>
<block>h2</block>
<block>h3</block>
<block>h4</block>
</elements>]]></eg>

<note><p>It may be necessary also to use aliases for namespaces other
than the XSLT namespace URI.  For example, literal result elements
belonging to a namespace dealing with digital signatures might cause
XSLT stylesheets to be mishandled by general-purpose security
software; using an alias for the namespace would avoid the possibility
of such mishandling.</p></note>

</div3>

<div3>
<head>Creating Elements with <code>xsl:element</code></head>

<e:element-syntax name="element">
  <e:in-category name="instruction"/>
  <e:attribute name="name" required="yes">
    <e:attribute-value-template>
      <e:data-type name="qname"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:attribute name="namespace">
    <e:attribute-value-template>
      <e:data-type name="uri-reference"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:attribute name="use-attribute-sets">
    <e:data-type name="qnames"/>
  </e:attribute>
  <e:model name="template"/>
</e:element-syntax>

<p>The <code>xsl:element</code> element allows an element to be
created with a computed name.  The <xtermref
href="&XPath;#dt-expanded-name">expanded-name</xtermref> of the
element to be created is specified by a required <code>name</code>
attribute and an optional <code>namespace</code> attribute.  The
content of the <code>xsl:element</code> element is a template for the
attributes and children of the created element.</p>

<p>The <code>name</code> attribute is interpreted as an <termref
def="dt-attribute-value-template">attribute value template</termref>.
It is an error if the string that results from instantiating the
attribute value template is not a <xnt
href="&XMLNames;#NT-QName">QName</xnt>.  An XSLT processor may signal
the error; if it does not signal the error, then it must recover
by making the the result of instantiating the <code>xsl:element</code>
element be the sequence of nodes created by instantiating
the content of the  <code>xsl:element</code> element, excluding
any initial attribute nodes. If the <code>namespace</code> attribute is
not present then the <xnt href="&XMLNames;#NT-QName">QName</xnt> is
expanded into an expanded-name using the namespace declarations in
effect for the <code>xsl:element</code> element, including any default
namespace declaration.</p>

<p>If the <code>namespace</code> attribute is present, then it also is
interpreted as an <termref def="dt-attribute-value-template">attribute
value template</termref>. The string that results from instantiating
the attribute value template should be a URI reference.  It is not an
error if the string is not a syntactically legal URI reference.  If
the string is empty, then the expanded-name of the element has a null
namespace URI.  Otherwise, the string is used as the namespace URI of
the expanded-name of the element to be created. The local part of the
<xnt href="&XMLNames;#NT-QName">QName</xnt> specified by the
<code>name</code> attribute is used as the local part of the
expanded-name of the element to be created.</p>

<p>XSLT processors may make use of the prefix of the <xnt
href="&XMLNames;#NT-QName">QName</xnt> specified in the
<code>name</code> attribute when selecting the prefix used for
outputting the created element as XML; however, they are not required
to do so.</p>

</div3>

<div3 id="creating-attributes">
<head>Creating Attributes with <code>xsl:attribute</code></head>

<e:element-syntax name="attribute">
  <e:in-category name="instruction"/>
  <e:attribute name="name" required="yes">
    <e:attribute-value-template>
      <e:data-type name="qname"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:attribute name="namespace">
    <e:attribute-value-template>
      <e:data-type name="uri-reference"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:model name="template"/>
</e:element-syntax>

<p>The <code>xsl:attribute</code> element can be used to add
attributes to result elements whether created by literal result
elements in the stylesheet or by instructions such as
<code>xsl:element</code>. The <xtermref
href="&XPath;#dt-expanded-name">expanded-name</xtermref> of the
attribute to be created is specified by a required <code>name</code>
attribute and an optional <code>namespace</code> attribute.
Instantiating an <code>xsl:attribute</code> element adds an attribute
node to the containing result element node. The content of the
<code>xsl:attribute</code> element is a template for the value of the
created attribute.</p>

<p>The <code>name</code> attribute is interpreted as an <termref
def="dt-attribute-value-template">attribute value template</termref>.
It is an error if the string that results from instantiating the
attribute value template is not a <xnt
href="&XMLNames;#NT-QName">QName</xnt> or is the string
<code>xmlns</code>.  An XSLT processor may signal the error; if it
does not signal the error, it must recover by not adding the attribute
to the result tree. If the <code>namespace</code> attribute is not
present, then the <xnt href="&XMLNames;#NT-QName">QName</xnt> is
expanded into an expanded-name using the namespace declarations in
effect for the <code>xsl:attribute</code> element, <emph>not</emph>
including any default namespace declaration.</p>

<p>If the <code>namespace</code> attribute is present, then it also is
interpreted as an <termref def="dt-attribute-value-template">attribute
value template</termref>. The string that results from instantiating
it should be a URI reference.  It is not an error if the string is not
a syntactically legal URI reference.  If the string is empty, then the
expanded-name of the attribute has a null namespace URI.  Otherwise,
the string is used as the namespace URI of the expanded-name of the
attribute to be created. The local part of the <xnt
href="&XMLNames;#NT-QName">QName</xnt> specified by the
<code>name</code> attribute is used as the local part of the
expanded-name of the attribute to be created.</p>

<p>XSLT processors may make use of the prefix of the <xnt
href="&XMLNames;#NT-QName">QName</xnt> specified in the
<code>name</code> attribute when selecting the prefix used for
outputting the created attribute as XML; however, they are not
required to do so and, if the prefix is <code>xmlns</code>, they must
not do so. Thus, although it is not an error to do:</p>

<eg>&lt;xsl:attribute name="xmlns:xsl" namespace="whatever">&XSLT.ns;&lt;/xsl:attribute></eg>

<p>it will not result in a namespace declaration being output.</p>

<p>Adding an attribute to an element replaces any existing attribute
of that element with the same expanded-name.</p>

<p>The following are all errors:</p>

<ulist>

<item><p>Adding an attribute to an element after children have been
added to it; implementations may either signal the error or ignore the
attribute.</p></item>

<item><p>Adding an attribute to a node that is not an element;
implementations may either signal the error or ignore the
attribute.</p></item>

<item><p>Creating nodes other than text nodes during the
instantiation of the content of the <code>xsl:attribute</code>
element; implementations may either signal the error or ignore the
offending nodes.</p></item>

</ulist>

<note><p>When an <code>xsl:attribute</code> contains a text node with
a newline, then the XML output must contain a character reference.
For example,</p>

<eg><![CDATA[<xsl:attribute name="a">x
y</xsl:attribute>]]></eg>

<p>will result in the output</p>

<eg><![CDATA[a="x&#xA;y"]]></eg>

<p>(or with any equivalent character reference). The XML output cannot
be</p>

<eg><![CDATA[a="x
y"]]></eg>

<p>This is because XML 1.0 requires newline characters in attribute
values to be normalized into spaces but requires character references
to newline characters not to be normalized.  The attribute values in
the data model represent the attribute value after normalization.  If
a newline occurring in an attribute value in the tree were output as a
newline character rather than as character reference, then the
attribute value in the tree created by reparsing the XML would contain
a space not a newline, which would mean that the tree had not been
output correctly.</p></note>

</div3>

<div3 id="attribute-sets">

<head>Named Attribute Sets</head>

<e:element-syntax name="attribute-set">
  <e:in-category name="top-level-element"/>
  <e:attribute name="name" required="yes">
    <e:data-type name="qname"/>
  </e:attribute>
  <e:attribute name="use-attribute-sets">
    <e:data-type name="qnames"/>
  </e:attribute>
  <e:element repeat="zero-or-more" name="attribute"/>
</e:element-syntax>

<p>The <code>xsl:attribute-set</code> element defines a named set of
attributes.  The <code>name</code> attribute specifies the name of the
attribute set.  The value of the <code>name</code> attribute is a <xnt
href="&XMLNames;#NT-QName">QName</xnt>, which is expanded as described
in <specref ref="qname"/>. The content of the <code>xsl:attribute-set</code>
element consists of zero or more <code>xsl:attribute</code> elements
that specify the attributes in the set.</p>

<p>Attribute sets are used by specifying a
<code>use-attribute-sets</code> attribute on <code>xsl:element</code>,
<code>xsl:copy</code> (see <specref ref="copying"/>) or
<code>xsl:attribute-set</code> elements.  The value of the
<code>use-attribute-sets</code> attribute is a whitespace-separated
list of names of attribute sets.  Each name is specified as a <xnt
href="&XMLNames;#NT-QName">QName</xnt>, which is expanded as described
in <specref ref="qname"/>.  Specifying a
<code>use-attribute-sets</code> attribute is equivalent to adding
<code>xsl:attribute</code> elements for each of the attributes in each
of the named attribute sets to the beginning of the content of the
element with the <code>use-attribute-sets</code> attribute, in the
same order in which the names of the attribute sets are specified in
the <code>use-attribute-sets</code> attribute.  It is an error if use
of <code>use-attribute-sets</code> attributes on
<code>xsl:attribute-set</code> elements causes an attribute set to
directly or indirectly use itself.</p>

<p>Attribute sets can also be used by specifying an
<code>xsl:use-attribute-sets</code> attribute on a literal result
element.  The value of the <code>xsl:use-attribute-sets</code>
attribute is a whitespace-separated list of names of attribute sets.
The <code>xsl:use-attribute-sets</code> attribute has the same effect
as the <code>use-attribute-sets</code> attribute on
<code>xsl:element</code> with the additional rule that attributes
specified on the literal result element itself are treated as if they
were specified by <code>xsl:attribute</code> elements before any
actual <code>xsl:attribute</code> elements but after any
<code>xsl:attribute</code> elements implied by the
<code>xsl:use-attribute-sets</code> attribute.  Thus, for a literal
result element, attributes from attribute sets named in an
<code>xsl:use-attribute-sets</code> attribute will be added first, in
the order listed in the attribute; next, attributes specified on the
literal result element will be added; finally, any attributes
specified by <code>xsl:attribute</code> elements will be added.  Since
adding an attribute to an element replaces any existing attribute of
that element with the same name, this means that attributes specified
in attribute sets can be overridden by attributes specified on the
literal result element itself.</p>

<p>The template within each <code>xsl:attribute</code> element in an
<code>xsl:attribute-set</code> element is instantiated each time the
attribute set is used; it is instantiated using the same current node
and current node list as is used for instantiating the element bearing
the <code>use-attribute-sets</code> or
<code>xsl:use-attribute-sets</code> attribute. However, it is the
position in the stylesheet of the <code>xsl:attribute</code> element
rather than of the element bearing the <code>use-attribute-sets</code>
or <code>xsl:use-attribute-sets</code> attribute that determines which
variable bindings are visible (see <specref ref="variables"/>); thus,
only variables and parameters declared by <termref
def="dt-top-level">top-level</termref> <code>xsl:variable</code> and
<code>xsl:param</code> elements are visible.</p>

<p>The following example creates a named attribute set
<code>title-style</code> and uses it in a template rule.</p>

<eg><![CDATA[<xsl:template match="chapter/heading">
  <fo:block quadding="start" xsl:use-attribute-sets="title-style">
    <xsl:apply-templates/>
  </fo:block>
</xsl:template>

<xsl:attribute-set name="title-style">
  <xsl:attribute name="font-size">12pt</xsl:attribute>
  <xsl:attribute name="font-weight">bold</xsl:attribute>
</xsl:attribute-set>]]></eg>

<p>Multiple definitions of an attribute set with the same
expanded-name are merged.  An attribute from a definition that has
higher <termref def="dt-import-precedence">import precedence</termref>
takes precedence over an attribute from a definition that has lower
<termref def="dt-import-precedence">import precedence</termref>.  It
is an error if there are two attribute sets that have the same
expanded-name and equal import precedence and that both contain
the same attribute, unless there is a definition of the attribute set
with higher <termref def="dt-import-precedence">import
precedence</termref> that also contains the attribute.  An XSLT
processor may signal the error; if it does not signal the error, it
must recover by choosing from amongst the definitions that specify the
attribute that have the highest import precedence the one that was
specified last in the stylesheet.  Where the attributes in an
attribute set were specified is relevant only in merging the
attributes into the attribute set; it makes no difference when the
attribute set is used.</p>

</div3>

</div2>

<div2>

<head>Creating Text</head>

<p>A template can also contain text nodes.  Each text node in a
template remaining after whitespace has been stripped as specified in
<specref ref="strip"/> will create a text node with the same
string-value in the result tree.  Adjacent text nodes in the result
tree are automatically merged.</p>

<p>Note that text is processed at the tree level. Thus, markup of
<code>&amp;lt;</code> in a template will be represented in the
stylesheet tree by a text node that includes the character
<code>&lt;</code>. This will create a text node in the result tree
that contains a <code>&lt;</code> character, which will be represented
by the markup <code>&amp;lt;</code> (or an equivalent character
reference) when the result tree is externalized as an XML document
(unless output escaping is disabled as described in <specref
ref="disable-output-escaping"/>).</p>

<e:element-syntax name="text">
  <e:in-category name="instruction"/>
  <e:attribute name="disable-output-escaping">
    <e:constant value="yes"/>
    <e:constant value="no"/>
  </e:attribute>
  <e:text/>  
</e:element-syntax>

<p>Literal data characters may also be wrapped in an
<code>xsl:text</code> element.  This wrapping may change what
whitespace characters are stripped (see <specref ref="strip"/>) but
does not affect how the characters are handled by the XSLT processor
thereafter.</p>

<note><p>The <code>xml:lang</code> and <code>xml:space</code>
attributes are not treated specially by XSLT. In particular,</p>

<ulist>
<item><p>it is the responsibility of the stylesheet author explicitly
to generate any <code>xml:lang</code> or <code>xml:space</code>
attributes that are needed in the result;</p></item>

<item><p>specifying an <code>xml:lang</code> or <code>xml:space</code>
attribute on an element in the XSLT namespace will not cause any
<code>xml:lang</code> or <code>xml:space</code> attributes to appear
in the result.</p></item>
</ulist>
</note>

</div2>


<div2>
<head>Creating Processing Instructions</head>


<e:element-syntax name="processing-instruction">
  <e:in-category name="instruction"/>
  <e:attribute name="name" required="yes">
    <e:attribute-value-template>
      <e:data-type name="ncname"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:model name="template"/>
</e:element-syntax>

<p>The <code>xsl:processing-instruction</code> element is instantiated
to create a processing instruction node.  The content of the
<code>xsl:processing-instruction</code> element is a template for the
string-value of the processing instruction node.  The
<code>xsl:processing-instruction</code> element has a required
<code>name</code> attribute that specifies the name of the processing
instruction node.  The value of the <code>name</code> attribute is
interpreted as an <termref def="dt-attribute-value-template">attribute
value template</termref>.</p>

<p>For example, this</p>

<eg><![CDATA[<xsl:processing-instruction name="xml-stylesheet">href="book.css" type="text/css"</xsl:processing-instruction>]]></eg>

<p>would create the processing instruction</p>

<eg><![CDATA[<?xml-stylesheet href="book.css" type="text/css"?>]]></eg>

<p>It is an error if the string that results from instantiating the
<code>name</code> attribute is not both an <xnt
href="&XMLNames;#NT-NCName">NCName</xnt> and a <xnt
href="&XML;#NT-PITarget">PITarget</xnt>.  An XSLT processor may signal
the error; if it does not signal the error, it must recover by not
adding the processing instruction to the result tree.</p>

<note><p>This means that <code>xsl:processing-instruction</code>
cannot be used to output an XML declaration.  The
<code>xsl:output</code> element should be used instead (see <specref
ref="output"/>).</p></note>

<p>It is an error if instantiating the content of
<code>xsl:processing-instruction</code> creates nodes other than
text nodes.  An XSLT processor may signal the error; if it does not
signal the error, it must recover by ignoring the offending nodes
together with their content.</p>

<p>It is an error if the result of instantiating the content of the
<code>xsl:processing-instruction</code> contains the string
<code>?&gt;</code>.  An XSLT processor may signal the error; if it does
not signal the error, it must recover by inserting a space after any
occurrence of <code>?</code> that is followed by a <code>&gt;</code>.</p>

</div2>

<div2>
<head>Creating Comments</head>

<e:element-syntax name="comment">
  <e:in-category name="instruction"/>
  <e:model name="template"/>
</e:element-syntax>

<p>The <code>xsl:comment</code> element is instantiated to create a
comment node in the result tree.  The content of the
<code>xsl:comment</code> element is a template for the string-value of
the comment node.</p>

<p>For example, this</p>

<eg><![CDATA[<xsl:comment>This file is automatically generated. Do not edit!</xsl:comment>]]></eg>

<p>would create the comment</p>

<eg><![CDATA[<!--This file is automatically generated. Do not edit!-->]]></eg>

<p>It is an error if instantiating the content of
<code>xsl:comment</code> creates nodes other than text nodes.  An
XSLT processor may signal the error; if it does not signal the error,
it must recover by ignoring the offending nodes together with their
content.</p>

<p>It is an error if the result of instantiating the content of the
<code>xsl:comment</code> contains the string <code>--</code> or ends
with <code>-</code>.  An XSLT processor may signal the error; if it
does not signal the error, it must recover by inserting a space after
any occurrence of <code>-</code> that is followed by another
<code>-</code> or that ends the comment.</p>

</div2>

<div2 id="copying">
<head>Copying</head>

<e:element-syntax name="copy">
  <e:in-category name="instruction"/>
  <e:attribute name="use-attribute-sets">
    <e:data-type name="qnames"/>
  </e:attribute>
  <e:model name="template"/>
</e:element-syntax>

<p>The <code>xsl:copy</code> element provides an easy way of copying
the current node. Instantiating the <code>xsl:copy</code> element
creates a copy of the current node.  The namespace nodes of the
current node are automatically copied as well, but the attributes and
children of the node are not automatically copied.  The content of the
<code>xsl:copy</code> element is a template for the attributes and
children of the created node; the content is instantiated only for
nodes of types that can have attributes or children (i.e. root
nodes and element nodes).</p>

<p>The <code>xsl:copy</code> element may have a
<code>use-attribute-sets</code> attribute (see <specref
ref="attribute-sets"/>). This is used only when copying element
nodes.</p>

<p>The root node is treated specially because the root node of the
result tree is created implicitly.  When the current node is the root
node, <code>xsl:copy</code> will not create a root node, but will just
use the content template.</p>

<p>For example, the identity transformation can be written using
<code>xsl:copy</code> as follows:</p>

<eg><![CDATA[<xsl:template match="@*|node()">
  <xsl:copy>
    <xsl:apply-templates select="@*|node()"/>
  </xsl:copy>
</xsl:template>]]></eg>

<p>When the current node is an attribute, then if it would be an error
to use <code>xsl:attribute</code> to create an attribute with the same
name as the current node, then it is also an error to use
<code>xsl:copy</code> (see <specref ref="creating-attributes"/>).</p>

<p>The following example shows how <code>xml:lang</code> attributes
can be easily copied through from source to result. If a stylesheet
defines the following named template:</p>

<eg><![CDATA[<xsl:template name="apply-templates-copy-lang">
 <xsl:for-each select="@xml:lang">
   <xsl:copy/>
 </xsl:for-each>
 <xsl:apply-templates/>
</xsl:template>]]></eg>

<p>then it can simply do</p>

<eg><![CDATA[<xsl:call-template name="apply-templates-copy-lang"/>]]></eg>

<p>instead of</p>

<eg><![CDATA[<xsl:apply-templates/>]]></eg>

<p>when it wants to copy the <code>xml:lang</code> attribute.</p>

</div2>

<div2>
<head>Computing Generated Text</head>

<p>Within a template, the <code>xsl:value-of</code> element can be
used to compute generated text, for example by extracting text from
the source tree or by inserting the value of a variable.  The
<code>xsl:value-of</code> element does this with an <termref
def="dt-expression">expression</termref> that is specified as the
value of the <code>select</code> attribute.  Expressions can
also be used inside attribute values of literal result elements by
enclosing the expression in curly braces (<code>{}</code>).</p>

<div3 id="value-of">
<head>Generating Text with <code>xsl:value-of</code></head>

<e:element-syntax name="value-of">
  <e:in-category name="instruction"/>
  <e:attribute name="select" required="yes">
    <e:data-type name="string-expression"/>
  </e:attribute>
  <e:attribute name="disable-output-escaping">
    <e:constant value="yes"/>
    <e:constant value="no"/>
  </e:attribute>
  <e:empty/>
</e:element-syntax>

<p>The <code>xsl:value-of</code> element is instantiated to create a
text node in the result tree.  The required <code>select</code>
attribute is an <termref def="dt-expression">expression</termref>;
this expression is evaluated and the resulting object is converted to
a string as if by a call to the <xfunction>string</xfunction>
function. The string specifies the string-value of the created text
node.  If the string is empty, no text node will be created.  The
created text node will be merged with any adjacent text nodes.</p>

<p>The <code>xsl:copy-of</code> element can be used to copy a node-set
over to the result tree without converting it to a string. See <specref
ref="copy-of"/>.</p>

<p>For example, the following creates an HTML paragraph from a
<code>person</code> element with <code>given-name</code> and
<code>family-name</code> attributes.  The paragraph will contain the value
of the <code>given-name</code> attribute of the current node followed
by a space and the value of the <code>family-name</code> attribute of the
current node.</p>

<eg><![CDATA[<xsl:template match="person">
  <p>
   <xsl:value-of select="@given-name"/>
   <xsl:text> </xsl:text>
   <xsl:value-of select="@family-name"/>
  </p>
</xsl:template>]]></eg>

<p>For another example, the following creates an HTML paragraph from a
<code>person</code> element with <code>given-name</code> and
<code>family-name</code> children elements.  The paragraph will
contain the string-value of the first <code>given-name</code> child
element of the current node followed by a space and the string-value
of the first <code>family-name</code> child element of the current
node.</p>

<eg><![CDATA[<xsl:template match="person">
  <p>
   <xsl:value-of select="given-name"/>
   <xsl:text> </xsl:text>
   <xsl:value-of select="family-name"/>
  </p>
</xsl:template>]]></eg>

<p>The following precedes each <code>procedure</code> element with a
paragraph containing the security level of the procedure.  It assumes
that the security level that applies to a procedure is determined by a
<code>security</code> attribute on the procedure element or on an
ancestor element of the procedure. It also assumes that if more than
one such element has a <code>security</code> attribute then the
security level is determined by the element that is closest to the
procedure.</p>

<eg><![CDATA[<xsl:template match="procedure">
  <fo:block>
    <xsl:value-of select="ancestor-or-self::*[@security][1]/@security"/>
  </fo:block>
  <xsl:apply-templates/>
</xsl:template>]]></eg>

</div3>

<div3 id="attribute-value-templates">
<head>Attribute Value Templates</head>

<p><termdef id="dt-attribute-value-template" term="Attribute Value
Template">In an attribute value that is interpreted as an
<term>attribute value template</term>, such as an attribute of a
literal result element, an <termref
def="dt-expression">expression</termref> can be used by surrounding
the expression with curly braces (<code>{}</code>)</termdef>.  The
attribute value template is instantiated by replacing the expression
together with surrounding curly braces by the result of evaluating the
expression and converting the resulting object to a string as if by a
call to the <xfunction>string</xfunction> function.  Curly braces are
not recognized in an attribute value in an XSLT stylesheet unless the
attribute is specifically stated to be one that is interpreted as an
attribute value template; in an element syntax summary, the value
of such attributes is surrounded by curly braces.</p>

<note><p>Not all attributes are interpreted as attribute value
templates.  Attributes whose value is an expression or pattern,
attributes of <termref def="dt-top-level">top-level</termref> elements
and attributes that refer to named XSLT objects are not interpreted as
attribute value templates. In addition, <code>xmlns</code> attributes
are not interpreted as attribute value templates; it would not be
conformant with the XML Namespaces Recommendation to do
this.</p></note>

<p>The following example creates an <code>img</code> result element
from a <code>photograph</code> element in the source; the value of the
<code>src</code> attribute of the <code>img</code> element is computed
from the value of the <code>image-dir</code> variable and the
string-value of the <code>href</code> child of the
<code>photograph</code> element; the value of the <code>width</code>
attribute of the <code>img</code> element is computed from the value
of the <code>width</code> attribute of the <code>size</code> child of
the <code>photograph</code> element:</p>

<eg><![CDATA[<xsl:variable name="image-dir">/images</xsl:variable>

<xsl:template match="photograph">
<img src="{$image-dir}/{href}" width="{size/@width}"/>
</xsl:template>]]></eg>

<p>With this source</p>

<eg><![CDATA[<photograph>
  <href>headquarters.jpg</href>
  <size width="300"/>
</photograph>]]></eg>

<p>the result would be</p>

<eg><![CDATA[<img src="/images/headquarters.jpg" width="300"/>]]></eg>

<p>When an attribute value template is instantiated, a double left or
right curly brace outside an expression will be replaced by a single
curly brace.  It is an error if a right curly brace occurs in an
attribute value template outside an expression without being followed
by a second right curly brace.  A right curly brace inside a <xnt
href="&XPath;#NT-Literal">Literal</xnt> in an expression is not
recognized as terminating the expression.</p>

<p>Curly braces are <emph>not</emph> recognized recursively inside
expressions.  For example:</p>

<eg role="error"><![CDATA[<a href="#{id({@ref})/title}">]]></eg>

<p>is <emph>not</emph> allowed.  Instead, use simply:</p>

<eg><![CDATA[<a href="#{id(@ref)/title}">]]></eg>

</div3>

</div2>

<div2 id="number">
<head>Numbering</head>

<e:element-syntax name="number">
  <e:in-category name="instruction"/>
  <e:attribute name="level">
    <e:constant value="single"/>
    <e:constant value="multiple"/>
    <e:constant value="any"/>
  </e:attribute>
  <e:attribute name="count">
    <e:data-type name="pattern"/>
  </e:attribute>
  <e:attribute name="from">
    <e:data-type name="pattern"/>
  </e:attribute>
  <e:attribute name="value">
    <e:data-type name="number-expression"/>
  </e:attribute>
  <e:attribute name="format">
    <e:attribute-value-template>
      <e:data-type name="string"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:attribute name="lang">
    <e:attribute-value-template>
      <e:data-type name="nmtoken"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:attribute name="letter-value">
    <e:attribute-value-template>
      <e:constant value="alphabetic"/>
      <e:constant value="traditional"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:attribute name="grouping-separator">
    <e:attribute-value-template>
      <e:data-type name="char"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:attribute name="grouping-size">
    <e:attribute-value-template>
      <e:data-type name="number"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:empty/>
</e:element-syntax>

<p>The <code>xsl:number</code> element is used to insert a formatted
number into the result tree.  The number to be inserted may be
specified by an expression. The <code>value</code> attribute contains
an <termref def="dt-expression">expression</termref>.  The expression
is evaluated and the resulting object is converted to a number as if
by a call to the <xfunction>number</xfunction> function.  The number is
rounded to an integer and then converted to a string using the
attributes specified in <specref ref="convert"/>; in this
context, the value of each of these attributes is
interpreted as an <termref def="dt-attribute-value-template">attribute
value template</termref>.  After conversion, the resulting string is
inserted in the result tree. For example, the following example
numbers a sorted list:</p>

<eg><![CDATA[<xsl:template match="items">
  <xsl:for-each select="item">
    <xsl:sort select="."/>
    <p>
      <xsl:number value="position()" format="1. "/>
      <xsl:value-of select="."/>
    </p>
  </xsl:for-each>
</xsl:template>]]></eg>

<p>If no <code>value</code> attribute is specified, then the
<code>xsl:number</code> element inserts a number based on the position
of the current node in the source tree. The following attributes
control how the current node is to be numbered:</p>

<ulist>

<item><p>The <code>level</code> attribute specifies what levels of the
source tree should be considered; it has the values
<code>single</code>, <code>multiple</code> or <code>any</code>. The
default is <code>single</code>.</p></item>

<item><p>The <code>count</code> attribute is a pattern that specifies
what nodes should be counted at those levels.  If <code>count</code>
attribute is not specified, then it defaults to the pattern that
matches any node with the same node type as the current node and, if
the current node has an expanded-name, with the same expanded-name as
the current node.</p></item>

<item><p>The <code>from</code> attribute is a pattern that specifies
where counting starts.</p></item>

</ulist>

<p>In addition, the attributes specified in <specref ref="convert"/>
are used for number to string conversion, as in the case when the
<code>value</code> attribute is specified.</p>

<p>The <code>xsl:number</code> element first constructs a list of
positive integers using the <code>level</code>, <code>count</code> and
<code>from</code> attributes:</p>

<ulist>

<item><p>When <code>level="single"</code>, it goes up to the first
node in the ancestor-or-self axis that matches
the <code>count</code> pattern, and constructs a list of length one
containing one plus the number of preceding siblings of that ancestor
that match the <code>count</code> pattern. If there is no such
ancestor, it constructs an empty list.  If the <code>from</code>
attribute is specified, then the only ancestors that are searched are
those that are descendants of the nearest ancestor that matches the
<code>from</code> pattern. Preceding siblings has the same meaning
here as with the <code>preceding-sibling</code> axis.</p></item>

<item><p>When <code>level="multiple"</code>, it constructs a list of all
ancestors of the current node in document order followed by the
element itself; it then selects from the list those nodes that match
the <code>count</code> pattern; it then maps each node in the list to
one plus the number of preceding siblings of that node that match the
<code>count</code> pattern.  If the <code>from</code> attribute is
specified, then the only ancestors that are searched are those that
are descendants of the nearest ancestor that matches the
<code>from</code> pattern. Preceding siblings has the same meaning
here as with the <code>preceding-sibling</code> axis.</p></item>

<item><p>When <code>level="any"</code>, it constructs a list of length
one containing the number of nodes that match the <code>count</code>
pattern and belong to the set containing the current node and all
nodes at any level of the document that are before the current node in
document order, excluding any namespace and attribute nodes (in other
words the union of the members of the <code>preceding</code> and
<code>ancestor-or-self</code> axes). If the <code>from</code>
attribute is specified, then only nodes after the first node before
the current node that match the <code>from</code> pattern are
considered.</p></item>

</ulist>

<p>The list of numbers is then converted into a string using the
attributes specified in <specref ref="convert"/>; in this
context, the value of each of these attributes is
interpreted as an <termref def="dt-attribute-value-template">attribute
value template</termref>.  After conversion, the resulting string is
inserted in the result tree.</p>

<p>The following would number the items in an ordered list:</p>

<eg><![CDATA[<xsl:template match="ol/item">
  <fo:block>
    <xsl:number/><xsl:text>. </xsl:text><xsl:apply-templates/>
  </fo:block>
<xsl:template>]]></eg>

<p>The following two rules would number <code>title</code> elements.
This is intended for a document that contains a sequence of chapters
followed by a sequence of appendices, where both chapters and
appendices contain sections, which in turn contain subsections.
Chapters are numbered 1, 2, 3; appendices are numbered A, B, C;
sections in chapters are numbered 1.1, 1.2, 1.3; sections in
appendices are numbered A.1, A.2, A.3.</p>

<eg><![CDATA[<xsl:template match="title">
  <fo:block>
     <xsl:number level="multiple"
                 count="chapter|section|subsection"
                 format="1.1 "/>
     <xsl:apply-templates/>
  </fo:block>
</xsl:template>

<xsl:template match="appendix//title" priority="1">
  <fo:block>
     <xsl:number level="multiple"
                 count="appendix|section|subsection"
                 format="A.1 "/>
     <xsl:apply-templates/>
  </fo:block>
</xsl:template>]]></eg>

<p>The following example numbers notes sequentially within a
chapter:</p>

<eg><![CDATA[<xsl:template match="note">
  <fo:block>
     <xsl:number level="any" from="chapter" format="(1) "/>
     <xsl:apply-templates/>
  </fo:block>
</xsl:template>]]></eg>

<p>The following example would number <code>H4</code> elements in HTML
with a three-part label:</p>

<eg><![CDATA[<xsl:template match="H4">
 <fo:block>
   <xsl:number level="any" from="H1" count="H2"/>
   <xsl:text>.</xsl:text>
   <xsl:number level="any" from="H2" count="H3"/>
   <xsl:text>.</xsl:text>
   <xsl:number level="any" from="H3" count="H4"/>
   <xsl:text> </xsl:text>
   <xsl:apply-templates/>
 </fo:block>
</xsl:template>]]></eg>

<div3 id="convert">
<head>Number to String Conversion Attributes</head>

<p>The following attributes are used to control conversion of a list
of numbers into a string. The numbers are integers greater than
0. The attributes are all optional.</p>

<p>The main attribute is <code>format</code>.  The default value for
the <code>format</code> attribute is <code>1</code>.  The
<code>format</code> attribute is split into a sequence of tokens where
each token is a maximal sequence of alphanumeric characters or a
maximal sequence of non-alphanumeric characters.  Alphanumeric means
any character that has a Unicode category of Nd, Nl, No, Lu, Ll, Lt,
Lm or Lo.  The alphanumeric tokens (format tokens) specify the format
to be used for each number in the list.  If the first token is a
non-alphanumeric token, then the constructed string will start with
that token; if the last token is non-alphanumeric token, then the
constructed string will end with that token.  Non-alphanumeric tokens
that occur between two format tokens are separator tokens that are
used to join numbers in the list.  The <var>n</var>th format token
will be used to format the <var>n</var>th number in the list.  If
there are more numbers than format tokens, then the last format token
will be used to format remaining numbers.  If there are no format
tokens, then a format token of <code>1</code> is used to format all
numbers.  The format token specifies the string to be used to
represent the number 1.  Each number after the first will be separated
from the preceding number by the separator token preceding the format
token used to format that number, or, if there are no separator
tokens, then by <code>.</code> (a period character).</p>

<p>Format tokens are a superset of the allowed values for the
<code>type</code> attribute for the <code>OL</code> element in HTML
4.0 and are interpreted as follows:</p>

<ulist>

<item><p>Any token where the last character has a decimal digit value
of 1 (as specified in the Unicode character property database),
and the Unicode value of preceding characters is one less than the
Unicode value of the last character generates a decimal
representation of the number where each number is at least as long as
the format token.  Thus, a format token <code>1</code> generates the
sequence <code>1 2 ... 10 11 12 ...</code>, and a format token
<code>01</code> generates the sequence <code>01 02 ... 09 10 11 12
... 99 100 101</code>.</p></item>

<item><p>A format token <code>A</code> generates the sequence <code>A
B C ... Z AA AB AC...</code>.</p></item>

<item><p>A format token <code>a</code> generates the sequence <code>a
b c ... z aa ab ac...</code>.</p></item>

<item><p>A format token <code>i</code> generates the sequence <code>i
ii iii iv v vi vii viii ix x ...</code>.</p></item>

<item><p>A format token <code>I</code> generates the sequence <code>I
II III IV V VI VII VIII IX X ...</code>.</p></item>

<item><p>Any other format token indicates a numbering sequence that
starts with that token.  If an implementation does not support a
numbering sequence that starts with that token, it must use a format
token of <code>1</code>.</p></item>

</ulist>

<p>When numbering with an alphabetic sequence, the <code>lang</code>
attribute specifies which language's alphabet is to be used; it has
the same range of values as <code>xml:lang</code> <bibref ref="XML"/>;
if no <code>lang</code> value is specified, the language should be
determined from the system environment.  Implementers should document
for which languages they support numbering.</p>

<note><p>Implementers should not make any assumptions about how
numbering works in particular languages and should properly research
the languages that they wish to support.  The numbering conventions of
many languages are very different from English.</p></note>

<p>The <code>letter-value</code> attribute disambiguates between
numbering sequences that use letters.  In many languages there are two
commonly used numbering sequences that use letters.  One numbering
sequence assigns numeric values to letters in alphabetic sequence, and
the other assigns numeric values to each letter in some other manner
traditional in that language.  In English, these would correspond to
the numbering sequences specified by the format tokens <code>a</code>
and <code>i</code>.  In some languages, the first member of each
sequence is the same, and so the format token alone would be
ambiguous.  A value of <code>alphabetic</code> specifies the
alphabetic sequence; a value of <code>traditional</code> specifies the
other sequence.  If the <code>letter-value</code> attribute is not
specified, then it is implementation-dependent how any ambiguity is
resolved.</p>

<note><p>It is possible for two conforming XSLT processors not to
convert a number to exactly the same string.  Some XSLT processors may not
support some languages.  Furthermore, there may be variations possible
in the way conversions are performed for any particular language that
are not specifiable by the attributes on <code>xsl:number</code>.
Future versions of XSLT may provide additional attributes to provide
control over these variations.  Implementations may also use
implementation-specific namespaced attributes on
<code>xsl:number</code> for this.</p></note>

<p>The <code>grouping-separator</code> attribute gives the separator
used as a grouping (e.g. thousands) separator in decimal numbering
sequences, and the optional <code>grouping-size</code> specifies the
size (normally 3) of the grouping.  For example,
<code>grouping-separator=","</code> and <code>grouping-size="3"</code>
would produce numbers of the form <code>1,000,000</code>.  If only one
of the <code>grouping-separator</code> and <code>grouping-size</code>
attributes is specified, then it is ignored.</p>

<p>Here are some examples of conversion specifications:</p>

<ulist>

<item><p><code>format="&amp;#x30A2;"</code> specifies Katakana
numbering</p></item>

<item><p><code>format="&amp;#x30A4;"</code> specifies Katakana
numbering in the <quote>iroha</quote> order</p></item>

<item><p><code>format="&amp;#x0E51;"</code> specifies numbering with
Thai digits</p></item>

<item><p><code>format="&amp;#x05D0;" letter-value="traditional"</code>
specifies <quote>traditional</quote> Hebrew numbering</p></item>

<item><p><code>format="&amp;#x10D0;" letter-value="traditional"</code>
specifies Georgian numbering</p></item>

<item><p><code>format="&amp;#x03B1;" letter-value="traditional"</code>
specifies <quote>classical</quote> Greek numbering</p></item>

<item><p><code>format="&amp;#x0430;" letter-value="traditional"</code>
specifies Old Slavic numbering</p></item>

</ulist>

</div3>
</div2>
</div1>

<div1 id="for-each">

<head>Repetition</head>

<e:element-syntax name="for-each">
  <e:in-category name="instruction"/>
  <e:attribute name="select" required="yes">
    <e:data-type name="node-set-expression"/>
  </e:attribute>
  <e:sequence>
    <e:element repeat="zero-or-more" name="sort"/>
    <e:model name="template"/>
  </e:sequence>
</e:element-syntax>

<p>When the result has a known regular structure, it is useful to be
able to specify directly the template for selected nodes.  The
<code>xsl:for-each</code> instruction contains a template, which is
instantiated for each node selected by the <termref
def="dt-expression">expression</termref> specified by the
<code>select</code> attribute. The <code>select</code> attribute is
required.  The expression must evaluate to a node-set.  The template
is instantiated with the selected node as the <termref
def="dt-current-node">current node</termref>, and with a list of all
of the selected nodes as the <termref
def="dt-current-node-list">current node list</termref>.  The nodes are
processed in document order, unless a sorting specification is present
(see <specref ref="sorting"/>).</p>

<p>For example, given an XML document with this structure</p>

<eg><![CDATA[<customers>
  <customer>
    <name>...</name>
    <order>...</order>
    <order>...</order>
  </customer>
  <customer>
    <name>...</name>
    <order>...</order>
    <order>...</order>
  </customer>
</customers>]]></eg>

<p>the following would create an HTML document containing a table with
a row for each <code>customer</code> element</p>

<eg><![CDATA[<xsl:template match="/">
  <html>
    <head>
      <title>Customers</title>
    </head>
    <body>
      <table>
	<tbody>
	  <xsl:for-each select="customers/customer">
	    <tr>
	      <th>
		<xsl:apply-templates select="name"/>
	      </th>
	      <xsl:for-each select="order">
		<td>
		  <xsl:apply-templates/>
		</td>
	      </xsl:for-each>
	    </tr>
	  </xsl:for-each>
	</tbody>
      </table>
    </body>
  </html>
</xsl:template>]]></eg>

</div1>

<div1>
<head>Conditional Processing</head>

<p>There are two instructions in XSLT that support conditional
processing in a template: <code>xsl:if</code> and
<code>xsl:choose</code>. The <code>xsl:if</code> instruction provides
simple if-then conditionality; the <code>xsl:choose</code> instruction
supports selection of one choice when there are several
possibilities.</p>

<div2>
<head>Conditional Processing with <code>xsl:if</code></head>

<e:element-syntax name="if">
  <e:in-category name="instruction"/>
  <e:attribute name="test" required="yes">
    <e:data-type name="boolean-expression"/>
  </e:attribute>
  <e:model name="template"/>
</e:element-syntax>

<p>The <code>xsl:if</code> element has a <code>test</code> attribute,
which specifies an <termref def="dt-expression">expression</termref>.
The content is a template.  The expression is evaluated and the
resulting object is converted to a boolean as if by a call to the
<xfunction>boolean</xfunction> function.  If the result is true, then
the content template is instantiated; otherwise, nothing is created.
In the following example, the names in a group of names are formatted
as a comma separated list:</p>

<eg><![CDATA[<xsl:template match="namelist/name">
  <xsl:apply-templates/>
  <xsl:if test="not(position()=last())">, </xsl:if>
</xsl:template>]]></eg>

<p>The following colors every other table row yellow:</p>

<eg><![CDATA[<xsl:template match="item">
  <tr>
    <xsl:if test="position() mod 2 = 0">
       <xsl:attribute name="bgcolor">yellow</xsl:attribute>
    </xsl:if>
    <xsl:apply-templates/>
  </tr>
</xsl:template>]]></eg>

</div2>


<div2>
<head>Conditional Processing with <code>xsl:choose</code></head>

<e:element-syntax name="choose">
  <e:in-category name="instruction"/>
  <e:sequence>
    <e:element repeat="one-or-more" name="when"/>
    <e:element repeat="zero-or-one" name="otherwise"/>
  </e:sequence>
</e:element-syntax>

<e:element-syntax name="when">
  <e:attribute name="test" required="yes">
    <e:data-type name="boolean-expression"/>
  </e:attribute>
  <e:model name="template"/>
</e:element-syntax>

<e:element-syntax name="otherwise">
  <e:model name="template"/>
</e:element-syntax>

<p>The <code>xsl:choose</code> element selects one among a number of
possible alternatives. It consists of a sequence of
<code>xsl:when</code> elements followed by an optional
<code>xsl:otherwise</code> element.  Each <code>xsl:when</code>
element has a single attribute, <code>test</code>, which specifies an
<termref def="dt-expression">expression</termref>. The content of the
<code>xsl:when</code> and <code>xsl:otherwise</code> elements is a
template.  When an <code>xsl:choose</code> element is processed, each
of the <code>xsl:when</code> elements is tested in turn, by evaluating
the expression and converting the resulting object to a boolean as if
by a call to the <xfunction>boolean</xfunction> function.  The content
of the first, and only the first, <code>xsl:when</code> element whose
test is true is instantiated.  If no <code>xsl:when</code> is true,
the content of the <code>xsl:otherwise</code> element is
instantiated. If no <code>xsl:when</code> element is true, and no
<code>xsl:otherwise</code> element is present, nothing is created.</p>

<p>The following example enumerates items in an ordered list using
arabic numerals, letters, or roman numerals depending on the depth to
which the ordered lists are nested.</p>

<eg><![CDATA[<xsl:template match="orderedlist/listitem">
  <fo:list-item indent-start='2pi'>
    <fo:list-item-label>
      <xsl:variable name="level"
                    select="count(ancestor::orderedlist) mod 3"/>
      <xsl:choose>
        <xsl:when test='$level=1'>
          <xsl:number format="i"/>
        </xsl:when>
        <xsl:when test='$level=2'>
          <xsl:number format="a"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:number format="1"/>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:text>. </xsl:text>
    </fo:list-item-label>
    <fo:list-item-body>
      <xsl:apply-templates/>
    </fo:list-item-body>
  </fo:list-item>
</xsl:template>]]></eg>

</div2>
</div1>

<div1 id="sorting">
<head>Sorting</head>

<e:element-syntax name="sort">
  <e:attribute name="select">
    <e:data-type name="string-expression"/>
  </e:attribute>
  <e:attribute name="lang">
    <e:attribute-value-template>
      <e:data-type name="nmtoken"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:attribute name="data-type">
    <e:attribute-value-template>
       <e:constant value="text"/>
       <e:constant value="number"/>
       <e:data-type name="qname-but-not-ncname"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:attribute name="order">
    <e:attribute-value-template>
       <e:constant value="ascending"/>
       <e:constant value="descending"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:attribute name="case-order">
    <e:attribute-value-template>
       <e:constant value="upper-first"/>
       <e:constant value="lower-first"/>
    </e:attribute-value-template>
  </e:attribute>
  <e:empty/>
</e:element-syntax>

<p>Sorting is specified by adding <code>xsl:sort</code> elements as
children of an <code>xsl:apply-templates</code> or
<code>xsl:for-each</code> element.  The first <code>xsl:sort</code>
child specifies the primary sort key, the second <code>xsl:sort</code>
child specifies the secondary sort key and so on.  When an
<code>xsl:apply-templates</code> or <code>xsl:for-each</code> element
has one or more <code>xsl:sort</code> children, then instead of
processing the selected nodes in document order, it sorts the nodes
according to the specified sort keys and then processes them in sorted
order.  When used in <code>xsl:for-each</code>, <code>xsl:sort</code>
elements must occur first.  When a template is instantiated by
<code>xsl:apply-templates</code> and <code>xsl:for-each</code>, the
<termref def="dt-current-node-list">current node list</termref> list
consists of the complete list of nodes being processed in sorted
order.</p>

<p><code>xsl:sort</code> has a <code>select</code> attribute whose
value is an <termref def="dt-expression">expression</termref>. For
each node to be processed, the expression is evaluated with that node
as the current node and with the complete list of nodes being
processed in unsorted order as the current node list.
The resulting object is converted to a string as
if by a call to the <xfunction>string</xfunction> function; this string
is used as the sort key for that node. The default value of the
<code>select</code> attribute is <code>.</code>, which will cause the
string-value of the current node to be used as the sort key.</p>

<p>This string serves as a sort key for the node.  The following
optional attributes on <code>xsl:sort</code> control how the list of
sort keys are sorted; the values of all of these attributes are
interpreted as <termref def="dt-attribute-value-template">attribute
value templates</termref>.</p>

<ulist>

<item><p><code>order</code> specifies whether the strings should be
sorted in ascending or descending order; <code>ascending</code>
specifies ascending order; <code>descending</code> specifies
descending order; the default is <code>ascending</code></p></item>

<item><p><code>lang</code> specifies the language of the sort keys; it
has the same range of values as <code>xml:lang</code> <bibref
ref="XML"/>; if no <code>lang</code> value is specified, the language
should be determined from the system environment</p></item>

<item><p><code>data-type</code> specifies the data type of the
strings; the following values are allowed:</p>

<ulist>

<item><p><code>text</code> specifies that the sort keys should be
sorted lexicographically in the culturally correct manner for the
language specified by <code>lang</code></p></item>

<item><p><code>number</code> specifies that the sort keys should be
converted to numbers and then sorted according to the numeric value;
the sort key is converted to a number as if by a call to the
<xfunction>number</xfunction> function; the <code>lang</code>
attribute is ignored</p></item>

<item><p>a <xnt href="&XMLNames;#NT-QName">QName</xnt> with a prefix
is expanded into an <xtermref
href="&XPath;#dt-expanded-name">expanded-name</xtermref> as described
in <specref ref="qname"/>; the expanded-name identifies the data-type;
the behavior in this case is not specified by this document</p></item>

</ulist>

<p>The default value is <code>text</code>.</p>

<note><p>The XSL Working Group plans that future versions of XSLT will
leverage XML Schemas to define further values for this
attribute.</p></note>

</item>

<item><p><code>case-order</code> has the value
<code>upper-first</code> or <code>lower-first</code>; this applies
when <code>data-type="text"</code>, and specifies that upper-case
letters should sort before lower-case letters or vice-versa
respectively. For example, if <code>lang="en"</code>, then <code>A a B
b</code> are sorted with <code>case-order="upper-first"</code> and
<code>a A b B</code> are sorted with
<code>case-order="lower-first"</code>. The default value is language
dependent.</p></item>

</ulist>

<note><p>It is possible for two conforming XSLT processors not to sort
exactly the same.  Some XSLT processors may not support some
languages.  Furthermore, there may be variations possible in the
sorting of any particular language that are not specified by the
attributes on <code>xsl:sort</code>, for example, whether Hiragana or
Katakana is sorted first in Japanese.  Future versions of XSLT may
provide additional attributes to provide control over these
variations.  Implementations may also use implementation-specific
namespaced attributes on <code>xsl:sort</code> for this.</p></note>

<note><p>It is recommended that implementers consult <bibref
ref="UNICODE-TR10"/> for information on internationalized
sorting.</p></note>

<p>The sort must be stable: in the sorted list of nodes, any sub list
that has sort keys that all compare equal must be in document
order.</p>

<p>For example, suppose an employee database has the form</p>

<eg><![CDATA[<employees>
  <employee>
    <name>
      <given>James</given>
      <family>Clark</family>
    </name>
    ...
  </employee>
</employees>
]]></eg>
  
<p>Then a list of employees sorted by name could be generated
using:</p>

<eg><![CDATA[<xsl:template match="employees">
  <ul>
    <xsl:apply-templates select="employee">
      <xsl:sort select="name/family"/>
      <xsl:sort select="name/given"/>
    </xsl:apply-templates>
  </ul>
</xsl:template>

<xsl:template match="employee">
  <li>
    <xsl:value-of select="name/given"/>
    <xsl:text> </xsl:text>
    <xsl:value-of select="name/family"/>
  </li>
</xsl:template>]]></eg>

</div1>

<div1 id="variables">
<head>Variables and Parameters</head>

<e:element-syntax name="variable">
  <e:in-category name="top-level-element"/>
  <e:in-category name="instruction"/>
  <e:attribute name="name" required="yes">
    <e:data-type name="qname"/>
  </e:attribute>
  <e:attribute name="select">
    <e:data-type name="expression"/>
  </e:attribute>
  <e:model name="template"/>
</e:element-syntax>

<e:element-syntax name="param">
  <e:in-category name="top-level-element"/>
  <e:attribute name="name" required="yes">
    <e:data-type name="qname"/>
  </e:attribute>
  <e:attribute name="select">
    <e:data-type name="expression"/>
  </e:attribute>
  <e:model name="template"/>
</e:element-syntax>

<p>A variable is a name that may be bound to a value.  The value to
which a variable is bound (the <term>value</term> of the variable) can
be an object of any of the types that can be returned by expressions.
There are two elements that can be used to bind variables:
<code>xsl:variable</code> and <code>xsl:param</code>. The difference
is that the value specified on the <code>xsl:param</code> variable is
only a default value for the binding; when the template or stylesheet
within which the <code>xsl:param</code> element occurs is invoked,
parameters may be passed that are used in place of the default
values.</p>

<p>Both <code>xsl:variable</code> and <code>xsl:param</code> have a
required <code>name</code> attribute, which specifies the name of the
variable.  The value of the <code>name</code> attribute is a <xnt
href="&XMLNames;#NT-QName">QName</xnt>, which is expanded as described
in <specref ref="qname"/>.</p>

<p>For any use of these variable-binding elements, there is a region
of the stylesheet tree within which the binding is visible; within
this region, any binding of the variable that was visible on the
variable-binding element itself is hidden.  Thus, only the innermost
binding of a variable is visible.  The set of variable bindings in
scope for an expression consists of those bindings that are visible at
the point in the stylesheet where the expression occurs.</p>

<div2>
<head>Result Tree Fragments</head>

<p>Variables introduce an additional data-type into the expression
language.  <termdef id="dt-result-tree-fragment" term="Result Tree
Fragment">This additional data type is called <term>result tree
fragment</term>.  A variable may be bound to a result tree fragment
instead of one of the four basic XPath data-types (string, number,
boolean, node-set).  A result tree fragment represents a fragment of
the result tree. A result tree fragment is treated equivalently to a
node-set that contains just a single root node.</termdef> However, the
operations permitted on a result tree fragment are a subset of those
permitted on a node-set.  An operation is permitted on a result tree
fragment only if that operation would be permitted on a string (the
operation on the string may involve first converting the string to a
number or boolean). In particular, it is not permitted to use the
<code>/</code>, <code>//</code>, and <code>[]</code> operators on
result tree fragments.  When a permitted operation is performed on a
result tree fragment, it is performed exactly as it would be on the
equivalent node-set.</p>

<p>When a result tree fragment is copied into the result tree (see
<specref ref="copy-of"/>), then all the nodes that are children of the
root node in the equivalent node-set are added in sequence to the
result tree.</p>

<p>Expressions can only return values of type result tree fragment by
referencing variables of type result tree fragment or calling
extension functions that return a result tree fragment or getting a
system property whose value is a result tree fragment.</p>

</div2>

<div2 id="variable-values">
<head>Values of Variables and Parameters</head>

<p>A variable-binding element can specify the value of the variable in
three alternative ways.</p>

<ulist>

<item><p>If the variable-binding element has a <code>select</code>
attribute, then the value of the attribute must be an <termref
def="dt-expression">expression</termref> and the value of the variable
is the object that results from evaluating the expression.  In this
case, the content must be empty.</p></item>

<item>

<p>If the variable-binding element does not have a <code>select</code>
attribute and has non-empty content (i.e. the variable-binding element
has one or more child nodes), then the content of the
variable-binding element specifies the value. The content of the
variable-binding element is a template, which is instantiated to give
the value of the variable. The value is a result tree fragment
equivalent to a node-set containing just a single root node having as
children the sequence of nodes produced by instantiating the template.
The base URI of the nodes in the result tree fragment is the base URI
of the variable-binding element.</p>

<p>It is an error if a member of the sequence of nodes created by
instantiating the template is an attribute node or a namespace node,
since a root node cannot have an attribute node or a namespace node as
a child. An XSLT processor may signal the error; if it does not signal
the error, it must recover by not adding the attribute node or
namespace node.</p>

</item>

<item>

<p>If the variable-binding element has empty content and does not have
a <code>select</code> attribute, then the value of the variable is an
empty string. Thus</p>

<eg><![CDATA[<xsl:variable name="x"/>]]></eg>

<p>is equivalent to</p>

<eg><![CDATA[<xsl:variable name="x" select="''"/>]]></eg>

</item>

</ulist>

<note><p>When a variable is used to select nodes by position, be careful
not to do:</p>

<eg><![CDATA[<xsl:variable name="n">2</xsl:variable>
...
<xsl:value-of select="item[$n]"/>]]></eg>

<p>This will output the value of the first item element, because the
variable <code>n</code> will be bound to a result tree fragment, not a
number. Instead, do either</p>

<eg><![CDATA[<xsl:variable name="n" select="2"/>
...
<xsl:value-of select="item[$n]"/>]]></eg>

<p>or</p>

<eg><![CDATA[<xsl:variable name="n">2</xsl:variable>
...
<xsl:value-of select="item[position()=$n]"/>]]></eg>
</note>

<note><p>One convenient way to specify the empty node-set as the default
value of a parameter is:</p>

<eg><![CDATA[<xsl:param name="x" select="/.."/>]]></eg>
</note>

</div2>

<div2 id="copy-of">
<head>Using Values of Variables and Parameters with
<code>xsl:copy-of</code></head>

<e:element-syntax name="copy-of">
  <e:in-category name="instruction"/>
  <e:attribute name="select" required="yes">
    <e:data-type name="expression"/>
  </e:attribute>
  <e:empty/>
</e:element-syntax>

<p>The <code>xsl:copy-of</code> element can be used to insert a result
tree fragment into the result tree, without first converting it to a
string as <code>xsl:value-of</code> does (see <specref
ref="value-of"/>).  The required <code>select</code> attribute
contains an <termref def="dt-expression">expression</termref>.  When
the result of evaluating the expression is a result tree fragment, the
complete fragment is copied into the result tree.  When the result is
a node-set, all the nodes in the set are copied in document order into
the result tree; copying an element node copies the attribute nodes,
namespace nodes and children of the element node as well as the
element node itself; a root node is copied by copying its children.
When the result is neither a node-set nor a result tree fragment, the
result is converted to a string and then inserted into the result
tree, as with <code>xsl:value-of</code>.</p>

</div2>

<div2 id="top-level-variables">
<head>Top-level Variables and Parameters</head>

<p>Both <code>xsl:variable</code> and <code>xsl:param</code> are
allowed as <termref def="dt-top-level">top-level</termref> elements.
A top-level variable-binding element declares a global variable that
is visible everywhere.  A top-level <code>xsl:param</code> element
declares a parameter to the stylesheet; XSLT does not define the
mechanism by which parameters are passed to the stylesheet.  It is an
error if a stylesheet contains more than one binding of a top-level
variable with the same name and same <termref
def="dt-import-precedence">import precedence</termref>. At the
top-level, the expression or template specifying the variable value is
evaluated with the same context as that used to process the root node
of the source document: the current node is the root node of the
source document and the current node list is a list containing just
the root node of the source document.  If the template or expression
specifying the value of a global variable <var>x</var> references a
global variable <var>y</var>, then the value for <var>y</var> must
be computed before the value of <var>x</var>.  It is an error if it
is impossible to do this for all global variable definitions; in other
words, it is an error if the definitions are circular.</p>

<p>This example declares a global variable <code>para-font-size</code>,
which it references in an attribute value template.</p>

<eg><![CDATA[<xsl:variable name="para-font-size">12pt</xsl:variable>

<xsl:template match="para">
 <fo:block font-size="{$para-font-size}">
   <xsl:apply-templates/>
 </fo:block>
</xsl:template>
]]></eg>

</div2>

<div2 id="local-variables">
<head>Variables and Parameters within Templates</head>

<p>As well as being allowed at the top-level, both
<code>xsl:variable</code> and <code>xsl:param</code> are also
allowed in templates.  <code>xsl:variable</code> is allowed anywhere
within a template that an instruction is allowed.  In this case, the
binding is visible for all following siblings and their descendants.
Note that the binding is not visible for the <code>xsl:variable</code>
element itself.  <code>xsl:param</code> is allowed as a child
at the beginning of an <code>xsl:template</code> element.  In this
context, the binding is visible for all following siblings and their
descendants.  Note that the binding is not visible for the
<code>xsl:param</code> element itself.</p>

<p><termdef id="dt-shadows" term="Shadows">A binding
<term>shadows</term> another binding if the binding occurs at a point
where the other binding is visible, and the bindings have the same
name.</termdef> It is an error if a binding established by an
<code>xsl:variable</code> or <code>xsl:param</code> element within a
template <termref def="dt-shadows">shadows</termref> another binding
established by an <code>xsl:variable</code> or <code>xsl:param</code>
element also within the template.  It is not an error if a binding
established by an <code>xsl:variable</code> or <code>xsl:param</code>
element in a template <termref def="dt-shadows">shadows</termref>
another binding established by an <code>xsl:variable</code> or
<code>xsl:param</code> <termref def="dt-top-level">top-level</termref>
element.  Thus, the following is an error:</p>

<eg role="error"><![CDATA[<xsl:template name="foo">
<xsl:param name="x" select="1"/>
<xsl:variable name="x" select="2"/>
</xsl:template>]]></eg>

<p>However, the following is allowed:</p>

<eg><![CDATA[<xsl:param name="x" select="1"/>
<xsl:template name="foo">
<xsl:variable name="x" select="2"/>
</xsl:template>]]></eg>

<note><p>The nearest equivalent in Java to an <code>xsl:variable</code>
element in a template is a final local variable declaration with an
initializer.  For example,</p>

<eg><![CDATA[<xsl:variable name="x" select="'value'"/>]]></eg>

<p>has similar semantics to</p>

<eg>final Object x = "value";</eg>

<p>XSLT does not provide an equivalent to the Java assignment operator</p>

<eg>x = "value";</eg>

<p>because this would make it harder to create an implementation that
processes a document other than in a batch-like way, starting at the
beginning and continuing through to the end.</p></note>

</div2>

<div2>
<head>Passing Parameters to Templates</head>

<e:element-syntax name="with-param">
  <e:attribute name="name" required="yes">
    <e:data-type name="qname"/>
  </e:attribute>
  <e:attribute name="select">
    <e:data-type name="expression"/>
  </e:attribute>
  <e:model name="template"/>
</e:element-syntax>

<p>Parameters are passed to templates using the
<code>xsl:with-param</code> element.  The required <code>name</code>
attribute specifies the name of the parameter (the variable the value
of whose binding is to be replaced).  The value of the
<code>name</code> attribute is a <xnt
href="&XMLNames;#NT-QName">QName</xnt>, which is expanded as described
in <specref ref="qname"/>.  <code>xsl:with-param</code> is allowed
within both <code>xsl:call-template</code> and
<code>xsl:apply-templates</code>.  The value of the parameter is
specified in the same way as for <code>xsl:variable</code> and
<code>xsl:param</code>.  The current node and current node list used
for computing the value specified by <code>xsl:with-param</code>
element is the same as that used for the
<code>xsl:apply-templates</code> or <code>xsl:call-template</code>
element within which it occurs.  It is not an error to pass a
parameter <var>x</var> to a template that does not have an
<code>xsl:param</code> element for <var>x</var>; the parameter is
simply ignored.</p>

<p>This example defines a named template for a
<code>numbered-block</code> with an argument to control the format of
the number.</p>

<eg><![CDATA[<xsl:template name="numbered-block">
  <xsl:param name="format">1. </xsl:param>
  <fo:block>
    <xsl:number format="{$format}"/>
    <xsl:apply-templates/>
  </fo:block>
</xsl:template>

<xsl:template match="ol//ol/li">
  <xsl:call-template name="numbered-block">
    <xsl:with-param name="format">a. </xsl:with-param>
  </xsl:call-template>
</xsl:template>]]></eg>

</div2>

</div1>

<div1 id="add-func">
<head>Additional Functions</head>

<p>This section describes XSLT-specific additions to the core XPath
function library.  Some of these additional functions also make use of
information specified by <termref def="dt-top-level">top-level</termref>
elements in the stylesheet; this section also describes these
elements.</p>

<div2 id="document">

<head>Multiple Source Documents</head>

<proto name="document" return-type="node-set"><arg type="object"/>
<arg type="node-set" occur="opt"/></proto>

<p>The <function>document</function> function allows
access to XML documents other than the main source document.</p>

<p>When the <function>document</function> function has exactly one
argument and the argument is a node-set, then the result is the union,
for each node in the argument node-set, of the result of calling the
<function>document</function> function with the first argument being
the <xtermref href="&XPath;#dt-string-value">string-value</xtermref>
of the node, and the second argument being a node-set with the node as
its only member. When the <function>document</function> function has
two arguments and the first argument is a node-set, then the result is
the union, for each node in the argument node-set, of the result of
calling the <function>document</function> function with the first
argument being the <xtermref
href="&XPath;#dt-string-value">string-value</xtermref> of the node,
and with the second argument being the second argument passed to the
<function>document</function> function.</p>

<p>When the first argument to the <function>document</function>
function is not a node-set, the first argument is converted to a
string as if by a call to the <xfunction>string</xfunction> function.
This string is treated as a URI reference; the resource identified by
the URI is retrieved. The data resulting from the retrieval action is
parsed as an XML document and a tree is constructed in accordance with
the data model (see <specref ref="data-model"/>).  If there is an
error retrieving the resource, then the XSLT processor may signal an
error; if it does not signal an error, it must recover by returning an
empty node-set.  One possible kind of retrieval error is that the XSLT
processor does not support the URI scheme used by the URI.  An XSLT
processor is not required to support any particular URI schemes.  The
documentation for an XSLT processor should specify which URI schemes
the XSLT processor supports.</p>

<p>If the URI reference does not contain a fragment identifier, then a
node-set containing just the root node of the document is returned.
If the URI reference does contain a fragment identifier, the function
returns a node-set containing the nodes in the tree identified by the
fragment identifier of the URI reference. The semantics of the
fragment identifier is dependent on the media type of the result of
retrieving the URI.  If there is an error in processing the fragment
identifier, the XSLT processor may signal the error; if it does not
signal the error, it must recover by returning an empty node-set.
Possible errors include:</p>

<ulist>

<item><p>The fragment identifier identifies something that cannot be
represented by an XSLT node-set (such as a range of characters within
a text node).</p></item>

<item><p>The XSLT processor does not support fragment identifiers for
the media-type of the retrieval result.  An XSLT processor is not
required to support any particular media types.  The documentation for
an XSLT processor should specify for which media types the XSLT
processor supports fragment identifiers.</p></item>

</ulist>

<p>The data resulting from the retrieval action is parsed as an XML
document regardless of the media type of the retrieval result; if the
top-level media type is <code>text</code>, then it is parsed in the
same way as if the media type were <code>text/xml</code>; otherwise,
it is parsed in the same way as if the media type were
<code>application/xml</code>.</p>

<note><p>Since there is no top-level <code>xml</code> media type, data
with a media type other than <code>text/xml</code> or
<code>application/xml</code> may in fact be XML.</p></note>

<p>The URI reference may be relative. The base URI (see <specref
ref="base-uri"/>) of the node in the second argument node-set that is
first in document order is used as the base URI for resolving the
relative URI into an absolute URI.  If the second argument is omitted,
then it defaults to the node in the stylesheet that contains the
expression that includes the call to the <function>document</function>
function.  Note that a zero-length URI reference is a reference to the
document relative to which the URI reference is being resolved; thus
<code>document("")</code> refers to the root node of the stylesheet;
the tree representation of the stylesheet is exactly the same as if
the XML document containing the stylesheet was the initial source
document.</p>

<p>Two documents are treated as the same document if they are
identified by the same URI. The URI used for the comparison is the
absolute URI into which any relative URI was resolved and does not
include any fragment identifier.  One root node is treated as the same
node as another root node if the two nodes are from the same document.
Thus, the following expression will always be true:</p>

<eg>generate-id(document("foo.xml"))=generate-id(document("foo.xml"))</eg>

<p>The <function>document</function> function gives rise to the
possibility that a node-set may contain nodes from more than one
document.  With such a node-set, the relative document order of two
nodes in the same document is the normal <xtermref
href="&XPath;#dt-document-order">document order</xtermref> defined by
XPath <bibref ref="XPATH"/>.  The relative document order of two nodes
in different documents is determined by an implementation-dependent
ordering of the documents containing the two nodes.  There are no
constraints on how the implementation orders documents other than that
it must do so consistently: an implementation must always use the same
order for the same set of documents.</p>

</div2>

<div2 id="key">
<head>Keys</head>

<p>Keys provide a way to work with documents that contain an implicit
cross-reference structure.  The <code>ID</code>, <code>IDREF</code>
and <code>IDREFS</code> attribute types in XML provide a mechanism to
allow XML documents to make their cross-reference explicit.  XSLT
supports this through the XPath <xfunction>id</xfunction> function.
However, this mechanism has a number of limitations:</p>

<ulist>

<item><p>ID attributes must be declared as such in the DTD.  If an ID
attribute is declared as an ID attribute only in the external DTD
subset, then it will be recognized as an ID attribute only if the XML
processor reads the external DTD subset.  However, XML does not require
XML processors to read the external DTD, and they may well choose not
to do so, especially if the document is declared
<code>standalone="yes"</code>.</p></item>

<item><p>A document can contain only a single set of unique IDs.
There cannot be separate independent sets of unique IDs.</p></item>

<item><p>The ID of an element can only be specified in an attribute;
it cannot be specified by the content of the element, or by a child
element.</p></item>

<item><p>An ID is constrained to be an XML name.  For example, it
cannot contain spaces.</p></item>

<item><p>An element can have at most one ID.</p></item>

<item><p>At most one element can have a particular ID.</p></item>

</ulist>

<p>Because of these limitations XML documents sometimes contain a
cross-reference structure that is not explicitly declared by
ID/IDREF/IDREFS attributes.</p>

<p>A key is a triple containing:</p>

<olist>

<item><p>the node which has the key</p></item>

<item><p>the name of the key (an <xtermref
href="&XPath;#dt-expanded-name">expanded-name</xtermref>)</p></item>

<item><p>the value of the key (a string)</p></item>

</olist>

<p>A stylesheet declares a set of keys for each document using the
<code>xsl:key</code> element.  When this set of keys contains a member
with node <var>x</var>, name <var>y</var> and value
<var>z</var>, we say that node <var>x</var> has a key with name
<var>y</var> and value <var>z</var>.</p>

<p>Thus, a key is a kind of generalized ID, which is not subject to the
same limitations as an XML ID:</p>

<ulist>

<item><p>Keys are declared in the stylesheet using
<code>xsl:key</code> elements.</p></item>

<item><p>A key has a name as well as a value; each key name may be
thought of as distinguishing a separate, independent space of
identifiers.</p></item>

<item><p>The value of a named key for an element may be specified in
any convenient place; for example, in an attribute, in a child element
or in content.  An XPath expression is used to specify where to find
the value for a particular named key.</p></item>

<item><p>The value of a key can be an arbitrary string; it is not
constrained to be a name.</p></item>

<item><p>There can be multiple keys in a document with the same node,
same key name, but different key values.</p></item>

<item><p>There can be multiple keys in a document with the same key
name, same key value, but different nodes.</p></item>

</ulist>

<e:element-syntax name="key">
  <e:in-category name="top-level-element"/>
  <e:attribute name="name" required="yes">
    <e:data-type name="qname"/>
  </e:attribute>
  <e:attribute name="match" required="yes">
    <e:data-type name="pattern"/>
  </e:attribute>
  <e:attribute name="use" required="yes">
    <e:data-type name="expression"/>
  </e:attribute>
  <e:empty/>
</e:element-syntax>

<p>The <code>xsl:key</code> element is used to declare keys.  The
<code>name</code> attribute specifies the name of the key.  The value
of the <code>name</code> attribute is a <xnt
href="&XMLNames;#NT-QName">QName</xnt>, which is expanded as described
in <specref ref="qname"/>. The <code>match</code> attribute is a <nt
def="NT-Pattern">Pattern</nt>; an <code>xsl:key</code> element gives
information about the keys of any node that matches the pattern
specified in the match attribute.  The <code>use</code> attribute is
an <termref def="dt-expression">expression</termref> specifying the
values of the key; the expression is evaluated once for each node that
matches the pattern.  If the result is a node-set, then for each node
in the node-set, the node that matches the pattern has a key of the
specified name whose value is the string-value of the node in the
node-set; otherwise, the result is converted to a string, and the node
that matches the pattern has a key of the specified name with value
equal to that string.  Thus, a node <var>x</var> has a key with name
<var>y</var> and value <var>z</var> if and only if there is an
<code>xsl:key</code> element such that:</p>

<ulist>

<item><p><var>x</var> matches the pattern specified in the
<code>match</code> attribute of the <code>xsl:key</code> element;</p></item>

<item><p>the value of the <code>name</code> attribute of the
<code>xsl:key</code> element is equal to <var>y</var>;
and</p></item>

<item><p>when the expression specified in the <code>use</code>
attribute of the <code>xsl:key</code> element is evaluated with
<var>x</var> as the current node and with a node list containing
just <var>x</var> as the current node list resulting in an object
<var>u</var>, then either <var>z</var> is equal to the result of
converting <var>u</var> to a string as if by a call to the
<xfunction>string</xfunction> function, or <var>u</var> is a
node-set and <var>z</var> is equal to the string-value of one or
more of the nodes in <var>u</var>.</p></item>

</ulist>

<p>Note also that there may be more than one <code>xsl:key</code>
element that matches a given node; all of the matching
<code>xsl:key</code> elements are used, even if they do not have the
same <termref def="dt-import-precedence">import
precedence</termref>.</p>

<p>It is an error for the value of either the <code>use</code>
attribute or the <code>match</code> attribute to contain a <xnt
href="&XPath;#NT-VariableReference">VariableReference</xnt>.</p>

<proto name="key" return-type="node-set"><arg type="string"/><arg type="object"/></proto>

<p>The <function>key</function> function does for keys what the
<xfunction>id</xfunction> function does for IDs.  The first argument
specifies the name of the key. The value of the argument must be a
<xnt href="&XMLNames;#NT-QName">QName</xnt>, which is expanded as
described in <specref ref="qname"/>. When the second argument to the
<function>key</function> function is of type node-set, then the result
is the union of the result of applying the <function>key</function>
function to the string <xtermref
href="&XPath;#dt-value">value</xtermref> of each of the nodes in the
argument node-set.  When the second argument to
<function>key</function> is of any other type, the argument is
converted to a string as if by a call to the
<xfunction>string</xfunction> function; it returns a node-set
containing the nodes in the same document as the context node that
have a value for the named key equal to this string.</p>

<p>For example, given a declaration</p>

<eg><![CDATA[<xsl:key name="idkey" match="div" use="@id"/>]]></eg>

<p>an expression <code>key("idkey",@ref)</code> will return the same
node-set as <code>id(@ref)</code>, assuming that the only ID attribute
declared in the XML source document is:</p>

<eg><![CDATA[<!ATTLIST div id ID #IMPLIED>]]></eg>

<p>and that the <code>ref</code> attribute of the current node
contains no whitespace.</p>

<p>Suppose a document describing a function library uses a
<code>prototype</code> element to define functions</p>

<eg><![CDATA[<prototype name="key" return-type="node-set">
<arg type="string"/>
<arg type="object"/>
</prototype>]]></eg>

<p>and a <code>function</code> element to refer to function names</p>

<eg><![CDATA[<function>key</function>]]></eg>

<p>Then the stylesheet could generate hyperlinks between the
references and definitions as follows:</p>

<eg><![CDATA[<xsl:key name="func" match="prototype" use="@name"/>

<xsl:template match="function">
<b>
  <a href="#{generate-id(key('func',.))}">
    <xsl:apply-templates/>
  </a>
</b>
</xsl:template>

<xsl:template match="prototype">
<p><a name="{generate-id()}">
<b>Function: </b>
...
</a></p>
</xsl:template>]]></eg>

<p>The <function>key</function> can be used to retrieve a key from a
document other than the document containing the context node.  For
example, suppose a document contains bibliographic references in the
form <code><![CDATA[<bibref>XSLT</bibref>]]></code>, and there is a
separate XML document <code>bib.xml</code> containing a bibliographic
database with entries in the form:</p>

<eg><![CDATA[<entry name="XSLT">...</entry>]]></eg>

<p>Then the stylesheet could use the following to transform the
<code>bibref</code> elements:</p>

<eg><![CDATA[<xsl:key name="bib" match="entry" use="@name"/>

<xsl:template match="bibref">
  <xsl:variable name="name" select="."/>
  <xsl:for-each select="document('bib.xml')">
    <xsl:apply-templates select="key('bib',$name)"/>
  </xsl:for-each>
</xsl:template>]]></eg>

</div2>

<div2 id="format-number">
<head>Number Formatting</head>

<proto name="format-number" return-type="string"><arg type="number"/><arg type="string"/><arg occur="opt" type="string"/></proto>

<p>The <function>format-number</function> function converts its first
argument to a string using the format pattern string specified by the
second argument and the decimal-format named by the third argument, or
the default decimal-format, if there is no third argument.  The format
pattern string is in the syntax specified by the JDK 1.1 <loc href=
"http://java.sun.com/products/jdk/1.1/docs/api/java.text.DecimalFormat.html"
>DecimalFormat</loc> class. The format pattern string is in a
localized notation: the decimal-format determines what characters have
a special meaning in the pattern (with the exception of the quote
character, which is not localized).  The format pattern must not
contain the currency sign (#x00A4); support for this feature was added
after the initial release of JDK 1.1.  The decimal-format name must be
a <xnt href="&XMLNames;#NT-QName">QName</xnt>, which is expanded as
described in <specref ref="qname"/>.  It is an error if the stylesheet
does not contain a declaration of the decimal-format with the specified
<xtermref href="&XPath;#dt-expanded-name">expanded-name</xtermref>.</p>

<note><p>Implementations are not required to use the JDK 1.1
implementation, nor are implementations required to be implemented in
Java.</p></note>

<note><p>Stylesheets can use other facilities in XPath to control
rounding.</p></note>

<e:element-syntax name="decimal-format">
  <e:in-category name="top-level-element"/>
  
  <e:attribute name="name">
    <e:data-type name="qname"/>
  </e:attribute>
  <e:attribute name="decimal-separator">
    <e:data-type name="char"/>
  </e:attribute>
  <e:attribute name="grouping-separator">
    <e:data-type name="char"/>
  </e:attribute>
  <e:attribute name="infinity">
    <e:data-type name="string"/>
  </e:attribute>
  <e:attribute name="minus-sign">
    <e:data-type name="char"/>
  </e:attribute>
  <e:attribute name="NaN">
    <e:data-type name="string"/>
  </e:attribute>
  <e:attribute name="percent">
    <e:data-type name="char"/>
  </e:attribute>
  <e:attribute name="per-mille">
    <e:data-type name="char"/>
  </e:attribute>
  <e:attribute name="zero-digit">
    <e:data-type name="char"/>
  </e:attribute>
  <e:attribute name="digit">
    <e:data-type name="char"/>
  </e:attribute>
  <e:attribute name="pattern-separator">
    <e:data-type name="char"/>
  </e:attribute>
  <e:empty/>
</e:element-syntax>

<p>The <code>xsl:decimal-format</code> element declares a
decimal-format, which controls the interpretation of a format pattern
used by the <function>format-number</function> function.  If there is
a <code>name</code> attribute, then the element declares a named
decimal-format; otherwise, it declares the default decimal-format.
The value of the <code>name</code> attribute is a <xnt
href="&XMLNames;#NT-QName">QName</xnt>, which is expanded as described
in <specref ref="qname"/>.  It is an error to declare either the
default decimal-format or a decimal-format with a given name more than
once (even with different <termref def="dt-import-precedence">import
precedence</termref>), unless it is declared every time with the same
value for all attributes (taking into account any default values).</p>

<p>The other attributes on <code>xsl:decimal-format</code> correspond
to the methods on the JDK 1.1 <loc href=
"http://java.sun.com/products/jdk/1.1/docs/api/java.text.DecimalFormatSymbols.html"
>DecimalFormatSymbols</loc> class.  For each
<code>get</code>/<code>set</code> method pair there is an attribute
defined for the <code>xsl:decimal-format</code> element.</p>

<p>The following attributes both control the interpretation of
characters in the format pattern and specify characters that may
appear in the result of formatting the number:</p>

<ulist>

<item><p><code>decimal-separator</code> specifies the character used
for the decimal sign; the default value is the period character
(<code>.</code>)</p></item>

<item><p><code>grouping-separator</code> specifies the character used
as a grouping (e.g. thousands) separator; the default value is the
comma character (<code>,</code>)</p></item>

<item><p><code>percent</code> specifies the character used as a
percent sign; the default value is the percent character
(<code>%</code>)</p></item>

<item><p><code>per-mille</code> specifies the character used as a per
mille sign; the default value is the Unicode per-mille character
(#x2030)</p></item>

<item><p><code>zero-digit</code> specifies the character used as the
digit zero; the default value is the digit zero
(<code>0</code>)</p></item>

</ulist>

<p>The following attributes control the interpretation of characters
in the format pattern:</p>

<ulist>

<item><p><code>digit</code> specifies the character used for a digit
in the format pattern; the default value is the number sign character
(<code>#</code>)</p></item>

<item><p><code>pattern-separator</code> specifies the character used
to separate positive and negative sub patterns in a pattern; the
default value is the semi-colon character (<code>;</code>)</p></item>

</ulist>

<p>The following attributes specify characters or strings that may
appear in the result of formatting the number:</p>

<ulist>

<item><p><code>infinity</code> specifies the string used to represent
infinity; the default value is the string
<code>Infinity</code></p></item>

<item><p><code>NaN</code> specifies the string used to represent the
NaN value; the default value is the string <code>NaN</code></p></item>

<item><p><code>minus-sign</code> specifies the character used as the
default minus sign; the default value is the hyphen-minus character
(<code>-</code>, #x2D)</p></item>

</ulist>

</div2>

<div2 id="misc-func">
<head>Miscellaneous Additional Functions</head>

<proto name="current" return-type="node-set"></proto>

<p>The <function>current</function> function returns a node-set that
has the <termref def="dt-current-node">current node</termref> as its
only member.  For an outermost expression (an expression not occurring
within another expression), the current node is always the same as the
context node.  Thus,</p>

<eg><![CDATA[<xsl:value-of select="current()"/>]]></eg>

<p>means the same as</p>

<eg><![CDATA[<xsl:value-of select="."/>]]></eg>

<p>However, within square brackets the current node is usually
different from the context node. For example,</p>

<eg><![CDATA[<xsl:apply-templates select="//glossary/item[@name=current()/@ref]"/>]]></eg>

<p>will process all <code>item</code> elements that have a
<code>glossary</code> parent element and that have a <code>name</code>
attribute with value equal to the value of the current node's
<code>ref</code> attribute. This is different from</p>

<eg><![CDATA[<xsl:apply-templates select="//glossary/item[@name=./@ref]"/>]]></eg>

<p>which means the same as</p>

<eg><![CDATA[<xsl:apply-templates select="//glossary/item[@name=@ref]"/>]]></eg>

<p>and so would process all <code>item</code> elements that have a
<code>glossary</code> parent element and that have a <code>name</code>
attribute and a <code>ref</code> attribute with the same value.</p>

<p>It is an error to use the <function>current</function> function in
a <termref def="dt-pattern">pattern</termref>.</p>

<proto name="unparsed-entity-uri" return-type="string"><arg type="string"/></proto>

<p>The <function>unparsed-entity-uri</function> returns the URI of the
unparsed entity with the specified name in the same document as the
context node (see <specref ref="unparsed-entities"/>).  It returns the
empty string if there is no such entity.</p>

<proto name="generate-id" return-type="string"><arg occur="opt" type="node-set"/></proto>

<p>The <function>generate-id</function> function returns a string that
uniquely identifies the node in the argument node-set that is first in
document order.  The unique identifier must consist of ASCII
alphanumeric characters and must start with an alphabetic character.
Thus, the string is syntactically an XML name.  An implementation is
free to generate an identifier in any convenient way provided that it
always generates the same identifier for the same node and that
different identifiers are always generated from different nodes. An
implementation is under no obligation to generate the same identifiers
each time a document is transformed.  There is no guarantee that a
generated unique identifier will be distinct from any unique IDs
specified in the source document.  If the argument node-set is empty,
the empty string is returned. If the argument is omitted, it defaults
to the context node.</p>

<proto name="system-property" return-type="object"><arg type="string"/></proto>

<p>The argument must evaluate to a string that is a <xnt
href="&XMLNames;#NT-QName">QName</xnt>.  The <xnt
href="&XMLNames;#NT-QName">QName</xnt> is expanded into a name using
the namespace declarations in scope for the expression. The
<function>system-property</function> function returns an object
representing the value of the system property identified by the name.
If there is no such system property, the empty string should be
returned.</p>

<p>Implementations must provide the following system properties, which
are all in the XSLT namespace:</p>

<slist>

<sitem><code>xsl:version</code>, a number giving the version of XSLT
implemented by the processor; for XSLT processors implementing the
version of XSLT specified by this document, this is the number
1.0</sitem>

<sitem><code>xsl:vendor</code>, a string identifying the vendor of the
XSLT processor</sitem>

<sitem><code>xsl:vendor-url</code>, a string containing a URL
identifying the vendor of the XSLT processor; typically this is the
host page (home page) of the vendor's Web site.</sitem>

</slist>

</div2>

</div1>

<div1 id="message">
<head>Messages</head>

<e:element-syntax name="message">
  <e:in-category name="instruction"/>
  <e:attribute name="terminate">
    <e:constant value="yes"/>
    <e:constant value="no"/>
  </e:attribute>
  <e:model name="template"/>
</e:element-syntax>

<p>The <code>xsl:message</code> instruction sends a message in a way
that is dependent on the XSLT processor.  The content of the
<code>xsl:message</code> instruction is a template.  The
<code>xsl:message</code> is instantiated by instantiating the content
to create an XML fragment.  This XML fragment is the content of the
message.</p>

<note><p>An XSLT processor might implement <code>xsl:message</code> by
popping up an alert box or by writing to a log file.</p></note>

<p>If the <code>terminate</code> attribute has the value
<code>yes</code>, then the XSLT processor should terminate processing
after sending the message.  The default value is <code>no</code>.</p>

<p>One convenient way to do localization is to put the localized
information (message text, etc.) in an XML document, which becomes an
additional input file to the stylesheet.  For example, suppose
messages for a language <code><var>L</var></code> are stored in an XML
file <code>resources/<var>L</var>.xml</code> in the form:</p>

<eg><![CDATA[<messages>
  <message name="problem">A problem was detected.</message>
  <message name="error">An error was detected.</message>
</messages>
]]></eg>

<p>Then a stylesheet could use the following approach to localize
messages:</p>

<eg><![CDATA[<xsl:param name="lang" select="en"/>
<xsl:variable name="messages"
  select="document(concat('resources/', $lang, '.xml'))/messages"/>

<xsl:template name="localized-message">
  <xsl:param name="name"/>
  <xsl:message>
    <xsl:value-of select="$messages/message[@name=$name]"/>
  </xsl:message>
</xsl:template>

<xsl:template name="problem">
  <xsl:call-template name="localized-message"/>
    <xsl:with-param name="name">problem</xsl:with-param>
  </xsl:call-template>
</xsl:template>]]></eg>

</div1>

<div1 id="extension">
<head>Extensions</head>

<p>XSLT allows two kinds of extension, extension elements and
extension functions.</p>

<p>This version of XSLT does not provide a mechanism for defining
implementations of extensions.  Therefore, an XSLT stylesheet that must
be portable between XSLT implementations cannot rely on particular
extensions being available.  XSLT provides mechanisms that allow an
XSLT stylesheet to determine whether the XSLT processor by which it is
being processed has implementations of particular extensions
available, and to specify what should happen if those extensions are
not available.  If an XSLT stylesheet is careful to make use of these
mechanisms, it is possible for it to take advantage of extensions and
still work with any XSLT implementation.</p>

<div2 id="extension-element">
<head>Extension Elements</head>

<p><termdef id="dt-extension-namespace" term="Extension Namespace">The
element extension mechanism allows namespaces to be designated as
<term>extension namespace</term>s. When a namespace is designated as
an extension namespace and an element with a name from that namespace
occurs in a template, then the element is treated as an instruction
rather than as a literal result element.</termdef> The namespace
determines the semantics of the instruction.</p>

<note><p>Since an element that is a child of an
<code>xsl:stylesheet</code> element is not occurring <emph>in a
template</emph>, non-XSLT <termref
def="dt-top-level">top-level</termref> elements are not extension
elements as defined here, and nothing in this section applies to
them.</p></note>

<p>A namespace is designated as an extension namespace by using an
<code>extension-element-prefixes</code> attribute on an
<code>xsl:stylesheet</code> element or an
<code>xsl:extension-element-prefixes</code> attribute on a literal
result element or extension element.
The value of both these attributes is a
whitespace-separated list of namespace prefixes. The namespace bound
to each of the prefixes is designated as an extension namespace.  It
is an error if there is no namespace bound to the prefix on the
element bearing the <code>extension-element-prefixes</code> or
<code>xsl:extension-element-prefixes</code> attribute.  The default
namespace (as declared by <code>xmlns</code>) may be designated as an
extension namespace by including <code>#default</code> in the list of
namespace prefixes.  The designation of a namespace as an extension
namespace is effective within the subtree of the stylesheet rooted at
the element bearing the <code>extension-element-prefixes</code> or
<code>xsl:extension-element-prefixes</code> attribute;
a subtree rooted at an <code>xsl:stylesheet</code> element
does not include any stylesheets imported or included by children
of that <code>xsl:stylesheet</code> element.</p>

<p>If the XSLT processor does not have an implementation of a
particular extension element available, then the
<function>element-available</function> function must return false for
the name of the element.  When such an extension element is
instantiated, then the XSLT processor must perform fallback for the
element as specified in <specref ref="fallback"/>.  An XSLT processor
must not signal an error merely because a template contains an
extension element for which no implementation is available.</p>

<p>If the XSLT processor has an implementation of a particular
extension element available, then the
<function>element-available</function> function must return true for
the name of the element.</p>

</div2>

<div2>
<head>Extension Functions</head>

<p>If a <xnt href="&XPath;#NT-FunctionName">FunctionName</xnt> in a
<xnt href="&XPath;#NT-FunctionCall">FunctionCall</xnt> expression is
not an <xnt href="&XMLNames;#NT-NCName">NCName</xnt> (i.e. if it
contains a colon), then it is treated as a call to an extension
function.  The <xnt href="&XPath;#NT-FunctionName">FunctionName</xnt>
is expanded to a name using the namespace declarations from the
evaluation context.</p>

<p>If the XSLT processor does not have an implementation of an
extension function of a particular name available, then the
<function>function-available</function> function must return false for
that name.  If such an extension function occurs in an expression and
the extension function is actually called, the XSLT processor must
signal an error.  An XSLT processor must not signal an error merely
because an expression contains an extension function for which no
implementation is available.</p>

<p>If the XSLT processor has an implementation of an extension
function of a particular name available, then the
<function>function-available</function> function must return
true for that name. If such an extension is called, then the XSLT
processor must call the implementation passing it the function call
arguments; the result returned by the implementation is returned as
the result of the function call.</p>

</div2>

</div1>

<div1 id="fallback">
<head>Fallback</head>

<e:element-syntax name="fallback">
  <e:in-category name="instruction"/>
  <e:model name="template"/>
</e:element-syntax>

<p>Normally, instantiating an <code>xsl:fallback</code> element does
nothing.  However, when an XSLT processor performs fallback for an
instruction element, if the instruction element has one or more
<code>xsl:fallback</code> children, then the content of each of the
<code>xsl:fallback</code> children must be instantiated in sequence;
otherwise, an error must be signaled. The content of an
<code>xsl:fallback</code> element is a template.</p>

<p>The following functions can be used with the
<code>xsl:choose</code> and <code>xsl:if</code> instructions to
explicitly control how a stylesheet should behave if particular
elements or functions are not available.</p>

<proto name="element-available" return-type="boolean"><arg
type="string"/></proto>

<p>The argument must evaluate to a string that is a <xnt
href="&XMLNames;#NT-QName">QName</xnt>.  The <xnt
href="&XMLNames;#NT-QName">QName</xnt> is expanded into an <xtermref
href="&XPath;#dt-expanded-name">expanded-name</xtermref> using the
namespace declarations in scope for the expression. The
<function>element-available</function> function returns true if and
only if the expanded-name is the name of an instruction.  If the
expanded-name has a namespace URI equal to the XSLT namespace URI,
then it refers to an element defined by XSLT.  Otherwise, it refers to
an extension element. If the expanded-name has a null namespace URI,
the <function>element-available</function> function will return
false.</p>

<proto name="function-available" return-type="boolean"><arg
type="string"/></proto>

<p>The argument must evaluate to a string that is a <xnt
href="&XMLNames;#NT-QName">QName</xnt>.  The <xnt
href="&XMLNames;#NT-QName">QName</xnt> is expanded into an <xtermref
href="&XPath;#dt-expanded-name">expanded-name</xtermref> using the
namespace declarations in scope for the expression. The
<function>function-available</function> function returns true if and
only if the expanded-name is the name of a function in the function
library. If the expanded-name has a non-null namespace URI, then it
refers to an extension function; otherwise, it refers to a function
defined by XPath or XSLT.</p>

</div1>

<div1 id="output">
<head>Output</head>

<e:element-syntax name="output">
  <e:in-category name="top-level-element"/>
  <e:attribute name="method">
    <e:constant value="xml"/>
    <e:constant value="html"/>
    <e:constant value="text"/>
    <e:data-type name="qname-but-not-ncname"/>
  </e:attribute>
  <e:attribute name="version">
    <e:data-type name="nmtoken"/>
  </e:attribute>
  <e:attribute name="encoding">
    <e:data-type name="string"/>
  </e:attribute>
  <e:attribute name="omit-xml-declaration">
    <e:constant value="yes"/>
    <e:constant value="no"/>
  </e:attribute>
  <e:attribute name="standalone">
    <e:constant value="yes"/>
    <e:constant value="no"/>
  </e:attribute>
  <e:attribute name="doctype-public">
    <e:data-type name="string"/>
  </e:attribute>
  <e:attribute name="doctype-system">
    <e:data-type name="string"/>
  </e:attribute>
  <e:attribute name="cdata-section-elements">
    <e:data-type name="qnames"/>
  </e:attribute>
  <e:attribute name="indent">
    <e:constant value="yes"/>
    <e:constant value="no"/>
  </e:attribute>
  <e:attribute name="media-type">
    <e:data-type name="string"/>
  </e:attribute>
  <e:empty/>
</e:element-syntax>

<p>An XSLT processor may output the result tree as a sequence of
bytes, although it is not required to be able to do so (see <specref
ref="conformance"/>). The <code>xsl:output</code> element allows
stylesheet authors to specify how they wish the result tree to be
output. If an XSLT processor outputs the result tree, it should do so
as specified by the <code>xsl:output</code> element; however, it is
not required to do so.</p>

<p>The <code>xsl:output</code> element is only allowed as a <termref
def="dt-top-level">top-level</termref> element.</p>

<p>The <code>method</code> attribute on <code>xsl:output</code>
identifies the overall method that should be used for outputting the
result tree.  The value must be a <xnt
href="&XMLNames;#NT-QName">QName</xnt>.  If the <xnt
href="&XMLNames;#NT-QName">QName</xnt> does not have a prefix, then it
identifies a method specified in this document and must be one of
<code>xml</code>, <code>html</code> or <code>text</code>.  If the <xnt
href="&XMLNames;#NT-QName">QName</xnt> has a prefix, then the <xnt
href="&XMLNames;#NT-QName">QName</xnt> is expanded into an <xtermref
href="&XPath;#dt-expanded-name">expanded-name</xtermref> as described
in <specref ref="qname"/>; the expanded-name identifies the output
method; the behavior in this case is not specified by this
document.</p>

<p>The default for the <code>method</code> attribute is chosen as
follows.  If</p>

<ulist>

<item><p>the root node of the result tree has an element
child,</p></item>

<item><p>the expanded-name of the first element child of the root node
(i.e. the document element) of the result tree has local part
<code>html</code> (in any combination of upper and lower case) and a
null namespace URI, and</p></item>

<item><p>any text nodes preceding the first element child of the root
node of the result tree contain only whitespace characters,</p></item>

</ulist>

<p>then the default output method is <code>html</code>; otherwise, the
default output method is <code>xml</code>.  The default output method
should be used if there are no <code>xsl:output</code> elements or if
none of the <code>xsl:output</code> elements specifies a value for the
<code>method</code> attribute.</p>

<p>The other attributes on <code>xsl:output</code> provide parameters
for the output method.  The following attributes are allowed:</p>

<ulist>

<item><p><code>version</code> specifies the version of the output
method</p></item>

<item><p><code>indent</code> specifies whether the XSLT processor may
add additional whitespace when outputting the result tree; the value
must be <code>yes</code> or <code>no</code></p></item>

<item><p><code>encoding</code> specifies the preferred character
encoding that the XSLT processor should use to encode sequences of
characters as sequences of bytes; the value of the attribute should be
treated case-insensitively; the value must contain only characters in
the range #x21 to #x7E (i.e. printable ASCII characters); the value
should either be a <code>charset</code> registered with the Internet
Assigned Numbers Authority <bibref ref="IANA"/>, <bibref
ref="RFC2278"/> or start with <code>X-</code></p></item>

<item><p><code>media-type</code> specifies the media type (MIME
content type) of the data that results from outputting the result
tree; the <code>charset</code> parameter should not be specified
explicitly; instead, when the top-level media type is
<code>text</code>, a <code>charset</code> parameter should be added
according to the character encoding actually used by the output
method</p></item>

<item><p><code>doctype-system</code> specifies the system identifier
to be used in the document type declaration</p></item>

<item><p><code>doctype-public</code> specifies the public identifier
to be used in the document type declaration</p></item>

<item><p><code>omit-xml-declaration</code> specifies whether the XSLT
processor should output an XML declaration; the value must be
<code>yes</code> or <code>no</code></p></item>

<item><p><code>standalone</code> specifies whether the XSLT processor
should output a standalone document declaration; the value must be
<code>yes</code> or <code>no</code></p></item>

<item><p><code>cdata-section-elements</code> specifies a list of the
names of elements whose text node children should be output using
CDATA sections</p></item>

</ulist>

<p>The detailed semantics of each attribute will be described
separately for each output method for which it is applicable.  If the
semantics of an attribute are not described for an output method, then
it is not applicable to that output method.</p>

<p>A stylesheet may contain multiple <code>xsl:output</code> elements
and may include or import stylesheets that also contain
<code>xsl:output</code> elements.  All the <code>xsl:output</code>
elements occurring in a stylesheet are merged into a single effective
<code>xsl:output</code> element. For the
<code>cdata-section-elements</code> attribute, the effective value is
the union of the specified values.  For other attributes, the
effective value is the specified value with the highest <termref
def="dt-import-precedence">import precedence</termref>. It is an error
if there is more than one such value for an attribute.  An XSLT
processor may signal the error; if it does not signal the error, if
should recover by using the value that occurs last in the stylesheet.
The values of attributes are defaulted after the
<code>xsl:output</code> elements have been merged; different output
methods may have different default values for an attribute.</p>

<div2>
<head>XML Output Method</head>

<p>The <code>xml</code> output method outputs the result tree as a
well-formed XML external general parsed entity. If the root node of
the result tree has a single element node child and no text node
children, then the entity should also be a well-formed XML document
entity. When the entity is referenced within a trivial XML document
wrapper like this</p>

<eg><![CDATA[
<!DOCTYPE doc [
<!ENTITY e SYSTEM "]]><var>entity-URI</var><![CDATA[">
]>
<doc>&e;</doc>]]></eg>

<p>where <code><var>entity-URI</var></code> is a URI for the entity,
then the wrapper
document as a whole should be a well-formed XML document conforming to
the XML Namespaces Recommendation <bibref ref="XMLNAMES"/>.  In
addition, the output should be such that if a new tree was constructed
by parsing the wrapper as an XML document as specified in <specref
ref="data-model"/>, and then removing the document element, making its
children instead be children of the root node, then the new tree would
be the same as the result tree, with the following possible
exceptions:</p>

<ulist>

<item><p>The order of attributes in the two trees may be
different.</p></item>

<item><p>The new tree may contain namespace nodes that were not
present in the result tree.</p>
<note><p>An XSLT processor may need to add
namespace declarations in the course of outputting the result tree as
XML.</p></note>
</item>

</ulist>

<p>If the XSLT processor generated a document type declaration because
of the <code>doctype-system</code> attribute, then the above
requirements apply to the entity with the generated document type
declaration removed.</p>

<p>The <code>version</code> attribute specifies the version of XML to
be used for outputting the result tree.  If the XSLT processor does
not support this version of XML, it should use a version of XML that
it does support.  The version output in the XML declaration (if an XML
declaration is output) should correspond to the version of XML that
the processor used for outputting the result tree. The value of the
<code>version</code> attribute should match the <xnt
href="&XML;#NT-VersionNum">VersionNum</xnt> production of the XML
Recommendation <bibref ref="XML"/>. The default value is
<code>1.0</code>.</p>

<p>The <code>encoding</code> attribute specifies the preferred
encoding to use for outputting the result tree.  XSLT processors are
required to respect values of <code>UTF-8</code> and
<code>UTF-16</code>.  For other values, if the XSLT processor does not
support the specified encoding it may signal an error; if it does not
signal an error it should use <code>UTF-8</code> or
<code>UTF-16</code> instead.  The XSLT processor must not use an
encoding whose name does not match the <xnt
href="&XML;#NT-EncName">EncName</xnt> production of the XML
Recommendation <bibref ref="XML"/>.  If no <code>encoding</code>
attribute is specified, then the XSLT processor should use either
<code>UTF-8</code> or <code>UTF-16</code>.  It is possible that the
result tree will contain a character that cannot be represented in the
encoding that the XSLT processor is using for output.  In this case,
if the character occurs in a context where XML recognizes character
references (i.e. in the value of an attribute node or text node), then
the character should be output as a character reference; otherwise
(for example if the character occurs in the name of an element) the
XSLT processor should signal an error.</p>

<p>If the <code>indent</code> attribute has the value
<code>yes</code>, then the <code>xml</code> output method may output
whitespace in addition to the whitespace in the result tree (possibly
based on whitespace stripped from either the source document or the
stylesheet) in order to indent the result nicely; if the
<code>indent</code> attribute has the value <code>no</code>, it should
not output any additional whitespace. The default value is
<code>no</code>.  The <code>xml</code> output method should use an
algorithm to output additional whitespace that ensures that the result
if whitespace were to be stripped from the output using the process
described in <specref ref="strip"/> with the set of
whitespace-preserving elements consisting of just
<code>xsl:text</code> would be the same when additional whitespace is
output as when additional whitespace is not output.</p>

<note><p>It is usually not safe to use <code>indent="yes"</code> with
document types that include element types with mixed content.</p></note>

<p>The <code>cdata-section-elements</code> attribute contains a
whitespace-separated list of <xnt
href="&XMLNames;#NT-QName">QName</xnt>s.  Each <xnt
href="&XMLNames;#NT-QName">QName</xnt> is expanded into an
expanded-name using the namespace declarations in effect on the
<code>xsl:output</code> element in which the <xnt
href="&XMLNames;#NT-QName">QName</xnt> occurs; if there is a default
namespace, it is used for <xnt href="&XMLNames;#NT-QName">QName</xnt>s
that do not have a prefix.  The expansion is performed before the
merging of multiple <code>xsl:output</code> elements into a single
effective <code>xsl:output</code> element. If the expanded-name of the
parent of a text node is a member of the list, then the text node
should be output as a CDATA section. For example,</p>

<eg><![CDATA[<xsl:output cdata-section-elements="example"/>]]></eg>

<p>would cause a literal result element written in the stylesheet as</p>

<eg><![CDATA[<example>&lt;foo></example>]]></eg>

<p>or as</p>

<eg>&lt;example>&lt;![CDATA[&lt;foo>]]&gt;&lt;/example></eg>

<p>to be output as</p>

<eg>&lt;example>&lt;![CDATA[&lt;foo>]]&gt;&lt;/example></eg>

<p>If the text node contains the sequence of characters
<code>]]&gt;</code>, then the currently open CDATA section should be
closed following the <code>]]</code> and a new CDATA section opened
before the <code>&gt;</code>. For example, a literal result element
written in the stylesheet as</p>

<eg>&lt;example&gt;]]&amp;gt;&lt;/example&gt;</eg>

<p>would be output as</p>

<eg>&lt;example&gt;&lt;![CDATA[]]]]&gt;&lt;![CDATA[&gt;]]&gt;&lt;/example&gt;</eg>

<p>If the text node contains a character that is not representable in
the character encoding being used to output the result tree, then the
currently open CDATA section should be closed before the character,
the character should be output using a character reference or entity
reference, and a new CDATA section should be opened for any further
characters in the text node.</p>

<p>CDATA sections should not be used except for text nodes that the
<code>cdata-section-elements</code> attribute explicitly specifies
should be output using CDATA sections.</p>

<p>The <code>xml</code> output method should output an XML declaration
unless the <code>omit-xml-declaration</code> attribute has the value
<code>yes</code>. The XML declaration should include both version
information and an encoding declaration. If the
<code>standalone</code> attribute is specified, it should include a
standalone document declaration with the same value as the value as
the value of the <code>standalone</code> attribute.  Otherwise, it
should not include a standalone document declaration; this ensures
that it is both a XML declaration (allowed at the beginning of a
document entity) and a text declaration (allowed at the beginning of
an external general parsed entity).</p>

<p>If the <code>doctype-system</code> attribute is specified, the
<code>xml</code> output method should output a document type
declaration immediately before the first element.  The name following
<code>&lt;!DOCTYPE</code> should be the name of the first element.  If
<code>doctype-public</code> attribute is also specified, then the
<code>xml</code> output method should output <code>PUBLIC</code>
followed by the public identifier and then the system identifier;
otherwise, it should output <code>SYSTEM</code> followed by the system
identifier.  The internal subset should be empty.  The
<code>doctype-public</code> attribute should be ignored unless the
<code>doctype-system</code> attribute is specified.</p>

<p>The <code>media-type</code> attribute is applicable for the
<code>xml</code> output method.  The default value for the
<code>media-type</code> attribute is <code>text/xml</code>.</p>

</div2>

<div2>
<head>HTML Output Method</head>

<p>The <code>html</code> output method outputs the result tree as
HTML; for example,</p>

<eg>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="&XSLT.ns;"><![CDATA[

<xsl:output method="html"/>

<xsl:template match="/">
  <html>
   <xsl:apply-templates/>
  </html>
</xsl:template>

...

</xsl:stylesheet>]]></eg>

<p>The <code>version</code> attribute indicates the version of the
HTML.  The default value is <code>4.0</code>, which specifies that the
result should be output as HTML conforming to the HTML 4.0
Recommendation <bibref ref="HTML"/>.</p>

<p>The <code>html</code> output method should not output an element
differently from the <code>xml</code> output method unless the
expanded-name of the element has a null namespace URI; an element
whose expanded-name has a non-null namespace URI should be output as
XML.  If the expanded-name of the element has a null namespace URI,
but the local part of the expanded-name is not recognized as the name
of an HTML element, the element should output in the same way as a
non-empty, inline element such as <code>span</code>.</p>

<p>The <code>html</code> output method should not output an end-tag
for empty elements.  For HTML 4.0, the empty elements are
<code>area</code>, <code>base</code>, <code>basefont</code>,
<code>br</code>, <code>col</code>, <code>frame</code>,
<code>hr</code>, <code>img</code>, <code>input</code>,
<code>isindex</code>, <code>link</code>, <code>meta</code> and
<code>param</code>. For example, an element written as
<code>&lt;br/></code> or <code>&lt;br>&lt;/br></code> in the
stylesheet should be output as <code>&lt;br></code>.</p>

<p>The <code>html</code> output method should recognize the names of
HTML elements regardless of case.  For example, elements named
<code>br</code>, <code>BR</code> or <code>Br</code> should all be
recognized as the HTML <code>br</code> element and output without an
end-tag.</p>

<p>The <code>html</code> output method should not perform escaping for
the content of the <code>script</code> and <code>style</code>
elements. For example, a literal result element written in the
stylesheet as</p>

<eg><![CDATA[<script>if (a &lt; b) foo()</script>]]></eg>

<p>or</p>

<eg><![CDATA[<script><![CDATA[if (a < b) foo()]]]]><![CDATA[></script>]]></eg>

<p>should be output as</p>

<eg><![CDATA[<script>if (a < b) foo()</script>]]></eg>

<p>The <code>html</code> output method should not escape
<code>&lt;</code> characters occurring in attribute values.</p>

<p>If the <code>indent</code> attribute has the value
<code>yes</code>, then the <code>html</code> output method may add or
remove whitespace as it outputs the result tree, so long as it does
not change how an HTML user agent would render the output.  The
default value is <code>yes</code>.</p>

<p>The <code>html</code> output method should escape non-ASCII
characters in URI attribute values using the method recommended in
<loc
href="http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.2.1">Section
B.2.1</loc> of the HTML 4.0 Recommendation.</p>

<p>The <code>html</code> output method may output a character using a
character entity reference, if one is defined for it in the version of
HTML that the output method is using.</p>

<p>The <code>html</code> output method should terminate processing
instructions with <code>&gt;</code> rather than
<code>?&gt;</code>.</p>

<p>The <code>html</code> output method should output boolean
attributes (that is attributes with only a single allowed value that
is equal to the name of the attribute) in minimized form. For example,
a start-tag written in the stylesheet as</p>

<eg><![CDATA[<OPTION selected="selected">]]></eg>

<p>should be output as</p>

<eg><![CDATA[<OPTION selected>]]></eg>

<p>The <code>html</code> output method should not escape a
<code>&amp;</code> character occurring in an attribute value
immediately followed by a <code>{</code> character (see <loc
href="http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.7.1.1">Section
B.7.1</loc> of the HTML 4.0 Recommendation). For example, a start-tag
written in the stylesheet as</p>

<eg><![CDATA[<BODY bgcolor='&amp;{{randomrbg}};'>]]></eg>

<p>should be output as</p>

<eg><![CDATA[<BODY bgcolor='&{randomrbg};'>]]></eg>

<p>The <code>encoding</code> attribute specifies the preferred
encoding to be used. If there is a <code>HEAD</code> element, then the
<code>html</code> output method should add a <code>META</code> element
immediately after the start-tag of the <code>HEAD</code> element
specifying the character encoding actually used. For example,</p>

<eg><![CDATA[<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=EUC-JP">
...]]></eg>

<p>It is possible that the result tree will contain a character that
cannot be represented in the encoding that the XSLT processor is using
for output.  In this case, if the character occurs in a context where
HTML recognizes character references, then the character should be
output as a character entity reference or decimal numeric character
reference; otherwise (for example, in a
<code>script</code> or <code>style</code> element or in a comment),
the XSLT processor should signal an error.</p>

<p>If the <code>doctype-public</code> or <code>doctype-system</code>
attributes are specified, then the <code>html</code> output method
should output a document type declaration immediately before the first
element.  The name following <code>&lt;!DOCTYPE</code> should be
<code>HTML</code> or <code>html</code>.  If the
<code>doctype-public</code> attribute is specified, then the output
method should output <code>PUBLIC</code> followed by the specified
public identifier; if the <code>doctype-system</code> attribute is
also specified, it should also output the specified system identifier
following the public identifier.  If the <code>doctype-system</code>
attribute is specified but the <code>doctype-public</code> attribute
is not specified, then the output method should output
<code>SYSTEM</code> followed by the specified system identifier.</p>

<p>The <code>media-type</code> attribute is applicable for the
<code>html</code> output method.  The default value is
<code>text/html</code>.</p>

</div2>

<div2>
<head>Text Output Method</head>

<p>The <code>text</code> output method outputs the result tree by
outputting the string-value of every text node in the result tree in
document order without any escaping.</p>

<p>The <code>media-type</code> attribute is applicable for the
<code>text</code> output method.  The default value for the
<code>media-type</code> attribute is <code>text/plain</code>.</p>

<p>The <code>encoding</code> attribute identifies the encoding that
the <code>text</code> output method should use to convert sequences of
characters to sequences of bytes.  The default is system-dependent. If
the result tree contains a character that cannot be represented in the
encoding that the XSLT processor is using for output, the XSLT
processor should signal an error.</p>

</div2>

<div2 id="disable-output-escaping">
<head>Disabling Output Escaping</head>

<p>Normally, the <code>xml</code> output method escapes &amp; and &lt;
(and possibly other characters) when outputting text nodes.  This
ensures that the output is well-formed XML. However, it is sometimes
convenient to be able to produce output that is almost, but not quite
well-formed XML; for example, the output may include ill-formed
sections which are intended to be transformed into well-formed XML by
a subsequent non-XML aware process.  For this reason, XSLT provides a
mechanism for disabling output escaping. An <code>xsl:value-of</code>
or <code>xsl:text</code> element may have a
<code>disable-output-escaping</code> attribute; the allowed values are
<code>yes</code> or <code>no</code>; the default is <code>no</code>;
if the value is <code>yes</code>, then a text node generated by
instantiating the <code>xsl:value-of</code> or <code>xsl:text</code>
element should be output without any escaping. For example,</p>

<eg><![CDATA[<xsl:text disable-output-escaping="yes">&lt;</xsl:text>]]></eg>

<p>should generate the single character <code>&lt;</code>.</p>

<p>It is an error for output escaping to be disabled for a text node
that is used for something other than a text node in the result tree.
Thus, it is an error to disable output escaping for an
<code>xsl:value-of</code> or <code>xsl:text</code> element that is
used to generate the string-value of a comment, processing instruction
or attribute node; it is also an error to convert a <termref
def="dt-result-tree-fragment">result tree fragment</termref> to a
number or a string if the result tree fragment contains a text node for
which escaping was disabled.  In both cases, an XSLT processor may
signal the error; if it does not signal the error, it must recover by
ignoring the <code>disable-output-escaping</code> attribute.</p>

<p>The <code>disable-output-escaping</code> attribute may be used with
the <code>html</code> output method as well as with the
<code>xml</code> output method.  The <code>text</code> output method
ignores the <code>disable-output-escaping</code> attribute, since it
does not perform any output escaping.</p>

<p>An XSLT processor will only be able to disable output escaping if
it controls how the result tree is output. This may not always be the
case.  For example, the result tree may be used as the source tree for
another XSLT transformation instead of being output.  An XSLT
processor is not required to support disabling output escaping.  If an
<code>xsl:value-of</code> or <code>xsl:text</code> specifies that
output escaping should be disabled and the XSLT processor does not
support this, the XSLT processor may signal an error; if it does not
signal an error, it must recover by not disabling output escaping.</p>

<p>If output escaping is disabled for a character that is not
representable in the encoding that the XSLT processor is using for
output, then the XSLT processor may signal an error; if it does not
signal an error, it must recover by not disabling output escaping.</p>

<p>Since disabling output escaping may not work with all XSLT
processors and can result in XML that is not well-formed, it should be
used only when there is no alternative.</p>


</div2>

</div1>

<div1 id="conformance">
<head>Conformance</head>

<p>A conforming XSLT processor must be able to use a stylesheet to
transform a source tree into a result tree as specified in this
document.  A conforming XSLT processor need not be able to output the
result in XML or in any other form.</p>

<note><p>Vendors of XSLT processors are strongly encouraged to provide
a way to verify that their processor is behaving conformingly by
allowing the result tree to be output as XML or by providing access to
the result tree through a standard API such as the DOM or
SAX.</p></note>

<p>A conforming XSLT processor must signal any errors except for those
that this document specifically allows an XSLT processor not to
signal. A conforming XSLT processor may but need not recover from any
errors that it signals.</p>

<p>A conforming XSLT processor may impose limits on the processing
resources consumed by the processing of a stylesheet.</p>

</div1>

<div1 id="notation">
<head>Notation</head>

<p>The specification of each XSLT-defined element type is preceded by
a summary of its syntax in the form of a model for elements of that
element type.  The meaning of syntax summary notation is as
follows:</p>

<ulist>

<item><p>An attribute is required if and only if its name is in
bold.</p></item>

<item><p>The string that occurs in the place of an attribute value
specifies the allowed values of the attribute.  If this is surrounded
by curly braces, then the attribute value is treated as an <termref
def="dt-attribute-value-template">attribute value template</termref>,
and the string occurring within curly braces specifies the allowed
values of the result of instantiating the attribute value template.
Alternative allowed values are separated by <code>|</code>.  A quoted
string indicates a value equal to that specific string. An unquoted,
italicized name specifies a particular type of value.</p></item>

<item><p>If the element is allowed not to be empty, then the element
contains a comment specifying the allowed content.  The allowed
content is specified in a similar way to an element type declaration
in XML; <emph>template</emph> means that any mixture of text nodes,
literal result elements, extension elements, and XSLT elements from
the <code>instruction</code> category is allowed;
<emph>top-level-elements</emph> means that any mixture of XSLT
elements from the <code>top-level-element</code> category is
allowed.</p></item>

<item><p>The element is prefaced by comments indicating if it belongs
to the <code>instruction</code> category or
<code>top-level-element</code> category or both.  The category of an
element just affects whether it is allowed in the content of elements
that allow a <emph>template</emph> or
<emph>top-level-elements</emph>.</p></item>

</ulist>

</div1>

</body>

<back>
<div1>
<head>References</head>
<div2>
<head>Normative References</head>

<blist>

<bibl id="XML" key="XML">World Wide Web Consortium. <emph>Extensible
Markup Language (XML) 1.0.</emph> W3C Recommendation. See <loc
href="http://www.w3.org/TR/1998/REC-xml-19980210">http://www.w3.org/TR/1998/REC-xml-19980210</loc></bibl>

<bibl id="XMLNAMES" key="XML Names">World Wide Web
Consortium. <emph>Namespaces in XML.</emph> W3C Recommendation. See
<loc
href="http://www.w3.org/TR/REC-xml-names">http://www.w3.org/TR/REC-xml-names</loc></bibl>

<bibl id="XPATH" key="XPath">World Wide Web Consortium. <emph>XML Path
Language.</emph> W3C Recommendation. See <loc
href="&XPath;">http://www.w3.org/TR/xpath</loc></bibl>

</blist>
</div2>
<div2>
<head>Other References</head>

<blist>

<bibl id="CSS2" key="CSS2">World Wide Web Consortium.  <emph>Cascading
Style Sheets, level 2 (CSS2)</emph>.  W3C Recommendation.  See <loc
href="http://www.w3.org/TR/1998/REC-CSS2-19980512"
>http://www.w3.org/TR/1998/REC-CSS2-19980512</loc></bibl>

<bibl id="DSSSL" key="DSSSL">International Organization
for Standardization, International Electrotechnical Commission.
<emph>ISO/IEC 10179:1996.  Document Style Semantics and Specification
Language (DSSSL)</emph>.  International Standard.</bibl>

<bibl id="HTML" key="HTML">World Wide Web Consortium. <emph>HTML 4.0
specification</emph>. W3C Recommendation. See <loc
href="http://www.w3.org/TR/REC-html40"
>http://www.w3.org/TR/REC-html40</loc></bibl>

<bibl id="IANA" key="IANA">Internet Assigned Numbers
Authority. <emph>Character Sets</emph>. See <loc
href="ftp://ftp.isi.edu/in-notes/iana/assignments/character-sets"
>ftp://ftp.isi.edu/in-notes/iana/assignments/character-sets</loc>.</bibl>

<bibl id="RFC2278" key="RFC2278">N. Freed, J. Postel.  <emph>IANA
Charset Registration Procedures</emph>.  IETF RFC 2278. See <loc
href="http://www.ietf.org/rfc/rfc2278.txt"
>http://www.ietf.org/rfc/rfc2278.txt</loc>.</bibl>

<bibl id="RFC2376" key="RFC2376">E. Whitehead, M. Murata.  <emph>XML
Media Types</emph>. IETF RFC 2376. See <loc
href="http://www.ietf.org/rfc/rfc2376.txt"
>http://www.ietf.org/rfc/rfc2376.txt</loc>.</bibl>

<bibl id="RFC2396" key="RFC2396">T. Berners-Lee, R. Fielding, and
L. Masinter.  <emph>Uniform Resource Identifiers (URI): Generic
Syntax</emph>. IETF RFC 2396. See <loc
href="http://www.ietf.org/rfc/rfc2396.txt">http://www.ietf.org/rfc/rfc2396.txt</loc>.</bibl>

<bibl id="UNICODE-TR10" key="UNICODE TR10">Unicode Consortium.
<emph>Unicode Technical Report #10. Unicode Collation
Algorithm</emph>.  Unicode Technical Report.  See <loc
href="http://www.unicode.org/unicode/reports/tr10/index.html"
>http://www.unicode.org/unicode/reports/tr10/index.html</loc>.</bibl>

<bibl id="XHTML" key="XHTML">World Wide Web Consortium. <emph>XHTML
1.0: The Extensible HyperText Markup Language.</emph> W3C Proposed
Recommendation. See <loc href="http://www.w3.org/TR/xhtml1"
>http://www.w3.org/TR/xhtml1</loc></bibl>

<bibl id="XPTR" key="XPointer">World Wide Web
Consortium. <emph>XML Pointer Language (XPointer).</emph> W3C Working
Draft. See <loc href="http://www.w3.org/TR/xptr"
>http://www.w3.org/TR/xptr</loc></bibl>

<bibl id="XMLSTYLE" key="XML Stylesheet">World Wide Web
Consortium. <emph>Associating stylesheets with XML documents.</emph>
W3C Recommendation. See <loc
href="http://www.w3.org/TR/xml-stylesheet"
>http://www.w3.org/TR/xml-stylesheet</loc></bibl>

<bibl id="XSL" key="XSL">World Wide Web Consortium.  <emph>Extensible
Stylesheet Language (XSL).</emph>  W3C Working Draft.  See <loc
href="http://www.w3.org/TR/WD-xsl"
     >http://www.w3.org/TR/WD-xsl</loc></bibl>

</blist>

</div2>
</div1>

<div1 id="element-syntax-summary">
<head>Element Syntax Summary</head>

<e:element-syntax-summary/>

</div1>

<inform-div1 id="dtd">
<head>DTD Fragment for XSLT Stylesheets</head>

<note><p>This DTD Fragment is not normative because XML 1.0 DTDs do
not support XML Namespaces and thus cannot correctly describe the
allowed structure of an XSLT stylesheet.</p></note>

<p>The following entity can be used to construct a DTD for XSLT
stylesheets that create instances of a particular result DTD.  Before
referencing the entity, the stylesheet DTD must define a
<code>result-elements</code> parameter entity listing the allowed
result element types.  For example:</p>

<eg><![CDATA[<!ENTITY % result-elements "
  | fo:inline-sequence
  | fo:block
">]]></eg>

<p>Such result elements should be declared to have
<code>xsl:use-attribute-sets</code> and
<code>xsl:extension-element-prefixes</code> attributes.  The following
entity declares the <code>result-element-atts</code> parameter for
this purpose. The content that XSLT allows for result elements is the
same as it allows for the XSLT elements that are declared in the
following entity with a content model of <code>%template;</code>.  The
DTD may use a more restrictive content model than
<code>%template;</code> to reflect the constraints of the result
DTD.</p>

<p>The DTD may define the <code>non-xsl-top-level</code> parameter
entity to allow additional top-level elements from namespaces other
than the XSLT namespace.</p>

<p>The use of the <code>xsl:</code> prefix in this DTD does not imply
that XSLT stylesheets are required to use this prefix.  Any of the
elements declared in this DTD may have attributes whose name starts
with <code>xmlns:</code> or is equal to <code>xmlns</code> in addition
to the attributes declared in this DTD.</p>

<eg><![CDATA[<!ENTITY % char-instructions "
  | xsl:apply-templates
  | xsl:call-template
  | xsl:apply-imports
  | xsl:for-each
  | xsl:value-of
  | xsl:copy-of
  | xsl:number
  | xsl:choose
  | xsl:if
  | xsl:text
  | xsl:copy
  | xsl:variable
  | xsl:message
  | xsl:fallback
">

<!ENTITY % instructions "
  %char-instructions;
  | xsl:processing-instruction
  | xsl:comment
  | xsl:element
  | xsl:attribute
">

<!ENTITY % char-template "
 (#PCDATA
  %char-instructions;)*
">

<!ENTITY % template "
 (#PCDATA
  %instructions;
  %result-elements;)*
">

<!-- Used for the type of an attribute value that is a URI reference.-->
<!ENTITY % URI "CDATA">

<!-- Used for the type of an attribute value that is a pattern.-->
<!ENTITY % pattern "CDATA">

<!-- Used for the type of an attribute value that is an
     attribute value template.-->
<!ENTITY % avt "CDATA">

<!-- Used for the type of an attribute value that is a QName; the prefix
     gets expanded by the XSLT processor. -->
<!ENTITY % qname "NMTOKEN">

<!-- Like qname but a whitespace-separated list of QNames. -->
<!ENTITY % qnames "NMTOKENS">

<!-- Used for the type of an attribute value that is an expression.-->
<!ENTITY % expr "CDATA">

<!-- Used for the type of an attribute value that consists
     of a single character.-->
<!ENTITY % char "CDATA">

<!-- Used for the type of an attribute value that is a priority. -->
<!ENTITY % priority "NMTOKEN">

<!ENTITY % space-att "xml:space (default|preserve) #IMPLIED">

<!-- This may be overridden to customize the set of elements allowed
at the top-level. -->

<!ENTITY % non-xsl-top-level "">

<!ENTITY % top-level "
 (xsl:import*,
  (xsl:include
  | xsl:strip-space
  | xsl:preserve-space
  | xsl:output
  | xsl:key
  | xsl:decimal-format
  | xsl:attribute-set
  | xsl:variable
  | xsl:param
  | xsl:template
  | xsl:namespace-alias
  %non-xsl-top-level;)*)
">

<!ENTITY % top-level-atts '
  extension-element-prefixes CDATA #IMPLIED
  exclude-result-prefixes CDATA #IMPLIED
  id ID #IMPLIED
  version NMTOKEN #REQUIRED
  xmlns:xsl CDATA #FIXED "]]>&XSLT.ns;<![CDATA["
  %space-att;
'>

<!-- This entity is defined for use in the ATTLIST declaration
for result elements. -->

<!ENTITY % result-element-atts '
  xsl:extension-element-prefixes CDATA #IMPLIED
  xsl:exclude-result-prefixes CDATA #IMPLIED
  xsl:use-attribute-sets %qnames; #IMPLIED
  xsl:version NMTOKEN #IMPLIED
'>

<!ELEMENT xsl:stylesheet %top-level;>
<!ATTLIST xsl:stylesheet %top-level-atts;>

<!ELEMENT xsl:transform %top-level;>
<!ATTLIST xsl:transform %top-level-atts;>

<!ELEMENT xsl:import EMPTY>
<!ATTLIST xsl:import href %URI; #REQUIRED>

<!ELEMENT xsl:include EMPTY>
<!ATTLIST xsl:include href %URI; #REQUIRED>

<!ELEMENT xsl:strip-space EMPTY>
<!ATTLIST xsl:strip-space elements CDATA #REQUIRED>

<!ELEMENT xsl:preserve-space EMPTY>
<!ATTLIST xsl:preserve-space elements CDATA #REQUIRED>

<!ELEMENT xsl:output EMPTY>
<!ATTLIST xsl:output
  method %qname; #IMPLIED
  version NMTOKEN #IMPLIED
  encoding CDATA #IMPLIED
  omit-xml-declaration (yes|no) #IMPLIED
  standalone (yes|no) #IMPLIED
  doctype-public CDATA #IMPLIED
  doctype-system CDATA #IMPLIED
  cdata-section-elements %qnames; #IMPLIED
  indent (yes|no) #IMPLIED
  media-type CDATA #IMPLIED
>

<!ELEMENT xsl:key EMPTY>
<!ATTLIST xsl:key
  name %qname; #REQUIRED
  match %pattern; #REQUIRED
  use %expr; #REQUIRED
>

<!ELEMENT xsl:decimal-format EMPTY>
<!ATTLIST xsl:decimal-format
  name %qname; #IMPLIED
  decimal-separator %char; "."
  grouping-separator %char; ","
  infinity CDATA "Infinity"
  minus-sign %char; "-"
  NaN CDATA "NaN"
  percent %char; "%"
  per-mille %char; "&#x2030;"
  zero-digit %char; "0"
  digit %char; "#"
  pattern-separator %char; ";"
>

<!ELEMENT xsl:namespace-alias EMPTY>
<!ATTLIST xsl:namespace-alias
  stylesheet-prefix CDATA #REQUIRED
  result-prefix CDATA #REQUIRED
>

<!ELEMENT xsl:template
 (#PCDATA
  %instructions;
  %result-elements;
  | xsl:param)*
>

<!ATTLIST xsl:template
  match %pattern; #IMPLIED
  name %qname; #IMPLIED
  priority %priority; #IMPLIED
  mode %qname; #IMPLIED
  %space-att;
>

<!ELEMENT xsl:value-of EMPTY>
<!ATTLIST xsl:value-of
  select %expr; #REQUIRED
  disable-output-escaping (yes|no) "no"
>

<!ELEMENT xsl:copy-of EMPTY>
<!ATTLIST xsl:copy-of select %expr; #REQUIRED>

<!ELEMENT xsl:number EMPTY>
<!ATTLIST xsl:number
   level (single|multiple|any) "single"
   count %pattern; #IMPLIED
   from %pattern; #IMPLIED
   value %expr; #IMPLIED
   format %avt; '1'
   lang %avt; #IMPLIED
   letter-value %avt; #IMPLIED
   grouping-separator %avt; #IMPLIED
   grouping-size %avt; #IMPLIED
>

<!ELEMENT xsl:apply-templates (xsl:sort|xsl:with-param)*>
<!ATTLIST xsl:apply-templates
  select %expr; "node()"
  mode %qname; #IMPLIED
>

<!ELEMENT xsl:apply-imports EMPTY>

<!-- xsl:sort cannot occur after any other elements or
any non-whitespace character -->

<!ELEMENT xsl:for-each
 (#PCDATA
  %instructions;
  %result-elements;
  | xsl:sort)*
>

<!ATTLIST xsl:for-each
  select %expr; #REQUIRED
  %space-att;
>

<!ELEMENT xsl:sort EMPTY>
<!ATTLIST xsl:sort
  select %expr; "."
  lang %avt; #IMPLIED
  data-type %avt; "text"
  order %avt; "ascending"
  case-order %avt; #IMPLIED
>

<!ELEMENT xsl:if %template;>
<!ATTLIST xsl:if
  test %expr; #REQUIRED
  %space-att;
>

<!ELEMENT xsl:choose (xsl:when+, xsl:otherwise?)>
<!ATTLIST xsl:choose %space-att;>

<!ELEMENT xsl:when %template;>
<!ATTLIST xsl:when
  test %expr; #REQUIRED
  %space-att;
>

<!ELEMENT xsl:otherwise %template;>
<!ATTLIST xsl:otherwise %space-att;>

<!ELEMENT xsl:attribute-set (xsl:attribute)*>
<!ATTLIST xsl:attribute-set
  name %qname; #REQUIRED
  use-attribute-sets %qnames; #IMPLIED
>

<!ELEMENT xsl:call-template (xsl:with-param)*>
<!ATTLIST xsl:call-template
  name %qname; #REQUIRED
>

<!ELEMENT xsl:with-param %template;>
<!ATTLIST xsl:with-param
  name %qname; #REQUIRED
  select %expr; #IMPLIED
>

<!ELEMENT xsl:variable %template;>
<!ATTLIST xsl:variable 
  name %qname; #REQUIRED
  select %expr; #IMPLIED
>

<!ELEMENT xsl:param %template;>
<!ATTLIST xsl:param 
  name %qname; #REQUIRED
  select %expr; #IMPLIED
>

<!ELEMENT xsl:text (#PCDATA)>
<!ATTLIST xsl:text
  disable-output-escaping (yes|no) "no"
>

<!ELEMENT xsl:processing-instruction %char-template;>
<!ATTLIST xsl:processing-instruction 
  name %avt; #REQUIRED
  %space-att;
>

<!ELEMENT xsl:element %template;>
<!ATTLIST xsl:element 
  name %avt; #REQUIRED
  namespace %avt; #IMPLIED
  use-attribute-sets %qnames; #IMPLIED
  %space-att;
>

<!ELEMENT xsl:attribute %char-template;>
<!ATTLIST xsl:attribute 
  name %avt; #REQUIRED
  namespace %avt; #IMPLIED
  %space-att;
>

<!ELEMENT xsl:comment %char-template;>
<!ATTLIST xsl:comment %space-att;>

<!ELEMENT xsl:copy %template;>
<!ATTLIST xsl:copy
  %space-att;
  use-attribute-sets %qnames; #IMPLIED
>

<!ELEMENT xsl:message %template;>
<!ATTLIST xsl:message
  %space-att;
  terminate (yes|no) "no"
>

<!ELEMENT xsl:fallback %template;>
<!ATTLIST xsl:fallback %space-att;>]]></eg>

</inform-div1>

<inform-div1>
<head>Examples</head>

<div2>
<head>Document Example</head>

<p>This example is a stylesheet for transforming documents that
conform to a simple DTD into XHTML <bibref ref="XHTML"/>.  The DTD
is:</p>

<eg><![CDATA[<!ELEMENT doc (title, chapter*)>
<!ELEMENT chapter (title, (para|note)*, section*)>
<!ELEMENT section (title, (para|note)*)>
<!ELEMENT title (#PCDATA|emph)*>
<!ELEMENT para (#PCDATA|emph)*>
<!ELEMENT note (#PCDATA|emph)*>
<!ELEMENT emph (#PCDATA|emph)*>]]></eg>

<p>The stylesheet is:</p>

<eg>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="&XSLT.ns;"
                xmlns="&XHTML.ns;"><![CDATA[

<xsl:strip-space elements="doc chapter section"/>
<xsl:output
   method="xml"
   indent="yes"
   encoding="iso-8859-1"
/>

<xsl:template match="doc">
 <html>
   <head>
     <title>
       <xsl:value-of select="title"/>
     </title>
   </head>
   <body>
     <xsl:apply-templates/>
   </body>
 </html>
</xsl:template>

<xsl:template match="doc/title">
  <h1>
    <xsl:apply-templates/>
  </h1>
</xsl:template>

<xsl:template match="chapter/title">
  <h2>
    <xsl:apply-templates/>
  </h2>
</xsl:template>

<xsl:template match="section/title">
  <h3>
    <xsl:apply-templates/>
  </h3>
</xsl:template>

<xsl:template match="para">
  <p>
    <xsl:apply-templates/>
  </p>
</xsl:template>

<xsl:template match="note">
  <p class="note">
    <b>NOTE: </b>
    <xsl:apply-templates/>
  </p>
</xsl:template>

<xsl:template match="emph">
  <em>
    <xsl:apply-templates/>
  </em>
</xsl:template>

</xsl:stylesheet>]]></eg>

<p>With the following input document</p>

<eg><![CDATA[<!DOCTYPE doc SYSTEM "doc.dtd">
<doc>
<title>Document Title</title>
<chapter>
<title>Chapter Title</title>
<section>
<title>Section Title</title>
<para>This is a test.</para>
<note>This is a note.</note>
</section>
<section>
<title>Another Section Title</title>
<para>This is <emph>another</emph> test.</para>
<note>This is another note.</note>
</section>
</chapter>
</doc>]]></eg>

<p>it would produce the following result</p>

<eg>&lt;?xml version="1.0" encoding="iso-8859-1"?>
&lt;html xmlns="&XHTML.ns;"><![CDATA[
<head>
<title>Document Title</title>
</head>
<body>
<h1>Document Title</h1>
<h2>Chapter Title</h2>
<h3>Section Title</h3>
<p>This is a test.</p>
<p class="note">
<b>NOTE: </b>This is a note.</p>
<h3>Another Section Title</h3>
<p>This is <em>another</em> test.</p>
<p class="note">
<b>NOTE: </b>This is another note.</p>
</body>
</html>]]></eg>

</div2>

<div2 id="data-example">
<head>Data Example</head>

<p>This is an example of transforming some data represented in XML
using three different XSLT stylesheets to produce three different
representations of the data, HTML, SVG and VRML.</p>

<p>The input data is:</p>

<eg><![CDATA[<sales>

        <division id="North">
                <revenue>10</revenue>
                <growth>9</growth>
                <bonus>7</bonus>
        </division>

        <division id="South">
                <revenue>4</revenue>
                <growth>3</growth>
                <bonus>4</bonus>
        </division>

        <division id="West">
                <revenue>6</revenue>
                <growth>-1.5</growth>
                <bonus>2</bonus>
        </division>

</sales>]]></eg>

<p>The following stylesheet, which uses the simplified syntax
described in <specref ref="result-element-stylesheet"/>, transforms
the data into HTML:</p>

<eg>&lt;html xsl:version="1.0"
      xmlns:xsl="&XSLT.ns;"<![CDATA[
      lang="en">
    <head>
	<title>Sales Results By Division</title>
    </head>
    <body>
	<table border="1">
	    <tr>
		<th>Division</th>
		<th>Revenue</th>
		<th>Growth</th>
		<th>Bonus</th>
	    </tr>
	    <xsl:for-each select="sales/division">
		<!-- order the result by revenue -->
		<xsl:sort select="revenue"
			  data-type="number"
			  order="descending"/>
		<tr>
		    <td>
			<em><xsl:value-of select="@id"/></em>
		    </td>
		    <td>
			<xsl:value-of select="revenue"/>
		    </td>
		    <td>
			<!-- highlight negative growth in red -->
			<xsl:if test="growth &lt; 0">
			     <xsl:attribute name="style">
				 <xsl:text>color:red</xsl:text>
			     </xsl:attribute>
			</xsl:if>
			<xsl:value-of select="growth"/>
		    </td>
		    <td>
			<xsl:value-of select="bonus"/>
		    </td>
		</tr>
	    </xsl:for-each>
	</table>
    </body>
</html>]]></eg>

<p>The HTML output is:</p>

<eg><![CDATA[<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Sales Results By Division</title>
</head>
<body>
<table border="1">
<tr>
<th>Division</th><th>Revenue</th><th>Growth</th><th>Bonus</th>
</tr>
<tr>
<td><em>North</em></td><td>10</td><td>9</td><td>7</td>
</tr>
<tr>
<td><em>West</em></td><td>6</td><td style="color:red">-1.5</td><td>2</td>
</tr>
<tr>
<td><em>South</em></td><td>4</td><td>3</td><td>4</td>
</tr>
</table>
</body>
</html>]]></eg>

<p>The following stylesheet transforms the data into SVG:</p>

<eg>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="&XSLT.ns;"<![CDATA[
                xmlns="http://www.w3.org/Graphics/SVG/SVG-19990812.dtd">

<xsl:output method="xml" indent="yes" media-type="image/svg"/>

<xsl:template match="/">

<svg width = "3in" height="3in">
    <g style = "stroke: #000000"> 
        <!-- draw the axes -->
        <line x1="0" x2="150" y1="150" y2="150"/>
        <line x1="0" x2="0" y1="0" y2="150"/>
        <text x="0" y="10">Revenue</text>
        <text x="150" y="165">Division</text>
        <xsl:for-each select="sales/division">
	    <!-- define some useful variables -->

	    <!-- the bar's x position -->
	    <xsl:variable name="pos"
	                  select="(position()*40)-30"/>

	    <!-- the bar's height -->
	    <xsl:variable name="height"
	                  select="revenue*10"/>

	    <!-- the rectangle -->
	    <rect x="{$pos}" y="{150-$height}"
                  width="20" height="{$height}"/>

	    <!-- the text label -->
	    <text x="{$pos}" y="165">
	        <xsl:value-of select="@id"/>
	    </text> 

	    <!-- the bar value -->
	    <text x="{$pos}" y="{145-$height}">
	        <xsl:value-of select="revenue"/>
	    </text>
        </xsl:for-each>
    </g>
</svg>

</xsl:template>
</xsl:stylesheet>]]></eg>

<p>The SVG output is:</p>

<eg><![CDATA[<svg width="3in" height="3in"
     xmlns="http://www.w3.org/Graphics/SVG/svg-19990412.dtd">
    <g style="stroke: #000000">
	<line x1="0" x2="150" y1="150" y2="150"/>
	<line x1="0" x2="0" y1="0" y2="150"/>
	<text x="0" y="10">Revenue</text>
	<text x="150" y="165">Division</text>
	<rect x="10" y="50" width="20" height="100"/>
	<text x="10" y="165">North</text>
	<text x="10" y="45">10</text>
	<rect x="50" y="110" width="20" height="40"/>
	<text x="50" y="165">South</text>
	<text x="50" y="105">4</text>
	<rect x="90" y="90" width="20" height="60"/>
	<text x="90" y="165">West</text>
	<text x="90" y="85">6</text>
    </g>
</svg>]]></eg>

<p>The following stylesheet transforms the data into VRML:</p>

<eg>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="&XSLT.ns;"><![CDATA[

<!-- generate text output as mime type model/vrml, using default charset -->
<xsl:output method="text" encoding="UTF-8" media-type="model/vrml"/>  

        <xsl:template match="/">#VRML V2.0 utf8 
 
# externproto definition of a single bar element 
EXTERNPROTO bar [ 
  field SFInt32 x  
  field SFInt32 y  
  field SFInt32 z  
  field SFString name  
  ] 
  "http://www.vrml.org/WorkingGroups/dbwork/barProto.wrl" 
 
# inline containing the graph axes 
Inline {  
        url "http://www.vrml.org/WorkingGroups/dbwork/barAxes.wrl" 
        } 
        
                <xsl:for-each select="sales/division">
bar {
        x <xsl:value-of select="revenue"/>
        y <xsl:value-of select="growth"/>
        z <xsl:value-of select="bonus"/>
        name "<xsl:value-of select="@id"/>" 
        }
                </xsl:for-each>
        
        </xsl:template> 
 
</xsl:stylesheet>]]></eg>

<p>The VRML output is:</p>

<eg><![CDATA[#VRML V2.0 utf8 
 
# externproto definition of a single bar element 
EXTERNPROTO bar [ 
  field SFInt32 x  
  field SFInt32 y  
  field SFInt32 z  
  field SFString name  
  ] 
  "http://www.vrml.org/WorkingGroups/dbwork/barProto.wrl" 
 
# inline containing the graph axes 
Inline {  
        url "http://www.vrml.org/WorkingGroups/dbwork/barAxes.wrl" 
        } 
        
                
bar {
        x 10
        y 9
        z 7
        name "North" 
        }
                
bar {
        x 4
        y 3
        z 4
        name "South" 
        }
                
bar {
        x 6
        y -1.5
        z 2
        name "West" 
        }]]></eg>

</div2>

</inform-div1>

<inform-div1>
<head>Acknowledgements</head>
<p>The following have contributed to authoring this draft:</p>
<slist>
<sitem>Daniel Lipkin, Saba</sitem>
<sitem>Jonathan Marsh, Microsoft</sitem>
<sitem>Henry Thompson, University of Edinburgh</sitem>
<sitem>Norman Walsh, Arbortext</sitem>
<sitem>Steve Zilles, Adobe</sitem>
</slist>

<p>This specification was developed and approved for publication by the
W3C XSL Working Group (WG). WG approval of this specification does not
necessarily imply that all WG members voted for its approval. The
current members of the XSL WG are:</p>

<orglist>
<member>
<name>Sharon Adler</name>
<affiliation>IBM</affiliation>
<role>Co-Chair</role>
</member>
<member>
<name>Anders Berglund</name>
<affiliation>IBM</affiliation>
</member>
<member>
<name>Perin Blanchard</name>
<affiliation>Novell</affiliation>
</member>
<member>
<name>Scott Boag</name>
<affiliation>Lotus</affiliation> 
</member>
<member>
<name>Larry Cable</name>
<affiliation>Sun</affiliation>
</member>
<member>
<name>Jeff Caruso</name>
<affiliation>Bitstream</affiliation>
</member>
<member>
<name>James Clark</name>
</member>
<member>
<name>Peter Danielsen</name>
<affiliation>Bell Labs</affiliation>
</member>
<member>
<name>Don Day</name>
<affiliation>IBM</affiliation>
</member>
<member>
<name>Stephen Deach</name>
<affiliation>Adobe</affiliation>
</member>
<member>
<name>Dwayne Dicks</name>
<affiliation>SoftQuad</affiliation>
</member>
<member>
<name>Andrew Greene</name>
<affiliation>Bitstream</affiliation>
</member>
<member>
<name>Paul Grosso</name>
<affiliation>Arbortext</affiliation>
</member>
<member>
<name>Eduardo Gutentag</name>
<affiliation>Sun</affiliation>
</member>
<member>
<name>Juliane Harbarth</name>
<affiliation>Software AG</affiliation>
</member>
<member>
<name>Mickey Kimchi</name>
<affiliation>Enigma</affiliation>
</member>
<member>
<name>Chris Lilley</name>
<affiliation>W3C</affiliation>
</member>
<member>
<name>Chris Maden</name>
<affiliation>Exemplary Technologies</affiliation>
</member>
<member>
<name>Jonathan Marsh</name>
<affiliation>Microsoft</affiliation>
</member>
<member>
<name>Alex Milowski</name> 
<affiliation>Lexica</affiliation>
</member>
<member>
<name>Steve Muench</name>
<affiliation>Oracle</affiliation>
</member>
<member>
<name>Scott Parnell</name>
<affiliation>Xerox</affiliation>
</member>
<member>
<name>Vincent Quint</name>
<affiliation>W3C</affiliation>
</member>
<member>
<name>Dan Rapp</name>
<affiliation>Novell</affiliation>
</member>
<member>
<name>Gregg Reynolds</name>
<affiliation>Datalogics</affiliation>
</member>
<member>
<name>Jonathan Robie</name>
<affiliation>Software AG</affiliation>
</member>
<member>
<name>Mark Scardina</name>
<affiliation>Oracle</affiliation>
</member>
<member>
<name>Henry Thompson</name>
<affiliation>University of Edinburgh</affiliation>
</member>
<member>
<name>Philip Wadler</name>
<affiliation>Bell Labs</affiliation>
</member>
<member>
<name>Norman Walsh</name>
<affiliation>Arbortext</affiliation>
</member>
<member>
<name>Sanjiva Weerawarana</name>
<affiliation>IBM</affiliation>
</member>
<member>
<name>Steve Zilles</name>
<affiliation>Adobe</affiliation>
<role>Co-Chair</role>
</member>
</orglist>

</inform-div1>

<inform-div1>
<head>Changes from Proposed Recommendation</head>

<p>The following are the changes since the Proposed Recommendation:</p>

<ulist>

<item><p>The <code>xsl:version</code> attribute is required on a
literal result element used as a stylesheet (see <specref
ref="result-element-stylesheet"/>).</p></item>

<item><p>The <code>data-type</code> attribute on <code>xsl:sort</code>
can use a prefixed name to specify a data-type not defined by
XSLT (see <specref ref="sorting"/>).</p></item>

</ulist>

</inform-div1>

<inform-div1>
<head>Features under Consideration for Future Versions of XSLT</head>

<p>The following features are under consideration for versions of XSLT
after XSLT 1.0:</p>

<ulist>

<item><p>a conditional expression;</p></item>

<item><p>support for XML Schema datatypes and archetypes;</p></item>

<item><p>support for something like style rules in the original XSL
submission;</p></item>

<item><p>an attribute to control the default namespace for names
occurring in XSLT attributes;</p></item>

<item><p>support for entity references;</p></item>

<item><p>support for DTDs in the data model;</p></item>

<item><p>support for notations in the data model;</p></item>

<item><p>a way to get back from an element to the elements that
reference it (e.g. by IDREF attributes);</p></item>

<item><p>an easier way to get an ID or key in another document;</p></item>

<item><p>support for regular expressions for matching against any or
all of text nodes, attribute values, attribute names, element type
names;</p></item>

<item><p>case-insensitive comparisons;</p></item>

<item><p>normalization of strings before comparison, for example for
compatibility characters;</p></item>

<item><p>a function <code>string resolve(node-set)</code> function
that treats the value of the argument as a relative URI and turns it
into an absolute URI using the base URI of the node;</p></item>

<item><p>multiple result documents;</p></item>

<item><p>defaulting the <code>select</code> attribute on
<code>xsl:value-of</code> to the current node;</p></item>

<item><p>an attribute on <code>xsl:attribute</code> to control how the
attribute value is normalized;</p></item>

<item><p>additional attributes on <code>xsl:sort</code> to provide
further control over sorting, such as relative order of
scripts;</p></item>

<item><p>a way to put the text of a resource identified by a URI into
the result tree;</p></item>

<item><p>allow unions in steps (e.g. <code>foo/(bar|baz)</code>);</p></item>

<item><p>allow for result tree fragments all operations that are
allowed for node-sets;</p></item>

<item><p>a way to group together consecutive nodes having duplicate
subelements or attributes;</p></item>

<item><p>features to make handling of the HTML <code>style</code>
attribute more convenient.</p></item>

</ulist>

</inform-div1>

</back>
</spec>
