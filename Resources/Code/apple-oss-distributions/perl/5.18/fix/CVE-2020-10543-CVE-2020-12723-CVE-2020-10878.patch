diff -Nurp perl-5.18.4-orig/embed.fnc perl-5.18.4/embed.fnc
--- perl-5.18.4-orig/embed.fnc	2014-09-30 18:33:00.000000000 -0700
+++ perl-5.18.4/embed.fnc	2020-05-18 20:59:28.000000000 -0700
@@ -2033,7 +2033,8 @@ Es	|I32	|study_chunk	|NN struct RExC_sta
 				|NULLOK struct scan_data_t *data \
 				|I32 stopparen|NULLOK U8* recursed \
 				|NULLOK struct regnode_charclass_class *and_withp \
-				|U32 flags|U32 depth
+				|U32 flags|U32 depth|bool was_mutate_ok
+Es	|void	|rck_elide_nothing	|NN regnode *node
 EsRn	|U32	|add_data	|NN struct RExC_state_t *pRExC_state|U32 n \
 				|NN const char *s
 rs	|void	|re_croak2	|NN const char* pat1|NN const char* pat2|...
diff -Nurp perl-5.18.4-orig/embed.h perl-5.18.4/embed.h
--- perl-5.18.4-orig/embed.h	2014-09-30 18:33:00.000000000 -0700
+++ perl-5.18.4/embed.h	2020-05-18 21:00:47.000000000 -0700
@@ -931,6 +931,7 @@
 #define make_trie_failtable(a,b,c,d)	S_make_trie_failtable(aTHX_ a,b,c,d)
 #define nextchar(a)		S_nextchar(aTHX_ a)
 #define parse_lparen_question_flags(a)	S_parse_lparen_question_flags(aTHX_ a)
+#define rck_elide_nothing(a) 	S_rck_elide_nothing(aTHX_ a)
 #define reg(a,b,c,d)		S_reg(aTHX_ a,b,c,d)
 #define reg_node(a,b)		S_reg_node(aTHX_ a,b)
 #define reg_recode(a,b)		S_reg_recode(aTHX_ a,b)
@@ -948,7 +949,7 @@
 #define reguni(a,b,c)		S_reguni(aTHX_ a,b,c)
 #define regwhite		S_regwhite
 #define scan_commit(a,b,c,d)	S_scan_commit(aTHX_ a,b,c,d)
-#define study_chunk(a,b,c,d,e,f,g,h,i,j,k)	S_study_chunk(aTHX_ a,b,c,d,e,f,g,h,i,j,k)
+#define study_chunk(a,b,c,d,e,f,g,h,i,j,k,l)	S_study_chunk(aTHX_ a,b,c,d,e,f,g,h,i,j,k,l)
 #  endif
 #  if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_REGEXEC_C) || defined(PERL_IN_UTF8_C)
 #define _get_invlist_len_addr(a)	S__get_invlist_len_addr(aTHX_ a)
diff -Nurp perl-5.18.4-orig/proto.h perl-5.18.4/proto.h
--- perl-5.18.4-orig/proto.h	2014-09-30 18:33:00.000000000 -0700
+++ perl-5.18.4/proto.h	2020-05-18 21:01:12.000000000 -0700
@@ -6641,7 +6641,9 @@ STATIC void	S_parse_lparen_question_flag
 			__attribute__nonnull__(pTHX_1);
 #define PERL_ARGS_ASSERT_PARSE_LPAREN_QUESTION_FLAGS	\
 	assert(pRExC_state)
-
+STATIC void	S_rck_elide_nothing(pTHX_ regnode *node);
+#define PERL_ARGS_ASSERT_RCK_ELIDE_NOTHING	\
+	assert(node)
 PERL_STATIC_NO_RET void	S_re_croak2(pTHX_ const char* pat1, const char* pat2, ...)
 			__attribute__noreturn__
 			__attribute__nonnull__(pTHX_1)
@@ -6749,7 +6751,7 @@ STATIC void	S_scan_commit(pTHX_ const st
 #define PERL_ARGS_ASSERT_SCAN_COMMIT	\
 	assert(pRExC_state); assert(data); assert(minlenp)
 
-STATIC I32	S_study_chunk(pTHX_ struct RExC_state_t *pRExC_state, regnode **scanp, I32 *minlenp, I32 *deltap, regnode *last, struct scan_data_t *data, I32 stopparen, U8* recursed, struct regnode_charclass_class *and_withp, U32 flags, U32 depth)
+STATIC I32	S_study_chunk(pTHX_ struct RExC_state_t *pRExC_state, regnode **scanp, I32 *minlenp, I32 *deltap, regnode *last, struct scan_data_t *data, I32 stopparen, U8* recursed, struct regnode_charclass_class *and_withp, U32 flags, U32 depth, bool was_mutate_ok)
 			__attribute__nonnull__(pTHX_1)
 			__attribute__nonnull__(pTHX_2)
 			__attribute__nonnull__(pTHX_3)
diff -Nurp perl-5.18.4-orig/regcomp.c perl-5.18.4/regcomp.c
--- perl-5.18.4-orig/regcomp.c	2014-09-30 18:33:00.000000000 -0700
+++ perl-5.18.4/regcomp.c	2020-05-18 21:17:04.000000000 -0700
@@ -2986,11 +2986,50 @@ typedef struct scan_frame {
     regnode *next;  /* next node to process when last is reached */
     struct scan_frame *prev; /*previous frame*/
     I32 stop; /* what stopparen do we use */
+    bool in_gosub;  /* this or an outer frame is for GOSUB */
 } scan_frame;
 
 
 #define SCAN_COMMIT(s, data, m) scan_commit(s, data, m, is_inf)
 
+/* Follow the next-chain of the current node and optimize away
+   all the NOTHINGs from it.
+ */
+STATIC void
+S_rck_elide_nothing(pTHX_ regnode *node)
+{
+    dVAR;
+
+    PERL_ARGS_ASSERT_RCK_ELIDE_NOTHING;
+
+    if (OP(node) != CURLYX) {
+        const int max = (reg_off_by_arg[OP(node)]
+                        ? I32_MAX
+                          /* I32 may be smaller than U16 on CRAYs! */
+                        : (I32_MAX < U16_MAX ? I32_MAX : U16_MAX));
+        int off = (reg_off_by_arg[OP(node)] ? ARG(node) : NEXT_OFF(node));
+        int noff;
+        regnode *n = node;
+
+        /* Skip NOTHING and LONGJMP. */
+        while (
+            (n = regnext(n))
+            && (
+                (PL_regkind[OP(n)] == NOTHING && (noff = NEXT_OFF(n)))
+                || ((OP(n) == LONGJMP) && (noff = ARG(n)))
+            )
+            && off + noff < max
+        ) {
+            off += noff;
+        }
+        if (reg_off_by_arg[OP(node)])
+            ARG(node) = off;
+        else
+            NEXT_OFF(node) = off;
+    }
+    return;
+}
+
 STATIC I32
 S_study_chunk(pTHX_ RExC_state_t *pRExC_state, regnode **scanp,
                         I32 *minlenp, I32 *deltap,
@@ -2999,7 +3038,7 @@ S_study_chunk(pTHX_ RExC_state_t *pRExC_
 			I32 stopparen,
 			U8* recursed,
 			struct regnode_charclass_class *and_withp,
-			U32 flags, U32 depth)
+			U32 flags, U32 depth, bool was_mutate_ok)
 			/* scanp: Start here (read-write). */
 			/* deltap: Write maxlen-minlen here. */
 			/* last: Stop before this one. */
@@ -3041,6 +3080,10 @@ S_study_chunk(pTHX_ RExC_state_t *pRExC_
                                    node length to get a real minimum (because
                                    the folded version may be shorter) */
 	bool has_exactf_sharp_s = FALSE;
+	/* avoid mutating ops if we are anywhere within the recursed or
+         * enframed handling for a GOSUB: the outermost level will handle it.
+         */
+	bool mutate_ok = was_mutate_ok && !(frame && frame->in_gosub);
 	/* Peephole optimizer: */
 	DEBUG_STUDYDATA("Peep:", data,depth);
 	DEBUG_PEEP("Peep",scan,depth);
@@ -3048,30 +3091,13 @@ S_study_chunk(pTHX_ RExC_state_t *pRExC_
         /* Its not clear to khw or hv why this is done here, and not in the
          * clauses that deal with EXACT nodes.  khw's guess is that it's
          * because of a previous design */
-        JOIN_EXACT(scan,&min_subtract, &has_exactf_sharp_s, 0);
+	if (mutate_ok)
+        	JOIN_EXACT(scan,&min_subtract, &has_exactf_sharp_s, 0);
 
-	/* Follow the next-chain of the current node and optimize
-	   away all the NOTHINGs from it.  */
-	if (OP(scan) != CURLYX) {
-	    const int max = (reg_off_by_arg[OP(scan)]
-		       ? I32_MAX
-		       /* I32 may be smaller than U16 on CRAYs! */
-		       : (I32_MAX < U16_MAX ? I32_MAX : U16_MAX));
-	    int off = (reg_off_by_arg[OP(scan)] ? ARG(scan) : NEXT_OFF(scan));
-	    int noff;
-	    regnode *n = scan;
-
-	    /* Skip NOTHING and LONGJMP. */
-	    while ((n = regnext(n))
-		   && ((PL_regkind[OP(n)] == NOTHING && (noff = NEXT_OFF(n)))
-		       || ((OP(n) == LONGJMP) && (noff = ARG(n))))
-		   && off + noff < max)
-		off += noff;
-	    if (reg_off_by_arg[OP(scan)])
-		ARG(scan) = off;
-	    else
-		NEXT_OFF(scan) = off;
-	}
+        /* Follow the next-chain of the current node and optimize
+           away all the NOTHINGs from it.
+         */
+        rck_elide_nothing(scan);
 
 
 
@@ -3125,7 +3151,7 @@ S_study_chunk(pTHX_ RExC_state_t *pRExC_
 		    /* we suppose the run is continuous, last=next...*/
 		    minnext = study_chunk(pRExC_state, &scan, minlenp, &deltanext,
 					  next, &data_fake,
-					  stopparen, recursed, NULL, f,depth+1);
+					  stopparen, recursed, NULL, f,depth+1, mutate_ok);
 		    if (min1 > minnext)
 			min1 = minnext;
 		    if (deltanext == I32_MAX) {
@@ -3193,7 +3219,7 @@ S_study_chunk(pTHX_ RExC_state_t *pRExC_
 		    }
 		}
 
-                if (PERL_ENABLE_TRIE_OPTIMISATION && OP( startbranch ) == BRANCH ) {
+                if (PERL_ENABLE_TRIE_OPTIMISATION && OP( startbranch ) == BRANCH  && mutate_ok) {
 		/* demq.
 
 		   Assuming this was/is a branch we are dealing with: 'scan' now
@@ -3542,6 +3568,9 @@ S_study_chunk(pTHX_ RExC_state_t *pRExC_
 	        newframe->last = last;
 	        newframe->stop = stopparen;
 	        newframe->prev = frame;
+		newframe->in_gosub = (
+			(frame && frame->in_gosub) || OP(scan) == GOSUB
+		);
 
 	        frame = newframe;
 	        scan =  start;
@@ -3850,7 +3879,7 @@ S_study_chunk(pTHX_ RExC_state_t *pRExC_
 		minnext = study_chunk(pRExC_state, &scan, minlenp, &deltanext, 
 		                      last, data, stopparen, recursed, NULL,
 				      (mincount == 0
-					? (f & ~SCF_DO_SUBSTR) : f),depth+1);
+					? (f & ~SCF_DO_SUBSTR) : f),depth+1, mutate_ok);
 
 		if (flags & SCF_DO_STCLASS)
 		    data->start_class = oclass;
@@ -3894,6 +3923,12 @@ S_study_chunk(pTHX_ RExC_state_t *pRExC_
 		    (void)ReREFCNT_inc(RExC_rx_sv);
 		}
 
+                if ( ( minnext > 0 && mincount >= SSize_t_MAX / minnext )
+                    || min >= SSize_t_MAX - minnext * mincount )
+                {
+                    FAIL("Regexp out of space");
+                }
+
 		min += minnext * mincount;
 		is_inf_internal |= deltanext == I32_MAX
 				     || (maxcount == REG_INFTY && minnext + deltanext > 0);
@@ -3907,7 +3942,9 @@ S_study_chunk(pTHX_ RExC_state_t *pRExC_
 		if (  OP(oscan) == CURLYX && data
 		      && data->flags & SF_IN_PAR
 		      && !(data->flags & SF_HAS_EVAL)
-		      && !deltanext && minnext == 1 ) {
+		      && !deltanext && minnext == 1
+                      && mutate_ok
+                ) {
 		    /* Try to optimize to CURLYN.  */
 		    regnode *nxt = NEXTOPER(oscan) + EXTRA_STEP_2ARGS;
 		    regnode * const nxt1 = nxt;
@@ -3954,6 +3991,7 @@ S_study_chunk(pTHX_ RExC_state_t *pRExC_
 		      && !deltanext	/* atom is fixed width */
 		      && minnext != 0	/* CURLYM can't handle zero width */
                       && ! (RExC_seen & REG_SEEN_EXACTF_SHARP_S) /* Nor \xDF */
+		      && mutate_ok
 		) {
 		    /* XXXX How to optimize if data == 0? */
 		    /* Optimize to a simpler form.  */
@@ -4000,7 +4038,7 @@ S_study_chunk(pTHX_ RExC_state_t *pRExC_
 #endif
 			/* Optimize again: */
 			study_chunk(pRExC_state, &nxt1, minlenp, &deltanext, nxt,
-				    NULL, stopparen, recursed, NULL, 0,depth+1);
+				    NULL, stopparen, recursed, NULL, 0,depth+1, mutate_ok);
 		    }
 		    else
 			oscan->flags = 0;
@@ -4124,11 +4162,7 @@ PerlIO_printf(Perl_debug_log, "LHS=%d RH
 		if (data && (fl & SF_HAS_EVAL))
 		    data->flags |= SF_HAS_EVAL;
 	      optimize_curly_tail:
-		if (OP(oscan) != CURLYX) {
-		    while (PL_regkind[OP(next = regnext(oscan))] == NOTHING
-			   && NEXT_OFF(next))
-			NEXT_OFF(oscan) += NEXT_OFF(next);
-		}
+		rck_elide_nothing(oscan);
 		continue;
 	    default:			/* REF, and CLUMP only? */
 		if (flags & SCF_DO_SUBSTR) {
@@ -4359,7 +4393,7 @@ PerlIO_printf(Perl_debug_log, "LHS=%d RH
                 next = regnext(scan);
                 nscan = NEXTOPER(NEXTOPER(scan));
                 minnext = study_chunk(pRExC_state, &nscan, minlenp, &deltanext, 
-                    last, &data_fake, stopparen, recursed, NULL, f, depth+1);
+                    last, &data_fake, stopparen, recursed, NULL, f, depth+1, mutate_ok);
                 if (scan->flags) {
                     if (deltanext) {
 			FAIL("Variable length lookbehind not implemented");
@@ -4445,7 +4479,7 @@ PerlIO_printf(Perl_debug_log, "LHS=%d RH
                 nscan = NEXTOPER(NEXTOPER(scan));
 
                 *minnextp = study_chunk(pRExC_state, &nscan, minnextp, &deltanext, 
-                    last, &data_fake, stopparen, recursed, NULL, f,depth+1);
+                    last, &data_fake, stopparen, recursed, NULL, f,depth+1, mutate_ok);
                 if (scan->flags) {
                     if (deltanext) {
 			FAIL("Variable length lookbehind not implemented");
@@ -4606,7 +4640,7 @@ PerlIO_printf(Perl_debug_log, "LHS=%d RH
                          */
                         minnext = study_chunk(pRExC_state, &scan, minlenp, 
                             &deltanext, (regnode *)nextbranch, &data_fake, 
-                            stopparen, recursed, NULL, f,depth+1);
+                            stopparen, recursed, NULL, f,depth+1, mutate_ok);
                     }
                     if (nextbranch && PL_regkind[OP(nextbranch)]==BRANCH)
                         nextbranch= regnext((regnode*)nextbranch);
@@ -6195,7 +6229,7 @@ reStudy:
         
 	minlen = study_chunk(pRExC_state, &first, &minlen, &fake, scan + RExC_size, /* Up to end */
             &data, -1, NULL, NULL,
-            SCF_DO_SUBSTR | SCF_WHILEM_VISITED_POS | stclass_flag,0);
+            SCF_DO_SUBSTR | SCF_WHILEM_VISITED_POS | stclass_flag,0, TRUE);
 
 
         CHECK_RESTUDY_GOTO_butfirst(LEAVE_with_name("study_chunk"));
@@ -6331,7 +6365,7 @@ reStudy:
 
         
 	minlen = study_chunk(pRExC_state, &scan, &minlen, &fake, scan + RExC_size,
-	    &data, -1, NULL, NULL, SCF_DO_STCLASS_AND|SCF_WHILEM_VISITED_POS,0);
+	    &data, -1, NULL, NULL, SCF_DO_STCLASS_AND|SCF_WHILEM_VISITED_POS,0, TRUE);
         
         CHECK_RESTUDY_GOTO_butfirst(NOOP);
 
diff -Nurp perl-5.18.4-orig/t/re/pat.t perl-5.18.4/t/re/pat.t
--- perl-5.18.4-orig/t/re/pat.t	2014-09-30 18:33:00.000000000 -0700
+++ perl-5.18.4/t/re/pat.t	2020-05-18 21:20:15.000000000 -0700
@@ -20,7 +20,7 @@ BEGIN {
     require './test.pl';
 }
 
-plan tests => 674;  # Update this when adding/deleting tests.
+plan tests => 678;  # Update this when adding/deleting tests.
 
 run_tests() unless caller;
 
@@ -1409,6 +1409,30 @@ EOP
                         b(?{})/x, 'RT #119125 with newline and codeblock');
     }
 
+    # gh16947: test regexp corruption (GOSUB)
+    {
+        fresh_perl_is(q{
+            'xy' =~ /x(?0)|x(?|y|y)/ && print 'ok'
+        }, 'ok', {}, 'gh16947: test regexp corruption (GOSUB)');
+    }
+    # gh16947: test fix doesn't break SUSPEND
+    {
+        fresh_perl_is(q{ 'sx' =~ m{ss++}i; print 'ok' },
+                'ok', {}, "gh16947: test fix doesn't break SUSPEND");
+    }
+
+    # gh17743: more regexp corruption via GOSUB
+    {
+        fresh_perl_is(q{
+            "0" =~ /((0(?0)|000(?|0000|0000)(?0))|)/; print "ok"
+        }, 'ok', {}, 'gh17743: test regexp corruption (1)');
+
+        fresh_perl_is(q{
+            "000000000000" =~ /(0(())(0((?0)())|000(?|\x{ef}\x{bf}\x{bd}|\x{ef}\x{bf}\x{bd}))|)/;
+            print "ok"
+        }, 'ok', {}, 'gh17743: test regexp corruption (2)');
+    }
+
 } # End of sub run_tests
 
 1;
